<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go语言学习11-测试</title>
    <link href="/road2go11.html"/>
    <url>/road2go11.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习11-测试"><a href="#Go语言学习11-测试" class="headerlink" title="Go语言学习11-测试"></a>Go语言学习11-测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// functions.go</span><br><span class="hljs-keyword">package</span> testing<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">square</span><span class="hljs-params">(op <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> op * op<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// functions_test.go</span><br><span class="hljs-keyword">package</span> testing<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/stretchr/testify/assert&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSquare</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>inputs := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>expected := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(inputs); i++ &#123;<br>ret := square(inputs[i])<br>assert.Equal(t, expected[i], ret)<br><span class="hljs-comment">//if ret != expected[i] &#123;</span><br><span class="hljs-comment">//t.Errorf(&quot;input is %d, the expcted is %d, the actual %d&quot;,</span><br><span class="hljs-comment">//inputs[i], expected[i], ret)</span><br><span class="hljs-comment">//&#125;</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorInCode</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Start&quot;</span>)<br>t.Error(<span class="hljs-string">&quot;Error&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;End&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFailInCode</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Start&quot;</span>)<br>t.Fatal(<span class="hljs-string">&quot;Error&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;End&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="内置单元测试框架"><a href="#内置单元测试框架" class="headerlink" title="内置单元测试框架"></a>内置单元测试框架</h4><ul><li><p>Fail, Error: 该测试失败, 该测试继续, 其他测试继续执行</p></li><li><p>FailNow, Fatal: 该测试失败, 该测试中止, 其他测试继续执行</p></li><li><p>代码覆盖率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">test</span> -v -cover<br></code></pre></td></tr></table></figure></li><li><p>断言<a href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a></p></li></ul><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkConcatStringByAdd</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-comment">// 与性能测试无关的代码</span><br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br><span class="hljs-comment">// 测试代码</span><br>&#125;<br>b.StopTimer()<br>    <span class="hljs-comment">// 与性能测试无关的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="benchmark命令"><a href="#benchmark命令" class="headerlink" title="benchmark命令"></a>benchmark命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go <span class="hljs-built_in">test</span> -bench=. -benchmem<br></code></pre></td></tr></table></figure><p>-bench=&lt;相关benchmark测试&gt;</p><p>Windows下使用<code>go test</code>命令行时, <code>-bench=.</code> 应写为 <code>-bench=&quot;.&quot;</code></p><h3 id="Behavior-Driven-Development"><a href="#Behavior-Driven-Development" class="headerlink" title="Behavior Driven Development"></a>Behavior Driven Development</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110432503.png" alt="让业务领域的专家参与开发"></p><p><em>“I believe that the hardest part of software projects, the most common source of project failure, is <strong>communication</strong> with the customers and users of that software. By providing a clear yet precise language to deal with domains, a DSL can help improve this communication.” – Martin Fowler.</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110434362.png" alt="用业务领域的语言来描述"></p><h4 id="BDD-in-Go"><a href="#BDD-in-Go" class="headerlink" title="BDD in Go"></a>BDD in Go</h4><h5 id="项目网站"><a href="#项目网站" class="headerlink" title="项目网站"></a>项目网站</h5><p><a href="https://github.com/smartystreets/goconvey">https://github.com/smartystreets/goconvey</a></p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">go get -u github.com/smartystreets/goconvey/convey<br></code></pre></td></tr></table></figure><h5 id="启动-web-ui"><a href="#启动-web-ui" class="headerlink" title="启动 web ui"></a>启动 web ui</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$GOPATH</span>/bin/goconvey<br></code></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSpec</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// Only pass t into top-level Convey calls</span><br>Convey(<span class="hljs-string">&quot;Given 2 even numbers&quot;</span>, t, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-number">2</span><br>b := <span class="hljs-number">4</span><br><br>Convey(<span class="hljs-string">&quot;When add the two numbers&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>c := a + b<br><br>Convey(<span class="hljs-string">&quot;Then the result is still even&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>So(c%<span class="hljs-number">2</span>, ShouldEqual, <span class="hljs-number">0</span>)<br>&#125;)<br>&#125;)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习10-sync.Pool对象缓存</title>
    <link href="/road2go10.html"/>
    <url>/road2go10.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习10-sync-Pool对象缓存"><a href="#Go语言学习10-sync-Pool对象缓存" class="headerlink" title="Go语言学习10-sync.Pool对象缓存"></a>Go语言学习10-sync.Pool对象缓存</h2><h3 id="sync-Pool-对象获取"><a href="#sync-Pool-对象获取" class="headerlink" title="sync.Pool 对象获取"></a><code>sync.Pool</code> 对象获取</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110340058.png"></p><ul><li>尝试从私有对象获取</li><li>私有对象不存在, 尝试从当前 Processor 的共享池获取</li><li>如果当前 Processor 共享池也是空的, name就尝试去其他 Processor 的共享池获取</li><li>如果所有子池都是空的, 最后就用用户指定的 New 函数产生一个新的对象返回</li></ul><h3 id="sync-Pool-对象的放回"><a href="#sync-Pool-对象的放回" class="headerlink" title="sync.Pool 对象的放回"></a><code>sync.Pool</code> 对象的放回</h3><ul><li>如果私有对象不存在则保存为私有对象</li><li>如果私有对象存在, 放入当前 Processor 子池的共享池中</li></ul><h3 id="使用-sync-Pool"><a href="#使用-sync-Pool" class="headerlink" title="使用 sync.Pool"></a>使用 <code>sync.Pool</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">pool := &amp;sync.Pool&#123;<br>New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;,<br>&#125;<br><br>arry := pool.Get().(<span class="hljs-type">int</span>)<br>...<br>pool.Put(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h3 id="sync-Pool-对象的生命周期"><a href="#sync-Pool-对象的生命周期" class="headerlink" title="sync.Pool 对象的生命周期"></a><code>sync.Pool</code> 对象的生命周期</h3><ul><li>GC 会清除 sync.pool 缓存的对象</li><li>对象的缓存有效期为下一次 GC 之前</li></ul><h3 id="sync-Pool-总结"><a href="#sync-Pool-总结" class="headerlink" title="sync.Pool  总结"></a><code>sync.Pool</code>  总结</h3><ul><li>适合于通过复用, 降低复杂对象的创建 和 GC 代价</li><li>协程安全, <font color="red">会有锁的开销</font></li><li><font color="red">声明周期受 GC 影响, 不适合于做连接池等, 需自己管理声明周期的资源的池化</font></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习09-典型并发任务</title>
    <link href="/road2go09.html"/>
    <url>/road2go09.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习09-典型并发任务"><a href="#Go语言学习09-典型并发任务" class="headerlink" title="Go语言学习09-典型并发任务"></a>Go语言学习09-典型并发任务</h2><h3 id="单例模式-懒汉式-线程安全"><a href="#单例模式-懒汉式-线程安全" class="headerlink" title="单例模式(懒汉式, 线程安全)"></a>单例模式(懒汉式, 线程安全)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Singleton <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">var</span> singleInstance *Singleton<br><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetSingletonObj</span><span class="hljs-params">()</span></span> *Singleton &#123;<br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Create Obj&quot;</span>)<br>singleInstance = <span class="hljs-built_in">new</span>(Singleton)<br>&#125;)<br><span class="hljs-keyword">return</span> singleInstance<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetSingletonObj</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>obj := GetSingletonObj()<br>fmt.Println(unsafe.Pointer(obj))<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="场景01-仅需任意任务完成"><a href="#场景01-仅需任意任务完成" class="headerlink" title="场景01: 仅需任意任务完成"></a>场景01: 仅需任意任务完成</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runTask</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;The result is from %d&quot;</span>, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FirstResponse</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>numOfRunner := <span class="hljs-number">10</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, numOfRunner)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numOfRunner; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>ret := runTask(i)<br>ch &lt;- ret<br>&#125;(i)<br>&#125;<br><span class="hljs-keyword">return</span> &lt;-ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFirstResponse</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Log(<span class="hljs-string">&quot;Before:&quot;</span>, runtime.NumGoroutine())<br>t.Log(FirstResponse())<br>time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>t.Log(<span class="hljs-string">&quot;After:&quot;</span>, runtime.NumGoroutine())<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="场景02-等待所有任务完成"><a href="#场景02-等待所有任务完成" class="headerlink" title="场景02: 等待所有任务完成"></a>场景02: 等待所有任务完成</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">runTask</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond)<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;The result is from %d&quot;</span>, id)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AllResponse</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>numOfRunner := <span class="hljs-number">10</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, numOfRunner)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numOfRunner; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>ret := runTask(i)<br>ch &lt;- ret<br>&#125;(i)<br>&#125;<br>finalRet := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; numOfRunner; j++ &#123;<br>finalRet += &lt;-ch + <span class="hljs-string">&quot;\n&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span> finalRet<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFirstResponse</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Log(<span class="hljs-string">&quot;Before:&quot;</span>, runtime.NumGoroutine())<br>t.Log(AllResponse())<br>time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>t.Log(<span class="hljs-string">&quot;After:&quot;</span>, runtime.NumGoroutine())<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="实现池化"><a href="#实现池化" class="headerlink" title="实现池化"></a>实现池化</h3><h4 id="使用-buffered-channel-实现对象池"><a href="#使用-buffered-channel-实现对象池" class="headerlink" title="使用 buffered channel 实现对象池"></a>使用 buffered channel 实现对象池</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReusableObj <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">type</span> ObjPool <span class="hljs-keyword">struct</span> &#123;<br>bufChan <span class="hljs-keyword">chan</span> *ReusableObj <span class="hljs-comment">// 用于缓冲可重用对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewObjPool</span><span class="hljs-params">(numOfObj <span class="hljs-type">int</span>)</span></span> *ObjPool &#123;<br>objPool := ObjPool&#123;&#125;<br>objPool.bufChan = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> *ReusableObj, numOfObj)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; numOfObj; i++ &#123;<br>objPool.bufChan &lt;- &amp;ReusableObj&#123;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> &amp;objPool<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ObjPool)</span></span> GetObj(timeout time.Duration) (*ReusableObj, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ret := &lt;-p.bufChan:<br><span class="hljs-keyword">return</span> ret, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> &lt;-time.After(timeout): <span class="hljs-comment">// 超时控制</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;time out&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ObjPool)</span></span> ReleaseObj(obj *ReusableObj) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> p.bufChan &lt;- obj:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;overflow&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习08-并发编程</title>
    <link href="/road2go08.html"/>
    <url>/road2go08.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习08-并发编程"><a href="#Go语言学习08-并发编程" class="headerlink" title="Go语言学习08-并发编程"></a>Go语言学习08-并发编程</h2><h3 id="Thread-vs-Groutine"><a href="#Thread-vs-Groutine" class="headerlink" title="Thread vs. Groutine"></a>Thread vs. Groutine</h3><ol><li><p>创建时默认的stack的大小</p><ul><li>JDK5 以后 Java Thread stack 默认为 1M</li><li>Groutine 的 Stack 初始化大小为 2K</li></ul></li><li><p>和 KSE (Kernel Space Entity) 的对应关系</p><ul><li>Java Thread 是 1:1 </li><li>Groutine 是 M:N</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211101405748.png"></p></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110251760.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGroutine</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Println(i)<br>&#125;(i)<br>&#125;<br>time.Sleep(time.Millisecond * <span class="hljs-number">50</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="共享内存并发机制"><a href="#共享内存并发机制" class="headerlink" title="共享内存并发机制"></a>共享内存并发机制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCounterThreadSafe</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> mut sync.Mutex<br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>mut.Unlock()<br>&#125;()<br>mut.Lock()<br>counter++<br>&#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>t.Logf(<span class="hljs-string">&quot;counter = %d&quot;</span>, counter)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCounterWaitGroup</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> mut sync.Mutex<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>counter := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>mut.Unlock()<br>&#125;()<br>mut.Lock()<br>counter++<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br>t.Logf(<span class="hljs-string">&quot;counter = %d&quot;</span>, counter)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSP并发机制"><a href="#CSP并发机制" class="headerlink" title="CSP并发机制"></a>CSP并发机制</h3><h4 id="CSP-vs-Actor"><a href="#CSP-vs-Actor" class="headerlink" title="CSP vs. Actor"></a>CSP vs. Actor</h4><ul><li><p>和Actor的直接通讯不不同，CSP模式则是通过Channel进行通讯的，更松耦合⼀些</p></li><li><p>Go中channel是有容量限制并且独立于处理Groutine，而如Erlang，Actor模式中的mailbox容量是无限的，接收进程也总是被动地处理消息。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110302506.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110302716.png"></p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110302717.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110302668.png"></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">service</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>time.Sleep(time.Millisecond * <span class="hljs-number">50</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Done&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">otherTask</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;working on something else&quot;</span>)<br>time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)<br>fmt.Println(<span class="hljs-string">&quot;Task is done.&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestService</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>fmt.Println(service())<br>otherTask()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AsyncService</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">//retCh := make(chan string)</span><br>retCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ret := service()<br>fmt.Println(<span class="hljs-string">&quot;returned result.&quot;</span>)<br>retCh &lt;- ret<br>fmt.Println(<span class="hljs-string">&quot;service exited.&quot;</span>)<br>&#125;()<br><span class="hljs-keyword">return</span> retCh<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAsynService</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>retCh := AsyncService()<br>otherTask()<br>fmt.Println(&lt;-retCh)<br>time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多路选择和超时控制"><a href="#多路选择和超时控制" class="headerlink" title="多路选择和超时控制"></a>多路选择和超时控制</h3><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p><font color="blue">多渠道的选择</font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> ret := &lt;-retCh1:<br>    t.Logf(<span class="hljs-string">&quot;result %s&quot;</span>, ret)<br>    <span class="hljs-keyword">case</span> ret := &lt;-retCh2:<br>    t.Logf(<span class="hljs-string">&quot;result %s&quot;</span>, ret)<br>    <span class="hljs-keyword">default</span>:<br>    t.Error(<span class="hljs-string">&quot;No one returned&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="blue">超时控制</font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>       <span class="hljs-keyword">case</span> ret := &lt;-retCh:<br>t.Logf(<span class="hljs-string">&quot;result %s&quot;</span>, ret)<br><span class="hljs-keyword">case</span> &lt;-time.After(time.Second * <span class="hljs-number">1</span>):<br>t.Error(<span class="hljs-string">&quot;time out&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="channel的关闭和广播"><a href="#channel的关闭和广播" class="headerlink" title="channel的关闭和广播"></a>channel的关闭和广播</h3><h4 id="channel的关闭"><a href="#channel的关闭" class="headerlink" title="channel的关闭"></a>channel的关闭</h4><ul><li>向 关闭的channel发送数据, 会导致 panic</li><li><code>v, ok &lt;-ch</code>; ok 为bool值, true 表示正常接受, false 表示通道关闭</li><li>所有的 channel 接收者都会在channel关闭时, 立刻从阻塞等待中返回且上述ok值为false. 这个广播机制常被利用, 进行向多个订阅者同时发送信号. 如: 退出信号</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dataProducer</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>ch &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(ch)<br><span class="hljs-comment">//ch &lt;- 11</span><br>wg.Done()<br>&#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dataReceiver</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, wg *sync.WaitGroup)</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">11</span>; i++ &#123;<br><span class="hljs-comment">//data := &lt;-ch</span><br><span class="hljs-comment">//fmt.Println(data)</span><br><span class="hljs-keyword">if</span> data, ok := &lt;-ch; ok &#123;<br>fmt.Println(data)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>wg.Done()<br>&#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCloseChannel</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>wg.Add(<span class="hljs-number">1</span>)<br>dataProducer(ch, &amp;wg)<br>wg.Add(<span class="hljs-number">1</span>)<br>dataReceiver(ch, &amp;wg)<br><span class="hljs-comment">//wg.Add(1)</span><br><span class="hljs-comment">//dataReceiver(ch, &amp;wg)</span><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="context处理复杂场景任务的取消"><a href="#context处理复杂场景任务的取消" class="headerlink" title="context处理复杂场景任务的取消"></a>context处理复杂场景任务的取消</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isCancelled</span><span class="hljs-params">(cancelChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-cancelChan:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancel_1</span><span class="hljs-params">(cancelChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br>cancelChan &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancel_2</span><span class="hljs-params">(cancelChan <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-built_in">close</span>(cancelChan)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCancel</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>cancelChan := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-type">int</span>, cancelCh <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> isCancelled(cancelCh) &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>time.Sleep(time.Millisecond * <span class="hljs-number">5</span>)<br>&#125;<br>fmt.Println(i, <span class="hljs-string">&quot;Cancelled&quot;</span>)<br>&#125;(i, cancelChan)<br>&#125;<br><span class="hljs-comment">//cancel_1(cancelChan)</span><br>cancel_2(cancelChan)<br>time.Sleep(time.Second * <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Context与关联任务取消"><a href="#Context与关联任务取消" class="headerlink" title="Context与关联任务取消"></a>Context与关联任务取消</h4><ul><li>根Context: 通过 context.Background() 创建</li><li>子Context: context.WithCancel(parentContext) 创建<ul><li>ctx, cancel := context.WithCancel(context.Background())</li></ul></li><li>当前Context 被取消时, 基于他的子 context 都会被取消</li><li>接收取消通知 <code>&lt;-ctx.Done()</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习07-包和依赖管理</title>
    <link href="/road2go07.html"/>
    <url>/road2go07.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习07-包和依赖管理"><a href="#Go语言学习07-包和依赖管理" class="headerlink" title="Go语言学习07-包和依赖管理"></a>Go语言学习07-包和依赖管理</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><ol><li><p><strong>基本复用模块单元</strong></p><p>以首字母大写来表明可被包外代码访问</p></li><li><p><strong>代码的 package 可以和所在的目录不一致</strong></p></li><li><p><strong>同一目录里的 Go 代码的 package 要保持一致</strong></p></li></ol><hr><ol><li><p>通过 <code>go get</code> 来获取远程依赖</p><p><code>go get -u</code> 强制从网络更新远程依赖</p></li><li><p>注意代码在 GitHub 上的组织形式, 以适应 <code>go get</code></p><p>直接以代码路径开始, 不要有 src</p></li></ol><h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h3><ul><li>在 main 被执行前, 所有依赖的 package 的 init 方法都会被执行</li><li>不同包的 init 函数按照包导入的依赖关系决定执行顺序</li><li>每个包可以有多个init函数</li><li>包的每个源文件也可以有多个init函数, 这点比较特殊</li></ul><h3 id="Go-未解决的依赖问题"><a href="#Go-未解决的依赖问题" class="headerlink" title="Go 未解决的依赖问题"></a>Go 未解决的依赖问题</h3><ol><li>统一环境下, 不同项目使用同一包的不同版本</li><li>无法管理对包的特定版本的依赖</li></ol><h3 id="vendor-路径"><a href="#vendor-路径" class="headerlink" title="vendor 路径"></a>vendor 路径</h3><p>随着Go 1.5 release 版本的发布, vendor目录被添加到除了<strong>GOPATH</strong> 和<strong>GOROOT</strong>之外的依赖目录查找的解决方案。在Go 1.6之前，你需要手动的设置环境变量</p><p><strong>查找依赖包路径的解决方案如下:</strong></p><ol><li>当前包下的 vendor 目录</li><li>向上级目录查找, 知道找到 src 下的 vendor 目录</li><li>在 GOPATH 下面查找依赖包</li><li>在 GOROOT 目录下查找</li></ol><h3 id="常用的依赖管理工具"><a href="#常用的依赖管理工具" class="headerlink" title="常用的依赖管理工具"></a>常用的依赖管理工具</h3><p>godep <a href="https://github.com/tools/godep">https://github.com/tools/godep</a></p><p>glide <a href="https://github.com/Masterminds/glide">https://github.com/Masterminds/glide</a></p><p>dep <a href="https://github.com/golang/dep">https://github.com/golang/dep</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习06-错误处理</title>
    <link href="/road2go06.html"/>
    <url>/road2go06.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习06-错误处理"><a href="#Go语言学习06-错误处理" class="headerlink" title="Go语言学习06-错误处理"></a>Go语言学习06-错误处理</h2><h3 id="Go的错误机制"><a href="#Go的错误机制" class="headerlink" title="Go的错误机制"></a>Go的错误机制</h3><p><font color="blue">与其他主要编程语言的差异</font></p><ol><li><p>没有异常机制</p></li><li><p><code>error</code>类型实现了error接口</p></li><li><p>可以通过 errors.New 来快速创建错误实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>    Error() <span class="hljs-type">string</span><br>&#125;<br><br>errors.New(<span class="hljs-string">&quot;n must be in range [0, 10]&quot;</span>)<br></code></pre></td></tr></table></figure></li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p><font color="blue">定义不同的错误变量, 以便于判断错误类型</font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> LessThanTwoError = errors.New(<span class="hljs-string">&quot;n should be not less than 2&quot;</span>)<br><span class="hljs-keyword">var</span> LargeThanHundredError = errors.New(<span class="hljs-string">&quot;n should be not larger than 100&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetFibonacci</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> ([]<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, LessThanTwoError<br>&#125;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">100</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, LargeThanHundredError<br>&#125;<br>fibList := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">2</span>; i &lt; n; i++ &#123;<br>fibList = <span class="hljs-built_in">append</span>(fibList, fibList[i<span class="hljs-number">-2</span>]+fibList[i<span class="hljs-number">-1</span>])<br>&#125;<br><span class="hljs-keyword">return</span> fibList, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetFibonacci</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> v, err := GetFibonacci(<span class="hljs-number">-10</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err == LessThanTwoError &#123;<br>fmt.Println(<span class="hljs-string">&quot;It is less.&quot;</span>)<br>&#125;<br>t.Error(err)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.Log(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="blue"><strong>及早失败, 避免嵌套!</strong></font></p><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><ul><li>panic 用于不可恢复的错误</li><li>panic 退出前会执行 defer 指定的内容</li></ul><h4 id="panic-vs-os-Exit"><a href="#panic-vs-os-Exit" class="headerlink" title="panic vs. os.Exit"></a>panic vs. os.Exit</h4><ul><li>os.Exit 退出时不会调用 defer 指定的函数</li><li>os.Exit 退出时不输出当前调用栈信息</li></ul><h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 最常见的&quot;错误恢复&quot;</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>        Log.Error(<span class="hljs-string">&quot;recovered panic&quot;</span>, err)<br>&#125;<br>&#125;()<br></code></pre></td></tr></table></figure><p>缺陷:</p><ul><li>形成僵尸服务进程, 导致 health check 失效</li><li>“Let it Crash!” 往往是我们恢复不确定性错误的最好方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习05-面向对象编程</title>
    <link href="/road2go05.html"/>
    <url>/road2go05.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习05-面向对象编程"><a href="#Go语言学习05-面向对象编程" class="headerlink" title="Go语言学习05-面向对象编程"></a>Go语言学习05-面向对象编程</h2><p>Go语言官方对于Go 语言是否为面向对象编程的描述<a href="https://golang.org/doc/faq">https://golang.org/doc/faq</a>：</p><blockquote><p><font color="blue"><strong>Is Go an object-oriented language?</strong></font></p><p><font color="red">Yes and no.</font> Although Go has types and methods and allows an object-oriented style of programming, there is <strong>no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is wasy to use and in some ways more general.</strong></p><p>Also, the lack of a type hierarchy makes “objects” in Go fell much more lightweight than in language such as C++ or Java.</p></blockquote><h3 id="封装数据和行为"><a href="#封装数据和行为" class="headerlink" title="封装数据和行为"></a>封装数据和行为</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>    Id <span class="hljs-type">string</span><br>    Name <span class="hljs-type">string</span><br>    Age <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例创建及初始化"><a href="#实例创建及初始化" class="headerlink" title="实例创建及初始化"></a>实例创建及初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">e := Employee&#123;<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>&#125;<br>e1 := Employee&#123;Name: <span class="hljs-string">&quot;Mike&quot;</span>, Age:<span class="hljs-number">30</span>&#125;<br>e2 := <span class="hljs-built_in">new</span>(Employee)<span class="hljs-comment">// 注意这里返回的引用/指针, 相当于 e:=&amp;EmployeeP&#123;&#125;</span><br>e2.Id = <span class="hljs-string">&quot;2&quot;</span><span class="hljs-comment">// 与其他编程语言的差异: 通过实例的指针访问成员不需要-&gt;</span><br>e2.Age = <span class="hljs-number">22</span><br>e2.Name = <span class="hljs-string">&quot;Rose&quot;</span><br></code></pre></td></tr></table></figure><h4 id="行为-方法-定义"><a href="#行为-方法-定义" class="headerlink" title="行为 (方法) 定义"></a>行为 (方法) 定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 第一种定义方式在实例对应方法被调用时, 实例的成员会进行值复制</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Employee)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;ID:%s-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)<br>&#125;<br><br><span class="hljs-comment">// 通常情况下为了避免内存拷贝我们使用第二种定义方式</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Employee)</span></span> String() <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;ID:%s-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口与依赖"><a href="#接口与依赖" class="headerlink" title="接口与依赖"></a>接口与依赖</h3><pre class="mermaid">classDiagram    class A    class AImpl    class AClient    <<interface>> A    AImpl ..|> A    AClient ..> A    AClient ..> AImpl</pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Programmer.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Programmer</span> &#123;<br>    String <span class="hljs-title function_">WriteCodes</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// GoProgrammer.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GoProgrammer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Programmer</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">WriteCodes</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fmt.Println(\&quot;Hello World!\&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Task.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Programmer</span> <span class="hljs-variable">prog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GoProgrammer</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">codes</span> <span class="hljs-operator">=</span> prog.WriteCodes();<br>        System.out.printlv(codes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Duck-Type式接口实现"><a href="#Duck-Type式接口实现" class="headerlink" title="Duck Type式接口实现"></a>Duck Type式接口实现</h3><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Programmer <span class="hljs-keyword">interface</span> &#123;<br>    WriteHelloWorld() Code<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> GoProgrammer <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *GoProgrammer)</span></span> WriteHelloWorld() Code &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fmt.Printlv(\&quot;Hello World!\&quot;)&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Go-接口"><a href="#Go-接口" class="headerlink" title="Go 接口"></a>Go 接口</h3><p><font color="blue">与其他主要编程语言的差异</font></p><ol><li>接口为非入侵性, 实现不依赖于接口定义</li><li>所以接口的定义可以包含在接口使用者包内</li></ol><h3 id="接口变量"><a href="#接口变量" class="headerlink" title="接口变量"></a>接口变量</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211091513954.png"></p><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><ol><li><code>type IntConvertionFn func(n int) int</code></li><li><code>type Mypoint int</code></li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211091856135.png"></p><h3 id="空接口与断言"><a href="#空接口与断言" class="headerlink" title="空接口与断言"></a>空接口与断言</h3><ol><li><p>空接口可以表示任何类型</p></li><li><p>通过断言来将空接口转换为指定类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">v, ok := p.(<span class="hljs-type">int</span>)   <span class="hljs-comment">//ok = true 时为转换成功</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="Go-接口最佳实践"><a href="#Go-接口最佳实践" class="headerlink" title="Go 接口最佳实践"></a>Go 接口最佳实践</h3><ul><li><p>倾向于使用小的接口定义, 很多接口只包含一个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>    Write(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>较大的接口定义, 可以由多个小接口定义组合而成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>只依赖于必要功能的最小接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StoreData</span><span class="hljs-params">(reader Reader)</span></span> <span class="hljs-type">error</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习04-函数</title>
    <link href="/road2go04.html"/>
    <url>/road2go04.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习04-函数"><a href="#Go语言学习04-函数" class="headerlink" title="Go语言学习04-函数"></a>Go语言学习04-函数</h2><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p><code>&lt;font color=&quot;Blue&quot;&gt;</code>与其他主要编程语言的差异<code>&lt;/font&gt;</code></p><ol><li>可以有多个返回值</li><li>所有参数都是值传递: slice, map, channel 会有传引用的错觉</li><li>函数可以作为变量的值</li><li>函数可以作为参数和返回值</li></ol><blockquote><p>学习函数式编程</p><p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.4u3dC5EX_oMdrMdvPy4LQgAAAA?pid=ImgDet&rs=1"></p></blockquote><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(ops ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>    s := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _, op := <span class="hljs-keyword">range</span> ops &#123;<br>        s += op<br>    &#125;<br>    <span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="defer-函数"><a href="#defer-函数" class="headerlink" title="defer 函数"></a>defer 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDefer</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        t.Log(<span class="hljs-string">&quot;Clear resources&quot;</span>)<br>    &#125;()<br>    t.Log(<span class="hljs-string">&quot;Started&quot;</span>)<br>    <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;Fatal error&quot;</span>) <span class="hljs-comment">// defer仍会执行</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习03-字符串</title>
    <link href="/road2go03.html"/>
    <url>/road2go03.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习03-字符串"><a href="#Go语言学习03-字符串" class="headerlink" title="Go语言学习03-字符串"></a>Go语言学习03-字符串</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><font color="Blue">与其他主要编程语言的差异</font></p><ol><li>string 是数据类型, 不是引用或指针类型</li><li>string 是只读的 byte slice, len 函数可以返回它所包含的byte数</li><li>string 的byte数组可以存放任何数据</li></ol><h3 id="Unicode-UTF8"><a href="#Unicode-UTF8" class="headerlink" title="Unicode UTF8"></a>Unicode UTF8</h3><ol><li>Unicode 是一种字符集(code point)</li><li>UTF8 是 unicode 的存储实现(转换为字节序列的规则)</li></ol><h3 id="编码与存储"><a href="#编码与存储" class="headerlink" title="编码与存储"></a>编码与存储</h3><table><thead><tr><th align="center">字符</th><th align="center">“中”</th></tr></thead><tbody><tr><td align="center">Unicode</td><td align="center">0x4E2D</td></tr><tr><td align="center">UTF-8</td><td align="center">0xE4B8AD</td></tr><tr><td align="center">string/[]byte</td><td align="center">[0xE4, 0xB8, 0xAD]</td></tr></tbody></table><h3 id="常用字符串函数"><a href="#常用字符串函数" class="headerlink" title="常用字符串函数"></a>常用字符串函数</h3><ol><li>strings包(<a href="https://golang.org/pkg/strings">https://golang.org/pkg/strings</a>)</li><li>strconv包(<a href="https://golang.org/pkg/strconv">https://golang.org/pkg/strconv</a>)</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习02-常用集合</title>
    <link href="/road2go02.html"/>
    <url>/road2go02.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习02-常用集合"><a href="#Go语言学习02-常用集合" class="headerlink" title="Go语言学习02-常用集合"></a>Go语言学习02-常用集合</h2><h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p><font color="Blue">与其他主要编程语言的差异</font></p><p>Go语言仅支持循环关键字 <code>for</code></p><p> <code>for j := 7; j &lt;= 9; j++</code></p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p><font color="green">while条件循环 </font></p><p><font color="green">while (n &lt; 5) </font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">n := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> n &lt; <span class="hljs-number">5</span> &#123;<br>    n++<br>    fmt.Println(n)<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="green">无限循环 </font></p><p><font color="green">while (true) </font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">n := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> n &lt; <span class="hljs-number">5</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="if条件"><a href="#if条件" class="headerlink" title="if条件"></a>if条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition &#123;<br>    <span class="hljs-comment">// code to be executed if condition is true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// code to be executed if condition is false</span><br>&#125;<br><br><span class="hljs-keyword">if</span> condition<span class="hljs-number">-1</span> &#123;<br>    <span class="hljs-comment">// code to be executed if condition-1 is true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition<span class="hljs-number">-2</span> &#123;<br>    <span class="hljs-comment">// code to be executed if condition-2 is true</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// code to be executed if both condition1 and condition2 are false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><font color="blue">与其他主要编程语言的差异</font></p><ol><li><p>condition 表达式结果必须为布尔值</p></li><li><p>支持变量赋值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> <span class="hljs-keyword">var</span> declaration; condition &#123;<br>    <span class="hljs-comment">// code to be executed if conditon is true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="switch条件"><a href="#switch条件" class="headerlink" title="switch条件"></a>switch条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> os := runtime.GOOS; os &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;darwin&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;OS X.&quot;</span>)<br><span class="hljs-comment">// break</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;linux&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;Linux.&quot;</span>)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// freebsd, openbsd,</span><br><span class="hljs-comment">// plan9, windows...</span><br>fmt.Printf(<span class="hljs-string">&quot;%s.&quot;</span>, os)<br>&#125;<br><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span> &lt;= Num &amp;&amp; Num &lt;= <span class="hljs-number">3</span>:<br>fmt.Printf(<span class="hljs-string">&quot;0-3&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span> &lt;= Num &amp;&amp; Num &lt;= <span class="hljs-number">6</span>:<br>fmt.Printf(<span class="hljs-string">&quot;4-6&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span> &gt;= Num &amp;&amp; Num &lt;= <span class="hljs-number">9</span>:<br>fmt.Printf(<span class="hljs-string">&quot;7-9&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="blue">与其他主要编程语言的差异</font></p><ol><li>条件表达式不限制为常量或者整数;</li><li>单个case中, 可以出现多个结果选项, 使用逗号分隔;</li><li>与C语言等规则相反, Go语言不需要用break来明确退出一个case;</li><li>可以不设定 switch 之后的条件表达式, 在此种情况下, 整个switch结构与多个if…else…的逻辑作用等同</li></ol><h3 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h3><h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> <span class="hljs-comment">//声明并初始化为默认零值</span><br>a[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br><br>b := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-comment">// 声明同时初始化</span><br>c := [<span class="hljs-number">2</span>][<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;&#125;<span class="hljs-comment">// 多位数组初始化</span><br></code></pre></td></tr></table></figure><p><font color="Blue">与其他主要编程语言的差异</font></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestTravelArray</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    a := [...]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<span class="hljs-comment">// 不指定元素个数</span><br>    <span class="hljs-keyword">for</span> idx<span class="hljs-comment">/*索引*/</span>, elem<span class="hljs-comment">/*元素*/</span> := <span class="hljs-keyword">range</span> a &#123;<br>        fmt.Println(idx, elem)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组截取"><a href="#数组截取" class="headerlink" title="数组截取"></a>数组截取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">a[开始索引(包含)，结束索引(不包含)]<br><br>a := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，<span class="hljs-number">4</span>，<span class="hljs-number">5</span>&#125;<br>a[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>] <span class="hljs-comment">//2</span><br>a[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">//2,3</span><br>a[<span class="hljs-number">1</span>:<span class="hljs-built_in">len</span>(a)] <span class="hljs-comment">//2,3,4,5</span><br>a[<span class="hljs-number">1</span>:] <span class="hljs-comment">//2,3,4,5</span><br>a[:<span class="hljs-number">3</span>] <span class="hljs-comment">//1,2,3</span><br></code></pre></td></tr></table></figure><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><h5 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211080205152.png"></p><h5 id="切片声明"><a href="#切片声明" class="headerlink" title="切片声明"></a>切片声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s0 []<span class="hljs-type">int</span><br>s0 = <span class="hljs-built_in">append</span>(s0，<span class="hljs-number">1</span>)<br><br>s := []<span class="hljs-type">int</span>&#123;&#125;<br><br>s1 := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>&#125;<br><br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>)<br>   <span class="hljs-comment">/* []type, len, cap</span><br><span class="hljs-comment">   其中len个元素会被初始化为默认零值, 未初始化元素不可以访问</span><br><span class="hljs-comment">   */</span><br></code></pre></td></tr></table></figure><h5 id="切片共享存储结构"><a href="#切片共享存储结构" class="headerlink" title="切片共享存储结构"></a>切片共享存储结构</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211080216477.png"></p><h4 id="数组-vs-切片"><a href="#数组-vs-切片" class="headerlink" title="数组 vs. 切片"></a>数组 vs. 切片</h4><ol><li>数组容量不可伸缩</li><li>相同维数, 相同长度的数组可以进行比较, 每一个元素都相同, 这两个数组会被认为相同</li></ol><h3 id="Map声明、元素访问及遍历"><a href="#Map声明、元素访问及遍历" class="headerlink" title="Map声明、元素访问及遍历"></a>Map声明、元素访问及遍历</h3><h4 id="Map声明"><a href="#Map声明" class="headerlink" title="Map声明"></a>Map声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&quot;three&quot;</span>:<span class="hljs-number">3</span>&#125;<br>m1 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>m1[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">1</span><br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>, <span class="hljs-number">10</span> <span class="hljs-comment">/*Initial Capacity*/</span>)<br></code></pre></td></tr></table></figure><h4 id="Map元素的访问"><a href="#Map元素的访问" class="headerlink" title="Map元素的访问"></a>Map元素的访问</h4><p><font color="Blue">与其他主要编程语言的差异</font></p><p>在访问的Key不存在时, 仍会返回零值, 不能通过返回nil来判断元素是否存在</p><h4 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">m := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>:<span class="hljs-number">2</span>, <span class="hljs-string">&quot;three&quot;</span>:<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m &#123;<br>    t.Log(k, v)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现Set"><a href="#实现Set" class="headerlink" title="实现Set"></a>实现Set</h3><p><strong>Go 的内置集合中没有 Set 实现, 可以map[type]bool</strong></p><ol><li><p><strong>元素的唯一性</strong></p></li><li><p><strong>基本操作</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestMapForSet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>mySet := <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>&#123;&#125;<br>mySet[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span><br>n := <span class="hljs-number">3</span><br><span class="hljs-keyword">if</span> mySet[n] &#123;<br>t.Logf(<span class="hljs-string">&quot;%d is existing&quot;</span>, n)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.Logf(<span class="hljs-string">&quot;%d is not existing&quot;</span>, n)<br>&#125;<br>mySet[<span class="hljs-number">3</span>] = <span class="hljs-literal">true</span><br>t.Log(<span class="hljs-built_in">len</span>(mySet))<br><span class="hljs-built_in">delete</span>(mySet, <span class="hljs-number">1</span>)<br>n = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> mySet[n] &#123;<br>t.Logf(<span class="hljs-string">&quot;%d is existing&quot;</span>, n)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.Logf(<span class="hljs-string">&quot;%d is not existing&quot;</span>, n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>添加元素</li><li>判断元素是否存在</li><li>删除元素</li><li>元素个数</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言学习01-基本程序结构</title>
    <link href="/road2go01.html"/>
    <url>/road2go01.html</url>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习01-基本程序结构"><a href="#Go语言学习01-基本程序结构" class="headerlink" title="Go语言学习01-基本程序结构"></a>Go语言学习01-基本程序结构</h2><h3 id="基本程序结构"><a href="#基本程序结构" class="headerlink" title="基本程序结构"></a>基本程序结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-comment">// 包, 表明代码所在的模块(包)</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-comment">// 引入代码依赖</span><br><span class="hljs-comment">// 功能实现</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="应用程序入口"><a href="#应用程序入口" class="headerlink" title="应用程序入口"></a>应用程序入口</h3><ol><li>必须是 main 包: <code>package main</code></li><li>必须是 main 方法: <code>func main()</code></li><li>文件名不一定是 <code>main.go</code></li></ol><h3 id="退出返回值"><a href="#退出返回值" class="headerlink" title="退出返回值"></a>退出返回值</h3><p><strong>与其他主要编程语言的差异</strong></p><ul><li><p>Go 中main 函数不支持任何返回值</p></li><li><p>通过 <code>os.Exit</code> 来返回状态</p></li><li><p>main 函数不支持传入参数</p><p>func main(<del>arg [] string</del>)</p></li><li><p>在程序中直接通过 <code>os.Args</code> 获取命令行参数</p></li></ul><h3 id="编写测试程序"><a href="#编写测试程序" class="headerlink" title="编写测试程序"></a>编写测试程序</h3><ol><li>源码文件以 <code>_test</code> 结尾: xxx_test.go</li><li>测试方法名以 <code>Test</code> 开头: <code>func TestXXX(t *testing.T) &#123;...&#125;</code></li></ol><h3 id="快速设置连续值"><a href="#快速设置连续值" class="headerlink" title="快速设置连续值"></a>快速设置连续值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>Monday = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span><br>    Tuesday<br>    Wednesday<br>    Thursday<br>    Friday<br>    Saturday<br>    Sunday<br>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>Open = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span><br>    Close<br>    Pending<br>)<br></code></pre></td></tr></table></figure><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><table>    <tr>        <td>bool</td>    </tr>    <tr>        <td>string</td>    </tr>    <tr>        <td>int int8 int16 int32 int64</td>    </tr>    <tr>        <td>uint uint8 uint16 uint32 uint64 uintptr</td>    </tr>    <tr>        <td>byte // alias for uint8</td>    </tr>    <tr>        <td>rune // alias for int32, represents a Unicode code point</td>    </tr>    <tr>        <td>float32 float64</td>    </tr>    <tr>        <td>complex32 complex64</td>    </tr></table><h3 id="类型的预定义值"><a href="#类型的预定义值" class="headerlink" title="类型的预定义值"></a>类型的预定义值</h3><ol><li>math.MaxInt64</li><li>math.MaxFloat64</li><li>math.MaxUint32</li></ol><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>与其他主要编程语言的差异</p><ol><li>不支持指针运算</li><li>string 是值类型, 其默认的初始化值为空字符串, 而不是 nil</li></ol><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>相加</td><td>A + B 输出结果 30</td></tr><tr><td>-</td><td>相减</td><td>A - B 输出结果 -10</td></tr><tr><td>*</td><td>相乘</td><td>A * B 输出结果 200</td></tr><tr><td>/</td><td>相除</td><td>B / A 输出结果 2</td></tr><tr><td>%</td><td>求余</td><td>B % A 输出结果 0</td></tr><tr><td>++</td><td>自增</td><td>A ++ 输出结果 11</td></tr><tr><td>–</td><td>自减</td><td>A – 输出结果 9</td></tr></tbody></table><blockquote><p>Go 语言没有前置的 ++, –,  <del>(++a)</del></p></blockquote><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>检查两个值是否相等, 如果相等返回 True 否则返回 False</td><td>(A == B) 为 False</td></tr><tr><td>!=</td><td>检查两个值是否不相等, 如果不相等返回 True 否则返回 False</td><td>(A != B) 为 True</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值, 如果是返回 True 否则返回 False</td><td>(A &gt; B) 为 False</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值, 如果是返回 True 否则返回 False</td><td>(A &lt; B) 为 True</td></tr><tr><td>&gt;=</td><td>检查左边值是否大于等于右边值, 如果是返回 True 否则返回 False</td><td>(A &gt;= B) 为 False</td></tr><tr><td>&lt;=</td><td>检查左边值是否小于等于右边值, 如果是返回 True 否则返回 False</td><td>(A &lt;= B) 为True</td></tr></tbody></table><h5 id="用-比较数组"><a href="#用-比较数组" class="headerlink" title="用 == 比较数组"></a>用 == 比较数组</h5><ul><li>相同维数且含有相同个数元素的数组才可以比较</li><li>每个元素都相同的才相等</li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑 AND 运算符. 如果两边的操作数都是 True, 则条件 True, 否则为 False.</td><td>(A &amp;&amp; B) 为 False</td></tr><tr><td>||</td><td>逻辑 OR 运算符. 如果两边的操作数有一个 True, 则条件 True, 否则为 False.</td><td>(A || B) 为 True</td></tr><tr><td>!</td><td>逻辑 NOT 运算符. 如果条件为 True, 则逻辑 NOT 条件 False, 否则为 True.</td><td>!(A &amp;&amp; B) 为 True</td></tr></tbody></table><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符 “&amp;” 是双目运算符. 其功能是参与运算的两数各对应的二进位相与.</td><td>(A &amp; B)结果为 12, 二进制为 0000 1100</td></tr><tr><td>|</td><td>按位与运算符 “|” 是双目运算符. 其功能是参与运算的两数各对应的二进位相或.</td><td>(A | B) 结果为61, 二进制为 0011 1101</td></tr><tr><td>^</td><td>按位与运算符 “^” 是双目运算符. 其功能是参与运算的两数各对应的二进位相异或.</td><td>(A ^ B) 结果为49, 二进制为 0011 1101</td></tr><tr><td>&lt;&lt;</td><td>左移运算符 “&lt;&lt;” 是双目运算符. 左移 n 位就是乘以 2 的 n 次方. 其功能把 “&lt;&lt;” 左边的运算数的各二进位全部左移若干位, 由 “&lt;&lt;” 右边的数指定移动的位数, 高位丢弃, 低位补0</td><td>A &lt;&lt; 2 结果为 240, 二进制为 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移运算符 “&gt;&gt;” 是双目运算符. 右移 n 位就是除以 2 的 n 次方. 其功能是把 “&gt;&gt;” 左边的运算数的各二进位全部右移若干位, “&gt;&gt;” 右边的数指定移动的位数</td><td>A &gt;&gt; 2 结果为 0000 1111</td></tr></tbody></table><h5 id="与其他主要编程语言的差异"><a href="#与其他主要编程语言的差异" class="headerlink" title="与其他主要编程语言的差异"></a>与其他主要编程语言的差异</h5><h4 id="amp-按位-置零"><a href="#amp-按位-置零" class="headerlink" title="&amp;^ 按位 置零"></a>&amp;^ 按位 置零</h4><p>1 &amp;^ 0 – 1</p><p>1 &amp;^ 1 – 0</p><p>0 &amp;^ 1 – 0</p><p>0 &amp;^ 0 – 0</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年中国石油招聘笔试03——EPI解题技巧</title>
    <link href="/cnpc-recuit-03.html"/>
    <url>/cnpc-recuit-03.html</url>
    
    <content type="html"><![CDATA[<h1 id="2023年中国石油校园招聘笔试03——EPI综合能力测试解题技巧"><a href="#2023年中国石油校园招聘笔试03——EPI综合能力测试解题技巧" class="headerlink" title="2023年中国石油校园招聘笔试03——EPI综合能力测试解题技巧"></a>2023年中国石油校园招聘笔试03——EPI综合能力测试解题技巧</h1><h2 id="1-常识解决技巧"><a href="#1-常识解决技巧" class="headerlink" title="1. 常识解决技巧"></a>1. 常识解决技巧</h2><p>从知识的偏重性来说，常识判断部分的导向性非常清晰，即加强考生对国情、社情的了解程度。</p><p>此阶段备考重在平时，平时多了解一些国家大事和重大举措，例如两会、政府工作报道、国家主权、法律等知识，平时多留意、多观察、多思考。</p><h2 id="2-判断推理题解题技巧"><a href="#2-判断推理题解题技巧" class="headerlink" title="2. 判断推理题解题技巧"></a>2. 判断推理题解题技巧</h2><h3 id="2-1-图形推理"><a href="#2-1-图形推理" class="headerlink" title="2.1 图形推理"></a>2.1 图形推理</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209282005198.png"></p><h4 id="2-1-1-规律推理-数量类"><a href="#2-1-1-规律推理-数量类" class="headerlink" title="2.1.1 规律推理: 数量类"></a>2.1.1 规律推理: 数量类</h4><p>概要说明:数量指图形中包含某种元素的多少，如含有几条边、含有几种元素等。题目中的每个图形仅代表一个或几个数量。</p><p>识别方法:观察题干中的图形组成元紊是否凌乱，或者部分相同元紊数量上的变化是否明显。如果某道题目组成元素混乱，那么可以判别该题目为数量类规律推理。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209282024638.png"></p><ul><li><strong>数量型解题要点总结: 点  线  角  面  素</strong><ol><li>首先从整体数考虑, 识别”点线角面素”, 确定数量规律;</li><li>如果整体不行的话, 可以从部分(分位置或分样式)的角度确定数量, 得出规律.</li></ol></li></ul><blockquote><p><strong>元素组成不同, 且无明显属性规律, 考虑数量规律</strong></p><p>例题:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209280318192.png"></p><p>观察图形可知, 第一个图形是分为2个区域, 第二个图形分为3个区域, 第三个图形分为4个区域…, 以此类推,可以判断第6个图形应该选择可以划分出7个区域的A图形,故选择A    <em>(面)</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209280340384.png"></p><p>黑块内部直角数量, B <em>(角)</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209280346454.png"></p><p>切点数量分类, ①④⑤/②③⑥, <em>(点)</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209291149293.png"></p><p>元素组成不同，无明显属性规律，考虑数量。分别数出曲线和直线数量可以得出选C  <em>（线）</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209291154913.png"></p><p>黑点 2 0 2 2<br>白点 1 2 3 5<br>可以得到规律后一项等于前两项之和，B <em>（素）</em></p></blockquote><h4 id="2-1-2-规律推理：样式类"><a href="#2-1-2-规律推理：样式类" class="headerlink" title="2.1.2 规律推理：样式类"></a>2.1.2 规律推理：样式类</h4><p>概要说明:样式是指图形的形状模样, 它表明了某个图形区别于其他图形的本质特征.</p><p>识别方法:观察题干中图形的组成元素是否相似, 相似也就是图形部分元素非实质性残缺. 如果某道题目组成的元素相似, 那么可以判别该题目为样式类规律推理.</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209282054071.png"></p><ul><li><strong>样式类解题要点总结: 先看样式遍历, 再看加减同异</strong><ol><li>首先观察是否属于样式遍历;</li><li>其次观察是否属于样式运算, 熟练掌握 ”加、减、同、异“四种情况；</li><li>最后再观察其他诸如周期、属性的变化规律</li></ol></li></ul><blockquote><p>例题：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209290049422.png"></p><p>对称性， 选D ， 轴对称、中心对称、中心对称/轴对称</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209290050371.png"></p><p>第一步，观察特征。组成元素相似，优先考虑样式类。第二步，九宫格，横向、纵向观察，没有明显规律，考虑“米”字型规律。题干对角线及十字位置的图形相加均得九宫格中心的图形，应用规律，B项符合。因此，选择B选项。</p></blockquote><h4 id="2-1-3-规律推理：位置类"><a href="#2-1-3-规律推理：位置类" class="headerlink" title="2.1.3 规律推理：位置类"></a>2.1.3 规律推理：位置类</h4><p>概要说明：位置是指图形本身变化的一个属性，就单个平面图形而言，其位置变化仅可能为平移、旋转和翻转。</p><p>识别方法：观察题干中图形的组成元素是否相同，且图形位置的变化是否明显。如果某道题目组成的元索相同，那么就可以判别该题目为位置类规律推理。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209290108994.png"></p><ul><li><strong>位置型解题要点总结：三种位置变化</strong>   平移     旋转     翻转</li></ul><h4 id="2-1-4-第四、五、六、七节：重构推理"><a href="#2-1-4-第四、五、六、七节：重构推理" class="headerlink" title="2.1.4 第四、五、六、七节：重构推理"></a>2.1.4 第四、五、六、七节：重构推理</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209290238196.png"></p><ul><li><p><strong>空间构成型解题要点总结：一个面的特征+两个面的关系</strong></p><p>一个面的特征：寻找“特征面”</p><p>两个面的关系：“相对关系” 有一面</p><p>“相邻关系” 用排除</p></li><li><p><strong>平面组成型解题要点总结:种类不同数个数，种类相同看时针</strong></p></li><li><p><strong>平面拼合型解题要点总结：直线消去法</strong></p></li><li><p><strong>线条组合型解题要点总结：对比排除法</strong></p></li></ul><h3 id="2-2-逻辑判断"><a href="#2-2-逻辑判断" class="headerlink" title="2.2 逻辑判断"></a>2.2 逻辑判断</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202210012317974.png"></p><h4 id="2-2-1-形式推理-翻译推理"><a href="#2-2-1-形式推理-翻译推理" class="headerlink" title="2.2.1 形式推理: 翻译推理"></a>2.2.1 形式推理: 翻译推理</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202210012345243.png"></p><ul><li><strong>翻译推理解题要点总结: 翻译 + 推理</strong><ol><li>翻译。就是指利用“三个关联翻译”和“三个判断翻译”将题目转化成逻辑语言。</li><li>推理。就是利用“肯定信息优先原则”，通过“三个等价”得到答案。</li></ol></li></ul><h4 id="2-2-2-形式推理：真假推理"><a href="#2-2-2-形式推理：真假推理" class="headerlink" title="2.2.2 形式推理：真假推理"></a>2.2.2 形式推理：真假推理</h4><p>概要说明：在题目中给出若干个前提，前提中有真有假，要求通过判断命题的真假情况，进而推理出指定的结论。</p><p>识别方法：题干中给出几个论断，但是几个论断中只有一个是真（假）的，要求由此得到一个肯定的结论。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202210020238675.png"></p><ul><li><strong>真假推理解题要点总结：先看矛盾，其次想反对，最后找包容</strong></li></ul><ol><li>首先看矛盾。一真其余全假，一假其余全真。</li><li>第二步：其次想反对。“有的”、“有的”必一真，“所有”、“所有”必一假。</li><li>第三步：最后找包容。一真前假，一假后真。</li></ol><h4 id="2-2-3-形式推理：分析推理"><a href="#2-2-3-形式推理：分析推理" class="headerlink" title="2.2.3 形式推理：分析推理"></a>2.2.3 形式推理：分析推理</h4><p>概要说明：在题目中给出若干人或事物，要求利用它们间的相互关系，对它们的烦序进行排列组合，实现一一对应。<br>识别方法：题目中给出多个肯定论断，交代相互间的关系，要求由此得到一个肯定的结论。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202210012358204.png"></p><ul><li><p><strong>分析推理解题要点总结：三个优先原则+四种典型方法</strong></p><p>三个优先原则：肯定信息优先、信息最大优先、特殊信息优先</p><p>四种典型方法：列表法、假设法、排除法、中途法</p></li></ul><h4 id="2-2-4-加强论证：假设加强"><a href="#2-2-4-加强论证：假设加强" class="headerlink" title="2.2.4 加强论证：假设加强"></a>2.2.4 加强论证：假设加强</h4><p>概要说明：假设是支持作者结论所隐含的前提，是前提与结论之间的连接，是推出结论所必要的条件。当否定这个假设的时候，论证将不能成立。</p><p>识别方法：其典型的问法有一一上文的说法基于以下哪一个假设？上述论证中假设了下列哪个前提？上文基于下列哪一个假设？如果上述断定为真，则必须假设一下哪项作为前提？</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202210020229787.png"></p><ul><li><p><strong>假设型加强解题总结：本质、有效方式、验证</strong></p><p>本质：寻找孤立信息，有效建立联系</p><p>有效方式：搭设桥梁    建立联系    肯定前提</p><p>验证：否定代入</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中石油</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年中国石油招聘笔试02——考点归纳</title>
    <link href="/cnpc-recuit-02.html"/>
    <url>/cnpc-recuit-02.html</url>
    
    <content type="html"><![CDATA[<h1 id="2023年中国石油校园招聘笔试02——考点归纳"><a href="#2023年中国石油校园招聘笔试02——考点归纳" class="headerlink" title="2023年中国石油校园招聘笔试02——考点归纳"></a>2023年中国石油校园招聘笔试02——考点归纳</h1><h2 id="1-中国石油笔试专业题考点"><a href="#1-中国石油笔试专业题考点" class="headerlink" title="1. 中国石油笔试专业题考点"></a>1. 中国石油笔试专业题考点</h2><p>一般涉及较少，请扫码关注公众号回复 “中石油专业题考点” ：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209262041045.png"></p><h2 id="2-中国石油笔试行测题考点"><a href="#2-中国石油笔试行测题考点" class="headerlink" title="2. 中国石油笔试行测题考点"></a>2. 中国石油笔试行测题考点</h2><ol><li><strong>常识题【考的少】：</strong> 包括历史常识、地理常识、文化常识、科技常识、生活常识等，设计范围广泛。考查知识广度</li><li><strong>推理【必考】：</strong> 根据给出的一组图形、数字、文字、一段话寻找规律，并据此找到另一组图形、数字、文字、一段话中类似关系。考查对图形的敏感性和推理能力</li><li><strong>数量关系【必考】：</strong> 一种类似于数列题，找出给出数列的规律，据此推断出下一个数字；另一种类似于应用题，根据给出条件计算结果。</li><li><strong>言语理解与表达【必考】：</strong> 言语理解与表达主要有四种类型的试题：<ul><li>词语替换，选词填空, 语句表达和阅读理解。近年出现语句表达和阅读理解居多;词语替换；从所给的四个选项中选一个填入句中划线部分，尽量使句子的意思保持不变；</li><li><strong>选词填空【必考】：</strong>从所给的四个词或四组词中选出一个或一组来填入句中的空格内，从而使句子的意思表达得最准确；</li><li><strong>语句表达【必考】：</strong> 从给出的几句话中选出没有或有歧义的一句或从给出的几句话中选出有或没有语病的一句；</li><li><strong>阅读理解【必考】：</strong> 形式较多，主要是对长句的意思进行准确的理解，即先给你一个复杂的长句，然后针对长句提出一个问题，提供四个选项，要求你根据长句的意思对这一问题作出正确的回答，选择出正确答案, 考查应试者对长句语意的理解和语言的组合、表达能力。</li></ul></li><li><strong>资料分析【必考】：</strong> 资料分析测验一般提供一组资料，这组资料可能是一个统计表，一个统计图，或者是一段文字的内容，考查包括三个部分:一是对某项工作或任务的进展或完成情况做出评价和判断，如对政策、计划执行情况的检查和监督: 二是对被研究现象的统计规律、现象之间的依存关系及依存程度的规律等加以揭示和阐述;三是对被研究现象的未来发展趋势及其变化特征进行预测或推断。考查应试者对各种资料(主要是统计资料，包括图表和文字资料)进行准确理解、转换与分析综合的能力。</li></ol><h2 id="3-中国石油笔试英语题考点"><a href="#3-中国石油笔试英语题考点" class="headerlink" title="3. 中国石油笔试英语题考点"></a>3. 中国石油笔试英语题考点</h2><p>一般都是考阅读理解题、语法题或者完型填空或改错，难度与托业考试或英语六级相当，多为金融英语。</p><p><strong>—-中石化发展历史、发展近况、企业文化、获奖情况等基本知识点</strong></p>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中石油</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023年中国石油招聘笔试01——综述</title>
    <link href="/cnpc-recuit-01.html"/>
    <url>/cnpc-recuit-01.html</url>
    
    <content type="html"><![CDATA[<h1 id="2023年中国石油校园招聘笔试01——综述"><a href="#2023年中国石油校园招聘笔试01——综述" class="headerlink" title="2023年中国石油校园招聘笔试01——综述"></a>2023年中国石油校园招聘笔试01——综述</h1><h2 id="1-中国石油招聘流程"><a href="#1-中国石油招聘流程" class="headerlink" title="1. 中国石油招聘流程"></a>1. 中国石油招聘流程</h2><p>一般分为如下四个环节：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202209282132242.svg"></p><p>一般笔试在前， 面试在后，</p><p>大部分分公司考试类型为 <strong>综合能力测试</strong> 或者 <strong>综合能力测试 + 专业题</strong> 的形式，少数分公司考试题型为 <strong>英语测试+综合测试+性格测试</strong>。 面试一般分为初面、专业面等几个环节。。。</p><h2 id="2-中国石油招聘笔试考什么？"><a href="#2-中国石油招聘笔试考什么？" class="headerlink" title="2. 中国石油招聘笔试考什么？"></a>2. 中国石油招聘笔试考什么？</h2><p>大部分中国石油为 <strong>EPI 综合能力测试</strong> 的形式， 有的分公司还会考查英语知识，写作能力等。</p><p>EPI 综合能力测试也就是 <strong>行测题测试</strong> .</p><h2 id="3-中国石油招聘笔试考试时长"><a href="#3-中国石油招聘笔试考试时长" class="headerlink" title="3. 中国石油招聘笔试考试时长"></a>3. 中国石油招聘笔试考试时长</h2><p>据绝大部分考过的考生反馈, 时间很紧张, 根本不够用, 尤其是没搞过行测专业训练的考生.</p><h2 id="4-应对笔试整体方案-关键在于准度、速度、技巧"><a href="#4-应对笔试整体方案-关键在于准度、速度、技巧" class="headerlink" title="4. 应对笔试整体方案: 关键在于准度、速度、技巧"></a>4. 应对笔试整体方案: 关键在于准度、速度、技巧</h2>]]></content>
    
    
    <categories>
      
      <category>秋招</category>
      
    </categories>
    
    
    <tags>
      
      <tag>中石油</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对KMP算法的一些认识</title>
    <link href="/KMP.html"/>
    <url>/KMP.html</url>
    
    <content type="html"><![CDATA[<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>从零搭建ELK日志分析系统</title>
    <link href="/ELKLogConstruction.html"/>
    <url>/ELKLogConstruction.html</url>
    
    <content type="html"><![CDATA[<h1 id="从零搭建ELK-filebeat-日志分析系统-以Windows为例"><a href="#从零搭建ELK-filebeat-日志分析系统-以Windows为例" class="headerlink" title="从零搭建ELK + filebeat 日志分析系统(以Windows为例)"></a>从零搭建ELK + filebeat 日志分析系统(以Windows为例)</h1><h2 id="1-什么是ELK"><a href="#1-什么是ELK" class="headerlink" title="1. 什么是ELK?"></a>1. 什么是ELK?</h2><p>ELK 是elastic公司提供的一套完整的日志收集以及展示的解决方案，是三个产品的首字母缩写，分别是 ElasticSearch、Logstash 和 Kibana。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191354749.png"></p><h2 id="2-filebeat"><a href="#2-filebeat" class="headerlink" title="2. filebeat"></a>2. filebeat</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191357605.png" alt="Filebeat工作流程图"></p><p>​        Filebeat是用于转发和集中日志数据的轻量级传送工具。Filebeat监视您指定的日志文件或位置，收集日志事件，并将它们转发到Elasticsearch或 Logstash进行索引。</p><p>　　Filebeat的工作方式如下：启动Filebeat时，它将启动一个或多个输入，这些输入将在为日志数据指定的位置中查找。对于Filebeat所找到的每个日志，Filebeat都会启动收集器。每个收集器都读取单个日志以获取新内容，并将新日志数据发送到libbeat，libbeat将聚集事件，并将聚集的数据发送到为Filebeat配置的输出。</p><h2 id="3-安装ElasticSearch"><a href="#3-安装ElasticSearch" class="headerlink" title="3. 安装ElasticSearch"></a>3. 安装ElasticSearch</h2><h3 id="3-1-ES-单节点搭建"><a href="#3-1-ES-单节点搭建" class="headerlink" title="3.1 ES 单节点搭建"></a>3.1 ES 单节点搭建</h3><ol><li><p>首先在官网下载Windows版本的<a href="https://www.elastic.co/cn/downloads/past-releases/elasticsearch-7-8-0">Elasticsearch压缩包</a>, 在任意处解压。</p><p>解压后文件结构如下：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191840111.png"></p></li><li><p>启动方式：</p><p>进入bin文件目录，在此处打开终端窗口，运行 <code>elasticsearch.bat</code>文件即可</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191844657.png"></p><p>待命令行窗口显示<code>started</code>即为启动成功.</p></li><li><p>此时可以在浏览器访问<a href="http://localhost:9200/">http://localhost:9200</a>, 可以看到浏览器返回如下信息</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191847965.png"></p></li></ol><h3 id="3-2-ES-集群搭建"><a href="#3-2-ES-集群搭建" class="headerlink" title="3.2 ES 集群搭建"></a>3.2 ES 集群搭建</h3><ol><li><p>创建<code>elasticsearch-cluster</code> 文件夹, 将ES安装包解压出的内容物复制三份分别命名如下：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191852452.png"></p></li><li><p>配置各节点的配置文件(各节点config文件夹下的<code>elasticsearch.yml</code>文件)</p><p>节点1配置文件配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 节点1的配置信息:</span><br><span class="hljs-comment"># 集群名称, 节点之间要保持一致</span><br><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">my-elasticsearch</span><br><span class="hljs-comment">#节点名称, 集群唯一</span><br><span class="hljs-attr">node.name:</span> <span class="hljs-string">node-1</span><br><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># ip地址</span><br><span class="hljs-attr">network.host:</span> <span class="hljs-string">localhost</span><br><span class="hljs-comment"># http端口</span><br><span class="hljs-attr">http.port:</span> <span class="hljs-number">9201</span><br><span class="hljs-comment"># tcp监听端口</span><br><span class="hljs-attr">transport.tcp.port:</span> <span class="hljs-number">9301</span><br><br><span class="hljs-attr">discovery.seed_hosts:</span> [<span class="hljs-string">&quot;localhost:9301&quot;</span>, <span class="hljs-string">&quot;localhost:9302&quot;</span>,<span class="hljs-string">&quot;localhost:9303&quot;</span>]<br><span class="hljs-attr">discovery.zen.fd.ping_timeout:</span> <span class="hljs-string">1m</span><br><span class="hljs-attr">discovery.zen.fd.ping_retries:</span> <span class="hljs-number">5</span><br><br><span class="hljs-comment"># 集群内可被选为主节点的节点列表</span><br><span class="hljs-attr">cluster.initial_master_nodes:</span> [<span class="hljs-string">&quot;node-1&quot;</span>, <span class="hljs-string">&quot;node-2&quot;</span>, <span class="hljs-string">&quot;node-3&quot;</span>]<br><br><span class="hljs-comment"># 跨域配置</span><br><span class="hljs-comment"># action.destructive_requires_name: true</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p>节点2配置文件配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 节点 2 的配置信息：</span><br><span class="hljs-comment"># 集群名称，节点之间要保持一致</span><br><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">my-elasticsearch</span><br><span class="hljs-comment"># 节点名称，集群内唯一</span><br><span class="hljs-attr">node.name:</span> <span class="hljs-string">node-2</span><br><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment">#ip 地址</span><br><span class="hljs-attr">network.host:</span> <span class="hljs-string">localhost</span><br><span class="hljs-comment"># http端口</span><br><span class="hljs-attr">http.port:</span> <span class="hljs-number">9202</span><br><span class="hljs-comment">#tcp监听端口</span><br><span class="hljs-attr">transport.tcp.port:</span> <span class="hljs-number">9302</span><br><br><span class="hljs-attr">discovery.seed_hosts:</span> [<span class="hljs-string">&quot;localhost:9301&quot;</span>]<br><span class="hljs-attr">discovery.zen.fd.ping_timeout:</span> <span class="hljs-string">1m</span><br><span class="hljs-attr">discovery.zen.fd.ping_retries:</span> <span class="hljs-number">5</span><br><br><span class="hljs-comment"># 集群内可被选为主节点的节点列表</span><br><span class="hljs-attr">cluster.initial_master_nodes:</span> [<span class="hljs-string">&quot;node-1&quot;</span>, <span class="hljs-string">&quot;node-2&quot;</span>, <span class="hljs-string">&quot;node-3&quot;</span>]<br><br><span class="hljs-comment"># 跨域配置</span><br><span class="hljs-comment"># action.destructive_requires_name: true</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><p>节点3配置文件配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 节点 3 的配置信息：</span><br><span class="hljs-comment"># 集群名称，节点之间要保持一致</span><br><span class="hljs-attr">cluster.name:</span> <span class="hljs-string">my-elasticsearch</span><br><span class="hljs-comment"># 节点名称，集群内要唯一</span><br><span class="hljs-attr">node.name:</span> <span class="hljs-string">node-3</span><br><span class="hljs-attr">node.master:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">node.data:</span> <span class="hljs-literal">true</span><br><span class="hljs-comment">#ip 地址</span><br><span class="hljs-attr">network.host:</span> <span class="hljs-string">localhost</span><br><span class="hljs-comment"># http端口</span><br><span class="hljs-attr">http.port:</span> <span class="hljs-number">9203</span><br><span class="hljs-comment">#tcp监听端口</span><br><span class="hljs-attr">transport.tcp.port:</span> <span class="hljs-number">9303</span><br><br><span class="hljs-attr">discovery.seed_hosts:</span> [<span class="hljs-string">&quot;localhost:9301&quot;</span>, <span class="hljs-string">&quot;localhost:9302&quot;</span>]<br><span class="hljs-attr">discovery.zen.fd.ping_timeout:</span> <span class="hljs-string">1m</span><br><span class="hljs-attr">discovery.zen.fd.ping_retries:</span> <span class="hljs-number">5</span><br><br><span class="hljs-comment"># 集群内可被选为主节点的节点列表</span><br><span class="hljs-attr">cluster.initial_master_nodes:</span> [<span class="hljs-string">&quot;node-1&quot;</span>, <span class="hljs-string">&quot;node-2&quot;</span>, <span class="hljs-string">&quot;node-3&quot;</span>]<br><br><span class="hljs-comment"># 跨域配置</span><br><span class="hljs-comment"># action.destructive_requires_name: true</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>修改好各节点的配置文件之后, 依次启动各节点即可成功创建ES集群</p></li><li><p><a href="https://chrome.google.com/webstore/detail/multi-elasticsearch-head/cpmmilfkofbeimbmgiclohpodggeheim">Multi Elasticsearch Head</a> 插件的安装</p><p>我们可以在如下链接下载此浏览器插件进行安装,浏览器插件安装方式请自行搜索有关资料</p><ul><li>Chrome应用商店直接安装<a href="https://chrome.google.com/webstore/detail/multi-elasticsearch-head/cpmmilfkofbeimbmgiclohpodggeheim">https://chrome.google.com/webstore/detail/multi-elasticsearch-head/cpmmilfkofbeimbmgiclohpodggeheim</a></li><li>Github仓库<a href="https://github.com/Mu-L/multi-elasticsearch-head-chrome">https://github.com/Mu-L/multi-elasticsearch-head-chrome</a></li></ul><p>安装插件完成之后我们可以点击插件,进入监控 Elasticsearch 状态界面,</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191905241.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191906392.png"></p><p>在此页面我们可以方便地对ES集群进行管理，可以查看到索引所有节点各个分片的健康度等信息，并且能够对索引进行增删改查操作</p></li></ol><h2 id="4-Kibana的安装及启动"><a href="#4-Kibana的安装及启动" class="headerlink" title="4. Kibana的安装及启动"></a>4. Kibana的安装及启动</h2><ol><li><p>在官网下载<a href="https://www.elastic.co/cn/downloads/past-releases/kibana-7-8-0">Kibana安装压缩包</a>, 并解压</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191918424.png"></p><ol start="2"><li><p>进入bin目录，双击<code>kibana.bat</code>即可启动成功</p><p>访问<a href="http://localhost:5601/">http://localhost:5601</a>, 查看kibana页面：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191920483.png"></p><blockquote><p>页面修改为中文需要在 <code>config/kibana.yml</code>中添加 <code>i18n.locale: &quot;zh-CN&quot;</code> 配置</p></blockquote></li></ol><h2 id="5-Logstash-的安装与配置"><a href="#5-Logstash-的安装与配置" class="headerlink" title="5. Logstash 的安装与配置"></a>5. Logstash 的安装与配置</h2><ol><li><p>首先从官网下载<a href="https://www.elastic.co/cn/downloads/past-releases/logstash-7-8-0">Logstash的zip压缩包</a>, 随后解压:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208191928354.png" alt="image-20220819192802301"></p></li><li><p>修改<code>config/logstash.conf</code> 文件如下, 为修改elasticsearch:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Sample Logstash configuration for creating a simple</span><br><span class="hljs-comment"># Beats -&gt; Logstash -&gt; Elasticsearch pipeline.</span><br> <br><span class="hljs-attr">input</span> <span class="hljs-string">&#123;</span><br>  <span class="hljs-attr">beats</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">port</span> =<span class="hljs-string">&gt; 5044</span><br>  <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br> <br><span class="hljs-attr">filter</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">grok</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">match</span> =<span class="hljs-string">&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;NGINXACCESS&#125;&quot; &#125;</span><br><br>    <span class="hljs-attr">&#125;</span><br>    <span class="hljs-attr">geoip</span> <span class="hljs-string">&#123;</span><br>      <span class="hljs-attr">source</span> =<span class="hljs-string">&gt; &quot;http_x_forwarded_for&quot;</span><br>      <span class="hljs-attr">target</span> =<span class="hljs-string">&gt; &quot;geoip&quot;</span><br>      <span class="hljs-attr">database</span> =<span class="hljs-string">&gt; &quot;C:\Software\nginx-1.22.0\GeoLiteCity.dat&quot;</span><br>      <span class="hljs-attr">add_field</span> =<span class="hljs-string">&gt; [ &quot;[geoip][coordinates]&quot;, &quot;%&#123;[geoip][longitude]&#125;&quot; ]</span><br>      <span class="hljs-attr">add_field</span> =<span class="hljs-string">&gt; [ &quot;[geoip][coordinates]&quot;, &quot;%&#123;[geoip][latitude]&#125;&quot; ]</span><br>    <span class="hljs-attr">&#125;</span><br><br>    <span class="hljs-attr">mutate</span> <span class="hljs-string">&#123;</span><br>      <span class="hljs-attr">convert</span> =<span class="hljs-string">&gt; [ &quot;[geoip][coordinates]&quot;, &quot;float&quot; ]</span><br>      <span class="hljs-attr">convert</span> =<span class="hljs-string">&gt; [ &quot;response&quot;,&quot;integer&quot; ]</span><br>      <span class="hljs-attr">convert</span> =<span class="hljs-string">&gt; [ &quot;bytes&quot;,&quot;integer&quot; ]</span><br>      <span class="hljs-attr">replace</span> =<span class="hljs-string">&gt; &#123; &quot;type&quot; =&gt; &quot;nginx_access&quot; &#125;</span><br>      <span class="hljs-attr">remove_field</span> =<span class="hljs-string">&gt; &quot;message&quot;</span><br>    <span class="hljs-attr">&#125;</span><br><br>    <span class="hljs-attr">date</span> <span class="hljs-string">&#123;</span><br>      <span class="hljs-attr">match</span> =<span class="hljs-string">&gt; [ &quot;timestamp&quot;,&quot;dd/MMM/yyyy:HH:mm:ss Z&quot;]</span><br><br>    <span class="hljs-attr">&#125;</span><br>    <span class="hljs-attr">mutate</span> <span class="hljs-string">&#123;</span><br>      <span class="hljs-attr">remove_field</span> =<span class="hljs-string">&gt; &quot;timestamp&quot;</span><br><br>    <span class="hljs-attr">&#125;</span><br><br><br><span class="hljs-attr">&#125;</span><br> <br> <br><span class="hljs-attr">output</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">elasticsearch</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">hosts</span> =<span class="hljs-string">&gt;  [&quot;http://localhost:9201&quot;]</span><br><span class="hljs-attr">&#125;</span><br> <br> <br><span class="hljs-attr">stdout</span> <span class="hljs-string">&#123;</span><br><span class="hljs-attr">codec</span> =<span class="hljs-string">&gt; rubydebug</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>启动命令<code>.\bin\logstash.bat -f &lt;配置文件路径(config/logstash.conf)&gt;</code> </p></li></ol></li></ol><h2 id="6-Filebeat-的安装与配置"><a href="#6-Filebeat-的安装与配置" class="headerlink" title="6. Filebeat 的安装与配置"></a>6. Filebeat 的安装与配置</h2><ol><li><p>从官网下载<a href="https://www.elastic.co/cn/downloads/past-releases/filebeat-7-8-0">Filebeat压缩包</a>, 并解压缩<br><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208192136902.png"></p></li><li><p>随后以采集nginx产生的日志为例:</p><p>配置<code>filebeat.yml</code>:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">output.logstash:</span><br>  <span class="hljs-comment"># The Logstash hosts</span><br>  <span class="hljs-attr">hosts:</span> [<span class="hljs-string">&quot;localhost:5044&quot;</span>]<br></code></pre></td></tr></table></figure><p>运行<code>.\filebeat.exe modules enable nginx</code>,随后更改<code>modules.d\nginx.yml</code>设置nginx日志的输出路径.</p><p>随后使用<code>.\filebeat.exe -e</code>运行filebeat即可</p><p>也或可将filebeat注册到Windows服务启动</p></li></ol><h2 id="7-启动整个日志系统"><a href="#7-启动整个日志系统" class="headerlink" title="7. 启动整个日志系统"></a>7. 启动整个日志系统</h2><p>按顺序(ES(集群)=&gt;logstash=&gt;filebeat=&gt;kibana)依次启动各项服务,随后启动nginx服务,并产生部分日志:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208192205968.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208192322272.png"></p><p>随后回到kibana界面, 使用logstash-* 新建索引模式</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208192209991.png"></p><p>随后就可看见kibana收集来的nginx日志</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208192322492.png"></p><p>更多使用方法可以查阅<a href="https://www.elastic.co/guide/en/elastic-stack/7.8/index.html">Kibana官网文档</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0718 Excel表格</title>
    <link href="/icbcinternship05.html"/>
    <url>/icbcinternship05.html</url>
    
    <content type="html"><![CDATA[<h1 id="10个Excel中的小问题"><a href="#10个Excel中的小问题" class="headerlink" title="10个Excel中的小问题"></a>10个Excel中的小问题</h1><h2 id="1-为什么丢数据"><a href="#1-为什么丢数据" class="headerlink" title="1. 为什么丢数据"></a>1. 为什么丢数据</h2><table>    <caption>Excel 文件最大存储容量</caption>    <tr>        <td>文件扩展名</td>        <td>.xls</td>        <td>.xlsx</td>    </tr>    <tr>        <td>行R</td>        <td>65536</td>        <td>1048576</td>    </tr>    <tr>        <td>列C</td>        <td>256</td>        <td>16384</td>    </tr>    <tr>        <td>版本</td>        <td>2003以前</td>        <td>2007以后</td>    </tr></table><h2 id="2-大表格如何固定表头"><a href="#2-大表格如何固定表头" class="headerlink" title="2. 大表格如何固定表头"></a>2. 大表格如何固定表头</h2><ul><li><p><strong>查阅</strong>固定表头</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090455764.png"></p></li><li><p>选中</p><p><kbd>Ctrl</kbd> + <kbd>A</kbd> : 选中内容部分任意单元格后，按组合键，全选内容部分</p><p><kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>↑↓←→</kbd>   : 按组合键, 可逐步选择内容</p></li></ul><h2 id="3-快速分离数据"><a href="#3-快速分离数据" class="headerlink" title="3. 快速分离数据"></a>3. 快速分离数据</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090459982.png"></p><ul><li>分列</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090500978.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090500747.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090501112.png" alt="image-20220809050122059"></p><h2 id="4-编码中的0怎么不见了"><a href="#4-编码中的0怎么不见了" class="headerlink" title="4. 编码中的0怎么不见了"></a>4. 编码中的0怎么不见了</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090503824.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090503944.png"></p><blockquote><p>知识补充：</p><ul><li><p>单元格默认格式是“常规”，如果输入的数值前面带“0”，系统会自动忽略。</p></li><li><p>文本格式的单元格一般显示为左对齐，左上角有个绿色的小三角形。</p></li><li><p>数值格式一般右对齐。</p></li><li><p>快速输入文本的方法是，首先输入一个英文(半角）状态下的单引号，再输入数字。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090505681.png"></p></li></ul></blockquote><h2 id="5-身份证号码这是怎么了"><a href="#5-身份证号码这是怎么了" class="headerlink" title="5. 身份证号码这是怎么了"></a>5. 身份证号码这是怎么了</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090507125.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090508412.png"></p><blockquote><p>知识补充：</p><ul><li>Excel中默认数值显示11位，如果超过11位，则用科学计数法显示。</li><li>Excel中默认数值如果超过15位，15位后的非0自动变成0，且不可逆转。</li><li>计算字符串长度的公式是: =LEN(需要计算的单元格)</li></ul></blockquote><h2 id="6-数字为什么不能计算"><a href="#6-数字为什么不能计算" class="headerlink" title="6. 数字为什么不能计算"></a>6. 数字为什么不能计算</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090510998.png"></p><p>文本转数据的三种方法：</p><h3 id="1-直接修改"><a href="#1-直接修改" class="headerlink" title="1. 直接修改"></a>1. 直接修改</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090512098.png"></p><h3 id="2-选择性粘贴"><a href="#2-选择性粘贴" class="headerlink" title="2. 选择性粘贴"></a>2. 选择性粘贴</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090516939.png"></p><h3 id="3-分列"><a href="#3-分列" class="headerlink" title="3. 分列"></a>3. 分列</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202208090517260.png"></p><h2 id="7-快速正确输入性别、单位等"><a href="#7-快速正确输入性别、单位等" class="headerlink" title="7. 快速正确输入性别、单位等"></a>7. 快速正确输入性别、单位等</h2>]]></content>
    
    
    <categories>
      
      <category>2022新疆工行星令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0714 可视化思维与表达</title>
    <link href="/icbcinternship04.html"/>
    <url>/icbcinternship04.html</url>
    
    <content type="html"><![CDATA[<h1 id="0714-可视化思维与表达"><a href="#0714-可视化思维与表达" class="headerlink" title="0714 可视化思维与表达"></a>0714 可视化思维与表达</h1><h2 id="1-可视化思维缘起"><a href="#1-可视化思维缘起" class="headerlink" title="1. 可视化思维缘起"></a>1. 可视化思维缘起</h2><blockquote><p>思维可视化：是指运用一系列图示技术把本来不可视的思维(思考方法和思考路径)呈现出来，使其清晰可见的过。被可视化的”思维”更有利于理解和记忆，因此可以有效提高信息加工及信息传递的效能。</p></blockquote><p>由巴普洛夫实验等相关的实验表明：</p><ul><li><p>学习的宏观本质：<strong>建立联系</strong></p></li><li><p>学习的微观本质：<strong>赫布定律</strong></p></li></ul><p>可视化思维：</p><ol><li>知识数量是基础，联结是关键；</li><li>内存有限，需要提供辅助；</li><li>广泛的联结需要更丰富的刺激；</li><li>可以通过练习达成稳定的联结。</li></ol><h2 id="2-可视化工具介绍"><a href="#2-可视化工具介绍" class="headerlink" title="2. 可视化工具介绍"></a>2. 可视化工具介绍</h2><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p>传统笔记缺点：</p><ol><li><strong>关键性信息少</strong>，不超过全部信息的20%;</li><li>笔记的修改整理让人头痛，内容<strong>存在重复</strong>;</li><li>难以看出材料中的内在<strong>逻辑关系</strong>;</li><li>单一的文字信息，让大脑<strong>昏昏欲睡</strong>;</li><li>阅读资料<strong>被动式接受</strong>，信息传递单向性，缺乏互动和创造;</li><li>传统的笔记记录方式容易有疏漏造成<strong>记忆断层</strong>。</li></ol><p>思维导图的原则：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207160206835.png"></p><h2 id="3-可视化表达应用"><a href="#3-可视化表达应用" class="headerlink" title="3. 可视化表达应用"></a>3. 可视化表达应用</h2><h3 id="3-1-提升自我"><a href="#3-1-提升自我" class="headerlink" title="3.1 提升自我"></a>3.1 提升自我</h3><h3 id="3-2-分析问题"><a href="#3-2-分析问题" class="headerlink" title="3.2 分析问题"></a>3.2 分析问题</h3><h3 id="3-3-改善团队"><a href="#3-3-改善团队" class="headerlink" title="3.3 改善团队"></a>3.3 改善团队</h3>]]></content>
    
    
    <categories>
      
      <category>2022新疆工行星令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0712 结构性思维笔记</title>
    <link href="/icbcinternship03.html"/>
    <url>/icbcinternship03.html</url>
    
    <content type="html"><![CDATA[<h1 id="0712-结构性思维笔记"><a href="#0712-结构性思维笔记" class="headerlink" title="0712 结构性思维笔记"></a>0712 结构性思维笔记</h1><blockquote><p>结构的定义：组成整体的各部分的搭配和安排</p><p>作用：</p><ul><li>在建筑中，决定形状建立连接</li><li>在影片中，不可见，确保故事精彩</li><li>在企业中，建立管理体系，决定组织效率</li></ul></blockquote><h2 id="1-构建结构性思维"><a href="#1-构建结构性思维" class="headerlink" title="1. 构建结构性思维"></a>1. 构建结构性思维</h2><h3 id="1-1-结构性思维的四个特点"><a href="#1-1-结构性思维的四个特点" class="headerlink" title="1.1 结构性思维的四个特点"></a>1.1 结构性思维的四个特点</h3><ul><li>结构先行</li><li>上下对应</li><li>分类清楚</li><li>排序逻辑</li></ul><h3 id="1-2-结构性思维接收信息"><a href="#1-2-结构性思维接收信息" class="headerlink" title="1.2 结构性思维接收信息"></a>1.2 结构性思维接收信息</h3><ol><li><strong>识别</strong>：识别信息中的事实与个人观点或判断</li><li><strong>对应</strong>：找到事实与观点之间的对应关系</li><li><strong>结构</strong>：画出结构性关系图</li><li><strong>表达</strong>：用语言表达信息的主要含义</li></ol><h2 id="2-纵向结构"><a href="#2-纵向结构" class="headerlink" title="2. 纵向结构"></a>2. 纵向结构</h2><h3 id="2-1-从上到下提问回答"><a href="#2-1-从上到下提问回答" class="headerlink" title="2.1 从上到下提问回答"></a>2.1 从上到下提问回答</h3><ol><li>步骤一、设定场景</li><li>步骤二、确定主题</li><li>步骤三、设想问题</li><li>步骤四、回答问题</li></ol><h3 id="2-2-从下到上概括总结"><a href="#2-2-从下到上概括总结" class="headerlink" title="2.2 从下到上概括总结"></a>2.2 从下到上概括总结</h3><blockquote><ol><li>文章的标题句就是主题句；</li><li>PPT的标题句就是主题句；</li><li>自然段的段首句就是主题句。</li></ol></blockquote><h3 id="3-横向结构"><a href="#3-横向结构" class="headerlink" title="3. 横向结构"></a>3. 横向结构</h3><h4 id="3-1-演绎论证"><a href="#3-1-演绎论证" class="headerlink" title="3.1 演绎论证"></a>3.1 演绎论证</h4><blockquote><p>从普遍性的理论知识出发认识个别、特殊的现象的一种论证推理方法、</p></blockquote><p>演绎论证的两种结构：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207150135950.png"></p><h4 id="3-2-归纳论证"><a href="#3-2-归纳论证" class="headerlink" title="3.2 归纳论证"></a>3.2 归纳论证</h4><blockquote><p>从许多个别的事务中概括出性概念、原则或结论的推理方法。</p></blockquote><p>三种排序：时间顺序、结构顺序、重要性顺序</p><p>分类的标准：<strong>MECE</strong>原则</p><blockquote><p>Mutually Exclusive &amp; Collectively Exhaustive</p><p>相互独立 完全穷尽 | 不重不漏</p><p>互不交叉 应有尽有 | 分清分尽</p></blockquote><h3 id="4-序言结构"><a href="#4-序言结构" class="headerlink" title="4. 序言结构"></a>4. 序言结构</h3><table>    <caption>序言的四要素</caption>    <tr>        <td style="background-color:red">S(情景)</td>        <td>发展和科技的进步，人群结构中的“老龄化”已经呈现明显的趋势</td>    </tr>    <tr>        <td style="background-color:red">C(冲突)</td>        <td>然而记者在调查中发现，虽然老年人越来越多，然而他们在服装购买方面却存在着各种各样的困难，在商场中很难找到老年人专柜，老年人也没有自己的“名牌”</td>    </tr>      <tr>        <td style="background-color:red">Q(疑问)</td>        <td>如何满足老年人的服装购买需要</td>    </tr>    <tr>        <td style="background-color:red">A(回答)</td>        <td>这一问题引起了嗅觉敏捷的商家开始经营老年人的服装，并初见成效</td>    </tr>    </table><p>序言标准结构及变化</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207150147153.png"></p><h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h3><p>第一部分:构建结构性思维，共学习了两个四。第一个，结构性思维的四大基本特点:结论先行、上下对应、分类清楚、排序逻辑。第二个，结构性思维接收信息的四大步骤:<br>第一识别，识别信息中的事实和观点;第二对应，找出事实与观点的对应关系;第三结构，画出结构图;<br>第四表达,表达成一句话，“在序的基础上，从ABC三个方面说明了G”</p><p>第二部分:纵向结构。纵向结构是两个方向:从上到下和从下到上。<br>从上到下是提问回答，从下到上是概括总结。<br>那从上到下的提问回答又做了两个延展，问到多深?公理定理和已知条件;问到多宽?重点是保证主题中所有的关键词都被提问到。<br>从下到上的概括总结基本要求是严格的上下对应，相当于数学题的等号，在商务文体写作中做到有内容的主题句。</p><p>第三部分:横向结构。两种逻辑关系:一个演绎、第二个归纳。<br>演绎论证有两种形式，第一个叫标准式，也叫三段论，也就是大前提、小前提和结论;第二个是常见式，也分三个部分，是现象、原因、解决方案。<br>归纳的重点两个知识点:排序和分类。三种常见的排序方法:第一个是按时间，第二个按结构，第三个按重要性。分类的衡量标准式MECE原则，分清和分净,或者相互独立、完全穷尽、或者不重不漏。分类的重要行为要求是界定范围和明确标准。</p><p>第四部分:序言结构。四要素，用英文字母是SCQA,用中文表达是:背景、冲突、提问和回答。一起做个变形:开门见山式是A在前面,突出忧虑式是C在前,突出信心式Q在前面。</p>]]></content>
    
    
    <categories>
      
      <category>2022新疆工行星令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0710 自我认知与个人发展</title>
    <link href="/icbcinternship02.html"/>
    <url>/icbcinternship02.html</url>
    
    <content type="html"><![CDATA[<h1 id="0710-自我认知与个人发展-成为更好的自己"><a href="#0710-自我认知与个人发展-成为更好的自己" class="headerlink" title="0710 自我认知与个人发展_成为更好的自己"></a>0710 自我认知与个人发展_成为更好的自己</h1><h2 id="1-谁是我-全景人才画像"><a href="#1-谁是我-全景人才画像" class="headerlink" title="1. 谁是我: 全景人才画像"></a>1. 谁是我: 全景人才画像</h2><ul><li><p>人的全景画像</p><ul><li>德、才</li><li>德、能、勤、绩、廉</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207092250236.png"></p></li><li><p>麦克里兰：冰山模型</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207092251418.png"></p></li><li><p>员工画像（MPA模型）</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207092252846.png"></p></li></ul><h2 id="2-我是谁：自我评价与分析"><a href="#2-我是谁：自我评价与分析" class="headerlink" title="2. 我是谁：自我评价与分析"></a>2. 我是谁：自我评价与分析</h2><h3 id="2-1-愿不愿：动机类测评工具"><a href="#2-1-愿不愿：动机类测评工具" class="headerlink" title="2.1 愿不愿：动机类测评工具"></a>2.1 愿不愿：动机类测评工具</h3><ul><li><p><strong>麦克里兰：动机理论</strong></p></li><li><p>霍兰德：职业兴趣测试</p></li><li><p>罗克奇：职业价值观测试</p></li><li><p><strong>埃德加·H·施恩：职业锚</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207092258857.png"></p></li></ul><h3 id="2-2-合不合：人格类测评工具"><a href="#2-2-合不合：人格类测评工具" class="headerlink" title="2.2 合不合：人格类测评工具"></a>2.2 合不合：人格类测评工具</h3><ul><li><p>特质类测评工具</p><ul><li><p>16PF、15FQ+、<strong>盖洛普优势才干</strong>、<strong>大五人格</strong></p></li><li><p>大五人格</p><ul><li><p>情绪稳定性、外倾性、经验开放性、宜人性、尽责性</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207092315603.png"></p></li><li></li></ul></li></ul></li><li><p>风格类测评工具</p><ul><li><p><strong>DISC</strong>、PDP、颜色心理、RTC、MBTI、MMPI</p></li><li><p>DISC</p><ul><li><p>美国心理学家、人类行为科学家马斯顿（Dr.WilliamMoulton Marston)博士于20世纪20年代所创（The Emotions of Normal People,1928)</p><ul><li>Dominance，支配型</li><li>Influence，影响型</li><li>Steadiness，稳健型</li><li>Compliance，服从型</li></ul></li><li><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207092317117.png"></p></li><li><p>高D（支配）型</p><p><strong>结果导向</strong> | 强调结果和目标 | 喜欢有挑战性的工作 | 自信、主动积极 | 说话直接 |地盘意识强 | 敢于冒险 | 喜欢创新</p></li><li><p>高I（影响）型</p><p><strong>人际导向</strong> | 喜欢做与人有关的工作 | 积极乐观、幽默风趣 | 善于语言激励 | 人际洞察力强 | 富有同理心 | 热情友善 | 富有创意</p></li><li><p>高S（稳健）型</p><p><strong>价值导向</strong> | 追求专业和中长期的卓越 | 做事持久有耐心 | 善于做中长期规划 | 喜欢按照自己的节奏、步调做事，不喜欢临时变化 | 追求和谐、富合作精神 | 避免冲突 | 亲切温暖</p></li><li><p>高C（服从）型</p><p><strong>过程导向</strong> | 重计划，讲条理、制度、规则 | 原则性强 | 完美主义、重细节 | 讲求专业价值 | 是非、道德观念强 | 可靠、重承诺 | 细心谨慎</p></li><li><p>整合型</p><p><strong>情景导向</strong> | 适应性和灵活性强 | 扮演不同的角色都感觉很舒适 | 能够轻易地在四种特质之间转换</p></li></ul></li><li><p>风格类测评报告解读</p><ul><li><strong>性格只有差异,没有好坏,相对于特定的情景,性格特质都有可能有不足或过当的情况</strong></li><li>每个人的性格特质上没有有无的差别,只有程度的不同</li><li><strong>不要为别人贴”标签”，更不要为自己的不足找借口</strong></li><li>领导需要特殊的才干,但每种类型的人都可能成为领导,重要的是你能否找到合适的领域,并配置好一个互补的团队</li></ul></li></ul></li></ul><h2 id="2-我会是谁：个人发展逻辑"><a href="#2-我会是谁：个人发展逻辑" class="headerlink" title="2. 我会是谁：个人发展逻辑"></a>2. 我会是谁：个人发展逻辑</h2><ul><li><p>自我认知与个人发展路径</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207092335880.png"></p></li><li><p>管理的认知</p><ul><li><p>管理的道与术：儒里道外</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207092339645.png"></p></li><li><p>管理的辩证法</p><ul><li>柔与刚：严管厚爱</li><li>有与无：无为创造有为</li></ul></li><li><p>以出世的心态做入世的事情</p></li></ul></li><li><p>个人发展的逻辑</p><p>知：终身成长</p><p>行：刻意练习</p><ul><li>终身成长=成长型思维+刻意练习</li><li>成长是一辈子的事,无关性格、无关年龄、无关性别,甚至无关天分</li><li>不要把不努力当做没有天分的借口</li><li>自我觉察、发现优势、发展优势</li><li>动机决定行为、行为决定习惯、习惯决定命运</li></ul></li><li><p>建设自己的个人发展计划</p></li></ul><blockquote><p>推荐书籍：</p><ol><li>《我们都是自己的陌生人》(美)戴维迈尔斯</li><li>《终身成长》（美）卡罗尔德韦克</li><li>《刻意练习》(美)安德斯艾利克森</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>2022新疆工行星令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>0708 中国工商银行集团文化介绍笔记</title>
    <link href="/icbcinternship01.html"/>
    <url>/icbcinternship01.html</url>
    
    <content type="html"><![CDATA[<h1 id="0708-中国工商银行集团文化介绍笔记"><a href="#0708-中国工商银行集团文化介绍笔记" class="headerlink" title="0708 中国工商银行集团文化介绍笔记"></a>0708 中国工商银行集团文化介绍笔记</h1><h2 id="1-文化传承"><a href="#1-文化传承" class="headerlink" title="1. 文化传承"></a>1. 文化传承</h2><h3 id="1-1-红色金融文化传承"><a href="#1-1-红色金融文化传承" class="headerlink" title="1.1 红色金融文化传承"></a>1.1 红色金融文化传承</h3><ul><li>大革命时期 -&gt; 土地革命时期 -&gt; 抗日战争时期</li><li>扁担银行、马背银行、窑洞银行</li></ul><h3 id="1-2-文化萌芽（1984-1993）"><a href="#1-2-文化萌芽（1984-1993）" class="headerlink" title="1.2 文化萌芽（1984-1993）"></a>1.2 文化萌芽（1984-1993）</h3><p><strong>三铁精神：</strong>铁账本、铁算盘、铁规章</p><p><strong>工行精神：</strong>求实创新、吃苦耐劳、顾全大局、团结奋进</p><p>1983年12月30日，中国工商银行成立大会在北京召开</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207082109157.png" alt="工行总行第一块门牌"></p><h3 id="1-3-文化成长（1994-2005）"><a href="#1-3-文化成长（1994-2005）" class="headerlink" title="1.3 文化成长（1994-2005）"></a>1.3 文化成长（1994-2005）</h3><p><strong>十字方针：</strong> 效益、质量、发展、管理、创新</p><p><strong>五种观念：</strong>稳健的发展观、真实的效益观、全面的质量观、严格的管理观、科学的创新观</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207082118862.png" alt="家喻户晓的宣传语"></p><h3 id="1-4-文化形成（2005-2019）"><a href="#1-4-文化形成（2005-2019）" class="headerlink" title="1.4 文化形成（2005-2019）"></a>1.4 文化形成（2005-2019）</h3><ul><li><p>2005年10月，成立中国工商银行股份有限公司</p></li><li><p>2006年10月，在上海、香港同步上市</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207082122018.png"></p></li><li><p>五项原则</p><ol><li>以<strong>改革</strong>为突破</li><li>以<strong>创新</strong>为突破</li><li>以<strong>服务</strong>为突破</li><li>以转变<strong>发展方式</strong>为主要途径</li><li>以<strong>人</strong>为本</li></ol></li><li><p>股改精神</p><p>勤于<strong>探索</strong> | 勇于<strong>创造</strong></p><p>善于<strong>借鉴</strong> | 敢于<strong>超越</strong></p></li><li><p>一个核心、四个支撑、两个延伸的企业文化建设体系</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207082201856.png"></p><ul><li><p>一个核心：工于至诚，行以致远的价值观</p></li><li><p>四个支撑：</p><pre><code>四个子文化：</code></pre><ol><li>廉洁：公开透明、公私分明、自律律他、言行并重</li><li>合规：合规为本、全员有责、风险可控、稳健高效</li><li>服务：客户为尊、服务如意、员工为本、诚信如一</li><li>创新：聚焦本源、因势革故、协同鼎新、永葆生机</li></ol></li><li><p>两个延伸</p><ul><li><p>向重点业务板块拓展的专业文化</p><p>经济本源 | 诚信合规 | 专家治贷</p><p>审慎稳健 | 客户优选 | 责任落实</p></li><li><p>区域特征鲜明的特色文化</p></li></ul></li></ul></li></ul><h3 id="1-5-文化提升（2019-至今）"><a href="#1-5-文化提升（2019-至今）" class="headerlink" title="1.5 文化提升（2019-至今）"></a>1.5 文化提升（2019-至今）</h3><p>为各地脱贫攻坚提供一支强有力的力量</p><h3 id="1-6-文化基因"><a href="#1-6-文化基因" class="headerlink" title="1.6 文化基因"></a>1.6 文化基因</h3><ul><li>党建引领、凝心聚力，是工行的底色</li><li>诚实守信、尽职尽责，是工行的本色</li><li>严谨规范、稳健合规，是工行的特色</li><li>创新进取、追求卓越，是工行的亮色</li><li>吃苦耐劳、敬业奉献，是工行的基色</li></ul><h2 id="2-文化体系和实践"><a href="#2-文化体系和实践" class="headerlink" title="2. 文化体系和实践"></a>2. 文化体系和实践</h2><h3 id="2-1-企业文化之定义"><a href="#2-1-企业文化之定义" class="headerlink" title="2.1 企业文化之定义"></a>2.1 企业文化之定义</h3><p><strong>企业文化</strong>是在长期经营管理实践活动中逐步形成的，被企业员工普遍认同和遵循的经营理念、价值取向、思维方式、规章制度、行为准则以及企业外部形象的总称。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202207082201729.png"></p><h3 id="2-2-工商银行的精神文化"><a href="#2-2-工商银行的精神文化" class="headerlink" title="2.2 工商银行的精神文化"></a>2.2 工商银行的精神文化</h3><h4 id="1-使命"><a href="#1-使命" class="headerlink" title="1. 使命"></a>1. 使命</h4><p>提供卓越金融服务</p><ul><li><strong>服务客户</strong>：就是要不断提高服务能力和质量</li><li><strong>回报股东</strong>：就是要为股东创造最佳价值回报</li><li><strong>成就员工</strong>：就是要为员工提供广阔发展平台</li><li><strong>奉献社会</strong>：就是要主动承担更多企业责任</li></ul><h4 id="2-愿景"><a href="#2-愿景" class="headerlink" title="2. 愿景"></a>2. 愿景</h4><p>全面建设具有全球竞争力的世界一流现代金融企业，成为基业长青的银行</p><ol><li>基本完成现代商业银行布局：于建党100年为起点，直到2023年工商银行成立40周年之际</li><li>完成由传统银行向现代银行的转型：展望2025年，十四五规划完成之际</li><li>成为卓越银行：远眺2035年，我国基本实现社会主义现代化工商银行成立50周年之时</li></ol><h4 id="3-价值观"><a href="#3-价值观" class="headerlink" title="3. 价值观"></a>3. 价值观</h4><p>工于至诚、行以致远</p><p>前提:</p><ul><li>工：工行、工匠 -&gt; 表明一种精神和态度</li><li>诚：诚信、忠诚 -&gt; 表明一种原则和信念</li></ul><p>结果:</p><ul><li>行：执行、同行 -&gt; 表明一种行为和状态</li><li>远：长远、高远 -&gt; 表明一种境界和追求</li></ul><h4 id="4-先进的文化理念"><a href="#4-先进的文化理念" class="headerlink" title="4. 先进的文化理念"></a>4. 先进的文化理念</h4><p>以坚持党的建设为统领，提升文化引导力</p><p>以社会主义核心价值观为指引，提升文化凝聚力</p><p>以融入经营管理为途径，提升文化渗透力</p><p>以打造品牌活动为抓手，提升文化感染力</p><p>以反应员工心声为着力点，提升文化感召力</p>]]></content>
    
    
    <categories>
      
      <category>2022新疆工行星令营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法题目01</title>
    <link href="/algorithm_problem01.html"/>
    <url>/algorithm_problem01.html</url>
    
    <content type="html"><![CDATA[<h3 id="1-链表题"><a href="#1-链表题" class="headerlink" title="1. 链表题"></a>1. 链表题</h3><ol><li><a href="https://leetcode.cn/problems/reverse-linked-list/">一个长度为n的单向链表，用O(1) 空间复杂度来实现倒转输出，使用最低时间复杂度</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span>) &#123;<br>            tmp = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = tmp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">找出单链表的中间元素，要求用时最少</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">null</span> &amp;&amp; fast.next!= <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li><a href="https://leetcode.cn/problems/linked-list-cycle/">单链表中是否有环，写出代码</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <br>        <span class="hljs-keyword">while</span>(fast!= <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            fast = fast.next.next;<br>            slow = slow.next;<br>            <span class="hljs-keyword">if</span>(fast == slow) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> !(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><a href="https://leetcode.cn/problems/c32eOV/">如果单链表中有环，请找到环的入口点</a></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">findLoopNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>            <span class="hljs-keyword">if</span>(slow == fast) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <br>        slow = head;<br>        <br>        <span class="hljs-keyword">while</span>(slow != fast) &#123;<br>            slow = slow.next;<br>            fast = fast.next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> fast;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-删除排序链表中的重复元素"><a href="#2-删除排序链表中的重复元素" class="headerlink" title="2. 删除排序链表中的重复元素"></a>2. 删除排序链表中的重复元素</h3><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">题目链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>();<br>        tmp.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span>tmp;<br>        pre.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span>(pre.next.val != cur.next.val) &#123;<br>                pre = pre.next;<br>                cur = cur.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span>(cur!= <span class="hljs-literal">null</span> &amp;&amp; cur.next != <span class="hljs-literal">null</span> &amp;&amp; cur.next.val == pre.next.val) &#123;<br>                    cur = cur.next;<br>                &#125;<br>                pre.next = cur.next;<br>                cur = cur.next;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> tmp.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-简单排序"><a href="#3-简单排序" class="headerlink" title="3. 简单排序"></a>3. 简单排序</h3><ol><li>冒泡排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TLE</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; nums.length - <span class="hljs-number">1</span>;++i) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j &lt; nums.length;++j) &#123;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; nums[j]) &#123;<br>                    nums[i] = nums[i] + nums[j];<br>                    nums[j] = nums[i] - nums[j];<br>                    nums[i] = nums[i] - nums[j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>插入排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">while</span>(j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> nums[j];<br>                nums[j] = nums[j - <span class="hljs-number">1</span>];<br>                nums[j - <span class="hljs-number">1</span>] = temp;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-快速排序代码"><a href="#4-快速排序代码" class="headerlink" title="4. 快速排序代码"></a>4. 快速排序代码</h3><p><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组 - 力扣（LeetCode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] sortArray(<span class="hljs-type">int</span>[] nums) &#123;<br>        quick_sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> nums;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> nums[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>        <span class="hljs-keyword">if</span>(l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> l -<span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = nums[l+r &gt;&gt; <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">while</span>(i &lt; j) &#123;<br>            <span class="hljs-keyword">do</span> i++; <span class="hljs-keyword">while</span>(nums[i] &lt; x);<br>            <span class="hljs-keyword">do</span> j--; <span class="hljs-keyword">while</span>(nums[j] &gt; x);<br>            <span class="hljs-keyword">if</span>(i&lt;j) &#123;<br>                nums[i] = nums[i] + nums[j];<br>                nums[j] = nums[i] - nums[j];<br>                nums[i] = nums[i] - nums[j];<br>            &#125;<br>        &#125;<br>        quick_sort(nums, l, j);<br>        quick_sort(nums, j + <span class="hljs-number">1</span>, r);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>校招</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>npm 常见命令</title>
    <link href="/npm-common-commands.html"/>
    <url>/npm-common-commands.html</url>
    
    <content type="html"><![CDATA[<h2 id="npm常用命令"><a href="#npm常用命令" class="headerlink" title="npm常用命令"></a>npm常用命令</h2><h3 id="1-构建项目"><a href="#1-构建项目" class="headerlink" title="1. 构建项目"></a>1. 构建项目</h3><p>初始化一个基于node的项目, 会创建一个配置文件<code>package.json</code>(两种方式):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 一般情况下, 全部enter</span><br>npm init<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. 全部使用默认配置</span><br>npm init --yes<br></code></pre></td></tr></table></figure><h3 id="2-安装模块-包"><a href="#2-安装模块-包" class="headerlink" title="2. 安装模块(包)"></a>2. 安装模块(包)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">全局安装</span><br>npm install 模块名 -g<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本地安装</span><br>npm install 模块名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">一次性安装多个</span><br>npm install 模块名1 模块名2 模块名n --save<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装运行时依赖包</span><br>npm install 模块名 --save<br></code></pre></td></tr></table></figure><h3 id="3-查看安装目录"><a href="#3-查看安装目录" class="headerlink" title="3. 查看安装目录"></a>3. 查看安装目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看本地安装的目录</span><br>npm root<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看全局安装的目录</span><br>npm root -g<br></code></pre></td></tr></table></figure><h3 id="4-卸载模块-包"><a href="#4-卸载模块-包" class="headerlink" title="4. 卸载模块(包)"></a>4. 卸载模块(包)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载本地模块</span><br>npm uninstall 模块名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载全局模块</span><br>npm uninstall -g 模块名<br></code></pre></td></tr></table></figure><h3 id="5-更新模块-包"><a href="#5-更新模块-包" class="headerlink" title="5. 更新模块(包)"></a>5. 更新模块(包)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm update 模块名<br>npm update 模块名 -g<br></code></pre></td></tr></table></figure><h3 id="6-查看当前安装的模块-包"><a href="#6-查看当前安装的模块-包" class="headerlink" title="6. 查看当前安装的模块(包)"></a>6. 查看当前安装的模块(包)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm ls<br>npm ls -g<br></code></pre></td></tr></table></figure><h3 id="7-命令配置"><a href="#7-命令配置" class="headerlink" title="7. 命令配置"></a>7. 命令配置</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;script&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;命令&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;执行代码&quot;</span><span class="hljs-punctuation">,</span><br>    ...<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>执行配置的命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">必须加run</span><br>npm run 命令<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">特殊的命令 start 可不加run</span><br>npm start<br>或<br>npm run start<br></code></pre></td></tr></table></figure><h3 id="8-使用国内npm镜像源"><a href="#8-使用国内npm镜像源" class="headerlink" title="8. 使用国内npm镜像源"></a>8. 使用国内npm镜像源</h3><ol><li><p>使用配置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm config set registry https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure></li><li><p>使用<code>cnpm</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先安装cnpm工具</span><br>npm install -g cnpm --registry=https://registry.npm.taobao.org<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用cnpm代替npm</span><br>cnpm install 模块名<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin运算符重载重载函数表</title>
    <link href="/Kotlin-operator-SyntacticSugar.html"/>
    <url>/Kotlin-operator-SyntacticSugar.html</url>
    
    <content type="html"><![CDATA[<table>    <caption><strong>Kotlin运算符重载语法糖表达式和实际调用函数对照表</strong></caption>    <tr>        <th>语法糖表达式</th>        <th>实际调用函数</th>    </tr>    <tr>        <td>a + b</td>        <td>a.plus(b)</td>    </tr>    <tr>        <td>a - b</td>        <td>a.minus(b)</td>    </tr>    <tr>        <td>a * b</td>        <td>a.times(b)</td>    </tr>    <tr>        <td>a / b</td>        <td>a.div(b)</td>    </tr>    <tr>        <td>a % b</td>        <td>a.rem(b)</td>    </tr>    <tr>        <td>a++</td>        <td>a.inc()</td>    </tr>    <tr>        <td>a--</td>        <td>a.dec()</td>    </tr>    <tr>        <td>+a</td>        <td>a.unaryPlus()</td>    </tr>    <tr>        <td>-a</td>        <td>a.unaryMinus()</td>    </tr>    <tr>        <td>!a</td>        <td>a.not()</td>    </tr>    <tr>        <td>a==b</td>        <td rowspan=4>a.equals(b)</td>    </tr>    <tr>        <td>a == b</td>    </tr>    <tr>        <td>a > b</td>    </tr>    <tr>        <td>a < b</td>    </tr>    <tr>        <td>a >= b</td>    </tr>    <tr>        <td>a <= b</td>        <td>a.compareTo(b)</td>    </tr>       <tr>        <td>a..b</td>        <td>a.rangeTo(b)</td>    </tr>    <tr>        <td>a[b]</td>        <td>a.get(b)</td>    </tr>    <tr>        <td>a[b] = c</td>        <td>a.set(b, c)</td>    </tr>    <tr>        <td>a in b</td>        <td>b.contains(a)</td>    </tr></table>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android常见限定符(自适应不同屏幕的资源)</title>
    <link href="/AndroidQuilifiers.html"/>
    <url>/AndroidQuilifiers.html</url>
    
    <content type="html"><![CDATA[<h2 id="Android中常见的限定符-自适应不同屏幕的资源"><a href="#Android中常见的限定符-自适应不同屏幕的资源" class="headerlink" title="Android中常见的限定符(自适应不同屏幕的资源)"></a>Android中常见的限定符(自适应不同屏幕的资源)</h2><table>    <caption>Android中常见的限定符</caption>    <tr>        <th>屏幕特征</th>        <th>限定符</th>        <th>描述</th>    </tr>    <tr>        <td rowspan=4>大小</td>        <td>small</td>        <td>提供给小屏幕设备的资源</td>    </tr>    <tr>        <td>mormal</td>        <td>提供给中等屏幕设备的资源</td>    </tr>    <tr>        <td>large</td>        <td>提供给大屏幕设备的资源</td>    </tr>    <tr>        <td>xlarge</td>        <td>提供给超大屏幕设备的资源</td>    </tr>    <tr>        <td rowspan=5>分辨率</td>        <td>ldpi</td>        <td>提供给低分辨率设备的资源（120 dpi以下）</td>    </tr>    <tr>        <td>mdpi</td>        <td>提供给中等分辨率设备的资源（120 dpi~160 dpi）</td>    </tr>       <tr>        <td>hdpi</td>        <td>提供给高分辨率设备的资源（160 dpi~240 dpi）</td>    </tr>    <tr>        <td>xhdpi</td>        <td>提供给超高分辨率设备的资源（240 dpi~320 dpi）</td>    </tr>    <tr>        <td>xxhdpi</td>        <td>提供给超超高分辨率设备的资源（320 dpi~480 dpi）</td>    </tr>    <tr>        <td rowspan=2>方向</td>        <td>land</td>        <td>提供给横屏设备的资源</td>    </tr>    <tr>        <td>port</td>        <td>提供给竖屏设备的资源</td>    </tr></table><p>下面是上面4种屏幕尺寸所需的最低尺寸</p><ul><li>xlarge屏幕尺寸至少需要 960dp × 720dp</li><li>large屏幕尺寸至少需要 640dp × 480dp</li><li>normal屏幕尺寸至少需要 470dp × 320dp</li><li>small屏幕尺寸至少需要426dp × 320dp</li></ul><blockquote><p>从Android3.2开始，Android的建议直接使用真实的屏幕尺寸来定义屏幕尺寸。</p><p>Android 3.2 支持在layout、 values 目录后添加 </p><p>sw&lt;N&gt;dp （屏幕尺寸至少宽 N 个 dp 才能使用该资源）、</p><p>w&lt;N&gt;dp（屏幕尺寸可用宽度为N个dp可使用该资源）、</p><p>h&lt;N&gt;dp （屏幕尺寸可用高度为N个dp才能使用该资源）、</p><p>例如可指定layout-sw600dp，表明该设备屏幕的宽度大于或等于600个dp时使用该目录下的布局资源。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>移动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java和Kotlin的对照</title>
    <link href="/comparasonofJava-Kotlin.html"/>
    <url>/comparasonofJava-Kotlin.html</url>
    
    <content type="html"><![CDATA[<h2 id="Java和Kotlin数据类型对照表"><a href="#Java和Kotlin数据类型对照表" class="headerlink" title="Java和Kotlin数据类型对照表"></a>Java和Kotlin数据类型对照表</h2><table><thead><tr><th align="center">Java基本数据类型</th><th>Kotlin基本数据类型</th><th>数据类型说明</th></tr></thead><tbody><tr><td align="center">int</td><td>Int</td><td>整型</td></tr><tr><td align="center">long</td><td>Long</td><td>长整型</td></tr><tr><td align="center">short</td><td>Short</td><td>短整型</td></tr><tr><td align="center">float</td><td>Float</td><td>单精度浮点型</td></tr><tr><td align="center">double</td><td>Double</td><td>双精度浮点型</td></tr><tr><td align="center">boolean</td><td>Boolean</td><td>布尔型</td></tr><tr><td align="center">char</td><td>Char</td><td>字符型</td></tr><tr><td align="center">byte</td><td>Byte</td><td>字节型</td></tr></tbody></table><h2 id="Java和Kotlin函数可见性修饰符对照表"><a href="#Java和Kotlin函数可见性修饰符对照表" class="headerlink" title="Java和Kotlin函数可见性修饰符对照表"></a>Java和Kotlin函数可见性修饰符对照表</h2><table><thead><tr><th align="center">修饰符</th><th align="center">Java</th><th align="center">Kotlin</th></tr></thead><tbody><tr><td align="center">public</td><td align="center">所有类可见</td><td align="center">所有类可见(默认)</td></tr><tr><td align="center">private</td><td align="center">当前类可见</td><td align="center">当前类可见</td></tr><tr><td align="center">protected</td><td align="center">当前类、子类、同一包路径下的类可见</td><td align="center">当前类、子类可见</td></tr><tr><td align="center">default</td><td align="center">同一包路径下的类可见(默认)</td><td align="center">无</td></tr><tr><td align="center">internal</td><td align="center">无</td><td align="center">同一模块中的类可见</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UML类图</title>
    <link href="/UMLClassDiagram.html"/>
    <url>/UMLClassDiagram.html</url>
    
    <content type="html"><![CDATA[<h1 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h1><p>[toc]</p><h2 id="1-UML概述"><a href="#1-UML概述" class="headerlink" title="1. UML概述"></a>1. UML概述</h2><p>UML(Unified Modeling Language， 统一建模语言）是当前面向对象软件系统建模的标准语言 ，它融合了众多软件建模技术的优点 ，通过一系列标准的图形符号来描述系统 。 在设计模式的学习和使用过程中也需要掌握一些UML相关技术 ， 尤其是UML类图 ，通过类图可以更好地理解每一个设计模式的结构并对每一个模式实例进行分析 。</p><h2 id="2-类与类的UML表示"><a href="#2-类与类的UML表示" class="headerlink" title="2. 类与类的UML表示"></a>2. 类与类的UML表示</h2><h3 id="2-1-类"><a href="#2-1-类" class="headerlink" title="2.1 类"></a>2.1 类</h3><p>类(Class)封装了数据和行为 ，是面向对象的重要组成部分，它是具有相同属性 、操作、关系的对象集合的总称。</p><p>类图(Class Diagram)使用出现在系统中的不同类来描述系统的静态结构 ，它用来描述 不同的类以及它们之间的关系 。</p><h3 id="2-2-类的UML图示"><a href="#2-2-类的UML图示" class="headerlink" title="2.2 类的UML图示"></a>2.2 类的UML图示</h3><p>在UML中类使用包含类名属性和操作且带有分隔线的长方形来表示:</p><pre><code class=" mermaid">classDiagramclass Employee&#123;- name : String- age : int- email : String+ modify() : void    &#125;</code></pre><p>对应的Java代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String email;<br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyInfo</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在UML类图中, 类一般由三部分组成。</p><ol><li><p>第一部分是列名；</p></li><li><p>第二部分是类的属性（Attributes）：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。</p><hr><p>属性的标识方式如下：</p><p><strong>[ 可见性 ] 名称:类型 [ = 默认值 ]</strong></p><hr></li></ol><ol><li><p>“可见性” 表示该属性对于类外的元素而言是否可见，它们的符号表示如下：</p><table>    <tr>        <td>公有(public)</td>        <td>+</td>    </tr>    <tr>        <td>私有(private)</td>        <td>-</td>    </tr>    <tr>        <td>受保护(protected)</td>        <td>#</td>    </tr>    <tr>        <td>默认</td>        <td>*</td>    </tr></table></li><li><p>”名称“表示属性名，用一个字符串表示。</p></li><li><p>“类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。</p></li><li><p>“默认值是一个可选项，即属性的初始值。</p></li><li><p>第三部分是类的操作（Operations）：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。</p></li></ol><hr><p>   UML规定操作的表示方式如下：</p><p>   <strong>[ 可见性 ] 名称([ 参数列表 ]) [ : 返回类型]</strong></p><hr><p>   其中：</p><ol><li>“可见性”的定义和属性的可见性的定义相同。</li><li>“名称”即方法名或操作名，用一个字符串表示。</li><li>“参数列表”表示方法的参数，其语法与属性的定义相似 ，参数个数是任意的，多个参数之间用逗号” , “隔开 。</li><li>“返回类型”是一个可选性，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型(void) ，<em>如果是构造方法， 则无返回类型</em>。</li></ol><h3 id="2-3-类之间的关系"><a href="#2-3-类之间的关系" class="headerlink" title="2.3 类之间的关系"></a>2.3 类之间的关系</h3><p>在软件系统中类并不是孤立存在的 ，类与类之间存在各种关系， 对于不同类型的关系， UML 提供了不同的表示方式。</p><h4 id="2-3-1-关联关系"><a href="#2-3-1-关联关系" class="headerlink" title="2.3.1 关联关系"></a>2.3.1 关联关系</h4><p><strong>关联(Association)关系</strong>是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系， 如汽车和轮胎 、 师傅和徒弟 、 班级和学生等。</p><p>在UML类图中用<strong>实线</strong>连接有关联关系的对象所对应的类，在使用 Java 、 C ＃和 C＋＋等编程语言实现关联关系时，通常将一个类的对象作为另一个类的成员变量。</p><p>在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名词表示角色名（有时该名词为实例对象名） ，关系的两端代表两种不同的角色，因此在一个关联关系中可以包含两个角色名，角色名不是必须的 ，可以根据需要增加 ， 其目的是使类之间的关系更加明确 。</p><pre><code class=" mermaid">classDiagramclass LoginForm &#123;- loginButton : JButton&#125;JButton &lt;-- LoginForm : contains</code></pre><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginForm</span> &#123;<br>    <span class="hljs-keyword">private</span> JButton loginButton; <span class="hljs-comment">//定义为成员变量</span><br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JButton</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在UML中，关联关系包含以下集中形式：</p><ol><li><p>双向关联</p><p>在默认情况下关联是双向的。例如顾客(Customer)购买商品(Product)并拥有商品，反之，卖出的商品总有某个顾客与之相关联。 因此，Customer 类和 Product 类之间具有双向关联关系， 如下图：</p><pre><code class=" mermaid">classDiagramclass Customer &#123;- products : Product[]&#125;class Product &#123;- customer : Customer&#125;Customer &quot;purchases&quot; -- &quot;is sold to&quot; Product</code></pre><p>对应的Java片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">private</span> Productor[] products;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> Customer customer;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>单向关联</p><p>类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如顾客(Customer)拥有地址 (Address), 则Customer类与Address类具有单向关联关系，如下图：</p><pre><code class=" mermaid">classDiagramCustomer --&gt; Address : hasclass Customer &#123;- address : Address&#125;</code></pre><p>对应的Java片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br><span class="hljs-keyword">private</span> Address address;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>自关联</p><p>在系统中可能会存在一些类的属性对象类型为该类本身 ， 这种特殊的关联关系称为自关联。 例如一个结点类(Node)的成员又是结点 Node 类型的对象 ，如下图：</p><pre><code class=" mermaid">classDiagramclass Node &#123;- subNode : Node&#125;Node --&gt; Node : contains</code></pre><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">private</span> Node subNode;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多重性关联</p><p>多重性关联关系又称为重数性(Multiplicity)关联关系，表示两个关联对象在数量上的对应关系。 在UML中对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。</p><p>常见的多重性表示方式如下表所示：</p><table>    <caption>多重性表示方式表</caption>    <tr>        <th>表示方式</th>        <th>多重性说明</th>    </tr>    <tr>        <td>1. .1</td>        <td>表示另—个类的一个对象只与该类的一个对象有关系</td>    </tr>    <tr>        <td>0. .*</td>        <td>表示另—个类的一个对象与该类的零个或多个对象有关系</td>    </tr>    <tr>        <td>1. .*</td>        <td>表示另—个类的一个对象只与该类的一个对象或多个对象有关系</td>    </tr>    <tr>        <td>0. .1</td>        <td>表示另—个类的一个对象没有或只与该类的一个对象有关系</td>    </tr>    <tr>        <td>m. .n</td>        <td>表示另—个类的一个对象与该类最少m最多n个对象有关系(m <= n)</td>    </tr></table><p>例如一个界面(Form)可以拥有零个或多个按钮(Button) ，但是一个按钮只能属于一个界面， 因此一个Form类的对象可以与零个或多个Button类的对象相关联， 但一个Button类的对象只能与一个Form类的对象关联 ，如图所示：</p><pre><code class=" mermaid">classDiagramForm &quot;1. .1&quot; --&gt; &quot;0. .*&quot; Buttonclass Form &#123;- buttons : Button[]&#125;</code></pre><p>对应的Java代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Form</span> &#123;<br><span class="hljs-keyword">private</span> Button[] button; <span class="hljs-comment">//定义一个集合对象</span><br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>聚合关系</p><p>聚合(Aggregation)关系表示整体与部分的关系 。 在聚合关系中 ，成员对象是整体对象的一部分 ，但是成员对象可以脱离整体对象独立存在。 在UML中 ，聚合关系用带空心菱形的直线表示 。 例如汽车发动机(Engine)是汽车(Car)的组成部分 ，但是汽车发动机可以独立存在 ， 因此汽车和发动机是聚合关系，如图所示：</p><pre><code class=" mermaid">classDiagramclass Car &#123;-engine : Engine+Car(Engine engine)+setEngine(Engine engine) void&#125;Car o--&gt; Engine : cotains</code></pre><p>对应的Java代码片段如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><span class="hljs-keyword">private</span> Engine engine;<br><span class="hljs-comment">//构造注入</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">( Engine engine)</span>&#123;<br><span class="hljs-built_in">this</span>.engine = engine;<br>)<br><span class="hljs-comment">//设值注入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setEngine</span><span class="hljs-params">(Engine engine)</span>&#123;<br><span class="hljs-built_in">this</span>.engine = engine;<br>)<br>)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>组合关系</p><p>组合(Composition)关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，<em>一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系</em>。 在UML中，组合关系用带实心菱形的直线表示 。 例如人的头(Head)与嘴巴(Mouth) ， 嘴巴是头的组成部分之一， 而且如果头没了， 嘴巴也就没了，因此头和嘴巴是组合关系，如图所示:</p><pre><code class=" mermaid">classDiagramclass Head &#123;-mouth : Mouth+Head()&#125;callback Head &quot;callbackFunction&quot; &quot;This is a tooltip for a callback&quot;Head *--&gt; Mouth : has</code></pre><p>Java代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Head</span> &#123;<br>    <span class="hljs-keyword">private</span> Mouth mouth;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Head</span><span class="hljs-params">()</span> &#123;<br>        mouth = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Mouth</span>();<span class="hljs-comment">//实例化成员类</span><br>    &#125;<br>...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mouth</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-2-依赖关系"><a href="#2-3-2-依赖关系" class="headerlink" title="2.3.2 依赖关系"></a>2.3.2 依赖关系</h4><p><strong>依赖(Dependency )关系</strong>是一种使用关系 ，特定事物的改变有可能会影响到使用该事物的其他事物， 在需要表示一个事物使用另一个事物时使用依赖关系。 在大多数情况下， 依赖关系体现在某个类的方法使用另一个类的对象作为参数。 在UML中， 依赖关系用<strong>带箭头的虚线</strong>表示， 由依赖 的一方指向被依赖 的一方 。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/UML.svg"></p><p>对应的Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Driver</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">(Car car)</span> &#123;<br>        car.move();<br>    &#125;<br>    ...<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>在系统实现阶段， 依赖关系通常通过3种方式来实现：</p><p>第一种（也是最常用的一种方式） 将一个类的对象作为另一个类中方法的参数(如上例)；</p><p>第二种方式是在一个类的方法中将另一个类的对象作为其局部变量；</p><p>第三种方式是在一个类的方法中调用另一个类的静态方法。</p><h4 id="2-3-3-泛化关系"><a href="#2-3-3-泛化关系" class="headerlink" title="2.3.3 泛化关系"></a>2.3.3 泛化关系</h4><p><strong>泛化(Generalization)关系</strong>也就是<strong>继承关系</strong> ，用于描述父类与子类之间的关系 ， 父类又称作基类或超类， 子类又称作派生类。 在UML中， 泛化关系用<strong>带空心三角形的直线</strong>来表示 。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/SoWkIImgAStDuUNYvU9CpaaiBbO8I2qgpizJg0OAS2hd9UQcAbWf19SKPUQbWqKIqq42cNab89vsRdvPgeOcKA0iFpC5B5ASM8aiK0itDxYaD2KrhqGXjQ8aDIy5rHxTOeYaNpwAPTeWOHp6XQGc9cUa5c4thWGYYMuSM1ZDE5uk1w1-O1000000.svg"></p><p>对应的Java片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">say</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String studentNo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String teacherNo;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">teach</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-4-接口与实现关系"><a href="#2-3-4-接口与实现关系" class="headerlink" title="2.3.4 接口与实现关系"></a>2.3.4 接口与实现关系</h4><p>在 UML 中用与类的表示法类似的方式表示接口，接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种<strong>实现(Realization)关系</strong>，在这种关系中类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用<strong>带空心三角形的虚线</strong>来表示。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/SoWkIImgAStDKNYwRjxplWrFMpS_txmRo7wohvkNgoIp92SLgmndPbv9Qb5QOdAgWcDUPcvYZeAD3Lp8pguQg89JEpU_B5L3Ky5AeIm_CmKiKfnVcfU2B5JBomKay_9BKXMIyajAydCLyjEW9e8qFEjR-hH_yVDPBQ6-Fazdxtk-P1TGD3KlHG6a0wmLuOwmr8pCPA1pYN08nDRadCJYOeNWZCm2XSpSWfpKtDIyacAOCOGrEYSMOT6dW5EZ0z3Tm8060000.svg"></p><p>对应的Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Ship</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>UML</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java.util.function 接口的基本命名规则</title>
    <link href="/InterfaceNaming.html"/>
    <url>/InterfaceNaming.html</url>
    
    <content type="html"><![CDATA[<h2 id="java-util-function-接口的命名规则"><a href="#java-util-function-接口的命名规则" class="headerlink" title="java.util.function 接口的命名规则"></a>java.util.function 接口的命名规则</h2><ol><li>如果接口只处理对象，而不是基本类型，那就会用一个直截了当的名字，像 Function、Consumer和Predicate等。参数类型通过泛型添加。</li><li>若接口接受一个基本类型的参数，则会用名字的第一部分来表示，例如LongConsumer、DoubleFunction和Predicate等。参数类型会通过泛型添加。</li><li>若接口返回的是基本类型的结果，则会用 To 来表示，例如 ToLongFunction&lt;T&gt; 和 IntToLongFunction。</li><li>若接口返回的类型和参数类型相同，则会被命名为Operator。UnaryOperator用于表示一个参数，BinaryOperator用于表示两个参数。</li><li>若接口接受一个参数并返回 boolean，则会被命名为Predicate。</li><li>若接口接受两个不同类型的参数，则名字中会有一个Bi（比如BiPredicate）。</li></ol><h3 id="java-util-function的目标类型"><a href="#java-util-function的目标类型" class="headerlink" title="java.util.function的目标类型"></a>java.util.function的目标类型</h3><table><thead><tr><th align="left">特点</th><th align="left">函数式方法命名</th><th align="left">用法</th></tr></thead><tbody><tr><td align="left">没有参数；没有返回值</td><td align="left"><code>Runnable</code> (java.lang) <code>run()</code></td><td align="left"><code>Runnable</code></td></tr><tr><td align="left">没有参数；可以返回任何类型</td><td align="left"><code>Supplier</code> <code>get()</code> <code>getAs</code>type<code>()</code></td><td align="left"><code>Supplier&lt;T&gt;</code> <code>BooleanSupplier</code> <code>IntSupplier</code> <code>LongSupplier</code> <code>DoubleSupplier</code></td></tr><tr><td align="left">没有参数；可以返回任何类型</td><td align="left"><code>Callable</code> (java.util.concurrent) <code>call()</code></td><td align="left"><code>Callable&lt;V&gt;</code></td></tr><tr><td align="left">一个参数；没有返回值</td><td align="left"><code>Consumer</code> <code>accept()</code></td><td align="left"><code>Consumer&lt;T&gt;</code> <code>IntConsumer</code> <code>LongConsumer</code> <code>DoubleConsumer</code></td></tr><tr><td align="left">两个参数的<code>Consumer</code></td><td align="left"><code>BiConsumer</code> <code>accept()</code></td><td align="left"><code>BiConsumer&lt;T,U&gt;</code></td></tr><tr><td align="left">两个参数的<code>Consumer</code>；第一个参数是引用，第二个参数是基本类型</td><td align="left"><code>Obj</code>type<code>Consumer</code> <code>accept()</code></td><td align="left"><code>ObjIntConsumer&lt;T&gt;</code> <code>ObjLongConsumer&lt;T&gt;</code> <code>ObjDoubleConsumer&lt;T&gt;</code></td></tr><tr><td align="left">一个参数；返回值为不同类型</td><td align="left"><code>Function</code> <code>apply()</code> <code>To</code>type &amp; type<code>To</code>type: <code>applyAs</code>type<code>()</code></td><td align="left"><code>Function&lt;T,R&gt;</code> <code>IntFunction&lt;R&gt;</code> <code>LongFunction&lt;R&gt;</code> <code>DoubleFunction&lt;R&gt;</code> <code>ToIntFunction&lt;T&gt;</code> <code>ToLongFunction&lt;T&gt;</code> <code>ToDoubleFunction&lt;T&gt;</code> <code>IntToLongFunction</code> <code>IntToDoubleFunction</code> <code>LongToIntFunction</code> <code>LongToDoubleFunction</code> <code>DoubleToIntFunction</code> <code>DoubleToLongFunction</code></td></tr><tr><td align="left">一个参数；返回值为相同类型</td><td align="left"><code>UnaryOperator</code> <code>apply()</code></td><td align="left"><code>UnaryOperator&lt;T&gt;</code> <code>IntUnaryOperator</code> <code>LongUnaryOperator</code> <code>DoubleUnaryOperator</code></td></tr><tr><td align="left">两个相同类型的参数；返回值也是相同类型</td><td align="left"><code>BinaryOperator</code> <code>apply()</code></td><td align="left"><code>BinaryOperator&lt;T&gt;</code> <code>IntBinaryOperator</code> <code>LongBinaryOperator</code> <code>DoubleBinaryOperator</code></td></tr><tr><td align="left">两个相同类型的参数；返回<code>int</code></td><td align="left"><code>Comparator</code> (java.util) <code>compare()</code></td><td align="left"><code>Comparator&lt;T&gt;</code></td></tr><tr><td align="left">两个参数；返回<code>boolean</code></td><td align="left"><code>Predicate</code> <code>test()</code></td><td align="left"><code>Predicate&lt;T&gt;</code> <code>BiPredicate&lt;T,U&gt;</code> <code>IntPredicate</code> <code>LongPredicate</code> <code>DoublePredicate</code></td></tr><tr><td align="left">基本类型的参数；返回值也是基本类型</td><td align="left">type<code>To</code>type<code>Function</code> <code>applyAs</code>type<code>()</code></td><td align="left"><code>IntToLongFunction</code> <code>IntToDoubleFunction</code> <code>LongToIntFunction</code> <code>LongToDoubleFunction</code> <code>DoubleToIntFunction</code> <code>DoubleToLongFunction</code></td></tr><tr><td align="left">两个参数；不同类型</td><td align="left"><code>Bi</code>+操作名（方法名会变化）</td><td align="left"><code>BiFunction&lt;T,U,R&gt;</code> <code>BiConsumer&lt;T,U&gt;</code> <code>BiPredicate&lt;T,U&gt;</code> <code>ToIntBiFunction&lt;T,U&gt;</code> <code>ToLongBiFunction&lt;T,U&gt;</code> <code>ToDoubleBiFunction&lt;T,U&gt;</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓常见距离单位</title>
    <link href="/AndroidDistances.html"/>
    <url>/AndroidDistances.html</url>
    
    <content type="html"><![CDATA[<h1 id="安卓常见距离单位"><a href="#安卓常见距离单位" class="headerlink" title="安卓常见距离单位"></a>安卓常见距离单位</h1><ul><li><strong>px (像素)</strong> : 每个px对应屏幕上的一个点</li><li><strong>dip 或 dp (device independent pixels， 设备独立像素)</strong> : 一种屏幕密度的抽象单位。 在每英寸 160 点的显示器上， 1dip = 1px， dip 与 px。 但随着屏幕密度的改变， dip 与 px 的换算会发生改变。</li><li><strong>sp (scaled pixels， 比例像素)</strong> : 主要处理字体的大小， 可以根据用户的字体大小首选项进行缩放。</li><li><strong>in (英寸)</strong> : 标准长度单位。</li><li><strong>mm (毫米)</strong> : 标准长度单位。</li><li><strong>pt (磅)</strong> : 标准长度单位。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>移动开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>构造随机数和随机字符串</title>
    <link href="/randomthingsofpython.html"/>
    <url>/randomthingsofpython.html</url>
    
    <content type="html"><![CDATA[<h1 id="利用Python构造随机数和随机字符串"><a href="#利用Python构造随机数和随机字符串" class="headerlink" title="利用Python构造随机数和随机字符串"></a>利用Python构造随机数和随机字符串</h1><table><thead><tr><th>Python语句</th><th>输出示例</th></tr></thead><tbody><tr><td><code>import random</code> 可以写成：<code>from random import *</code> 此时后面的代码能够简单一点，例如把<code>random.randint</code>直接写为 <code>randint</code></td><td></td></tr><tr><td>在指定范围内生成一个很大的随机整数： <code>print (random.randint(-9999999999999999,10e20))</code></td><td>417715183092046338</td></tr><tr><td>在指定范围内（0到100000）生成一个随机偶数： <code>print (random.randrange(0, 100001, 2))</code></td><td>14908</td></tr><tr><td>生成一个0到1之间的随机浮点数： <code>print (random.random())</code></td><td>0.2856636141181378</td></tr><tr><td>在指定范围内（1到20）生成一个随机浮点数： <code>print (random.uniform(1, 20))</code></td><td>9.81984258258233</td></tr><tr><td>在指定字符中生成一个随机字符： <code>print (random.choice(&#39;abcdefghijklmnopqrst@#$%*()&#39;))</code></td><td>d</td></tr><tr><td>在指定字符中生成指定数量的随机字符： <code>print (random.sample(&#39;utsrqpozyxwvnmlkjihgfedcba&#39;,5))</code></td><td>[‘z’, ‘u’, ‘x’, ‘w’, ‘j’]</td></tr><tr><td><code>import string</code> 若写成 <code>from string import *</code>，下面的<code>string.ascii_letters</code> 改为 <code>ascii_letters</code></td><td></td></tr><tr><td>用a-z、A-Z、0-9生成指定数量的随机字符串： <code>ran_s = &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 7))print (ran_s)</code></td><td>iCTm6yN</td></tr><tr><td>从多个字符中选取指定数量的字符组成新字符串： <code>print (&#39;&#39;.join(random.sample([&#39;m&#39;,&#39;l&#39;,&#39;i&#39;,&#39;h&#39;,&#39;g&#39;,&#39;k&#39;,&#39;j&#39;,&#39;d&#39;], 5)))</code></td><td>mjlhd</td></tr><tr><td>打乱顺序： <code>items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] random.shuffle(items)for i in range(0,len(items),1): #逐个打印 print (items[i],&quot; &quot;,end=&#39;&#39;)</code></td><td>1 0 8 3 5 7 9 4 6 2###</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CSS 层叠样式表</title>
    <link href="/CSSLearning.html"/>
    <url>/CSSLearning.html</url>
    
    <content type="html"><![CDATA[<h1 id="CSS学习"><a href="#CSS学习" class="headerlink" title="CSS学习"></a>CSS学习</h1><p>CSS全称为“层叠样式表 (Cascading Style Sheets)”，它主要是用于定义HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202203271734537.jpeg" alt="img"></p><p><strong>选择符：</strong>又称选择器，指明网页中要应用样式规则的元素，如本例中是网页中所有的段（p）的文字将变成蓝色，而其他的元素（如ol）不会受到影响。</p><p><strong>声明：</strong>在英文大括号“｛｝”中的的就是声明，属性和值之间用英文冒号“：”分隔。当有多条声明时，中间可以英文分号“;”分隔，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;<span class="hljs-attribute">color</span>:red;&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>1、最后一条声明可以没有分号，但是为了以后修改方便，一般也加上分号。</p><p>2、为了使用样式更加容易阅读，可以将每条代码写在一个新行内，如下所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span>&#123;<br>   <span class="hljs-attribute">font-size</span>:<span class="hljs-number">12px</span>;<br>   <span class="hljs-attribute">color</span>:red;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>就像在Html的注释一样，在CSS中也有注释语句：用<code>/*注释语句*/</code>来标明（Html中使用<code>&lt;!--注释语句--&gt;</code>)。就像下面代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>; <span class="hljs-comment">/*设置文字子号为12px*/</span><br>    <span class="hljs-attribute">color</span>: red; <span class="hljs-comment">/*设置文字颜色为红色*/</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h3><p><em>不要在属性值与单位之间留有空格（如：”margin-left: 20 px” ），正确的写法是 “margin-left: 20px” 。</em></p><h4 id="内联式"><a href="#内联式" class="headerlink" title="内联式"></a>内联式</h4><p>CSS样式可以写在哪些地方呢？从CSS 样式代码插入的形式来看基本可以分为以下3种：内联式、嵌入式和外部式三种。这一小节先来讲解内联式。</p><p><code>内联式</code>css样式表就是把css代码直接写在现有的HTML标签中，如下面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red&quot;</span>&gt;</span>这里文字是红色。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意要写在元素的开始标签里，下面这种写法是错误的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这里文字是红色。&lt;/p style=&quot;color:red&quot;&gt;<br></code></pre></td></tr></table></figure><p>并且css样式代码要写在style=””双引号中，如果有多条css样式代码设置可以写在一起，中间用分号隔开。如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red;font-size:12px&quot;</span>&gt;</span>这里文字是红色。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="嵌入式-内部"><a href="#嵌入式-内部" class="headerlink" title="嵌入式/内部"></a>嵌入式/内部</h4><p>嵌入式css样式，就是可以把css样式代码写在**<style type="text/css"></style>**标签之间。如下面代码实现把三个<span>标签中的文字设置为红色：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">span</span>&#123;</span><br><span class="language-css"><span class="hljs-attribute">color</span>:red;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>嵌入式css样式必须写在<code>&lt;style&gt;``&lt;/style&gt;</code>之间，并且一般情况下嵌入式css样式写在<code>&lt;head&gt;``&lt;/head&gt;</code>之间。如右边编辑器中的代码。</p><h4 id="外部式"><a href="#外部式" class="headerlink" title="外部式"></a>外部式</h4><p>外部式css样式(也可称为外联式)就是把css代码写一个单独的外部文件中，这个css样式文件以“<code>.css</code>”为扩展名，在<code>&lt;head&gt;</code>内（不是在<code>&lt;style&gt;</code>标签内）使用<code>&lt;link&gt;</code>标签将css样式文件链接到HTML文件内，如下面代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mystyle.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mystyle.css : </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hr &#123;<span class="hljs-attribute">color</span>:sienna;&#125;<br><span class="hljs-selector-tag">p</span> &#123;<span class="hljs-attribute">margin-left</span>:<span class="hljs-number">20px</span>;&#125;<br><span class="hljs-selector-tag">body</span> &#123;<span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;/images/back40.gif&quot;</span>);&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><ol><li><p>css样式文件名称以有意义的英文字母命名，如 main.css。</p></li><li><p>rel=”stylesheet” type=”text/css” 是固定写法不可修改。</p></li><li><p><code>&lt;link&gt;</code>标签位置一般写在<code>&lt;head&gt;</code>标签之内。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML中的&lt;head&gt;标签</title>
    <link href="/HTML-head.html"/>
    <url>/HTML-head.html</url>
    
    <content type="html"><![CDATA[<h1 id="HTML中的-lt-head-gt-标签"><a href="#HTML中的-lt-head-gt-标签" class="headerlink" title="HTML中的 &lt;head&gt;标签"></a>HTML中的 <code>&lt;head&gt;</code>标签</h1><h3 id="Metadata-HTML中的元数据"><a href="#Metadata-HTML中的元数据" class="headerlink" title="Metadata-HTML中的元数据"></a>Metadata-HTML中的元数据</h3><p>HTML <code>&lt;head&gt;</code>元素与 <code>&lt;body&gt;</code>元素不同，它的内容不会在浏览器中显示，它的作用是保存页面的一些 元数据。</p><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p><code>&lt;title&gt;</code>元素是一项元数据，用于表示整个 HTML 文档的标题（而不是文档内容）。</p><h4 id="原数据-lt-meta-gt-元素"><a href="#原数据-lt-meta-gt-元素" class="headerlink" title="原数据 &lt;meta&gt;元素"></a>原数据 <code>&lt;meta&gt;</code>元素</h4><p><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code> : 这个元素简单的指定了文档的字符编码 —— 在这个文档中被允许使用的字符集。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h4><ul><li><code>&lt;name&gt;</code> : 指定了meta 元素的类型； 说明该元素包含了什么类型的信息。</li><li><code>&lt;content&gt;</code> :  指定了实际的元数据内容。</li></ul><h3 id="自定义图标"><a href="#自定义图标" class="headerlink" title="自定义图标"></a>自定义图标</h3><ol><li><p>将其保存在与网站的索引页面相同的目录中，以.ico格式保存（大多数浏览器将支持更通用的格式，如.gif或.png，但使用ICO格式将确保它能在如Internet Explorer 6一样久远的浏览器显示）</p></li><li><p>将以下行添加到HTML <code>&lt;head&gt;</code>中以引用它：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;shortcut icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon.ico&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/x-icon&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="应用CSS和JavaScript"><a href="#应用CSS和JavaScript" class="headerlink" title="应用CSS和JavaScript"></a>应用CSS和JavaScript</h3><ul><li><code>link</code>元素经常位于文档的头部。这个link元素有2个属性，rel=”stylesheet”表明这是文档的样式表，而 href包含了样式表文件的路径：</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;my-css-file.css&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><code>&lt;script&gt;</code>部分没必要非要放在文档头部；实际上，把它放在文档的尾部（在 <code>&lt;/body&gt;标签之前</code>）是一个更好的选择，这样可以确保在加载脚本之前浏览器已经解析了HTML内容（如果脚本加载某个不存在的元素，浏览器会报错）。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;my-js-file.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="文档主语言"><a href="#文档主语言" class="headerlink" title="文档主语言"></a>文档主语言</h3><p>在<code>&lt;html&gt;</code>中添加<code>lang</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;zh-CN&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML常见标签</title>
    <link href="/htmllearning.html"/>
    <url>/htmllearning.html</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-学习"><a href="#HTML-学习" class="headerlink" title="HTML 学习"></a>HTML 学习</h1><h2 id="HTML文档"><a href="#HTML文档" class="headerlink" title="HTML文档"></a>HTML文档</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的测试站点<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是我的页面<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>分析如下:</p><ol><li><code>&lt;!DOCTYPE html&gt;</code>: 声明文档类型.</li><li><code>&lt;html&gt;&lt;/html&gt;</code>: <code>&lt;html&gt;</code>元素。这个元素包裹了整个完整的页面，是一个根元素。</li><li><code>&lt;head&gt;&lt;/head&gt;</code>: <code>&lt;head&gt;</code>元素。这个元素是一个容器，包含所有想包含在HTML页面中但不想在HTML页面中显示的内容。这些内容包括你想在搜索结果中出现的关键字和页面描述，CSS样式，字符集声明等等。</li><li><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>: 这个元素设置文档使用utf-8字符集编码，utf-8字符集包含了人类大部分的文字。基本上他能识别你放上去的所有文本内容。毫无疑问要使用它，并且它能在以后避免很多其他问题。</li><li><code>&lt;title&gt;&lt;/title&gt;</code>: 设置页面标题，出现在浏览器标签上。</li><li><code>&lt;body&gt;&lt;/body&gt;</code>: <code>&lt;body&gt;</code>元素。 包含了你访问页面时所有显示在页面上的内容，文本，图片，音频，游戏等等。</li></ol><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>主标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>顶层标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>子标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>次子标题<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><h1>主标题</h1><h2>顶层标题</h2><h3>子标题</h3><h4>次子标题</h4></blockquote><h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>精彩少年<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>美丽突然出现<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>触动心灵的旋律<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><ul>  <li>精彩少年</li>  <li>美丽突然出现</li>  <li>触动心灵的旋律</li></ul><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>前端开发面试心法 <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>零基础学习html<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>JavaScript全攻略<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure><ol>   <li>前端开发面试心法 </li>   <li>零基础学习html</li>   <li>JavaScript全攻略</li></ol><h4 id="描述列表"><a href="#描述列表" class="headerlink" title="描述列表"></a>描述列表</h4><p>描述列表使用与其他列表类型不同的闭合标签— <code>&lt;dl&gt;</code>; 此外，每一项都用 <code>&lt;dt&gt;</code>元素闭合。每个描述都用元素 <code>&lt;dd&gt;</code>闭合。</p><p>浏览器的默认样式会在<strong>描述列表的描述部分</strong>（description definition）和<strong>描述术语</strong>（description terms）之间产生缩进。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>内心独白<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>语言独白<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>旁白<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></td></tr></table></figure><dl>  <dt>内心独白</dt>    <dd>戏剧中，某个角色对自己的内心活动或感受进行念白表演，这些台词只面向观众，而其他角色不会听到。</dd>  <dt>语言独白</dt>    <dd>戏剧中，某个角色把自己的想法直接进行念白表演，观众和其他角色都可以听到。</dd>  <dt>旁白</dt>    <dd>戏剧中，为渲染幽默或戏剧性效果而进行的场景之外的补充注释念白，只面向观众，内容一般都是角色的感受、想法、以及一些背景信息等。</dd></dl><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>a标签有的 <code>target</code>属性，代表打开网页的方式。可选值为”<code>_self</code>和 <code>_blank</code>”，默认值为 <code>_self</code>，代表在当前页面打开链接，<code>_blank</code>代表在新窗口打开链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;目标网址&quot;</span>  <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;鼠标滑过显示的文本&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>链接显示的文本<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:nowhere@mozilla.org&quot;</span>&gt;</span>向 nowhere 发邮件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;a href=&quot;mailto:nowhere@mozilla.org&quot;&gt;</code>向 nowhere 发邮件<code>&lt;/a&gt;</code></p><p>主题(subject)、抄送(cc)和主体(body):</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:nowhere@mozilla.org?cc=name2@rapidtables.com&amp;bcc=name3@rapidtables.com&amp;subject=The%20subject%20of%20the%20email&amp;body=The%20body%20of%20the%20email&quot;</span>&gt;</span><br>  Send mail with cc, bcc, subject and body<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><a href="mailto:nowhere@mozilla.org?cc=name2@rapidtables.com&bcc=name3@rapidtables.com&subject=The%20subject%20of%20the%20email&body=The%20body%20of%20the%20email">  Send mail with cc, bcc, subject and body</a><h3 id="HTML的特殊字符"><a href="#HTML的特殊字符" class="headerlink" title="HTML的特殊字符"></a>HTML的特殊字符</h3><table><thead><tr><th align="left">原义字符</th><th align="left">等价字符引用</th></tr></thead><tbody><tr><td align="left">&lt;</td><td align="left">&amp;lt;</td></tr><tr><td align="left">&gt;</td><td align="left">&amp;gt;</td></tr><tr><td align="left">“</td><td align="left">&amp;quot;</td></tr><tr><td align="left">‘</td><td align="left">&amp;apos;</td></tr><tr><td align="left">&amp;</td><td align="left">&amp;amp;</td></tr></tbody></table><h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- &lt;p&gt;我在注释内！&lt;/p&gt; --&gt;</span><br></code></pre></td></tr></table></figure><h3 id="自定义文字样式"><a href="#自定义文字样式" class="headerlink" title="自定义文字样式"></a>自定义文字样式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>文字<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="块引用"><a href="#块引用" class="headerlink" title="块引用"></a>块引用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>HTML <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> Element<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> (or <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>HTML Block<br>  Quotation Element<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span>) indicates that the enclosed text is an extended quotation.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/blockquote">  <p>The <strong>HTML <code><blockquote></code> Element</strong> (or <em>HTML Block  Quotation Element</em>) indicates that the enclosed text is an extended quotation.</p></blockquote><h4 id="行内引用"><a href="#行内引用" class="headerlink" title="行内引用"></a>行内引用</h4><p><code>&lt;q&gt;</code> : 浏览器默认将其作为普通文本放入引号内表示引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The quote element — <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">q</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> — is <span class="hljs-tag">&lt;<span class="hljs-name">q</span> <span class="hljs-attr">cite</span>=<span class="hljs-string">&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q&quot;</span>&gt;</span>intended<br>for short quotations that don&#x27;t require paragraph breaks.<span class="hljs-tag">&lt;/<span class="hljs-name">q</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>The quote element — <code><q></code> — is <q cite="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/q">intendedfor short quotations that don't require paragraph breaks.</q></p><h3 id="缩略语"><a href="#缩略语" class="headerlink" title="缩略语"></a>缩略语</h3><p><code>&lt;abbr&gt;</code>常被用来包裹一个缩略语或缩写，并且提供缩写的解释（包含在 <code>&lt;title&gt;</code>属性中）。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我们使用 <span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;超文本标记语言（Hyper text Markup Language）&quot;</span>&gt;</span>HTML<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span> 来组织网页文档。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>第 33 届 <span class="hljs-tag">&lt;<span class="hljs-name">abbr</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;夏季奥林匹克运动会&quot;</span>&gt;</span>奥运会<span class="hljs-tag">&lt;/<span class="hljs-name">abbr</span>&gt;</span> 将于 2024 年 8 月在法国巴黎举行。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>我们使用 <abbr title="超文本标记语言（Hyper text Markup Language）">HTML</abbr> 来组织网页文档。</p><p>第 33 届 <abbr title="夏季奥林匹克运动会">奥运会</abbr> 将于 2024 年 8 月在法国巴黎举行。</p><h3 id="标记联系方式"><a href="#标记联系方式" class="headerlink" title="标记联系方式"></a>标记联系方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Page written by <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../authors/chris-mills/&quot;</span>&gt;</span>Chris Mills<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br></code></pre></td></tr></table></figure><address>  <p>Page written by <a href="../authors/chris-mills/">Chris Mills</a>.</p></address><h3 id="上标和下标"><a href="#上标和下标" class="headerlink" title="上标和下标"></a>上标和下标</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>咖啡因的化学方程式是 C<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>H<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>N<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>O<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>如果 x<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span> 的值为 9，那么 x 的值必为 3 或 -3。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>咖啡因的化学方程式是 C<sub>8</sub>H<sub>10</sub>N<sub>4</sub>O<sub>2</sub>。</p><p>如果 x<sup>2</sup> 的值为 9，那么 x 的值必为 3 或 -3。</p><h3 id="展示计算机代码"><a href="#展示计算机代码" class="headerlink" title="展示计算机代码"></a>展示计算机代码</h3><ul><li><code>&lt;code&gt;</code> : 用于标记计算机通用代码。</li><li><code>&lt;pre&gt;</code> : 用于保留空白字符（通常用于代码块）。</li><li><code>&lt;var&gt;</code> : 用于标记具体变量名。</li><li><code>&lt;kbd&gt;</code> : 用于标记输入电脑的键盘（或其他类型）输入。</li><li><code>&lt;samp&gt;</code> : 用于标记计算机程序的输出。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>const para = document.querySelector(&#x27;p&#x27;);<br><br>para.onclick = function() &#123;<br>  alert(&#x27;噢，噢，噢，别点我了。&#x27;);<br>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>请不要使用 <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">font</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> 、 <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> 等表象元素。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>在上述的 JavaScript 示例中，<span class="hljs-tag">&lt;<span class="hljs-name">var</span>&gt;</span>para<span class="hljs-tag">&lt;/<span class="hljs-name">var</span>&gt;</span> 表示一个段落元素。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>按 <span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>Ctrl<span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span>/<span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>Cmd<span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span> + <span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span> 选择全部内容。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span>$ <span class="hljs-tag">&lt;<span class="hljs-name">kbd</span>&gt;</span>ping mozilla.org<span class="hljs-tag">&lt;/<span class="hljs-name">kbd</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">samp</span>&gt;</span>PING mozilla.org (63.245.215.20): 56 data bytes<br>64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms<span class="hljs-tag">&lt;/<span class="hljs-name">samp</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><pre><code>const para = document.querySelector('p');para.onclick = function() &#123;  alert('噢，噢，噢，别点我了。');&#125;</code></pre><p>请不要使用 <code><font></code> 、 <code><center></code> 等表象元素。</p><p>在上述的 JavaScript 示例中，<var>para</var> 表示一个段落元素。</p><p>按 <kbd>Ctrl</kbd>/<kbd>Cmd</kbd> + <kbd>A</kbd> 选择全部内容。</p><pre>$ <kbd>ping mozilla.org</kbd><samp>PING mozilla.org (63.245.215.20): 56 data bytes64 bytes from 63.245.215.20: icmp_seq=0 ttl=40 time=158.233 ms</samp></pre><hr><h3 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h3><p><code>&lt;time&gt;</code> 元素 :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2016-01-20&quot;</span>&gt;</span>2016年1月20日<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 标准简单日期 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2016-01-20&quot;</span>&gt;</span>20 January 2016<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只包含年份和月份--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2016-01&quot;</span>&gt;</span>January 2016<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只包含月份和日期 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;01-20&quot;</span>&gt;</span>20 January<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只包含时间，小时和分钟数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;19:30&quot;</span>&gt;</span>19:30<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 还可包含秒和毫秒 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;19:30:01.856&quot;</span>&gt;</span>19:30:01.856<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 日期和时间 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2016-01-20T19:30&quot;</span>&gt;</span>7.30pm, 20 January 2016<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 含有时区偏移值的日期时间 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2016-01-20T19:30+01:00&quot;</span>&gt;</span>7.30pm, 20 January 2016 is 8.30pm in France<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 调用特定的周 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">time</span> <span class="hljs-attr">datetime</span>=<span class="hljs-string">&quot;2016-W04&quot;</span>&gt;</span>The fourth week of 2016<span class="hljs-tag">&lt;/<span class="hljs-name">time</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="区段专用标签"><a href="#区段专用标签" class="headerlink" title="区段专用标签"></a>区段专用标签</h3><ul><li><code>&lt;header&gt;</code> : 页眉。是简介形式的内容。如果它是 <code>&lt;body&gt;</code>的子元素，那么就是网站的全局页眉。如果它是 <code>&lt;body&gt;</code>或 <code>&lt;section&gt;</code>的子元素，那么它是这些部分特有的页眉。</li><li><code>&lt;nav&gt;</code> ：导航栏。包含页面主导航功能。其中不应包含二级链接等内容。</li><li><code>&lt;main&gt;</code> ：主内容。主内容中还可以有各种子内容区段，可用 <code>&lt;article&gt;</code>、<code>&lt;section&gt;</code>  和 <code>&lt;div&gt;</code>等元素表示。存放每个页面独有的内容。每个页面上只能用一次 <code>&lt;main&gt;</code>，且直接位于 <code>&lt;body&gt;</code> 中。最好不要把它嵌套进其它元素。</li><li><code>&lt;article&gt;</code> : 包围的内容即一篇文章，与页面其它部分无关（比如一篇博文）。</li><li><code>&lt;section&gt;</code> : 与 <code>&lt;article&gt;</code> 类似，但 <code>&lt;section&gt;</code> 更适用于组织页面使其按功能（比如迷你地图、一组文章标题和摘要）分块。</li><li><code>&lt;aside&gt;</code> ：侧边栏，经常嵌套在 <code>&lt;main&gt;</code> 中。包含一些间接信息（术语条目、作者简介、相关链接，等等）。</li><li><code>&lt;footer&gt;</code> ：页脚。</li></ul><h3 id="无语义元素"><a href="#无语义元素" class="headerlink" title="无语义元素"></a>无语义元素</h3><p><code>&lt;div&gt;</code> : 块级无语义元素, 应仅用于找不到更好的块级元素时，或者不想增加特定的意义时。</p><p><code>&lt;span&gt; </code> : 是一个内联的（inline）无语义元素，最好只用于无法找到更好的语义元素来包含内容时，或者不想增加特定的含义时。</p><h3 id="换行与水平分割线"><a href="#换行与水平分割线" class="headerlink" title="换行与水平分割线"></a>换行与水平分割线</h3><p><code>&lt;br&gt;</code> : 换行</p><p><code>&lt;hr&gt;</code> : 水平分割线</p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ol><li>src：标识图像的位置；</li><li>alt：指定图像的描述性文本，当图像不可见时（下载不成功时），可看到该属性指定的文本；</li><li>title：提供在图像可见时对图像的描述(鼠标滑过图片时显示的文本)；</li><li>图像可以是GIF，PNG，JPEG格式的图像文件。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;图片地址&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;下载失败时的替换文本&quot;</span> <span class="hljs-attr">title</span> = <span class="hljs-string">&quot;提示文本&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 例如 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307174519139.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;下载失败&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;时区选择&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307174519139.png" alt="下载失败" title="时区选择" width="240" height="200"><p> HTML5 的 <code>&lt;figure&gt;</code> 和 <code>&lt;figcaption&gt;</code>元素在标题和图片之间建立关联</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307174519139.png&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;时区选择&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;240&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;200&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>这是CentOS系统安装的时区选择界面<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br></code></pre></td></tr></table></figure><figure>  <img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307174519139.png"     alt="时区选择"     width="240"     height="200">  <figcaption>这是CentOS系统安装的时区选择界面</figcaption></figure><p><code>&lt;figure&gt;</code> 里不一定要是一张图片，</p><p>只要是一个类似的独立内容单元(图片, 代码, 音视频, 方程, 表格等)：</p><ul><li>用简洁、易懂的方式表达意图。</li><li>可以置于页面线性流的某处。</li><li>为主要内容提供重要的补充说明。</li></ul><h4 id="自适应图片"><a href="#自适应图片" class="headerlink" title="自适应图片"></a>自适应图片</h4><p><code>&lt;picture&gt; </code>元素 : picture 元素允许我们在不同的设备上显示不同的图片，一般用于响应式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">picture</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 650px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;demo1.jpg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(min-width: 465px)&quot;</span> <span class="hljs-attr">srcset</span>=<span class="hljs-string">&quot;demo2.jpg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img_girl.jpg&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">picture</span>&gt;</span><br></code></pre></td></tr></table></figure><picture>  <source media="(min-width: 650px)" srcset="https://static.runoob.com/images/mix/html-css-js.png">  <source media="(min-width: 465px)" srcset="https://static.runoob.com/images/mix/htmlbig.png">  <img src="https://static.runoob.com/images/mix/img_avatar.png"  style="width:auto;"></picture><p><code>&lt;picture&gt;</code> 元素零或多个 <code>&lt;source&gt; </code>元素和一个 <code>&lt;img&gt;</code>元素，每个 <code> &lt;source&gt;</code> 元素匹配不同的设备并引用不同的图像源，如果没有匹配的，就选择 <code>&lt;img&gt;</code> 元素的 src 属性中的 url。</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>创建表格的四个元素: <code>&lt;table&gt;</code>、<code>&lt;tr&gt;</code>、<code>&lt;th&gt;</code>、<code>&lt;td&gt;</code></p><ol><li><code>&lt;table&gt;</code>…<code>&lt;/table&gt;</code> ：整个表格以 <code>&lt;table&gt;</code>标记开始、<code>&lt;/table&gt;</code>标记结束。</li><li><code>&lt;tr&gt;</code>…<code>&lt;/tr&gt;</code> ：表格的一行，所以有几对 tr 表格就有几行。</li><li><code>&lt;td&gt;</code>…<code>&lt;/td&gt;</code> ：表格的一个单元格，一行中包含几对 <code>&lt;td&gt;</code>…<code>&lt;/td&gt;</code>，说明一行中就有几列。</li><li><code>&lt;th&gt;</code>…<code>&lt;/th&gt;</code>：表格的头部的一个单元格，表格表头。</li><li>表格中列的个数，取决于一行中数据单元格的个数。</li><li>border属性可以为表格添加边框，属性值为数字。</li></ol><p>**注意 : **</p><ol><li>table标签用来定义整个表格，为双标签，必须有结束标签。</li><li>table标签里面可以放caption标签和tr标签。</li><li>caption标签用来定义表格的标题。</li><li>tr标签用来设置表格的行，tr里面只能放th或者td标签，一组tr标签代表一行。</li><li>th用来设置表格的标题，会<strong>加粗居中</strong>显示。也就是th标签中的文本默认为粗体并且居中显示。</li><li>td同来设置表格的列，一组td标签代表一列。</li><li>table表格在没有添加border属性之前, 在浏览器中显示是没有表格线的。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>前端三剑客<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>知识点<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>重要程度<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>难度<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>学习周期<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>html<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>*****<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>***<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>7天<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>css<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>*****<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>****<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>10天<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>js<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>*****<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>*****<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>20天<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table border="1">        <caption>前端三剑客</caption>        <tr>            <th>知识点</th>            <th>重要程度</th>            <th>难度</th>            <th>学习周期</th>        </tr>        <tr>            <td>html</td>            <td>*****</td>            <td>***</td>            <td>7天</td>        </tr>        <tr>            <td>css</td>            <td>*****</td>            <td>****</td>            <td>10天</td>        </tr>        <tr>            <td>js</td>            <td>*****</td>            <td>*****</td>            <td>20天</td>        </tr>    </table>#### 允许单元格跨多行和列<p><code>rowspan</code> : 设置单元格可纵跨的行数。</p><p><code>colspan</code> : 规定单元格可横跨的列数。</p><h4 id="表格格式化"><a href="#表格格式化" class="headerlink" title="表格格式化"></a>表格格式化</h4><p><code>&lt;colgroup&gt;</code>标签 : 用于对表格中的列进行组合，以便对其进行格式化。通过使用 <code>&lt;colgroup&gt;</code> 标签，可以向整个列应用样式，而不需要重复为每个单元格或每一行设置样式。</p><p><strong>注释：</strong>只能在 <code>&lt;table&gt;</code>元素之内，在任何一个 <code>&lt;caption&gt;</code> 元素之后，在任何一个 <code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>、<code>&lt;tfoot&gt;</code>、<code>&lt;tr&gt; </code>元素之前使用 <code>&lt;colgroup&gt;</code> 标签。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">colgroup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">span</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:red&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">col</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color:yellow&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">colgroup</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>ISBN<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>3476896<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>My first HTML<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$53<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>5869207<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>My first CSS<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>$49<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table border="1">  <colgroup>    <col span="2" style="background-color:red">    <col style="background-color:yellow">  </colgroup>  <tr>    <th>ISBN</th>    <th>Title</th>    <th>Price</th>  </tr>  <tr>    <td>3476896</td>    <td>My first HTML</td>    <td>$53</td>  </tr>  <tr>    <td>5869207</td>    <td>My first CSS</td>    <td>$49</td>  </tr></table><h4 id="使用thead-tbody-tfoot-定义表格"><a href="#使用thead-tbody-tfoot-定义表格" class="headerlink" title="使用thead, tbody, tfoot 定义表格"></a>使用thead, tbody, tfoot 定义表格</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/2022-03-24/5e91834a000161cc06140254.jpg">)</p><p>表格第一行为表头数据,我们用 <code>&lt;thead&gt;</code>标签包裹,中间的科目和分数为表格的主体内容,我们用 <code>&lt;tbody&gt;</code>标签包裹,最后的总分我们用 <code>&lt;tfoot&gt;</code>标签包裹。</p><ol><li><code>&lt;thead&gt;</code> 标签定义表格的表头。该标签用于组合 HTML 表格的表头内容。</li><li><code>&lt;tbody&gt;…&lt;/tbody&gt;</code>：如果不加 <code>&lt;thead&gt;</code> <code>&lt;tbody&gt;</code> <code>&lt;tfooter&gt;</code> , table表格加载完后才显示。加上这些表格结构， tbody包含行的内容下载完优先显示，不必等待表格结束后在显示，同时如果表格很长，用tbody分段，可以一部分一部分地显示。（通俗理解table 可以按结构一块块的显示，不在等整个表格加载完后显示。）</li><li><code>&lt;tfoot&gt;</code> 元素用于对 HTML 表格中的表注（页脚）内容进行分组。</li><li>thead、tfoot 以及 tbody 元素使您有能力对表格中的行进行分组。当您创建某个表格时，您也许希望拥有一个标题行，一些带有数据的行，以及位于底部的一个总计行。这种划分使浏览器有能力支持独立于表格标题和页脚的表格正文滚动。当长的表格被打印时，表格的表头和页脚可被打印在包含表格数据的每张页面上。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>使用thead、tbody、tfoot标签<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>成绩表<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>科目<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>分数<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>99<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>60<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tfoot</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>总分<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>159<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tfoot</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3><table border="1">        <thead>            <tr>                <th>科目</th>                <th>分数</th>            </tr>        </thead>        <tbody>            <tr>                <td>语文</td>                <td>99</td>            </tr>            <tr>                <td>数学</td>                <td>60</td>            </tr>        </tbody>        <tfoot>            <tr>                <td>总分</td>                <td>159</td>            </tr>        </tfoot>    </table></h3>#### 表格嵌套<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;table1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>title1<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>title2<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>title3<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nested&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;table2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>cell1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>cell2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>cell3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>cell2<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>cell3<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>cell4<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>cell5<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>cell6<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure><table id="table1">  <tr>    <th>title1</th>    <th>title2</th>    <th>title3</th>  </tr>  <tr>    <td id="nested">      <table id="table2">        <tr>          <td>cell1</td>          <td>cell2</td>          <td>cell3</td>        </tr>      </table>    </td>    <td>cell2</td>    <td>cell3</td>  </tr>  <tr>    <td>cell4</td>    <td>cell5</td>    <td>cell6</td>  </tr></table><h3 id="视频和音频内容"><a href="#视频和音频内容" class="headerlink" title="视频和音频内容"></a>视频和音频内容</h3><h4 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h4><p><code>&lt;video&gt;</code>标签定义视频，比如电影片段或其他视频流。目前，<code>&lt;video&gt;</code> 元素支持三种视频格式：MP4、WebM、Ogg。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.mp4&quot;</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/mp4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;movie.ogg&quot;</span>  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;video/ogg&quot;</span>&gt;</span><br>  您的浏览器不支持 HTML5 video 标签。<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><video width="320" height="240" controls>  <source src="https://www.runoob.com/try/demo_source/movie.mp4"  type="video/mp4">  <source src="movie.ogg"  type="video/ogg">  您的浏览器不支持 HTML5 video 标签。</video><p>属性:</p><ul><li><code>width</code> 和 <code>height</code> : 控制视频的尺寸, 但视频会保持<code>&lt;strong&gt;</code>长宽比<code>&lt;/strong&gt;</code>。</li><li><code>autoplay</code> : 使音频和视频内容立即播放，即使页面的其他部分还没有加载完全。</li><li><code>loop</code> : 让音频或者视频文件循环播放。</li><li><code>muted</code> : 媒体播放时，默认关闭声音。</li><li><code>poster</code> : 指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告。</li><li><code>preload</code> : 用来缓冲较大的文件, 有三个选项:<ul><li><code>&quot;none&quot;</code> : 不缓冲</li><li><code>&quot;auto&quot;</code> : 页面加载后缓存媒体文件</li><li><code>&quot;metadata&quot;</code> : 仅缓冲文件的原数据</li></ul></li></ul><h4 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h4><p><code>&lt;audio&gt;</code> 标签定义声音，比如音乐或其他音频流。目前，<code>&lt;audio&gt; </code>元素支持的3种文件格式：MP3、Wav、Ogg。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">audio</span> <span class="hljs-attr">controls</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.runoob.com/try/demo_source/horse.ogg&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/ogg&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">source</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;horse.mp3&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;audio/mpeg&quot;</span>&gt;</span><br>  您的浏览器不支持 audio 元素。<br><span class="hljs-tag">&lt;/<span class="hljs-name">audio</span>&gt;</span><br></code></pre></td></tr></table></figure><audio controls>  <source src="https://www.runoob.com/try/demo_source/horse.ogg" type="audio/ogg">  <source src="horse.mp3" type="audio/mpeg">  您的浏览器不支持 audio 元素。</audio><p>跟 <code>&lt;video&gt;</code>标签相比, 不支持 <code>width</code> / <code>height</code>  和 <code>poster</code> 属性</p><h4 id="音轨文本"><a href="#音轨文本" class="headerlink" title="音轨文本"></a>音轨文本</h4><p><code>&lt;tracker&gt;</code> 标签 为媒体元素（比如 <code> &lt;audio&gt;</code> and <code> &lt;video&gt;</code>）规定外部文本轨道，也就是字幕，字幕格式有 WebVTT 格式（.vtt 格式文件）。这个元素用于规定字幕文件或其他包含文本的文件，当媒体播放时，这些文件是可见的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">controls</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;320&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;240&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.runoob.com/video/php/friday.mp4&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">track</span> <span class="hljs-attr">default</span></span><br><span class="hljs-tag">           <span class="hljs-attr">kind</span>=<span class="hljs-string">&quot;captions&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">srclang</span>=<span class="hljs-string">&quot;en&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.runoob.com/video/php/friday.vtt&quot;</span> /&gt;</span><br>    抱歉，您的浏览器不支持嵌入视频！<br><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure><p><video controls width="320" height="240"       src="https://www.runoob.com/video/php/friday.mp4"><br>    <track default           kind="captions"           srclang="en"           src="https://www.runoob.com/video/php/friday.vtt" /><br>    抱歉，您的浏览器不支持嵌入视频！<br></video></p><h3 id="嵌入技术"><a href="#嵌入技术" class="headerlink" title="嵌入技术"></a>嵌入技术</h3><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//player.bilibili.com/player.html?aid=19390801&amp;bvid=BV1bW411n7fY&amp;cid=31621681&amp;page=1&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">scrolling</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">border</span>=<span class="hljs-string">&quot;0&quot;</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;no&quot;</span> <span class="hljs-attr">framespacing</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">allowfullscreen</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: absolute; width: 100%; height: 100%;left: 0; top: 0;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attributes">属性</a></h4><p><code>allowfullscreen</code>]: 如果设置为 <code>true</code>，<code>&lt;iframe&gt;</code>则可以通过全屏API设置为全屏模式。</p><p><code>frameborder</code> : 如果设置为1，则会告诉浏览器在此框架和其他框架之间绘制边框，这是默认行为。0删除边框。不推荐这样设置，因为在CSS中可以更好地实现相同的效果。<code>border: none</code>;</p><p><code>src</code> : 该属性指向要嵌入文档的URL路径。</p><p><code>width</code> 和 <code>height</code> : 指定iframe的宽度和高度。</p><p><code>sandbox</code> : 对框架中的内容应用额外的限制。属性的值可以为空以应用所有限制，也可以是空格分隔的标记以解除特定限制：</p><ul><li><code>allow-downloads-without-user-activation</code> ：允许在没有用户手势的情况下进行下载。</li><li><code>allow-downloads</code>：允许使用用户的手势进行下载。</li><li><code>allow-forms</code>：允许资源提交表单。如果未使用此关键字，则会阻止表单提交。</li><li><code>allow-modals</code>：允许资源<a href="https://html.spec.whatwg.org/multipage/origin.html#sandboxed-modals-flag">打开模式窗口</a>。</li><li><code>allow-orientation-lock</code>：允许资源<a href="https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation">锁定屏幕方向</a>。</li><li><code>allow-pointer-lock</code>：允许资源使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API">指针锁定 API</a>。</li><li><code>allow-popups</code>：允许弹出窗口（如 、或 ）。如果未使用此关键字，弹出窗口将无法以静默方式打开。<code>window.open()``target=&quot;_blank&quot;``showModalDialog()</code></li><li><code>allow-popups-to-escape-sandbox</code>：允许沙盒文档打开新窗口，而这些窗口不会继承沙盒。例如，这可以安全地对广告进行沙盒处理，而不会对广告链接到的页面施加相同的限制。</li><li><code>allow-presentation</code>：允许资源启动<a href="https://developer.mozilla.org/en-US/docs/Web/API/PresentationRequest">演示会话</a>。</li><li><code>allow-same-origin</code>：如果未使用此令牌，则资源将被视为来自始终不符合<a href="https://developer.mozilla.org/en-US/docs/Glossary/Same-origin_policy">同源策略的特殊源</a>（可能会阻止访问<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#cross-origin_data_storage_access">数据存储/cookie</a> 和某些 JavaScript API）。</li><li><code>allow-scripts</code>：允许资源运行脚本（但不创建弹出窗口）。</li><li><code>allow-storage-access-by-user-activation</code> ：允许资源请求使用存储访问 API 访问父级的<a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage_Access_API">存储</a>功能。</li><li><code>allow-top-navigation</code>：允许资源导航顶级浏览上下文（名为 ）。<code>_top</code></li><li><code>allow-top-navigation-by-user-activation</code>：允许资源导航顶级浏览上下文，但仅当由用户手势启动时。</li></ul><h4 id="lt-embed-gt-和-lt-object-gt"><a href="#lt-embed-gt-和-lt-object-gt" class="headerlink" title="&lt;embed&gt;和&lt;object&gt;"></a><a href="https://www.runoob.com/tags/tag-embed.html"><code>&lt;embed&gt;</code></a>和<a href="https://www.runoob.com/tags/tag-object.html"><code>&lt;object&gt;</code></a></h4><p>现在已经不建议使用 <code>&lt;embed&gt;</code> 标签了，可以使用 <code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;audio&gt;</code> 等标签代替。</p><p><code>&lt;object&gt;</code>定义一个嵌入的对象。请使用此元素向您的 XHTML 页面添加多媒体。此元素允许您规定插入 HTML 文档中的对象的数据和参数，以及可用来显示和操作数据的代码。</p><p><code>&lt;object&gt;</code> 标签用于包含对象，比如图像、音频、视频、Java applets、ActiveX、PDF 以及 Flash。</p><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>   <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;传送方式&quot;</span>   <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;服务器文件&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>&lt;form&gt;</code> ：<code>&lt;form&gt;</code>标签是成对出现的，以 <code>&lt;form&gt;</code>开始，以 <code>&lt;/form&gt;</code>结束。</li><li><code>action</code> ：浏览者输入的数据被传送到的地方,比如一个PHP页面(save.php)。</li><li><code>method</code> ： 数据传送的方式（get/post）。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>    <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>   <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;save.php&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;pass&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pass&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="文本输入框、密码输入框"><a href="#文本输入框、密码输入框" class="headerlink" title="文本输入框、密码输入框"></a>文本输入框、密码输入框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;名称&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;文本&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><strong>type</strong> ：</li></ol><ul><li>当type=”<strong>text</strong>“时，输入框为<strong>文本输入框</strong> ;</li><li>当type=”<strong>password</strong>“时, 输入框为<strong>密码输入框</strong> ;</li><li>当type=”<strong>number</strong>“时, 输入框类类型为数字 ; 数字框只能输入数字，输入其他字符无效 ;</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/2022-03-24/5e9196a5000183f107300076.jpg"></p><ul><li>当type=”<strong>url</strong>“时, 表示该输入框的类型为网址 ; 以http://或者https://开头,且后面必须有内容,否则表单提交的时候会报错误提示 ;</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/2022-03-24/5e9198fb0001934606750121.jpg"></p><ul><li>当type=”<strong>email</strong>“时 , 则表示该输入框的类型为邮箱。数字框的值必须包含@ ; 数字框的值@之后必须有内容,否则会报错误提示。</li></ul><ol start="2"><li><strong>name</strong> ：为文本框命名，以备后台程序ASP 、PHP使用。</li><li><strong>value</strong> ：为文本输入框设置默认值。(一般起到提示作用)</li><li><strong>placeholder</strong> : 输入框占位符,里面可以放提示的输入信息。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>  姓名：<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myName&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>  密码：<br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pass&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form>  姓名：  <input type="text" name="myName" placeholder="请输入姓名">  <br/>  密码：  <input type="password" name="pass" placeholder="请输入密码"></form><h4 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h4><p><code>&lt;textarea&gt;</code> 标签 :</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span>  <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;行数&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;列数&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>&lt;textarea&gt;</code>标签是成对出现的，以 <code>&lt;textarea&gt;</code>开始，以 <code>&lt;/textarea&gt;</code>结束。</li><li>cols ：多行输入域的列数。</li><li>rows ：多行输入域的行数。</li></ol><blockquote><p>这两个属性可用css样式的width和height来代替：col用width、row用height来代替。</p></blockquote><ol start="4"><li>在 <code>&lt;textarea&gt;</code> <code>&lt;/textarea&gt;</code>标签之间可以输入默认值。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>  <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;save.php&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>联系我们<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;50&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span> &gt;</span>在这里输入内容...<span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form  method="post" action="save.php">        <label>联系我们</label>        <textarea cols="50" rows="10" >在这里输入内容...</textarea></form><h4 id="lt-label-gt-标签"><a href="#lt-label-gt-标签" class="headerlink" title="&lt;label&gt; 标签"></a><a href="https://www.runoob.com/tags/tag-label.html"><code>&lt;label&gt;</code></a> 标签</h4><p><code>&lt;label&gt; </code>标签为 input 元素定义标注（标记）。label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。</p><p><code>&lt;span style=&quot;color:red&quot;&gt;</code>注意：标签的<code>&lt;span style=&quot;color:red&quot;&gt;</code> for 属性中的值应当与相关控件的<code>&lt;span style=&quot;color:red&quot;&gt;</code> id 属性值一定要相同。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;控件id名称&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span></span><br><span class="hljs-tag">  &lt;<span class="hljs-attr">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>输入你的邮箱地址<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter email&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form  <label for="email">输入你的邮箱地址</label>  <input type="email" id="email" placeholder="Enter email"></form><h4 id="单选框、复选框"><a href="#单选框、复选框" class="headerlink" title="单选框、复选框"></a>单选框、复选框</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>   <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio/checkbox&quot;</span>   <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;值&quot;</span>    <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;名称&quot;</span>   <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;checked&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ol><li><strong>type:</strong></li></ol><ul><li>当 <strong>type=”radio”</strong> 时，控件为<strong>单选框</strong></li><li>当 <strong>type=”checkbox”</strong> 时，控件为<strong>复选框</strong></li></ul><ol start="2"><li><strong>value：</strong>提交数据到服务器的值（后台程序PHP使用）</li><li><strong>name：</strong>为控件命名，以备后台程序 ASP、PHP 使用</li><li><strong>checked：</strong>当设置 checked=”checked” 时，该选项被默认选中</li></ol><form action="save.php" method="post">    <label>性别:</label>    <label>男</label>    <input type="radio" value="1" name="gender" />    <label>女</label>    <input type="radio" value="2" name="gender" /><br />    你有什么vehicle?<br />    <input type="checkbox" name="vehicle[]" value="Bike"> 我有一辆自行车<br>    <input type="checkbox" name="vehicle[]" value="Car"> 我有一辆小轿车<br>    <input type="checkbox" name="vehicle[]" value="Boat"> 我有一艘船<br></form><p><strong>注意</strong> : <strong>同一组</strong>的单选按钮，name 取值一定要一致，这样同一组的单选按钮才可以起到单选的作用。</p><h4 id="下拉列表"><a href="#下拉列表" class="headerlink" title="下拉列表"></a><a href="https://www.runoob.com/tags/tag-select.html">下拉列表</a></h4><p>下拉列表在网页中也常会用到，它可以有效的节省网页空间。既可以单选、又可以多选。</p><ol><li>select和option标签都是双标签，它总是成对出现的，需要首标签和尾标签。</li><li>select标签里面只能放option标签，表示下拉列表的选项。</li><li>option标签放选项内容，不放置其他标签。</li><li>value：</li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/2022-03-24/52e6037300015a9905030165.jpg"></p><p>5、selected=”selected”：设置selected=”selected”属性，则该选项就被默认选中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;看书&quot;</span>&gt;</span>看书<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;旅游&quot;</span> <span class="hljs-attr">selected</span>=<span class="hljs-string">&quot;selected&quot;</span>&gt;</span>旅游<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;运动&quot;</span>&gt;</span>运动<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;购物&quot;</span>&gt;</span>购物<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form>    <select>        <option value="看书">看书</option>        <option value="旅游" selected="selected">旅游</option>        <option value="运动">运动</option>        <option value="购物">购物</option>    </select></form><h4 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h4><p>在表单中有两种按钮可以使用，分别为：提交按钮、重置。当用户需要提交表单信息到服务器时，需要用到<strong>提交按钮</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span>   <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>   <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>type：只有当type值设置为submit时，按钮才有提交作用</li><li>value：按钮上显示的文字</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;save.php&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;myName&quot;</span>&gt;</span>姓名：<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot; &quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myName &quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submitBtn&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form method="post" action="save.php">    <label for="myName">姓名：</label>    <input type="text" value=" " name="myName " />    <input type="submit" value="提交" name="submitBtn" /></form><h4 id="重置按钮"><a href="#重置按钮" class="headerlink" title="重置按钮"></a>重置按钮</h4><p>当用户需要重置表单信息到初始时的状态时，比如用户输入“用户名”后，发现书写有误，可以使用<code>&lt;kbd&gt;</code>重置<code>&lt;/kbd&gt;</code>按钮使输入框恢复到初始状态。只需要把type设置为”reset”即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>type：只有当type值设置为reset时，按钮才有重置作用</li><li>value：按钮上显示的文字</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;demo-form.php&quot;</span>&gt;</span><br>  Email: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  Pin: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pin&quot;</span> <span class="hljs-attr">maxlength</span>=<span class="hljs-string">&quot;4&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><form action="demo-form.php">  Email: <input type="text" name="email"><br>  Pin: <input type="text" name="pin" maxlength="4"><br>  <input type="reset" value="重置">  <input type="submit" value="提交"></form>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机搭建Hadoop集群</title>
    <link href="/HadoopContructionOnVM.html"/>
    <url>/HadoopContructionOnVM.html</url>
    
    <content type="html"><![CDATA[<h1 id="虚拟机搭建Hadoop集群"><a href="#虚拟机搭建Hadoop集群" class="headerlink" title="虚拟机搭建Hadoop集群"></a>虚拟机搭建Hadoop集群</h1><h2 id="1-创建虚拟机"><a href="#1-创建虚拟机" class="headerlink" title="1. 创建虚拟机"></a>1. 创建虚拟机</h2><p>下载VirtualBox或其他虚拟机软件并安装.</p><p>进入管理菜单-&gt;全局设置-&gt;网络-&gt;添加新NAT网络, 勾选启用网络并开启DHCP,确认即可.</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307172344864.png"></p><p>随后点击新建虚拟机, 将名称改为cluster1, 虚拟机类型选择Linux, Red Hat(64位),</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307172741873.png"></p><p>将内存大小改为1536MB,点击下一步</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307172827900.png"></p><p>选择现在创建虚拟硬盘(VHD, 动态分配, 8G), 点击创建即可成功创建虚拟机:</p><p>如下图所示,</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307173039991.png"></p><p>进入刚刚新建的虚拟机设置, 在网卡1处连接方式选择NAT网络, 在网卡2处勾选启用网络连接,连接方式设为: 仅主机(Host-Only)网络,点击OK即可,网络信息如下所示,</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307173502018.png"></p><p>然后选择存储设置, 加载CentOS7系统镜像到光驱</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307173709989.png"></p><p>确认之后将虚拟机启动,</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307173833389.png"></p><p>单击界面,让Virtual Box捕获鼠标(注:右Ctrl键可以接触捕获), 上移光标至Install CentOS 7处按回车键进行系统安装,</p><p>随后单击Continue</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307174203851.png"></p><p>将时区更改为: :earth_asia: Asia, Shanghai</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307174519139.png"></p><p>磁盘分区默认即可,</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307175112388.png"></p><p>随后设置用户名和密码, 如果密码不符合安全要求, 会需要点击两次以确认,耐心等待系统安装完成,然后点击重启按钮, 系统即安装完成</p><p>另外创建两台配置一样的虚拟机, 用户名分别为 cluster2 和 cluster3.</p><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2. 准备工作"></a>2. 准备工作</h2><h3 id="2-1-关闭防火墙和-Selinux"><a href="#2-1-关闭防火墙和-Selinux" class="headerlink" title="2.1 关闭防火墙和 Selinux"></a>2.1 关闭防火墙和 Selinux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 关闭防火墙并阻止服务开机启动<br><span class="hljs-comment"># systemctl stop firewalld.service</span><br><span class="hljs-comment"># systemctl disable firewalld.service</span><br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307181250561.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 编辑Selinux配置文件关闭Selinux<br><span class="hljs-comment"># vi /etc/selinux/config</span><br>// 将SELINUX设为disabled<br>// 重启<br><span class="hljs-comment"># reboot</span><br>// 用root用户查看Selinux状态<br><span class="hljs-comment"># getenforce</span><br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307181417466.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220307181459557.png"></p><p>另两台虚拟机进行同样的操作.</p><h3 id="2-2-检查网卡是否开机自启"><a href="#2-2-检查网卡是否开机自启" class="headerlink" title="2.2 检查网卡是否开机自启"></a>2.2 检查网卡是否开机自启</h3><p>使用<code>ip addr</code>命令查看网卡名称,</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220308010929988.png"></p><p>可见两张网卡均未启用,</p><p>接下来编辑第一张网卡的配置文件, 修改如下文件<code>/etc/sysconfig/network-scripts/ifcfg-enp0s3</code>,将其中的ONBOOT项修改为yes,使网卡能够开机自启,</p><p>随后编辑第二章网卡的配置文件<code>etc/sysconfig/network-scripts/ifcfg-enp0s8</code>, 将BOOTPROTO设置为none, ONBOOT同样改为yes,并新增如下项:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">56.121</span>  <span class="hljs-comment"># cluster2为192.168.56.122, cluster3为192.168.56.123</span><br><span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br><span class="hljs-attr">NETWORK</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">56.0</span><br></code></pre></td></tr></table></figure><p>保存之后, 重启网络服务发现配置成功</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220308011832168.png"></p><p>将另外两台机器也配置完成,进入下一步,</p><p>将网络配置成功之后我们就可以使用SSH工具连接虚拟机了,在这里我使用Finalshell工具进行连接:</p><p>添加如下所示的三个连接就可以连上虚拟机了:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220308012637088.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220308012706054.png"></p><p>对于文件传输功能, Finalshell有集成功能可以方便的拖拽文件进行上传和下载操作.</p><h3 id="2-3-安装软件"><a href="#2-3-安装软件" class="headerlink" title="2.3 安装软件"></a>2.3 安装软件</h3><p>每台机器上都要安装,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install perl*  ntpdate  libaio  screen -y<br></code></pre></td></tr></table></figure><h3 id="2-4-修改hosts"><a href="#2-4-修改hosts" class="headerlink" title="2.4 修改hosts"></a>2.4 修改hosts</h3><p>将每台机器的ip写入每台机器的hosts文件</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">10.0.2.8</span> cluster1<br><span class="hljs-number">10.0.2.4</span> cluster2<br><span class="hljs-number">10.0.2.9</span> cluster3<br></code></pre></td></tr></table></figure><p>修改之后测试网络连通性, 在cluster1上 ping 另两台机器:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220308183616945.png"></p><p>可见hosts文件生效.</p><h3 id="2-5-新建用于维护集群的hadoop用户"><a href="#2-5-新建用于维护集群的hadoop用户" class="headerlink" title="2.5 新建用于维护集群的hadoop用户"></a>2.5 新建用于维护集群的hadoop用户</h3><p>在每台机器上用root用户执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 新建hadoop组</span><br>groupadd hadoop<br><span class="hljs-comment"># 新建hadoop用户</span><br>useradd -s /bin/bash -g hadoop -d /home/hadoop -m hadoop<br><span class="hljs-comment"># 修改 hadoop 这个用户的密码</span><br>passwd hadoop<br></code></pre></td></tr></table></figure><h3 id="2-6-生成SSH密钥并分发"><a href="#2-6-生成SSH密钥并分发" class="headerlink" title="2.6 生成SSH密钥并分发"></a>2.6 生成SSH密钥并分发</h3><p>首先在cluster1上切换到<strong>hadoop用户</strong>, 然后执行如下命令生成密钥:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa<br></code></pre></td></tr></table></figure><p>随后分发密钥,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-copy-id cluster1<br>ssh-copy-id cluster2<br>ssh-copy-id cluster3<br></code></pre></td></tr></table></figure><p>密钥分发完毕, 使用cluster1与cluster2和cluster3建立连接均能成功,说明密钥分发无误.</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220308231119122.png"></p><h3 id="2-7-安装NTP服务"><a href="#2-7-安装NTP服务" class="headerlink" title="2.7 安装NTP服务"></a>2.7 安装NTP服务</h3><p>在三台机器上安装ntpdate</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install ntpdate<br></code></pre></td></tr></table></figure><p>在cluster1上执行yum安装命令安装ntp并将<code>/etc/ntp.conf</code>文件的下列四行注释掉,</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">server0<span class="hljs-selector-class">.centos</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.ntp</span><span class="hljs-selector-class">.org</span> iburst<br>server1<span class="hljs-selector-class">.centos</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.ntp</span><span class="hljs-selector-class">.org</span> iburst <br>server2<span class="hljs-selector-class">.centos</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.ntp</span><span class="hljs-selector-class">.org</span> iburst <br>server3<span class="hljs-selector-class">.centos</span><span class="hljs-selector-class">.pool</span><span class="hljs-selector-class">.ntp</span><span class="hljs-selector-class">.org</span> iburst<br></code></pre></td></tr></table></figure><p>在文件末加入如下内容:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">restrict</span> default ignore<br>restrict <span class="hljs-number">10.0.2.0</span> mask <span class="hljs-number">255.255.255.0</span> nomodify notrap<br>server <span class="hljs-number">127.127.1.0</span><br></code></pre></td></tr></table></figure><p>重启ntp服务并设置ntp 服务器开机自启</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">service</span> ntpd restart<br>chkconfig ntpd <span class="hljs-literal">on</span><br></code></pre></td></tr></table></figure><p>接下来对cluster2和cluster3这两个客户端进行配置:</p><p>设定每天0:00向服务器同步时间并写入日志:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># crontab -e</span><br></code></pre></td></tr></table></figure><p>输入以下内容后保存并退出：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> * * * /<span class="hljs-keyword">usr</span>/sbin/ntpdate cluster1&gt;&gt; /root/ntpd.<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><p>之后在两台客户机上使用<code>ntpdate cluster1</code>同步时间.</p><h2 id="3-安装MySQL"><a href="#3-安装MySQL" class="headerlink" title="3. 安装MySQL"></a><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309011624607.png">3. 安装MySQL</h2><h3 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1 安装"></a>3.1 安装</h3><p>只需要在cluster2上安装一个MySQL即可</p><p>登录root用户以执行以下命令:</p><p>若安装过MySQL先移除原有MySQL:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove mysql mysql-server mnysql-libs compat-mysql51<br><span class="hljs-built_in">rm</span> -rf /var/lib/mysql<br><span class="hljs-built_in">rm</span> -rf /etc/my.cnf<br></code></pre></td></tr></table></figure><p>将mysql-5.6.37-linux-glibc2.12-x86_64.tar.gz上传至cluster2,随后将其解压到/usr/local/目录下,并将解压后的文件目录名改为mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf mysql-5.6.37-linux-glibc2.12-x86_64.tar.gz<br><span class="hljs-built_in">mv</span> mysql-5.6.37-linux-glibc2.12-x86_64 mysql<br></code></pre></td></tr></table></figure><p>将MySQL添加进环境变量:在/etc/profile末尾添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> MYSQL_HOME=/usr/local/mysql <br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$MYSQL_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>随后用source命令使其生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>新建MySQL用户:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">groupadd mysql<br>useradd -r -g mysql -s /bin/false mysql<br><span class="hljs-built_in">cd</span> /usr/local/mysql<br><span class="hljs-built_in">chown</span> -R mysql:mysql .<br>scripts/mysql_install_db --user=mysql<br></code></pre></td></tr></table></figure><p>将当前目录的拥有者改为root</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R root<br></code></pre></td></tr></table></figure><p>修改当前data目录拥有者为mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R mysql data<br>bin/mysqld_safe --user=mysql &amp;<br></code></pre></td></tr></table></figure><p>用<code>bin/mysql</code>命令登录MySQL,成功后使用<code>exit;</code>命令退出即可</p><p>进行修改MySQL的root账户密码操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/mysql_secure_installation<br><span class="hljs-built_in">cp</span> support-files/mysql.server /etc/init.d/mysql.server<br></code></pre></td></tr></table></figure><p>查看MySQL的进程号并kill掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps -ef | grep mysql<br></code></pre></td></tr></table></figure><p>用普通用户配置访问权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;cluster&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION; <br>mysql<span class="hljs-operator">&gt;</span> FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309193809638.png"></p><h3 id="3-2-测试"><a href="#3-2-测试" class="headerlink" title="3.2 测试"></a>3.2 测试</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> database test_table; <br>mysql<span class="hljs-operator">&gt;</span> use test_table;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> userinfo(id <span class="hljs-type">int</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>); <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> userinfo <span class="hljs-keyword">values</span>(<span class="hljs-number">1</span>); <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> userinfo;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">drop</span> database test_table;<br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">show</span> databases;<br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309194232911.png"></p><h2 id="4-安装JDK"><a href="#4-安装JDK" class="headerlink" title="4. 安装JDK"></a>4. 安装JDK</h2><p>需要在每台机器上安装JDK,将jdk压缩包传到服务器<code>/usr/local</code>目录下并解压,修改环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.8.0_102<br><span class="hljs-built_in">export</span> JRE_HOME=/usr/local/jdk1.8.0_102/jre<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib:<span class="hljs-variable">$JRE_HOME</span>/lib:<span class="hljs-variable">$CLASSPATH</span> <br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JRE_HOME</span>/bin:<span class="hljs-variable">$JAVA_HOME</span>:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>配置完成,并使用scp命令将jdk复制到其他节点:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309205340946.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r /usr/local/jdk1.7.0_80/ cluster2:/usr/local/<br></code></pre></td></tr></table></figure><p>同样的方式将jdk目录写入环境变量</p><h2 id="5-安装Zookeeper"><a href="#5-安装Zookeeper" class="headerlink" title="5. 安装Zookeeper"></a>5. 安装Zookeeper</h2><p>最终需要在每一台机器上安装ZooKeeper:</p><p>在cluster1上将zookeeper的压缩包解压到/usr/local目录下,</p><p>并写入环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ZOOKEEPER_HOME=/usr/local/zookeeper-3.4.6 <br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$ZOOKEEPER_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>随后在 /usr/local/zookeeper-3.4.6/conf/zoo.cfg中新建zoo.cfg文件,写入如下内容:</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 客户端心跳时间(毫秒)    </span><br><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-comment"># 允许心跳间隔的最大时间</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span> <br><span class="hljs-comment"># 同步时限</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-comment"># 数据存储目录</span><br><span class="hljs-attr">dataDir</span>=/home/hadoop_files/hadoop_data/zookeeper<br><span class="hljs-comment"># 数据日志存储目录</span><br><span class="hljs-attr">dataLogDir</span>=/home/hadoop_files/hadoop_logs/zookeeper/dataLog <br><span class="hljs-comment"># 端口号</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-comment"># 集群节点和服务端口配置</span><br><span class="hljs-attr">server.1</span>=cluster1:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span> <br><span class="hljs-attr">server.2</span>=cluster2:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span> <br><span class="hljs-attr">server.3</span>=cluster3:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br></code></pre></td></tr></table></figure><p>接下来创建zookeeper的数据目录和日志存储目录, 并修改文件夹的权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_data/zookeeper<br><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_logs/zookeeper/dataLog <br><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_logs/zookeeper/logs<br><br><span class="hljs-built_in">chown</span> -R hadoop:hadoop /home/hadoop_files<br><span class="hljs-built_in">chown</span> -R hadoop:hadoop /usr/local/zookeeper-3.4.6<br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309214332045.png"></p><p>在 cluster1 号服务器的 data 目录中创建一个文件 myid，输入内容为 1, 且myid 应与 zoo.cfg 中的集群节点相匹配, cluster2和cluster3就写2和3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;1&quot;</span> &gt;&gt; /home/hadoop_files/hadoop_data/zookeeper/myid<br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309214553265.png"></p><p>接下来修改zookeeper/目录下相关配置文件</p><p>修改 zookeeper 的日志输出路径(注意CDH 版与原生版配置文件不同)</p><blockquote><p>修改bin/zkEnv.sh中的部分如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;x<span class="hljs-variable">$&#123;ZOO_LOG_DIR&#125;</span>&quot;</span> = <span class="hljs-string">&quot;x&quot;</span> ]<br><span class="hljs-keyword">then</span><br>ZOO_LOG_DIR=<span class="hljs-string">&quot;/home/hadoop_files/hadoop_logs/zookeeper/logs&quot;</span><br><span class="hljs-keyword">fi</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;x<span class="hljs-variable">$&#123;ZOO_LOG4J_PROP&#125;</span>&quot;</span> = <span class="hljs-string">&quot;x&quot;</span> ]<br><span class="hljs-keyword">then</span><br>ZOO_LOG4J_PROP=<span class="hljs-string">&quot;INFO,ROLLINGFILE&quot;</span><br><span class="hljs-keyword">fi</span><br></code></pre></td></tr></table></figure></blockquote><p>然后修改conf/zookeeper的日志配置文件<code>log4j.properties</code>:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">zookeeper.root.logger</span>=<span class="hljs-string">INFO,ROLLINGFILE log4j.appender.ROLLINGFILE=org.apache.log4j.DailyRollingFileAppender</span><br></code></pre></td></tr></table></figure><p>将zookeeper-3.4.6的内容复制到其他两个节点上:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r /usr/local/zookeeper-3.4.6 cluster2:/usr/local/ <br>scp -r /usr/local/zookeeper-3.4.6 cluster3:/usr/local/<br></code></pre></td></tr></table></figure><p>接下来切换到hadoop用户,使用<code>source /etc/profile</code>刷新环境变量,随后启动zookeeper:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">zkServer.sh start<br></code></pre></td></tr></table></figure><p>三台机器都把zookeeper启动之后用命令<code>jps</code>查看进程是否启动:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309234544293.png"></p><p>可以看到在每台机器上都能看到一个叫<em>QuorumPeerMain</em>的进程,说明启动成功</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309234950820.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309235011745.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220309235023280.png"></p><p>可以看到三台机器中一台是leader,另两台是follower</p><p>zookeeper的关闭命令是<code>zkServer.sh stop</code></p><h2 id="6-安装Kafka"><a href="#6-安装Kafka" class="headerlink" title="6. 安装Kafka"></a>6. 安装Kafka</h2><h3 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1 安装"></a>6.1 安装</h3><p>在cluster1上解压kafka到/usr/local</p><p>然后添加环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> KAFKA_HOME=/usr/local/kafka_2.10-0.8.2.1 <br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$KAFKA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>随后修改<code>kafka/config/server.properties</code>文件:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 1. 将brokers 的 id设为唯一的值,这里就把编号作为它的值, 即1,2,3</span><br><span class="hljs-attr">broker.id</span>=<span class="hljs-string">1</span><br><span class="hljs-comment"># 2. 修改日志路径</span><br><span class="hljs-attr">log.dirs</span>=<span class="hljs-string">/home/hadoop_files/hadoop_logs/kafka</span><br><span class="hljs-comment"># 3. zookeeper集群的ip和端口, 用逗号隔开</span><br><span class="hljs-attr">zookeeper.connect</span>=<span class="hljs-string">cluster1:2181,cluster2:2181,cluster3:2181</span><br><span class="hljs-comment"># 4. 对应机器的ip地址!</span><br><span class="hljs-attr">advertised.host.name</span>=<span class="hljs-string">192.168.56.121</span><br></code></pre></td></tr></table></figure><p>创建logs文件夹:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_logs/kafka<br><span class="hljs-built_in">chown</span> -R hadoop:hadoop /home/hadoop_files<br><span class="hljs-built_in">chown</span> -R hadoop:hadoop /usr/local/kafka_2.10-0.8.2.1<br></code></pre></td></tr></table></figure><p>之后使用 hadoop 用户启动 kafka 集群<br>先启动 zookeeper 集群，然后在 kafka 集群中的每个节点使用,下面是启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kafka-server-start.sh /usr/local/kafka_2.10-0.8.2.1/config/server.properties &amp;<br></code></pre></td></tr></table></figure><h3 id="6-2-测试"><a href="#6-2-测试" class="headerlink" title="6.2 测试"></a>6.2 测试</h3><p>使用hadoop用户执行命令,</p><p>创建topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kafka-topics.sh --create --zookeeper cluster1:2181,cluster2:2181,cluster3:2181 --replication-factor 3 --partitions 1 --topic mykafka<br></code></pre></td></tr></table></figure><p>查看Topic</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kafka-topics.sh --list --zookeeper cluster1:2181,cluster2:2181,cluster3:2181<br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310002701290.png"></p><p>查看详细信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kafka-topics.sh --describe --zookeeper cluster1:2181,cluster2:2181,cluster3:2181 <br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310002812404.png"></p><p>在cluster1上执行如下命令用来发送消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kafka-console-producer.sh --broker-list localhost:9092 --topic mykafka<br></code></pre></td></tr></table></figure><p>在cluster2上执行如下命令用来接收消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kafka-console-consumer.sh -zookeeper cluster1:2181,cluster2:2181,cluster3:2181 --topic mykafka --from-beginning<br></code></pre></td></tr></table></figure><p>接着在cluster1上输入以下内容:</p><blockquote><p>test</p><p>mycluster test</p></blockquote><p>在cluster2上可以成功接收到相应信息</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310003237619.png"></p><p>在每台机器上执行<code>kafka-server-stop.sh</code>命令关闭kafka,随后在每台机器上用screen命令新建窗口在后台跑kafka集群</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">screen -S kafka<br>kafka-server-start.sh <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/kafka_2.10-0.8.2.1/</span>config/server.properties<br></code></pre></td></tr></table></figure><p>随后使用Ctrl +  A + D退出新建的screen,用<code>jps</code>命令看到Kafka进程在运行</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310003857453.png"></p><h2 id="7-安装Hadoop"><a href="#7-安装Hadoop" class="headerlink" title="7. 安装Hadoop"></a>7. 安装Hadoop</h2><h3 id="7-1-安装"><a href="#7-1-安装" class="headerlink" title="7.1 安装"></a>7.1 安装</h3><p><strong>在启动Hadoop之前应先启动zookeeper</strong></p><p>以下命令若无特殊说明,均使用 用户hadoop执行</p><p>将 hadoop-2.6.5.tar.gz 解压到 /usr/local/ 目录下</p><p>进入hadoop配置文件目录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/local/hadoop-2.6.5/etc/hadoop<br></code></pre></td></tr></table></figure><p>修改hadoop-env.sh文件:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.7.0_80<br><span class="hljs-built_in">export</span> HADOOP_PID_DIR=/home/hadoop_files<br></code></pre></td></tr></table></figure><p>配置mapred-env.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HADOOP_MAPRED_PID_DIR=/home/hadoop_files<br></code></pre></td></tr></table></figure><p>配置core-site.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 指定 hdfs的 nameservices名称为 mycluster，与 hdfs-site.xml的 HA配置相同 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://cluster1:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 指定缓存文件存储的路径 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/hadoop_files/hadoop_tmp/hadoop/data/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置 hdfs文件被永久删除前保留的时间（单位：分钟），默认值为 0表明垃圾回收站功能关闭 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.trash.interval<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>1440<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 指定 zookeeper地址，配置 HA时需要 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ha.zookeeper.quorum<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster1:2181,cluster2:2181,cluster3:2181<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置hdfs-site.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 指定 hdfs元数据存储的路径 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.namenode.name.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/hadoop_files/hadoop_data/hadoop/namenode<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定 hdfs数据存储的路径 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.datanode.data.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/hadoop_files/hadoop_data/hadoop/datanode<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.secondary.http.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster1:50090<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 数据备份的个数 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.replication<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 关闭权限验证 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.permissions.enabled<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 开启 WebHDFS功能（基于 REST的接口服务） --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>dfs.webhdfs.enabled<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置mapred-site.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 指定 MapReduce计算框架使用 YARN --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定 jobhistory server的 rpc地址 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster1:10020<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 指定 jobhistory server的 http地址 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.jobhistory.webapp.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster1:19888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置yarn-site.xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- NodeManager上运行的附属服务，需配置成 mapreduce_shuffle才可运行 MapReduce程序 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置 Web Application Proxy安全代理（防止 yarn被攻击） --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.web-proxy.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster2:8888<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br>    <span class="hljs-comment">&lt;!-- 开启日志 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation-enable<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置日志删除时间为 7天， ，-1为禁用，单位为秒 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.log-aggregation.retain-seconds<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>604800<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 修改日志目录 --&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.remote-app-log-dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/hadoop_files/hadoop_logs/yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster1:8032<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.scheduler.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster1:8030<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.resource-tracker.address<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster1:8031<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置slaves文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cluster1</span><br>cluster2 <br>cluster3<br></code></pre></td></tr></table></figure><p>在所有节点上创建如下目录,即上述配置涉及的目录:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_data/hadoop/namenode <br><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_data/hadoop/datanode<br><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_tmp/hadoop/data/tmp<br><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_logs/yarn<br></code></pre></td></tr></table></figure><p>将cluster1的hadoop工作目录同步到集群其他节点:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r /usr/local/hadoop-2.6.5 cluster2:/usr/local/<br>scp -r /usr/local/hadoop-2.6.5 cluster3:/usr/local/<br></code></pre></td></tr></table></figure><p>之后保证工作目录所有者为hadoop用户</p><p>每台机器新建环境变量如下, 并使之生效:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HADOOP_HOME=/usr/local/hadoop-2.6.5<br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=<span class="hljs-variable">$HADOOP_HOME</span>/lib/native<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$HADOOP_HOME</span>/bin:<span class="hljs-variable">$HADOOP_HOME</span>/sbin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>启动zookeeper集群后开始格式化:</p><p>在所有节点上启动journalnode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hadoop-daemon.sh start journalnode<br></code></pre></td></tr></table></figure><p>使用jps可以看到journalnode进程</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310010351641.png"></p><p>在cluster1上执行格式化HDFS命令:<code>hdfs namenode -format, </code></p><p>之后使用<code>hadoop-daemon.sh stop journalnode</code>命令可在节点上关闭journalnode, </p><p>在cluster1上启用HDFS:<code>start-dfs.sh</code>, </p><p>可在cluster1上看到NameNode, DataNode, SecondaryNameNode;</p><p> 在cluster2和cluster3上看到DataNode:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310012508472.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310012522550.png"></p><p>在cluster1上启用YARN:<code>start-yarn.sh</code></p><p>启动后 cluster1 上使用 jps 可以看到NodeManager, ResourceManager, </p><p>cluster2 和 cluster3 上可以看到NodeManager:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310012949160.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310013004848.png"></p><h3 id="7-2-测试"><a href="#7-2-测试" class="headerlink" title="7.2 测试"></a>7.2 测试</h3><p>启动HDFS 后，可以在浏览器中，打开 <a href="http://192.168.56.121:50070/">http://192.168.56.121:50070</a>，可以看到HDFS 的 web 界面:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310013155182.png"></p><p>上图第一页是当前HDFS 的概况，里面显示了HDFS 的启动时间，版本等信息。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310013244551.png"></p><p>Datanodes页面显示了当前HDFS 中的可用节点。</p><p>启用YARN后可以通过访问<a href="http://192.168.56.121:8088/">http://192.168.56.121:8088</a>查看YARN的web界面</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310013421172.png"></p><p>该页面展示了所有提交到 YARN 上的程序，点击左侧的Nodes 可以看到 YARN 的节点:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310090014904.png" alt="image-20220310090014904"></p><p>此处每个节点的可用内存 Mem Avail 为 8G，而我们的虚拟机每台内存只有 1.5G，由于没有在 yarn-site.xml 这个文件中对节点的可用内存进行配置出现了此问题，可以增加以下内容进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置 nodemanager 可用的资源内存 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>20480<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置 nodemanager 可用的资源 CPU --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.resource.cpu-vcores<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>24<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>进行命令行测试:</p><p>在cluster1上,</p><p>首先切换到hadoop用户目录:<code>cd ~/</code></p><p>新建一个测试文件:<code>Vi testfile</code></p><p>输入:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>3<br></code></pre></td></tr></table></figure><p>保存之后退出</p><p>在 HDFS 的根目录创建 test 目录: <code>hdfs dfs -mkdir /test</code></p><p>查看HDFS 根目录的文件: <code>hdfs dfs -ls /</code></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310014227354.png"></p><p>将测试文件 testfile 上传至 HDFS 根目录下的 test 目录中: <code>hdfs dfs -put testfile /test</code></p><p>在cluster2上,</p><p>首先切换到hadoop用户目录:<code>cd ~/</code></p><p>查看HDFS 根目录: <code>hdfs dfs -ls /</code></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310014513363.png"></p><p>查看HDFS 根目录下的 test 目录，看到刚才在 cluster1 上上传的文件 testfile: <code>hdfs dfs -ls /test</code></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310014603118.png"></p><p>使用<code>hdfs dfs -get /test/testfile</code>将testfile下载到本地,</p><p>再查看当前目录下的文件可以发现testfile,</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310014808596.png" alt="image-20220310014808596"></p><h2 id="8-安装HBase"><a href="#8-安装HBase" class="headerlink" title="8. 安装HBase"></a>8. 安装HBase</h2><h3 id="8-1-安装"><a href="#8-1-安装" class="headerlink" title="8.1 安装"></a>8.1 安装</h3><p><strong>HBase 启动的先决条件是 zookeeper 和Hadoop 已经启动</strong></p><p>在cluster1上, 将hbase-1.2.6-bin.tar.gz解压到/usr/local/目录下,随后修改<code>/usr/local/hbase-1.2.6/conf/</code>目录下的hbase-env.sh如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置 JDK 安装路径</span><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.7.0_80 <br><span class="hljs-comment"># 配置 Hadoop 安装路径</span><br><span class="hljs-built_in">export</span> HADOOP_HOME=/usr/local/hadoop-2.6.5 <br><span class="hljs-comment"># 设置 HBase 的日志目录</span><br><span class="hljs-built_in">export</span> HBASE_LOG_DIR=/home/hadoop_files/hadoop_logs/hbase/logs <br><span class="hljs-comment"># 使用独立的ZooKeeper 集群</span><br><span class="hljs-built_in">export</span> HBASE_MANAGES_ZK=<span class="hljs-literal">false</span> <br><span class="hljs-comment"># 设置 pid 的路径</span><br><span class="hljs-built_in">export</span> HBASE_PID_DIR=/home/hadoop_files<br></code></pre></td></tr></table></figure><p>配置hbase-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.rootdir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://cluster1:9000/hbase<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.cluster.distributed<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.master<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>60000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/hadoop_files/hadoop_tmp/hbase/tmp<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.quorum<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>cluster1,cluster2,cluster3<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.property.dataDir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/hadoop_files/hadoop_data/zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.zookeeper.property.clientPort<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>2181<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>zookeeper.session.timeout<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>120000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.regionserver.restart.on.zk.expire<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hbase.master.info.port<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>60010<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置regionservers</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cluster1</span><br>cluster2<br>cluster3<br></code></pre></td></tr></table></figure><p>删除hbase的slf4j-log4j12-1.7.5.jar, 解决hbase和hadoop的LSF4J冲突,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> /usr/local/hbase-1.2.6/lib/slf4j-log4j12-1.7.5.jar /usr/local/hbase-1.2.6/lib/slf4j-log4j12-1.7.5.jar.bk<br></code></pre></td></tr></table></figure><p>将 hbase 工作目录同步到集群其它节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r /usr/local/hbase-1.2.6/ cluster2:/usr/local/ <br>scp -r /usr/local/hbase-1.2.6/ cluster3:/usr/local/<br></code></pre></td></tr></table></figure><p>在所有节点创建 hbase 的缓存文件目录和日志文件目录,并修改相应权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_tmp/hbase/tmp<br><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_logs/hbase/logs<br><span class="hljs-built_in">chown</span> -R hadoop:hadoop /usr/local/hbase-1.2.6 <br><span class="hljs-built_in">chown</span> -R hadoop:hadoop /home/hadoop_files<br></code></pre></td></tr></table></figure><p>Hbase的环境变量如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HBASE_HOME=/usr/local/hbase-1.2.6 <br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$HBASE_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>在cluster1上,先启动zookeeper, Hadoop的HDFS和YARN,然后才能启动HBase,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">start-dfs.sh<br>start-yarn.sh<br>start-hbase.sh<br></code></pre></td></tr></table></figure><p>启动后在cluster1上使用<code>jps</code>可以看到HMaster和HRegionServer,</p><p>cluster2和cluster3上可以看到HRegionServer</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310085135752.png" alt="image-20220310085135752"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310085202547.png" alt="image-20220310085202547"></p><h3 id="8-2-测试"><a href="#8-2-测试" class="headerlink" title="8.2 测试"></a>8.2 测试</h3><p>打开<a href="http://192.168.56.121:60010/">http://192.168.56.121:60010</a>查看Hbase的web界面</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310090107851.png"></p><p>在cluster1上, 输入<code>hbase shell</code> 进入hbase shell.键入以下命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash">create <span class="hljs-string">&#x27;userinfotable&#x27;</span>,&#123;NAME=&gt;<span class="hljs-string">&#x27;username&#x27;</span>&#125;,&#123;NAME=&gt;<span class="hljs-string">&#x27;fullname&#x27;</span>&#125;,&#123;NAME=&gt;<span class="hljs-string">&#x27;homedir&#x27;</span>&#125;</span> <br><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash">put <span class="hljs-string">&#x27;userinfotable&#x27;</span>,<span class="hljs-string">&#x27;r1&#x27;</span>,<span class="hljs-string">&#x27;username&#x27;</span>,<span class="hljs-string">&#x27;vcsa&#x27;</span></span><br><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash">put <span class="hljs-string">&#x27;userinfotable&#x27;</span>,<span class="hljs-string">&#x27;r2&#x27;</span>,<span class="hljs-string">&#x27;username&#x27;</span>,<span class="hljs-string">&#x27;sasuser&#x27;</span></span> <br><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash">scan <span class="hljs-string">&#x27;userinfotable&#x27;</span></span><br></code></pre></td></tr></table></figure><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310091241471.png" alt="image-20220310091241471"></p><p>在 web 界面也可以看到刚才建立的表:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310091504388.png" alt="image-20220310091504388"></p><p>删除刚才建立的表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash"><span class="hljs-built_in">disable</span> <span class="hljs-string">&#x27;userinfotable&#x27;</span></span> <br><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash">drop <span class="hljs-string">&#x27;userinfotable&#x27;</span></span> <br><span class="hljs-meta prompt_">hbase&gt; </span><span class="language-bash"><span class="hljs-built_in">exit</span></span><br></code></pre></td></tr></table></figure><h2 id="9-安装Hive"><a href="#9-安装Hive" class="headerlink" title="9. 安装Hive"></a>9. 安装Hive</h2><h3 id="9-1-安装"><a href="#9-1-安装" class="headerlink" title="9.1 安装"></a>9.1 安装</h3><p><strong>hive 能启动的先决条件是 MySQL 已经安装并配置完成，而且 HDFS 也要启动之后才能运行 hive</strong></p><p>将apache-hive-1.1.0-bin.tar.gz上传到<code>/usr/local</code>并解压</p><p>添加环境变量:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HIVE_HOME=/usr/local/apache-hive-1.1.0-bin<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$HIVE_HOME</span>/bin:<span class="hljs-variable">$HIVE_HOME</span>/conf:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>使用root用户登录MySQL:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u root -p<br></code></pre></td></tr></table></figure><p>创建用户hive, 密码hive:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">GRANT</span> USAGE <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;hive&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;hive&#x27;</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><p>创建数据库hive</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">create</span> database hive;<br></code></pre></td></tr></table></figure><p>允许任意 ip 以hive 登陆数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> hive.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> hive@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;hive&#x27;</span>; <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> hive.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> hive@<span class="hljs-string">&#x27;localhost&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;hive&#x27;</span>; <br>mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> hive.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> hive@<span class="hljs-string">&#x27;cluster2&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;hive&#x27;</span>;<br></code></pre></td></tr></table></figure><p>刷新权限并退出:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> flush privileges;<br>mysql<span class="hljs-operator">&gt;</span> exit;<br></code></pre></td></tr></table></figure><p>验证hive用户是否正确创建:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310093902048.png"></p><p>接下来修改hive-site.xml</p><p>将提供的hive-site.xml上传到apache-hive-1.1.0-bin/conf/目录下即可</p><p>将mysql-connector-java-5.1.43-bin.jar上传至 /usr/local/apache-hive-1.1.0-bin/lib/,</p><p>将jline-2.12.jar拷贝到/usr/local/hadoop-2.6.5/share/hadoop/yarn/lib/</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp /usr/local/apache-hive-1.1.0-bin/lib/jline-2.12.jar /usr/local/hadoop-2.6.5/share/hadoop/yarn/lib/<br></code></pre></td></tr></table></figure><p>并将原先存在的jline-0.9.94.jar重命名为jline-0.9.94.jar.bak,</p><p>切换到hadoop用户执行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /home/hadoop_files/hadoop_tmp/hive/iotmp<br>mkdir -p /home/hadoop_files/hadoop_logs/hive/querylog<br></code></pre></td></tr></table></figure><h2 id="10-安装Scala"><a href="#10-安装Scala" class="headerlink" title="10. 安装Scala"></a>10. 安装Scala</h2><p>在cluster1上将scala-2.10.6.tgz解压到/usr/local/目录下,</p><p>环境变量为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> SCALA_HOME=/usr/local/scala-2.10.6<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$SCALA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>刷新环境变量后用<code>scala -version</code>查看Scala版本验证安装:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310115940338.png"></p><p>复制到所有的服务器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r /usr/local/scala-2.10.6 cluster2:/usr/local/ <br>scp -r /usr/local/scala-2.10.6 cluster3:/usr/local/<br></code></pre></td></tr></table></figure><p>之后设置环境变量,并且修改文件夹权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R hadoop:hadoop /usr/local/scala-2.10.6<br></code></pre></td></tr></table></figure><h2 id="11-安装Spark"><a href="#11-安装Spark" class="headerlink" title="11. 安装Spark"></a>11. 安装Spark</h2><h3 id="11-1-安装"><a href="#11-1-安装" class="headerlink" title="11.1 安装"></a>11.1 安装</h3><p>将spark-1.6.3-bin-hadoop2.6.tgz解压到/usr/local</p><p>环境变量为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> SPARK_HOME=/usr/local/spark-1.6.3-bin-hadoop2.6 <br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$SPARK_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-comment"># cluster1作为主节点需要再加一行</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$SPARK_HOME</span>/sbin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>在 conf 文件夹里面复制一份 template，改名为 spark-env.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> conf/spark-env.sh.template conf/spark-env.sh<br></code></pre></td></tr></table></figure><p>并在其中添加以下语句:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/local/jdk1.7.0_80 <br><span class="hljs-built_in">export</span> SCALA_HOME=/usr/local/scala-2.10.6 <br><span class="hljs-built_in">export</span> SPARK_MASTER_IP=cluster1<br><span class="hljs-built_in">export</span> HADOOP_CONF_DIR=/usr/local/hadoop-2.6.5/etc/hadoop<br><span class="hljs-built_in">export</span> SPARK_DIST_CLASSPATH=$(/usr/local/hadoop-2.6.5/bin/hadoop classpath) <br><span class="hljs-built_in">export</span> SPARK_CLASSPATH=<span class="hljs-variable">$HIVE_HOME</span>/lib/mysql-connector-java-5.1.43-bin.jar <br><span class="hljs-built_in">export</span> SPARK_PID_DIR=/home/hadoop_files<br></code></pre></td></tr></table></figure><p>在conf下新建slaves文件,内容为:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">cluster1</span><br>cluster2<br>cluster3<br></code></pre></td></tr></table></figure><p>将 hive 目录下 conf 文件夹中的 hive-site.xml 复制到 spark 的 conf 目录下,</p><p>将 hadoop/etc/hadoop 文件中的 hdfs-site.xml 和 core-site.xml 文件复制到 spark 的 conf 目录下,</p><p>将 conf 目录下的 spark-defaults.conf.template 复制一份，改名为 spark-default.conf ,并在最下面加上一行:<code>spark.files file:///usr/local/spark-1.6.3-bin-hadoop2.6/conf/hdfs-site.xml,file:///usr/local/spark-1.6.3-binhadoop2.6/conf/core-site.xml</code></p><p>复制到所有的服务器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">scp -r /usr/local/spark-1.6.3-bin-hadoop2.6 cluster2:/usr/local/ <br>scp -r /usr/local/spark-1.6.3-bin-hadoop2.6 cluster3:/usr/local/<br></code></pre></td></tr></table></figure><p>修改 spark 文件夹的权限（每个 spark 结点）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R hadoop:hadoop /usr/local/spark-1.6.3-bin-hadoop2.6<br></code></pre></td></tr></table></figure><p>在cluster1上运行Spark</p><p>运行 spark 前需启动 hadoop 的HDFS 和 YARN</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">start-master.sh<br>start-slaves.sh<br></code></pre></td></tr></table></figure><blockquote><p>关闭 Spark 的命令（cluster1 上）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">stop-slaves.sh<br>stop-master.sh<br></code></pre></td></tr></table></figure></blockquote><h3 id="11-2-测试"><a href="#11-2-测试" class="headerlink" title="11.2 测试"></a>11.2 测试</h3><p>在 cluster1 上使用 jps 命令可以看到 Master 和 Worker，cluster2 和 3 上可以看到Worker,</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310122903560.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310122926901.png"></p><p>用浏览器访问 &lt;<a href="http://192.168.56.121:8080/">http://192.168.56.121:8080</a> &gt;可以看到 Spark 的web 界面，可以看到 3 个worker</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310122837660.png"></p><h2 id="12-安装Storm"><a href="#12-安装Storm" class="headerlink" title="12. 安装Storm"></a>12. 安装Storm</h2><p>storm需要Python2.6以上版本</p><p>将apache-storm-1.1.1.tar.gz解压到<code>/usr/local/</code>下,</p><p>环境变量添加:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> STORM_HOME=/usr/local/apache-storm-1.1.1 <br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$STORM_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><p>改一下权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chown</span> -R hadoop:hadoop apache-storm-1.1.1<br></code></pre></td></tr></table></figure><p>更改storm/conf/storm.yaml文件:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">storm.zookeeper.servers :</span><br><span class="hljs-string">-</span><span class="hljs-string">“cluster1”</span><br><span class="hljs-string">-</span><span class="hljs-string">“cluster2”</span><br><span class="hljs-string">-</span><span class="hljs-string">“cluster3”</span><br> <span class="hljs-attr">storm.local.dir :</span> <span class="hljs-string">“/home/hadoop_files/hadoop_tmp/storm/tmp”</span><br></code></pre></td></tr></table></figure><p>新建tmp文件夹,改权限:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /home/hadoop_files/hadoop_tmp/storm/tmp <br><span class="hljs-built_in">chown</span> -R hadoop:hadoop /home/hadoop_files<br><span class="hljs-built_in">chown</span> -R hadoop:hadoop /usr/local/apache-storm-1.1.1<br></code></pre></td></tr></table></figure><p>在cluster1上新建storm-master的虚拟窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S storm-master<br>storm nimbus<br></code></pre></td></tr></table></figure><p>随后将窗口挂到后台</p><p>在cluster2,3上新建storm-supervisor的虚拟窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S storm-master<br>storm supervisor<br></code></pre></td></tr></table></figure><p>随后将窗口挂到后台</p><p>在cluster1上新建storm-ui的虚拟窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S storm-ui<br>storm ui<br></code></pre></td></tr></table></figure><p>随后将窗口挂到后台</p><p>在cluster1,2,3上新建storm-logviewer的虚拟窗口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S storm-logviewer<br>storm logviewer<br></code></pre></td></tr></table></figure><p>随后将窗口挂到后台</p><p>使用 jps 可以看到以下进程</p><p>cluster1：nimbus, core, logviewer</p><p>cluster2：Supervisor, logviewer</p><p>cluster3：Supervisor, logviewer</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310130740038.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/image-20220310130759287.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MCPE 我的世界基岩版level.dat相关配置</title>
    <link href="/mcpe_level_intro.html"/>
    <url>/mcpe_level_intro.html</url>
    
    <content type="html"><![CDATA[<table>    <tr>        <th bgcolor="yellow" align = "center">配置名</th>        <th bgcolor="yellow" align = "center">中文翻译</th>        <th bgcolor="yellow" align = "center">十六进制表示</th>        <th bgcolor="yellow" align = "center">备注</th>    </tr>    <tr>        <td align = "center">showcoordinates</td>        <td>坐标显示</td>        <td>73 68 6F 77 63 6F 6F 72 64 69 6E 61 74 65 73 [00 | 01]</td>        <td>中括号内如果为00, 则坐标显示为关闭, 为01, 坐标显示开</td>    </tr>    <tr>        <td align = "center">Difficulty</td>        <td>难度</td>        <td>44 69 66 66 69 63 75 6C 74 79 [00 | 01 | 02 | 03]</td>        <td>中括号内数字分别对应:和平|简单|普通|困难</td>    </tr>    <tr>        <td align = "center">RandomSeed</td>        <td>世界的种子号码</td>        <td>52 61 6E 64 6F 6D 53 65 65 64 [FF FF FF FF]</td>        <td>括号中4个字节为种子,规则为:若种子十进制为123456789, 化为十六进制07 5B CD 15,则在文件中为15 CD 5B 07</td>    </tr>    <tr>        <td align = "center">hasBeenLoadedInCreative</td>        <td>曾在创造模式加载</td>        <td>68 61 73 42 65 65 6E 4C 6F 61 64 65 64 49 6E 43 72 65 61 74 69 76 65 [00 | 01]</td>        <td>将此处设置为01将导致游戏无法获得成就,当在游戏中切换到创造模式,此处被置1,同时commandsEnabled也会置1,成就无法获得,需退出游戏将上述两项置0才可恢复成就</td>    </tr>    <tr>        <td align = "center">GameType</td>        <td>游戏模式</td>        <td>47 61 6D 65 54 79 70 65 [00 | 01 | 02]</td>        <td>00 为生存模式, 01 为创造模式, 02 为冒险模式</td>    </tr>    <tr>        <td align = "center">commandsEnabled</td>        <td>启用命令</td>        <td>63 6F 6D 6D 61 6E 64 73 45 6E 61 62 6C 65 64 [00 | 01]</td>        <td>当开启作弊时,此配置和hasBeenLoadedInCreative将会被置1,成就无法获得,将上述两项重新置为0可以重新开启成就</td>    </tr>    <tr>        <td align = "center">keepinventory</td>        <td>保留物品栏</td>        <td>6B 65 65 70 69 6E 76 65 6E 74 6F 72 79 [00 | 01]</td>        <td>开启死亡不掉落将此项置为1即可</td>    </tr>        <tr>        <td align = "center">randomtickspeed</td>        <td>随机刻速度</td>        <td>72 61 6E 64 6F 6D 74 69 63 6B 73 70 65 65 64 [XX | XX]</td>        <td>默认值为1</td>    </tr>    <tr>        <td align = "center">playerPermissionsLevel</td>        <td>其他玩家的权限等级</td>        <td>70 6C 61 79 65 72 50 65 72 6D 69 73 73 69 6F 6E 73 4C 65 76 65 6C [00 | 01 | 02]</td>        <td>00:访客, 01: 成员, 02: 操作员</td>    </tr>    <tr>        <td align = "center">startWithMapEnabled</td>        <td>初始地图</td>        <td>73 74 61 72 74 57 69 74 68 4D 61 70 45 6E 61 62 6C 65 64 [00 | 01]</td>        <td>玩家是否携带地图首次生成</td>    </tr>    <tr>        <td>bonusChestEnabled</td>        <td>奖励箱</td>        <td>62 6F 6E 75 73 43 68 65 73 74 45 6E 61 62 6C 65 64 [00 | 01]</td>        <td>是否允许生成奖励箱</td>    </tr>    <tr>        <td>serverChunkTickRange</td>        <td>渲染距离</td>        <td>73 65 72 76 65 72 43 68 75 6E 6B 54 69 63 6B 52 61 6E 67 65 [XX]</td>        <td>模拟距离</td>    </tr>    <tr>        <td>attackplayers</td>        <td>误伤</td>        <td>61 74 74 61 63 6B 70 6C 61 79 65 72 73 [00 | 01]</td>    </tr>    <tr>        <td>tntexplodes</td>        <td>TNT爆炸</td>        <td>74 6E 74 65 78 70 6C 6F 64 65 73 [00 | 01]</td>    </tr>    <tr>        <td>espawnblocksexplode</td>        <td>重生方块爆炸</td>        <td>72 65 73 70 61 77 6E 62 6C 6F 63 6B 73 65 78 70 6C 6F 64 65 [00 | 01]</td>    </tr>    <tr>        <td>tntexplodes</td>        <td>TNT爆炸</td>        <td>74 6E 74 65 78 70 6C 6F 64 65 73 [00 | 01]</td>    </tr>    <tr>        <td>tntexplodes</td>        <td>TNT爆炸</td>        <td>74 6E 74 65 78 70 6C 6F 64 65 73 [00 | 01]</td>    </tr>    <tr>        <td>tntexplodes</td>        <td>TNT爆炸</td>        <td>74 6E 74 65 78 70 6C 6F 64 65 73 [00 | 01]</td>    </tr></table>]]></content>
    
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件工程导论复习</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.html</url>
    
    <content type="html"><![CDATA[<h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><h2 id="1-软件工程概论"><a href="#1-软件工程概论" class="headerlink" title="1. 软件工程概论"></a>1. 软件工程概论</h2><h3 id="1-1-软件危机-Soft-Crisis"><a href="#1-1-软件危机-Soft-Crisis" class="headerlink" title="1.1. 软件危机(Soft Crisis)"></a>1.1. 软件危机(Soft Crisis)</h3><ul><li><p>计算机软件的开发和维护过程中遇到的一系列严重问题</p></li><li><p>两方面问题</p><ul><li>如何开发软件,满足对软件日益增长的需求</li><li>如何维护数量不断膨胀的已有软件</li></ul></li><li><p>具体表现</p><ul><li><ol><li>对软件开发成本和进度的估计常常很不准确</li></ol></li><li><ol start="2"><li>用户不满意的现象经常发生</li></ol></li><li><ol start="3"><li>软件产品的质量往往靠不住</li></ol></li><li><ol start="4"><li>软件常常是不可维护的</li></ol></li><li><ol start="5"><li>软件没有适当的文档资料</li></ol></li><li><ol start="6"><li>软件成本在计算机系统总成本占比逐年上升</li></ol></li><li><ol start="7"><li>软件开发生产率提高的速度远不及计算机应用迅速普及深入的趋势</li></ol></li></ul></li><li><p>产生原因</p><ul><li><ol><li>与软件本身特点有关</li></ol><ul><li><p>逻辑部件</p><ul><li>质量难以评价, 管理、开发和维护困难</li></ul></li><li><p>规模庞大</p><ul><li>开发繁琐，多人分工协作，设计技术和管理等问题</li></ul></li></ul></li><li><ol start="2"><li>与软件开发与维护不正确有关</li></ol><ul><li>早期软件开发具有个体化特点</li><li>忽视软件需求分析的重要性</li><li>认为软件开发就是写程序并设法使之运行</li><li>轻视软件维护</li></ul></li></ul></li><li><p>消除途径</p><ul><li>对计算机软件有正确的认识, 消除”软件就是程序”的错误认识. 认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目,充分借鉴吸取已有经验</li><li>推广使用在实践中总结出的开发软件的成功技术和方法,并继续研究探索</li><li>开发和使用更好地软件工具</li></ul></li></ul><h3 id="2-1-软件工程"><a href="#2-1-软件工程" class="headerlink" title="2.1 软件工程"></a>2.1 软件工程</h3><ul><li><p>简介</p><ul><li><p>定义</p><ul><li>指导计算机软件开发和维护的一门工程学科, 该学科的目的是生产出能按期交付的、在预算范围内的、满足用户需求的、质量合格的软件产品</li></ul></li><li><p>本质特性</p><ul><li>关注于大型程序的构造</li><li>中心课题是控制复杂性</li><li>软件经常变化</li><li>开发软件效率非常重要</li><li>和谐地合作是开发软件的关键（标准和规程）</li><li>软件必须有效地支持它的用户（满足各方面需求）</li><li>在软件工程领域中通常由具有一种文化的人替具有另一种文化的人开发产品</li></ul></li></ul></li><li><p>基本原理</p><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该小而精</li></ul></li><li><p>方法学</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>软件工程导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Authentication required. System policy prevents WiFi scans</title>
    <link href="/LinuxProblem001.html"/>
    <url>/LinuxProblem001.html</url>
    
    <content type="html"><![CDATA[<h1 id="Authentication-required-System-policy-prevents-WiFi-scans"><a href="#Authentication-required-System-policy-prevents-WiFi-scans" class="headerlink" title="Authentication required. System policy prevents WiFi scans"></a>Authentication required. System policy prevents WiFi scans</h1><p>那天装了Ubuntu树莓派的系统，由于没有显示器，于是给树莓派连的网线和VNC，发现打开 WIFI 的时候总是弹出 “Authentication required. System policy prevents WiFi scans” 这样的标识让你输入密码，输完之后还是不能用 WIFI，点击又会不断弹出这样的标识，好像输完密码会自动退出 WIFI 扫描列表的界面吧，写此文的时候没用Ubuntu了，不记得了。于是 Google 找到了类似的问题，记录如下：</p><p>在 <code>/etc/polkit-1/localauthority/50-local-d</code> 目录下新建一个扩展名为 <code>pkla</code> 的文件，在其中写入如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Allow Wifi Scan]</span><br><span class="hljs-attr">Identity</span>=unix-user:*<br><span class="hljs-attr">Action</span>=org.freedesktop.NetworkManager.wifi.scan<span class="hljs-comment">;org.freedesktop.NetworkManager.enable-disable-wifi;org.freedesktop.NetworkManager.settings.modify.own;org.freedesktop.NetworkManager.settings.modify.system;org.freedesktop.NetworkManager.network-control</span><br><span class="hljs-attr">ResultAny</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">ResultInactive</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">ResultActive</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>不过好像只要加入<code>Action=org.freedesktop.NetworkManager.wifi.scan;</code>就行，其他的不加也无所谓。</p><p>原贴链接:<a href="https://askubuntu.com/questions/1291512/authentication-required-system-policy-prevents-wifi-scans-in-focalfossa">https://askubuntu.com/questions/1291512/authentication-required-system-policy-prevents-wifi-scans-in-focalfossa</a></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>Linux</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java套接字</title>
    <link href="/ComputerNetworkingSocket.html"/>
    <url>/ComputerNetworkingSocket.html</url>
    
    <content type="html"><![CDATA[<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><h2 id="1-套接字"><a href="#1-套接字" class="headerlink" title="1. 套接字"></a>1. 套接字</h2><p>当两个程序需要通信时,它们可以通过使用Socket类建立套接字对象并连接在一起(端口号与IP地址的组合得出一个网络套接字),本节将讲解怎样将客户端和服务器端的套接字对象连接在一起来交互信息。</p><h2 id="2-客户端套接字"><a href="#2-客户端套接字" class="headerlink" title="2. 客户端套接字"></a>2. 客户端套接字</h2><p>客户端的程序使用 Socket类建立负责连接到服务器的套接字对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">Socket</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> newSocket(<span class="hljs-string">&quot;http://192.168.0.78&quot;</span>,<span class="hljs-number">2010</span>);<span class="hljs-comment">//[c1]</span><br>   <span class="hljs-type">InputStream</span> <span class="hljs-variable">inClient</span> <span class="hljs-operator">=</span> clientSocket.getInputStream();<span class="hljs-comment">//[c2]</span><br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outClient</span> <span class="hljs-operator">=</span> clientSocket.getOutputStream();<span class="hljs-comment">//[c3]</span><br>&#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="3-ServerSocket-对象与服务器端套接字"><a href="#3-ServerSocket-对象与服务器端套接字" class="headerlink" title="3. ServerSocket 对象与服务器端套接字"></a>3. ServerSocket 对象与服务器端套接字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverForClient</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>();<span class="hljs-comment">//[s1]</span><br>&#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">Socket</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> serverForClient.accept();<span class="hljs-comment">//[s2]</span><br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outServer</span> <span class="hljs-operator">=</span> sc.getOutputStream();<span class="hljs-comment">//[s3]</span><br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inServer</span> <span class="hljs-operator">=</span> sc.getInputStream();<span class="hljs-comment">//[s4]</span><br>&#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h2><p>通过一个简单的例子说明上面讲的套接字连接。在例子中,客户端向服务器问了三句话,服务器都一一给出了回答。首先将例子3中服务器端的Server. java编译通过,并运行起来,等待客户的呼叫,然后运行客户端程序</p><p>Client.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.DataInputStream;<br><span class="hljs-keyword">import</span> java.io.DataOutputStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String [] mess = &#123;<span class="hljs-string">&quot;2014世界杯在哪举行?&quot;</span>, <span class="hljs-string">&quot;巴西进入世界杯了吗?&quot;</span>, <span class="hljs-string">&quot;中国进入世界杯了吗?&quot;</span>&#125;;<br>        Socket mysocket;<br>        <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mysocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">2010</span>);<br>            in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(mysocket.getInputStream());<br>            out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(mysocket.getOutputStream());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; mess.length; i++) &#123;<br>                out.writeUTF(mess[i]);<br>                <span class="hljs-comment">// in读取信息, 状态堵塞</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> in.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;客户收到服务器的回答:&quot;</span> + s);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务器已断开&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Server.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.DataInputStream;<br><span class="hljs-keyword">import</span> java.io.DataOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        String[] answer = &#123;<span class="hljs-string">&quot;巴西&quot;</span>, <span class="hljs-string">&quot;进入世界杯了&quot;</span>, <span class="hljs-string">&quot;哈哈...问题真逗!&quot;</span>&#125;;<br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverForClient</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socketOnServer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serverForClient = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">2010</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>            System.out.println(e1);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;等待客户呼叫&quot;</span>);<br>            <span class="hljs-comment">//堵塞状态，除非有客户呼叫</span><br>            socketOnServer = serverForClient.accept();<br>            out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(socketOnServer.getOutputStream());<br>            in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(socketOnServer.getInputStream());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; answer.length; i++) &#123;<br>                <span class="hljs-comment">// in读取信息，堵塞状态</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> in.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;服务器收到客户的提问:&quot;</span> + s);<br>                out.writeUTF(answer[i]);<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;客户已断开&quot;</span>+e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-使用多线程技术"><a href="#5-使用多线程技术" class="headerlink" title="5. 使用多线程技术"></a>5. 使用多线程技术</h2><ul><li>服务器端收到一个客户的套接字后,就应该启动一个专门为该客户服务的线程.</li><li>使用套接字连接时,可能在另一端数据发送出来之前,就已经开始试着读取了,这时,就会堵塞本线程,直到该读取方法成功读取到信息,本线程才继续执行后续的操作.</li></ul><p>例子中,</p><ul><li>客户输入圆的半径并发送给服务器。</li><li>服务器把计算出的圆的面积返回给客户。</li><li>因此可以将计算量大的工作放在服务器端,客户负责计算量小的工作,实现客户-服务器交互计算,来完成某项任务。</li><li>首先将例子中服务器端的程序编译通过,并运行起来,等待客户的呼叫。</li></ul><p>Client.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span>  &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>      <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>      Socket mysocket=<span class="hljs-literal">null</span>;<br>      DataInputStream in=<span class="hljs-literal">null</span>;<br>      DataOutputStream out=<span class="hljs-literal">null</span>;<br>      Thread readData ; <br>      Read read=<span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">try</span>&#123;  mysocket=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>();<br>            read = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Read</span>();<br>            readData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(read);<br>            System.out.print(<span class="hljs-string">&quot;输入服务器的IP:&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">IP</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>            System.out.print(<span class="hljs-string">&quot;输入端口号:&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>            <span class="hljs-keyword">if</span>(mysocket.isConnected())&#123;&#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>              InetAddress  address=InetAddress.getByName(IP);<br>              InetSocketAddress socketAddress=<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(address,port);<br>              mysocket.connect(socketAddress); <br>              in =<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(mysocket.getInputStream());<br>              out = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(mysocket.getOutputStream());<br>              read.setDataInputStream(in);<br>              readData.start();<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务器已断开&quot;</span>+e);<br>       &#125;<br>       System.out.print(<span class="hljs-string">&quot;输入园的半径(放弃请输入N):&quot;</span>);<br>       <span class="hljs-keyword">while</span>(scanner.hasNext()) &#123;<br>           <span class="hljs-type">double</span> radius=<span class="hljs-number">0</span>; <br>           <span class="hljs-keyword">try</span> &#123;<br>               radius = scanner.nextDouble();<br>           &#125;<br>           <span class="hljs-keyword">catch</span>(InputMismatchException exp)&#123;<br>              System.exit(<span class="hljs-number">0</span>);<br>           &#125;   <br>           <span class="hljs-keyword">try</span> &#123; <br>               out.writeDouble(radius);<br>           &#125;<br>           <span class="hljs-keyword">catch</span>(Exception e) &#123;&#125;<br>       &#125; <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Server.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Server</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>      ServerSocket server=<span class="hljs-literal">null</span>;<br>      ServerThread thread;<br>      Socket you=<span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">try</span>&#123;  server=<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">2010</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(IOException e1) &#123; <br>              System.out.println(<span class="hljs-string">&quot;正在监听&quot;</span>); <span class="hljs-comment">//ServerSocket对象不能重复创建</span><br>        &#125; <br>        <span class="hljs-keyword">try</span>&#123;  System.out.println(<span class="hljs-string">&quot; 等待客户呼叫&quot;</span>);<br>              you=server.accept();<br>              System.out.println(<span class="hljs-string">&quot;客户的地址:&quot;</span>+you.getInetAddress());<br>        &#125; <br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>              System.out.println(<span class="hljs-string">&quot;正在等待客户&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(you!=<span class="hljs-literal">null</span>) &#123; <br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerThread</span>(you).start(); <span class="hljs-comment">//为每个客户启动一个专门的线程  </span><br>        &#125;<br>      &#125;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>   Socket socket;<br>   DataOutputStream out=<span class="hljs-literal">null</span>;<br>   DataInputStream  in=<span class="hljs-literal">null</span>;<br>   String s=<span class="hljs-literal">null</span>;<br>   ServerThread(Socket t) &#123;<br>      socket=t;<br>      <span class="hljs-keyword">try</span> &#123;  out=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(socket.getOutputStream());<br>             in=<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(socket.getInputStream());<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (IOException e)&#123;&#125;<br>   &#125;  <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;        <br>      <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>         <span class="hljs-keyword">try</span>&#123;  <span class="hljs-type">double</span> r=in.readDouble();<span class="hljs-comment">//堵塞状态，除非读取到信息</span><br>               <span class="hljs-type">double</span> area=Math.PI*r*r;<br>               out.writeDouble(area);<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               System.out.println(<span class="hljs-string">&quot;客户离开&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>         &#125;<br>      &#125;<br>   &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>Read.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Read</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    DataInputStream in;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataInputStream</span><span class="hljs-params">(DataInputStream in)</span> &#123;<br>        <span class="hljs-built_in">this</span>.in = in;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span>&#123; result=in.readDouble();<br>                System.out.println(<span class="hljs-string">&quot;圆的面积:&quot;</span>+result);<br>                System.out.print(<span class="hljs-string">&quot;输入圆的半径(放弃请输入N):&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;与服务器已断开&quot;</span>+e);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络与信息安全</title>
    <link href="/SDE01.html"/>
    <url>/SDE01.html</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络与信息安全"><a href="#计算机网络与信息安全" class="headerlink" title="计算机网络与信息安全"></a>计算机网络与信息安全</h1><h2 id="课程内容提要"><a href="#课程内容提要" class="headerlink" title="课程内容提要"></a>课程内容提要</h2><ul><li>开放系统互连参考模型$（\star\star）$</li><li>TCP/IP协议族$\color{red}{（\star\star\star\star）}$</li><li>IP地址与子网划分 $\color{red}{（\star\star\star\star\star）}$</li><li>网络规划与设计$（\star）$</li><li>3G 与 4G 标准 $（\star\star）$</li><li>HTML 语言$（\star\star）$</li></ul><h2 id="一、OSI-RM-七层模型"><a href="#一、OSI-RM-七层模型" class="headerlink" title="一、OSI/RM 七层模型"></a>一、OSI/RM 七层模型</h2><table>    <tr>        <th bgcolor="yellow" align = "center">层次</th>        <th bgcolor="yellow" align = "center">名称</th>        <th bgcolor="yellow" align = "center">主要功能</th>        <th bgcolor="yellow" align = "center">主要设备及协议</th>    </tr>    <tr>        <td align = "center">7</td>        <td>应用层</td>        <td>实现具体的应用功能</td>        <td rowspan="3">POP3、FTP、Telnet、</br>SMTP</br>DHCP、TFTP、SNMP、DNS</th>    </tr>    <tr>        <td align = "center">6</td>        <td>表示层</td>        <td>数据的格式与表达、加密、压缩</td>    </tr>    <tr>        <td align = "center">5</td>        <td>会话层</td>        <td>建立、管理和终止会话</td>    </tr>    <tr>        <td align = "center">4</td>        <td>传输层</td>        <td>端到端的连接</td>        <td>TCP、UDP</td>    </tr>    <tr>        <td align = "center">3</td>        <td>网络层</td>        <td>分组传输和路由选择</td>        <td>三层交换机、路由器</br>ARP、RARP、IP、ICMP、IGMP</td>    </tr>    <tr>        <td align = "center">2</td>        <td>数据链路层</td>        <td>传送以帧为单位的信息</td>        <td>网桥、交换机（多端口网桥）、网卡、PPTP、L2TP、SLIP、PPP</td>    </tr>    <tr>        <td align = "center">1</td>        <td>物理层</td>        <td>二进制传输</td>        <td>中继器、集线器（多端口中继器）</td>    </tr></table><h2 id="二、TCP-IP协议族"><a href="#二、TCP-IP协议族" class="headerlink" title="二、TCP/IP协议族"></a>二、TCP/IP协议族</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111290054003.png"></p><table>    <tr>        <th frame=void align="center">TCP/IP 模型</th>        <th frame=void align="center">OSI 七层模型</th>    </tr>    <tr>        <td align="center" rowspan=3>应用层</td>        <td align="center">应用层</td>    </tr>    <tr>        <td align="center">表示层</td>    </tr>    <tr>        <td align="center">会话层</td>    </tr>    <tr>        <td align="center" bgcolor="yellow">传输层</td>        <td align="center" bgcolor="yellow">传输层</td>    </tr>       <tr>        <td align="center" bgcolor="#9393FF">网际层</td>        <td align="center" bgcolor="#9393FF">网络层</td>    </tr>    <tr>        <td align="center" rowspan="2" bgcolor="pink">网络接口层</td>        <td align="center" bgcolor="pink">数据链路层</td>    </tr>    <tr>        <td align="center" bgcolor="pink">物理层</td>    </tr></table><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>软考</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>百度高效研发实战训练营</title>
    <link href="/bitTraingClub.html"/>
    <url>/bitTraingClub.html</url>
    
    <content type="html"><![CDATA[<h1 id="一、百度高效研发实战训练营Step1"><a href="#一、百度高效研发实战训练营Step1" class="headerlink" title="一、百度高效研发实战训练营Step1"></a>一、百度高效研发实战训练营Step1</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-设计方法与实践"><a href="#1-设计方法与实践" class="headerlink" title="1 设计方法与实践"></a>1 设计方法与实践</h2><h3 id="1-1-软件设计原则"><a href="#1-1-软件设计原则" class="headerlink" title="1.1 软件设计原则"></a>1.1 软件设计原则</h3><ol><li><p>软件设计的目的</p><blockquote><p>软件设计是为了使软件在长期范围内能够容易的进行变化。我们从下面这三个点来理解这句话。</p><blockquote><ol><li><p>变化：<em>软件不是一成不变的</em>，无论是软件本身的需求、软件依赖的其他软件资源都是一直在发生变化的，唯一不变的就是变化。</p></li><li><p>容易：任何一个软件的变化都需要成本，要尽可能的降低变化的成本，使得软件可以很容易应对软件的变化。</p></li><li><p>长期：事实上需要长期进行维护的软件更应该做好软件设计，因为软件长期的变化非常多，难以提前作出预测，需要良好的软件设计来应对。</p></li></ol></blockquote></blockquote></li><li><p>软件设计原则</p></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111232319206.png"></p><blockquote><p>软件设计有着很多的原则，<em>最基本的原则是高内聚低耦合，它也是软件设计追求的最高目标</em>。 <em><strong>内聚</strong></em> 指的是一个软件内部间元素相关联的程度。</p><p><em><strong>高内聚</strong></em>追求的是紧密相关联的元素要放在一起。</p><p><em><strong>低耦合</strong></em>指的是单位之间尽可能少地关联，依赖。</p></blockquote><blockquote><p>在高内聚低耦合之上有很多其他的原则：如SOLID原则、简单设计、正交设计，在这之上还会有设计模式作为最高层的软件设计原则。</p></blockquote><h3 id="1-2-clean-code"><a href="#1-2-clean-code" class="headerlink" title="1.2 clean code"></a>1.2 clean code</h3><ol><li><p>clean code的概念</p><blockquote><p>clean code中文解释为<em>整洁代码</em>，是指写的代码能够在尽可能短的时间内被别人读懂，且代码看上去排版整洁、逻辑清晰、扩展性好。</p></blockquote></li><li><p>命名规则</p><blockquote><p>代码中命名需要遵循以下的几个规则：</p><blockquote><ol><li><p>表达它是什么，不要表达怎么做。</p></li><li><p>代码要做到自注释。</p></li><li><p>使用有意义的循环迭代变量。</p></li><li><p>避免缩写，尤其拼音缩写。</p></li><li><p>不要使用非约定俗成的缩写。</p></li><li><p>避免使用魔法数。</p></li><li><p>不要害怕长变量名。</p></li></ol></blockquote></blockquote></li><li><p>注释</p><blockquote><p>注释对于代码来说是必不可少的。通常情况下，<em>好的注释包含：版权信息，设计意图，警示信息。</em></p><p>不好的注释则具有以下一个或几个特点：同义反复、隐晦关联关系、套用模板、提供历史修改记录以及注释掉的代码。</p></blockquote></li><li><p>函数</p><blockquote><p>在写函数时，应当注意，<em>每个函数只做一件事</em>，每个函数应是单一职责。</p><p>函数分为骨架函数和步骤函数。</p><ul><li><em>骨架函数</em> 是业务逻辑和算法是在高层次上的抽象描述。</li><li><em>步骤函数</em> 是业务逻辑和算法的一些实现细节，是被隐藏起来的。</li></ul></blockquote></li><li><p>编码细节</p><blockquote><p>在编码细节方面，需要遵循以下几点规则：</p><blockquote><ol><li>使用自然的比较顺序。</li><li>简化逻辑层次，避免多层嵌套。</li><li>在写三元表达式时不要出现复杂的逻辑和过长的条件。</li><li>需要控制变量的作用域，也就是缩小变量作用域的范围，越小越好。</li></ol></blockquote></blockquote></li></ol><h3 id="1-3-单元测试"><a href="#1-3-单元测试" class="headerlink" title="1.3 单元测试"></a>1.3 单元测试</h3><ol><li><p>为什么进行单元测试</p><blockquote><p>测试是分为不同层次的：最底层是单元测试，中间是基于模块级、组件级的测试，再往上则是系统级别的测试。</p><p><em>越底层的测试，越能够快速地发现问题。</em>底层的测试集成性更好，能够安全的进行代码修改。上层的测试一般情况下获得反馈的速度比较慢，测试过程也比较笨重。</p><p>所以单元测试具有<em>更早发现问题，更容易集成，更安全地代码修改的优点</em>。</p></blockquote></li><li><p>写好单元测试的重要性</p><blockquote><p>写好单元很费时。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111232334866.webp"></p><p><em>好的单元测试能够降低产品开发的成本。</em> 然而单元测试写得不好的话，不但会增加产品开发的成本，而且还会增加单元测试成本。</p></blockquote></li><li><p>单元测试原则与模式</p><p><strong>第一个原则：Tests As Documentation</strong></p><p>将测试当成一个文档工作，也就是说我们需要把测试写得像文档一样简洁，通过一些描述，可以清晰地知道这个测试的作用。在之后对项目修改时，只需要查看单元测试即可。</p><p><strong>第二个原则：Fully Automated and Self-Checking</strong></p><p>单元测试都是可以进行自我检查、自我校验的，通过代码的编写，能够知道测试是否成功，不需要人为判定。</p><p><strong>第三个原则：Do No Harm，不可破坏性。</strong></p><p>部分开发人员在进行测试时，为了完成目的，会基于测试代码创立一些逻辑，这种做法是错误的。在写测试时不能单独为测试创建特别的逻辑，更不能破坏原有代码的逻辑。</p><p><strong>第四个原则：Keep tests as simple as possible，简洁性。</strong></p><p>单元测试虽然是用来保证代码的正确性，但单元测试也是一份代码，为了避免过多的测试代码相覆盖，要尽可能地把单元测试的代码写得简单，保证其不会出错。</p></li></ol><h3 id="1-4-重构"><a href="#1-4-重构" class="headerlink" title="1.4 重构"></a>1.4 重构</h3><p>​    重构时需要遵循的规则如下:</p><blockquote><ol><li><strong>业务导向</strong></li></ol><p>重构一定是要解决实际的业务问题的，而不是为了重构去重构。</p><ol start="2"><li><strong>小步快跑</strong></li></ol><p>​        通常重构是需要多人同时参与，重构过程中开发人员要随时对比主干与分支的情况。当某一个开发人员在分支上进行了大量改动并准备将其合并到主干时，有可能主干和分支的代码有很大的差异。所以进行重构时，要<em>将问题拆分成多个小的单元进行修改，并且每修改一个就进行一次分支合并</em>。这种小步快跑的模式可以随时同步主干上的代码，减少出错的可能。</p><ol start="3"><li><strong>演进式设计</strong></li></ol><p>​        在进行代码重构之前，我们不可能知道重构的最终结果是什么。为了保证能够得到一个比较好的结果，我们采用演进式设计方法。在重构过程中<em>遵循包括高内聚低耦合、正交设计原则、SOLID原则等软件设计原则，不断地用小步快跑的方式去重构</em>，只有这样结果才能令人满意。</p><ol start="4"><li><p><strong>正交设计原则</strong></p><p>分离关注点、消除重复、缩小依赖范围、向着稳定的方向依赖。</p></li></ol></blockquote><p>​        在代码中，根据功能的不同，将其分为不同的变化方向。每个变化方向都是一个职责，我们把每一个不同的变化方向称作关注点，根据它的变化方向来进行相应的处理。</p><h3 id="1-5-配置化架构"><a href="#1-5-配置化架构" class="headerlink" title="1.5 配置化架构"></a>1.5 配置化架构</h3><ol><li><strong>配置化架构的定义：</strong></li></ol><p>以可配置的方式构建软件的方法。它是在领域建模的基础上，以配置表述业务，以配置组织架构元素，比如服务、组件、数据等，并对配置进行规范化、自动化的管理。</p><p>定义的原因：</p><blockquote><ol><li><p>通常情况下配置指的是对数据的抽象，需要架构上的描述；</p></li><li><p>架构上描述的配置指的是对架构元素的抽象，描述配置化不完整；</p></li><li><p>配置化包括对业务的抽象，尤其是逻辑；</p></li><li><p>配置化还包括对配置的管理以及分支。</p></li></ol></blockquote><ol start="2"><li><strong>如何应用配置化架构</strong></li></ol><p>应用配置化架构包括三方面：从业务上改造，提高配置本身的开发效率，降低配置的维护成本。</p><blockquote><ol><li><strong>业务配置化改造</strong></li></ol><blockquote><ol><li>组件配置化</li></ol><p>组件配置化表达<em>是业务层面上非常重要的一环</em>，组件是一个独立升级发布的单元，这样的单元关联了很多配置，可将这些配置分为两类。一类是<em>组件内部的配置</em>，另二类是<em>描述组件与组件间关系的配置</em>。只有组件配置化是不够的，往往还需要构建DSL来帮助。</p><ol start="2"><li>构建DSL：</li></ol><p>DSL是工程师针对不同的领域创建的语言。具有很强的针对性，在专业领域有时很长的代码只需要将其改为一行配置就足够了。</p></blockquote><ol start="2"><li><strong>提高配置的开发效率</strong></li></ol><p>通过下面的持续发布的系统，能够很好地提高配置的开发效率。它只针对配置，可以独立的发布配置。在系统中：需要配置前端编辑逻辑，后端校验逻辑，当存储发生变更时，触发测试流水线，当测试流水线无异常后，才会借用部署的工具，将配置分发到线上去。</p><ol start="3"><li><strong>降低配置的维护成本</strong></li></ol><p>通常来说，代码数量很大的项目，配置也会很多。这样的配置在维护起来需要花费大量的成本。所以在设计配置的时候，要满足以下这些规则：</p><blockquote><ol><li><p>让配置尽可能地在部署、数据版本、业务属性和架构描述这四个不同维度间参数能够共用。把部署的配置和策略的配置分离开来。</p></li><li><p>针对配置本身的语法，让配置支持合并.</p></li><li><p>减少冗余信息。</p></li><li><p>消除信息重复。</p></li><li><p>使用配置的默认值。</p></li></ol></blockquote></blockquote><h2 id="2-高效研发流程脚本"><a href="#2-高效研发流程脚本" class="headerlink" title="2. 高效研发流程脚本"></a>2. 高效研发流程脚本</h2><h3 id="2-1-从产品目标到产品路线图"><a href="#2-1-从产品目标到产品路线图" class="headerlink" title="2.1 从产品目标到产品路线图"></a><strong>2.1 从产品目标到产品路线图</strong></h3><blockquote><p>满足用户诉求是产品的基础功能，在此之上还有一个更高的期望，即产品的目标。通常情况下产品目标与产品的收益、市场份额、流水有关。在制定具体产品目标时，需要考虑产品的商业模式以及产品所处的阶段。<em>好的产品目标是具体的、可衡量的、相对稳定的。</em></p><p>在进行产品目标阶段性地拆解时，需要考虑拆解的维度与方法。除了根据阶段性的时间维度进行拆分外，还可以根据产品的里程碑进行拆分。</p></blockquote><h3 id="2-2-从产品路线图到发布计划"><a href="#2-2-从产品路线图到发布计划" class="headerlink" title="2.2 从产品路线图到发布计划"></a>2.2 <strong>从产品路线图到发布计划</strong></h3><p>在了解如何制定产品发布计划之前，我们需要先了解一个工具：<em>用户故事地图</em>。用户故事地图实际上是一个完整的用户故事。它可以帮助我们增强团队协作、洞察真实需求、打磨优良产品。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242041157.png" alt="image-20211124204157089"></p><p>想要创建用户故事地图，首先要有用户故事地图的框架。它的核心是一条从左到右的时间线，然后从上到下按照归纳结构分为三个层级。这一条时间线上方的一级粒度的功能需求，在工作中，我们称之为Epic，也就是橙色卡片。这条时间线下方的第一行为二级粒度的功能需求，在工作中，称之为Feature，是黄色卡片。在二级粒度功能下，蓝色的卡片为三级粒度的需求，工作中，称之为Story，是蓝色卡片。</p><p>用户故事地图创建中五个重要的步骤：</p><blockquote><ol><li><p>一步一步写出你的故事</p></li><li><p>组织情节</p></li><li><p>探索替代故事</p></li><li><p>提取故事地图的主干</p></li><li><p>切分出能帮你达成特定目标的任务</p></li></ol></blockquote><p><strong>“训练智能机器人小A从起床到出门”</strong>的简单例子</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242043740.png" alt="image-20211124204337683"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242053569.png"></p><p><em>首先我们使用蓝色卡片</em> 按照步骤写出每个任务，每张卡片只写一个任务，任务以动词开头，如“睁眼”、“关闹钟”、“穿拖鞋”、“叠被子”等等。然后按照任务的发生顺序从左到右的组织卡片摆放。</p><p>接下来第二步，对所有的任务进行提取，得到概括性的行为，把这些<em>行为放到黄色卡片</em>上，也就是feature。如：“睁眼”、“关闹钟”这些行为可以归为“醒来”后要做的事情；“穿拖鞋”、“叠被子”这两个行为可以归为“起来”后要做的事情。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242055033.png"></p><p>接下来进入第三步：探索替代故事。细节、替代、变化和异常构成故事地图的主题。比如：时间充裕可以睡个回笼觉，楼上装修被提前吵醒等等可能发生的变化和异常。我们需要将这些任务补充进地图。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242057602.png"></p><p>然后进入第四步：将一系列类似的任务提取出来，形成更大的目标。在类似任务的上方，放一张<em>橙色的卡片,也就是之前提到的Epic,卡片贴上一个动词短语</em>，使其足以覆盖其下方所有任务卡片所要表达的意思。例如：“起床”可以概括“醒来”和“起来”；“如厕”可以概括“如厕”和“刷牙”。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242058456.png"></p><p>此时已经完成了较为完整的故事地图。然后进入第五步，切分出能达成特定目标的任务。先确定本次迭代需要完成的特性/目标，使用切分来识别和特定相关的所有任务和细节。</p><p>在“训练智能机器人小A从起床到出门”这个例子中，分为了三个版本。在第一个版本15分钟起床，回笼觉这张卡片明显是不需要放到其中的。在这些的story中选出满足15分钟起床的事务并将其放入都第一个版本中。至此我们也就完成了一个简单的用户故事地图的创建。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242002082.webp"></p><p>上面这张图片是实际工作中对用户故事地图的应用，可以看到在实际工作中完整的用户故事地图所包含的内容非常庞杂。</p><p>完成用户故事地图之后，就需要制订发布计划。在创建用户故事地图的第五步中，我们切分出了达成特定功能的任务目标，每一个发布计划都对应着一个版本。具体的步骤如下：</p><blockquote><ol><li><p>Big Story进行细化讨论</p></li><li><p>按照价值和重要程度进行版本规划</p></li><li><p>确定每个版本的期望达成目标</p></li><li><p>确定每个版本的内容</p></li><li><p>团队达成共识</p></li></ol></blockquote><p>通过以上步骤，就基本确定了用户故事地图的发布计划。</p><h3 id="2-3-从发布计划到迭代计划"><a href="#2-3-从发布计划到迭代计划" class="headerlink" title="2.3 从发布计划到迭代计划"></a>2.3 <strong>从发布计划到迭代计划</strong></h3><p>第三部分主要讲解 <em>集中发布式模式</em> 这一常用的模式，在集中发布式模式中<em>，一次发布包含多次迭代</em>；在迭代发布模式中，一次发布等于一次迭代。</p><p>很多大型项目都在使用这一模式，通常是每月发布一次，<em>一次发布包含四个迭代</em>，四个迭代之后，发布一次版本。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242101886.png"></p><p>从发布计划到迭代计划共包括四个内容。</p><ol><li><strong>用户故事拆分</strong></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242101974.png"></p><p>​        用户故事的拆分<em>对迭代速率有一定影响</em>。对用户故事的拆分要做到拆分出的故事尽量小，但是要适当，并不是越小越好。避免出现一个迭代内无法完成的故事。</p><ol start="2"><li><strong>用户故事优先级</strong></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242104291.webp"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242006342.webp"></p><p>​        在完成用户故事拆分后，需要对用户故事的优先级进行排序。用户故事的排序其实是对需求的一个排序，优先级排序有许多方法，如高中低、数字排序、衣服尺码L、XL等方式。<em>优先级决定排入迭代的顺序。</em></p><p>​        以一个两周的迭代时间为例，假设我们有这样一个需求，前面的数字是需求卡片的序号，后面的数字从100到45，这是项目优先级排序的一个方式。每一次迭代能做4个卡片时，我们就会<em>把优先级最高的卡片放入迭代池</em>。</p><p>​        而当第二次迭代时，需求发生了变化，出现了x和y两个新的需求，x和y有着较高的优先级，那么我们仍然将优先级最高的四个卡片放入迭代池中。</p><p>​        第三次迭代中又插入了新需求z，需求z也有较高的优先级，那么当我们进行迭代的时候，需求z就会顶替另一个需求被放入迭代池中。</p><p>​        通过以上的例子可以看到，在原本的迭代计划中，12张卡片会被按顺序放入迭代池中，而真实情况是插入了更高优先级的需求，替换了低优先级的需求，把低优先级的需求放入了下一次迭代中。这就是优先级排序对迭代计划的影响。</p><ol start="3"><li><strong>用户故事估算</strong></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242105269.png"></p><p>​        在迭代之前，需要对用户故事进行估算，<em>用户故事估算实际上是对工作量的估算</em>。这个工作量体现的是团队均值能力。</p><p>​        通常在公司内有不同级别的员工，高级别的员工和低级别的员工完成同一任务所需的时间是不同的。所以在进行用户故事估算时就需要规避掉技能的差异，根据团队的均值能力来进行估算。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242106613.png"></p><ol start="4"><li><strong>迭代计划制定</strong></li></ol><p>当前面三步全部完成后，才能开始指定迭代计划。</p><p>将已拆分好的用户故事按照优先级依次放入迭代池中，对每个要进行迭代的用户故事进行估算，确定好迭代的时间期限。所以我们就制定出了迭代计划。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242107859.png"></p><p><em>推荐采用范围调整、需求置换</em>方式，即插入高优先级用户故事，顺延低优先级故事到下一次迭代。</p><h3 id="2-4-从迭代计划到迭代的落地执行"><a href="#2-4-从迭代计划到迭代的落地执行" class="headerlink" title="2.4 从迭代计划到迭代的落地执行"></a>2.4 <strong>从迭代计划到迭代的落地执行</strong></h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242108710.png" alt="迭代计划会、站会、需求评审会、迭代回顾会"></p><p>在整个过程中开发和测试以story的力度进行。<em>分析、开发与测试三个步骤并行。</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242110996.png" alt="卡片墙"></p><p>团队可以使用卡片墙标注完成的任务和未完成的任务以及遇到的bug等。通过这种方式，能够对执行情况有清晰的认知，对执行过程产生积极的影响。</p><h2 id="3-研发工具链介绍"><a href="#3-研发工具链介绍" class="headerlink" title="3 研发工具链介绍"></a>3 研发工具链介绍</h2><h3 id="3-1-项目管理工具-iCafe"><a href="#3-1-项目管理工具-iCafe" class="headerlink" title="3.1 项目管理工具: iCafe"></a>3.1 项目管理工具: iCafe</h3><h4 id="3-1-1-需求管理"><a href="#3-1-1-需求管理" class="headerlink" title="3.1.1 需求管理"></a>3.1.1 需求管理</h4><p><strong>需求管理是一个项目的基石。</strong>在互联网行业中，因为产品需求迭代快速这一特点，需求管理一直非常令人头疼。所以如何对需求进行更好的管理，更好的做出产品规划对互联网行业的项目来说是一个重要的问题。</p><blockquote><p>传统的需求管理方法有以下几种：</p><ol><li><p>直接将需求写在文档上面，</p></li><li><p>将需求制作成需求卡片，通过这样的方式让研发人员与需求人员保持信息的一致。</p></li><li><p>使用Excel进行需求管理和排序。</p></li></ol></blockquote><p>这三种方法都存在很多的缺点，如撰写文档耗时长、文档编写需求较多人力、文档维护成本高、文档使用过程中沟通不畅等等。文字因为其阅读特性，不方便对任务进行直观的展现。所以在很多项目开发过程中，经常会出现文档交给研发人员后，开发出的产品与文档设计不一致的问题。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111250059343.png"></p><p>互联网的需求管理需要具有<strong>需求完整性、沟通高效性、表达准确性，沟通便捷性</strong>等特点。</p><p>研究表明，不同的沟通方式产生的沟通效果各有不同。在所有的沟通方式中，文档沟通是最低效的沟通方式，而面对面使用白板沟通是最高效的沟通方式。结合多种高效沟通方式，就产生了用户故事地图这种新颖的需求管理、排序的方式。</p><p><strong>用户故事地图是敏捷项目管理中一种重要的管理方式。</strong></p><p>首先<strong>使用卡片在白板上将所有的需求列出来，</strong>这样有助于展现产品全貌，而且将需求转化为可视的卡片能更好的根据用户反馈对任务需求进行排序；</p><p>然后<strong>使用不同的颜色对卡片进行分层。</strong>蓝色卡片是第一层，黄色卡片是第二层，白色卡片是第三层。将颗粒度最小的需求放在白色卡片这一层，低颗粒度的需求更容易被研发人员接受。</p><p>最后通过横向的分组，把迭代计划每一期的每一版本的<strong>需求进行归类分组。</strong>这样有利于打通产品视图和研发计划视图。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292131175.png"></p><p>通过以上步骤可以得到一个较为完整的用户故事地图。</p><h4 id="3-1-2-迭代计划"><a href="#3-1-2-迭代计划" class="headerlink" title="3.1.2 迭代计划"></a>3.1.2 迭代计划</h4><p>在完成产品的版本规划后，研发团队需要制定相应的迭代计划。敏捷、快速、合理地迭代计划能够更高效地促进项目的迭代。</p><p>基于用户故事地图，可以在制定迭代计划的过程中中直接对需求进行<strong>上下拖拽修改优先级，左右拖拽更改计划。</strong>这样可以更清晰的展现迭代计划，使开发团队更好定位到的里程碑，完善整个迭代计划。</p><h4 id="3-1-3-进度追踪"><a href="#3-1-3-进度追踪" class="headerlink" title="3.1.3 进度追踪"></a>3.1.3 进度追踪</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111250103932.png"></p><p>进度跟踪的三大法宝：<strong>站会、卡片墙、燃尽图。</strong></p><p>站会同卡片墙相结合，在站会过程中可以直接通过电子看板共享项目进度和项目问题，提升站会沟通效率。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270116972.png"></p><p><strong>用户故事地图是一种非常高效需求管理方式，</strong>目前所有的研发团队都可以在效率云上不受物理条件限制的直接使用它进行需求管理和追踪。</p><h4 id="3-1-4-持续改进"><a href="#3-1-4-持续改进" class="headerlink" title="3.1.4 持续改进"></a>3.1.4 持续改进</h4><p>针对持续改进，有卡片状态时长散点图和卡片状态累积流图这两种工具。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270127171.png"></p><p><strong>卡片状态时长散点图</strong>能够精确展示团队工作速率，从需求提出到需求上线的单个周期时长和平均周期时长，精确的展示团队在每一个状态的工作速率及工作速率的变化。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270128848.png"></p><p><strong>卡片状态累积流图</strong>能够宏观展示项目各流程效率趋势，颜色的色块宽表示该流程积压的需求和任务比较多，色条变窄表明团队状态流动速率提高。</p><p>基于这两幅图工具，研发团队可以周期性地进行自检，对过去一段时间的工作进行自我审视，然后持续改进。</p><h3 id="3-2-代码管理工具-iCode"><a href="#3-2-代码管理工具-iCode" class="headerlink" title="3.2 代码管理工具:iCode"></a>3.2 代码管理工具:iCode</h3><h4 id="3-2-1-工作流"><a href="#3-2-1-工作流" class="headerlink" title="3.2.1 工作流"></a>3.2.1 工作流</h4><p>运转无序，开发混乱是困扰很多团队的一个问题，严重影响产品的交付。</p><p>典型的问题有：代码处理随意、bug重复发生、测试不完善、发布版本混乱等。</p><p>支持以下两种标准的工作流，用来保障团队有序协作。</p><h5 id="1-基于主干的工作流"><a href="#1-基于主干的工作流" class="headerlink" title="1.  基于主干的工作流"></a>1.  基于主干的工作流</h5><p>​            在基于主干的工作流中，整个团队维护一条主干分支。为了保证主干分支的质量，需要配套严    格的准入机制，变更点在合入前需要经过机器、人工的双重评审，通过后才能合入主干。</p><p>​            需要发布的时候，会基于主干拉取发布分支，这个分支其实是主干特定点的快照，单纯用于发        布，如果发布问题过程中发现问题，回到主干修复Bug或进行功能增强，必要时再将主干提交拣        选到相应的发布分支上。</p><p>​            分支发布和主干并行不悖，不用担心开发中的功能被带到线上，发布完成后恢复到一条主干的        简明模式。</p><blockquote><p>  基于主干的工作流<strong>优点</strong>有：</p><ol><li>主干质量高，随时可以发布。</li><li>模型简单，只有一条主干，节省分支合并的成本。</li></ol></blockquote><p>​    缺点: 在开发高质量的工程项目时，团队需要建设完备的测试用例，在提交环节要求提交人保持原子提交，即功能和提交一一对应。</p><h5 id="2-基于分支的工作流"><a href="#2-基于分支的工作流" class="headerlink" title="2. 基于分支的工作流"></a>2. 基于分支的工作流</h5><p>在基于分支的工作流中，<strong>主干用于存储线上代码</strong>，需要变更时，基于主干最新代码开分支完成功能的开发、测试和发布；分支发布前，需要先同步主干的更新；上线之后，需要将分支合并回主干。</p><blockquote><p>基于分支的工作流的<strong>优点</strong>有：</p><ol><li>分支并行，独立开发，分支不会相互影响；</li><li>对团队而言，使用门槛低，分支贯穿一个独立功能开发、测试、发布的整个过程，给予团队充分的时间完善测试用例及完成人工测试；</li><li>容易上手，系统会引导开发人员完成新建分支、同步主干、合会主干等全部操作。</li></ol></blockquote><p>缺点：需要花费分支合并的成本、需要不断地同步主干，来发现分支的冲突风险点并提前解决。</p><h3 id="3-2-2-评审"><a href="#3-2-2-评审" class="headerlink" title="3.2.2 评审"></a>3.2.2 评审</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270327159.png"></p><p>评审是<strong>保证团队工程质量</strong>的一个重要的过程。如果不经过评审直接提交代码，可能会污染代码历史，增加后期维护成本，严重时可能还会产生代码质量问题。</p><p>在项目开发过程中，可能会出现本地运行正常的代码，在测试环境或者线上环境突然崩溃的情况。针对这样的问题，可以使用<strong>质量防护网</strong>。质量防护网包括代码扫描、持续集成、人工评审三个层次。</p><p><strong>代码扫描</strong>能够找出不符合代码规范的地方，在行间距中插入代码评论，同时出具一个风格报告，方便工程师对代码风格问题进行修改。</p><p><strong>持续集成</strong>会配置一个云端构建，通过云端构建，快速探测出代码初期Bug，帮助开发人员提早修复。</p><p>在前两步做好后，团队的资深成员就可以就架构、逻辑、设计等问题进行深入评审。</p><p>通过这三步，实现了机器、人工双重评审，层层递进，确保团队的工程质量。</p><h3 id="3-3-交付平台-iPipe"><a href="#3-3-交付平台-iPipe" class="headerlink" title="3.3 交付平台:iPipe"></a>3.3 交付平台:iPipe</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270329017.png"></p><h4 id="3-3-1-固化端到端的交付流程"><a href="#3-3-1-固化端到端的交付流程" class="headerlink" title="3.3.1 固化端到端的交付流程"></a>3.3.1 固化端到端的交付流程</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270333279.png"></p><p>标准的软件交付的过程包括以下几点：</p><blockquote><ol><li><p>会有一个明确的发布版本的输入，</p></li><li><p>基于这个发布版本，会进行代码提交。</p></li><li><p>代码提交之后会进行编译、测试。其中测试环节可能包含模块级的测试和系统级的测试。</p></li><li><p>进行发布。发布上线的过程可能会分为预上线、生产灰度、生产全量几个环节。</p></li></ol></blockquote><p>为了使代码变更流程标准化，需要<strong>使用交付流水线的方式来落地</strong>。通过标准化交付过程从而达到可靠、可重复的作用。交付流水线是<strong>串行执行</strong>的，上一个阶段成功执行后，就会触发下一个阶段。执行阶段由任务组成，这些任务可以是穿行的也可是并行的。任务的执行状态决定阶段执行状态。</p><p><strong>iPipe这一工具目前包含了标准的交付流水线</strong>，用户可以在iPipe中看到流水线的构建情况。在使用交付流水线的过程中，如果当前阶段失败，后面的阶段就不会继续进行，这样可以节省资源并且快速的发现问题，及时修复问题。</p><h4 id="3-3-2-插件化现有工具和服务"><a href="#3-3-2-插件化现有工具和服务" class="headerlink" title="3.3.2 插件化现有工具和服务"></a>3.3.2 插件化现有工具和服务</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292130209.png"></p><p>在交付流水线中执行各种任务时需要依赖很多工具和服务，比如maven，docker、jenkins、git等工具和服务。</p><p>我们通过一套<strong>标准的插件化开发规范</strong>将这些工具和服务集成到了流水线中，用户在使用流水线的过程中就可以很方便的使用这些插件和服务。如果流水线中没有想使用的插件、服务或工具，可以根据效率云提供的插件规范，自行扩展以满足项目需求。</p><h4 id="3-3-3-数据度量驱动过程改进"><a href="#3-3-3-数据度量驱动过程改进" class="headerlink" title="3.3.3 数据度量驱动过程改进"></a>3.3.3 数据度量驱动过程改进</h4><p>通过交付流水线，可以快速获取项目所有的数据和信息，如：一个版本从代码提交到交付上线的周期或者一个项目各个阶段发现的缺陷数量等等。</p><p>用户可以通过调用API获取数据来进行数据的度量，从而推动交付过程的改进。在后续的发展中，平台会识别项目中关键的数据指标并且自动化的形成更加鲜明的数据报表。这样就可以持续的进行数据度量，给个人及团队提供一个维度丰富的平台。</p><h2 id="4-持续交付方法与实践"><a href="#4-持续交付方法与实践" class="headerlink" title="4 持续交付方法与实践"></a>4 持续交付方法与实践</h2><h3 id="4-1-为什么要做持续交付"><a href="#4-1-为什么要做持续交付" class="headerlink" title="4.1 为什么要做持续交付"></a>4.1 为什么要做持续交付</h3><h4 id="4-1-1-软件交付流程"><a href="#4-1-1-软件交付流程" class="headerlink" title="4.1.1 软件交付流程"></a>4.1.1 软件交付流程</h4><p>传统软件交付流程通常包括四个步骤：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271338880.png"></p><ol><li><p>首先业务人员会诞生一个软件的想法；</p></li><li><p>然后开发人员将这个想法变为一个产品或者功能；</p></li><li><p>经过测试人员的测试之后提交给用户使用并产生收益；</p></li><li><p>最后运维人员参与产品或功能的后期运维。</p></li></ol><h4 id="4-1-2-传统软件交付的问题和困境"><a href="#4-1-2-传统软件交付的问题和困境" class="headerlink" title="4.1.2 传统软件交付的问题和困境"></a>4.1.2 传统软件交付的问题和困境</h4><p>通过分析以上流程，可以发现一些传统软件交付流程<strong>存在的问题</strong>。</p><ol><li><p><strong>业务人员产生的需求文档沟通效率较低</strong>，有时会产生需求文档描述不明确、需求文档变更频繁等问题。</p></li><li><p>随着开发进度的推进，测试人员的工作量会逐步增加，测试工作的比重会越来越大。而且由于测试方法和测试工具有限，自动化测试程度低，<strong>无法很好地把控软件质量</strong>。</p></li><li><p>真实项目中运维的排期经常会被挤占，又因为手工运维繁琐复杂，<strong>时间和技术上的双重压迫</strong>会导致运维质量难以保证。</p></li></ol><p>因为存在以上问题，所以传统的软件交付经常会出现开发团队花费大量成本开发出的功能或产品并不能满足客户需求这一双输的局面。由此可以总结出传统的软件交付存在<strong>两个层面的困境：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271339450.png"></p><p>从<strong>表现层</strong>来看，传统软件交付存在进度不可控；流程不可靠；环境不稳定；协作不顺畅等困境。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271339695.png"></p><p>表现层的问题其实都是由<strong>底层问题</strong>引起的，从根源上来说，存在分支冗余导致合并困难；缺陷过多导致阻塞测试；开发环境、测试环境、部署环境不统一导致的未知错误；代码提交版本混乱无法回溯；等待上线周期过长；项目部署操作复杂经常失败；上线之后出现问题需要紧急回滚；架构设计不合理导致发生错误之后无法准确定位等困境。</p><h4 id="4-1-3-持续交付的流程与优势"><a href="#4-1-3-持续交付的流程与优势" class="headerlink" title="4.1.3 持续交付的流程与优势"></a>4.1.3 持续交付的流程与优势</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271340504.png"></p><p>经过对传统软件交付问题的分析和总结，持续交付应运而生，持续交付是一系列开发实践方法，用来确保让代码能够快速、安全的部署到生产环境中。持续交付是一个完全自动化的过程，当业务开发完成的时候，可以做到一键部署。持续交付提供了一套更为完善的解决传统软件开发流程的方案。</p><ol><li><p>在需求阶段，抛弃了传统的需求文档的方式，使用便于开发人员理解的用户故事。</p></li><li><p>在开发测试阶段，做到持续集成，让测试人员尽早进入项目开始测试。</p></li><li><p>在运维阶段，打通开发和运维之间的通路，保持开发环境和运维环境的统一。</p></li></ol><p><strong>持续交付具备以下几个优势：</strong></p><blockquote><ol><li>持续交付能够有效缩短提交代码到正式部署上线的时间，降低部署风险。</li><li>持续交付能够自动的、快速的提供反馈，及时发现和修复缺陷。</li><li>持续交付让软件在整个生命周期内都处于可部署的状态。</li><li>持续交付能够简化部署步骤，使软件版本更加清晰。</li><li>持续交付能够让交付过程成为一种可靠的、可预期的、可视化的过程。</li></ol></blockquote><h4 id="4-1-4-敏捷开发与Devops"><a href="#4-1-4-敏捷开发与Devops" class="headerlink" title="4.1.4 敏捷开发与Devops"></a>4.1.4 敏捷开发与Devops</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271341155.png"></p><p>持续交付依靠<strong>敏捷开发（Agile）</strong>和<strong>Devops</strong>两个组件的支撑可以更好地发挥作用。</p><p>敏捷开发（Agile）主要作用于需求阶段和研发阶段。</p><p>Devops主要作用于开发测试和运维部署阶段。</p><blockquote><p>了解Devops的相关知识。</p><blockquote><ol><li><p>Devops的趋势</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271341165.png"></p><p>根据最近的一项集体研究，DevOps的市场在2020年创造了约50亿美元的产值，预计到2022年，这个数字将达到约66亿美元。随着Devops的影响力不断扩大，目前DevOps已经成为软件工程的主流模式。</p></li></ol></blockquote><blockquote><ol start="2"><li><p>Devops效能</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271342341.png"></p><p>Devops的效能跟发布频率、部署时间、平均修复故障的时间点、部署变更的失败率四个因素紧密相关。通常在高效的团队内，发布频率会达到每天多次发布、部署时间和平均修复故障时间都小于一小时，部署变更的失败率也能维持在15%以下。</p></li></ol></blockquote></blockquote><h4 id="4-1-5-软件交付能力指标"><a href="#4-1-5-软件交付能力指标" class="headerlink" title="4.1.5 软件交付能力指标"></a>4.1.5 软件交付能力指标</h4><p>在评价互联网公司的软件交付能力的时候，通常会使用两个指标：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271343658.png"></p><ol><li><p>仅涉及一行代码的改动需要花费多少时间才能部署上线，这也是<strong>核心指标</strong>。</p></li><li><p>开发团队是否在以一种可重复、可靠的方式在执行软件交付。</p></li></ol><p>目前，国外的主流互联网企业部署周期都以分钟为单位， Amazon、Google这些头部互联网企业单日的部署频率都在20000次以上。国内以百度、阿里、腾讯三大互联网巨头的数据来看，单日部署的频率也达到了单日8000次以上。高频率的部署代表着能够更快更好的响应客户的需求。</p><h3 id="4-2-如何做到高效的持续交付"><a href="#4-2-如何做到高效的持续交付" class="headerlink" title="4.2 如何做到高效的持续交付"></a>4.2 如何做到高效的持续交付</h3><h4 id="4-2-1-持续交付方法"><a href="#4-2-1-持续交付方法" class="headerlink" title="4.2.1 持续交付方法"></a>4.2.1 持续交付方法</h4><p>为了能更好的做到高效的持续交付。在此我们提供了一个<strong>三层叠加的持续交付方法</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271345629.png"></p><p>首先最上层，持续交付的<strong>总目标是价值交付</strong>，要为用户交付有价值的内容。</p><p>然后第二层包含了业务、流程、组织三个维度。</p><p>在业务这一维度，主要通过精益、用户故事地图、看板三种方式来减少业务部门与开发部门的沟通困难。</p><p>在流程这一维度，主要集中于创建一个供开发、测试、运维人员使用的可靠、可重复的流水线，将这种流水线应用于项目的流程中。</p><p>在组织这一维度，要求加强团队协作，提高项目质量和项目改进能力，并且引入了成熟度模型用于评估团队的能力层级。</p><p>如果没有技术能力的支撑，仅依靠方法和指导思想不足以做到高效持续交付。所以<strong>第三层也是最重要的底层是技术层</strong>。技术层包括了基础架构和应用架构。<strong>基础架构</strong>引入了容器集群管理、研发工具平台、持续交付工具链。<strong>应用框架</strong>引入了浮现式设计、微服务框架还有能够抽离出来的配置化架构。</p><h4 id="4-2-2-持续交付、持续集成、持续部署的关系"><a href="#4-2-2-持续交付、持续集成、持续部署的关系" class="headerlink" title="4.2.2 持续交付、持续集成、持续部署的关系"></a>4.2.2 持续交付、持续集成、持续部署的关系</h4><p>要进一步构建可靠可重复的流水线，首先就是要理清持续交付、持续集成和持续部署三者之间的关系。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271348755.png"></p><p>简单来说<strong>持续集成和持续部署是持续交付的基础，持续交付包括但不限于持续集成和持续部署。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271350656.png"></p><p>持续集成是包含了代码的编译、近代检查、单元测试任务的集成，虽然持续集成也能构成一条流水线，但是这条流水线并不完整，而且集成并没有明确的目标。</p><p>近几年得益于虚拟机技术和容器技术的迅速发展，持续部署也逐渐变得简单高效，能够运用这些工具快速将项目部署到例如准入环境、预生产环境等等各种环境中。</p><h4 id="4-2-3-如何构建一个可靠可重复的流水线"><a href="#4-2-3-如何构建一个可靠可重复的流水线" class="headerlink" title="4.2.3 如何构建一个可靠可重复的流水线"></a>4.2.3 如何构建一个可靠可重复的流水线</h4><p>在理清持续交付的关系后，需要通过持续交付来构建一条可靠可重复的流水线，构建这条流水线的目的是为了让开发人员、测试人员、运维人员能更好的协作完成整个项目并上线到生产环境。</p><p>通过对比传统流水线和持续交付流水线，能更加清晰地展现出持续交付流水线的强大。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271351747.png"></p><p>在传统流水线中，首先代码提交要用过填写表单的形式进行版本申请，然后开发人员在离线环境上手工进行代码编译和单元测试，单元测试完成后需要撰写对应的测试报告文档并且向上提测，在系统测试环节需要测试人员手动构建和部署测试环境，完成测试之后再次撰写测试报告，并且申请上线，在通过上线审批之后，在线上生产环境需要再次手动构建环境以及进行生产环境的测试，最终完成整体的开发。</p><p>在持续交付流水线中，代码合入到主干之后会直接触发自动编译，自动编译完成之后会进行初步的自动化单元测试、模块测试和系统测试，在测试过程中持续交付可以自动构建和部署环境。完成系统测试之后会将问题抛出来，解决完成后再次提测，会自动化的再次进行系统测试，通过系统测试之后可以一键操作进行项目发布，并进行预上线，在完成预上线后，可以再次进行一键操作完成正式生产环境的上线。</p><p>通过两种流水线的对比，可以看出来，持续交付的流水线有显著的优势。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271352109.png"></p><p>实际生产中的产品级流水线，可以视为多个模块级流水线的组合，多个模块级流水线组合成为复杂的多线并发的产品级流水线，最终可以完成整个项目的持续交付。</p><h4 id="4-2-4-交付流水线落地工具"><a href="#4-2-4-交付流水线落地工具" class="headerlink" title="4.2.4 交付流水线落地工具"></a>4.2.4 交付流水线落地工具</h4><p>交付流水线的落地需要依靠<strong>落地方案</strong>和<strong>落地工具</strong>，目前常用的落地方案有GoCD，这是thoughtworks的一个产品。还有目前广泛应用的Jenkins和Spinnakeer。</p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271354818.png" style="zoom:50%;" /><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271354355.png" style="zoom:50%;" /><p>常用的交付流水线落地工具有效率云平台中的iPipe工具，在这个工具中可以根据需求创建流水线，并且将相关内容全都关联到流水线中，这样可以让开发人员、测试人员和运维人员在这个工具中直观的看到产品的状态以及质量情况。</p><h3 id="4-3-持续部署"><a href="#4-3-持续部署" class="headerlink" title="4.3 持续部署"></a>4.3 持续部署</h3><p>对于持续交付整体来说，持续部署非常重要。</p><h4 id="4-3-1-持续部署方案"><a href="#4-3-1-持续部署方案" class="headerlink" title="4.3.1 持续部署方案"></a>4.3.1 持续部署方案</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292130946.png"></p><p>容器技术目前是部署中最流行的技术，常用的持续部署方案有Kubernetes+Docker和Matrix系统两种。容器技术一经推出就被广泛的接受和应用，主要原因是对比传统的虚拟机技术有以下几个<strong>优点</strong>：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292130129.png"></p><ol><li>容器技术上手简单，轻量级架构，体积很小。</li><li>容器技术的集合性更好，能更容易对环境和软件进行打包复制和发布。</li></ol><p>容器技术的引入为软件的部署带来了前所未有的改进，不但<strong>解决了复制和部署麻烦</strong>的问题，还能<strong>更精准的将环境中的各种依赖进行完整的打包。</strong></p><h4 id="4-3-2-部署原则"><a href="#4-3-2-部署原则" class="headerlink" title="4.3.2 部署原则"></a>4.3.2 部署原则</h4><p><strong>在持续部署管理的时候，需要遵循一定的原则，内容包括以下几点：</strong></p><ol><li>部署包全部来自统一的存储库。</li><li>所有的环境使用相同的部署方式。</li><li>所有的环境使用相同的部署脚本。</li><li>部署流程编排阶梯式晋级，即在部署过程中需要设置多个检查点，一旦发生问题可以有序的进行回滚操作。</li><li>整体部署由运维人员执行。</li><li>仅通过流水线改变生产环境，防止配置漂移。</li><li>不可变服务器。部署方式采用蓝绿部署或金丝雀部署。</li></ol><h4 id="4-3-3-部署层次"><a href="#4-3-3-部署层次" class="headerlink" title="4.3.3 部署层次"></a>4.3.3 部署层次</h4><p>部署层次的设置对于部署管理来说也是非常重要的。首先要明确部署的目的并不是部署一个可工作的软件，而是<strong>部署一套可正常运行的环境</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271634406.png"></p><p><strong>完整的镜像部署包括三个环节：Build – Ship – Run。</strong></p><p>Build跟传统的编译类似，将软件编译形成RPM包或者Jar包。</p><p>Ship则是将所需的第三方依赖和第三方插件安装到环境中。</p><p>Run就是在不同的地方启动整套环境。</p><p>制作完成部署包之后，每次需要变更软件或者第三方依赖、插件升级的时候，不需要重新打包，直接更新部署包即可。</p><h4 id="4-3-4-不可变服务器"><a href="#4-3-4-不可变服务器" class="headerlink" title="4.3.4 不可变服务器"></a>4.3.4 不可变服务器</h4><p>在部署原则中提到的不可变服务器原则对于部署管理来说非常重要。不可变服务器<strong>是技术逐步演化的结果。</strong></p><p>在早期阶段，软件的部署是在物理机上进行的，每一台服务器的网络、存储、软件环境都是不同的，物理机的不稳定让环境重构变得异常困难。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271635334.png"></p><p>后来逐渐发展为虚拟机部署，在虚拟机上借助流程化的部署能较好的构建软件环境，但是第三方依赖库的重构不稳定为整体部署带来了困难。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292130431.png"></p><p>现阶段使用容器部署不但继承和优化了虚拟机部署的优点，而且很好的解决了第三方依赖库的重构问题，容器部署就像一个集装箱，直接把所有需要的内容全部打包进行复制和部署。</p><h4 id="4-3-5-蓝绿部署和金丝雀部署"><a href="#4-3-5-蓝绿部署和金丝雀部署" class="headerlink" title="4.3.5 蓝绿部署和金丝雀部署"></a>4.3.5 蓝绿部署和金丝雀部署</h4><p>在部署原则中提到两大部署方式分别为蓝绿部署和金丝雀部署。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271635700.png"></p><p><strong>蓝绿部署</strong>是指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速的将用户环境切回旧版本，并对新版本进行修复和调整。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271636728.png"></p><p><strong>金丝雀部署</strong>是指当有新版本发布的时候，先让少量的用户使用新版本并且观察新版本是否存在问题，如果出现问题，就及时处理并重新发布，如果一切正常，就稳步的将新版本适配给所有的用户。</p><h4 id="4-3-6-服务描述"><a href="#4-3-6-服务描述" class="headerlink" title="4.3.6 服务描述"></a>4.3.6 服务描述</h4><p>服务描述要实现的目标是当软件部署到不同的环境中时，通过服务描述来<strong>规避环境配置的差异</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637518.png"></p><p>在服务描述中，通常会对不同的环境下所需的配置进行描述，例如所需要的CPU、内存、网络等。当实际部署的时候，如果出现环境差异，调度工具就可以按照服务描述的配置发放资源，使环境能够正常运行。</p><h4 id="4-3-7-流程控制"><a href="#4-3-7-流程控制" class="headerlink" title="4.3.7 流程控制"></a>4.3.7 流程控制</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637506.png"></p><p>在部署阶段，为了防止意外问题的发生，会在一些环节<strong>加入人工审核</strong>。例如在灰度发布工具中，就会先对线上机器进行分组部署，然后由人工去分组检查，如果没有问题，就进行下一组的部署，如果出现问题，人工就可以及时的进行回滚操作，避免问题扩大到更多地线上环境中。</p><h4 id="4-3-8-数据度量和分析"><a href="#4-3-8-数据度量和分析" class="headerlink" title="4.3.8 数据度量和分析"></a>4.3.8 数据度量和分析</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637498.png"></p><p>在完成持续部署或持续交付之后，需要结合多个维度的数据对项目整体的<strong>研发效率和部署效率进行分析</strong>。例如通过交付时间周期的长短变化来反映流水线为团队带来的价值。再比如通过筛选和展示团队的相关数据，方便团队来进行决策。还有通过环比汇总数据来分析变化的趋势。系统也会通过数据的自动分析和异常报表监控一些关键指标，一旦关键数据出现问题，系统能够及时联系关键人员关注。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271640201.png"></p><p>通过以上的例子能够发现，<strong>持续交付与量化驱动改进是密不可分的</strong>，团队能够在度量中发现问题，在度量中看到进步。持续交付就是这样一个不断改进不断优化的过程，通过数据可以量化产出并且指引团队找到痛点并且进一步的深化改进。</p><h1 id="二、百度高效研发实战训练营Step2"><a href="#二、百度高效研发实战训练营Step2" class="headerlink" title="二、百度高效研发实战训练营Step2"></a>二、百度高效研发实战训练营Step2</h1><h2 id="1-代码的艺术"><a href="#1-代码的艺术" class="headerlink" title="1 代码的艺术"></a>1 代码的艺术</h2><h3 id="1-1-《代码的艺术》目的解读"><a href="#1-1-《代码的艺术》目的解读" class="headerlink" title="1.1 《代码的艺术》目的解读"></a>1.1 《代码的艺术》目的解读</h3><h4 id="1-1-1-了解公司与学校写代码的不同"><a href="#1-1-1-了解公司与学校写代码的不同" class="headerlink" title="1.1.1 了解公司与学校写代码的不同"></a>1.1.1 了解公司与学校写代码的不同</h4><p>在公司写程序和在学校写程序有很大的不同。</p><p>在学校写程序时，对于代码的质量要求比较低。</p><p>当进入公司之后，做的是工业级的产品，服务用户量可能会到达亿万级，所以相对而言对于代码的质量要求比较高。<em>一些伟大产品中的代码，甚至可以被称为艺术品。</em></p><h4 id="1-1-2-消除对于程序员这个职业的误解"><a href="#1-1-2-消除对于程序员这个职业的误解" class="headerlink" title="1.1.2 消除对于程序员这个职业的误解"></a>1.1.2 消除对于程序员这个职业的误解</h4><p>很多人都对程序员这个职业有误解，认为程序员就是码农，认为程序员35岁之后就写不出代码了。还有人认为程序员未来的唯一出路是以后做管理。</p><p>希望通过这门课程的学习，能使大家对于程序员有一个新的认识，消除误解。</p><h4 id="1-1-3-建立对软件编程的正确认识"><a href="#1-1-3-建立对软件编程的正确认识" class="headerlink" title="1.1.3 建立对软件编程的正确认识"></a>1.1.3 建立对软件编程的正确认识</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272315701.png"></p><p>在做一件事物时，我们常说“知”与“行”要合一。即：我们需要对这件事物有一个正确的认识，才会有正确的行动。同理，<em>写出好代码的前提，是对软件编程有正确的认识</em>。</p><h4 id="1-1-4-明确作为软件工程师的修炼方向"><a href="#1-1-4-明确作为软件工程师的修炼方向" class="headerlink" title="1.1.4 明确作为软件工程师的修炼方向"></a>1.1.4 明确作为软件工程师的修炼方向</h4><p>艺术品是由艺术家创造的。艺术家的修炼是有方式方法的。同样，软件工程师的修炼也是方式有方法的。希望通过这门课程，能使大家对软件工程师这个职业有一个全新的认识。</p><h3 id="1-2-代码与艺术之间的关系"><a href="#1-2-代码与艺术之间的关系" class="headerlink" title="1.2 代码与艺术之间的关系"></a>1.2 代码与艺术之间的关系</h3><h4 id="1-2-1-代码是可以被称为艺术的"><a href="#1-2-1-代码是可以被称为艺术的" class="headerlink" title="1.2.1 代码是可以被称为艺术的"></a>1.2.1 代码是可以被称为艺术的</h4><p>艺术，是多种多样、丰富多彩的。同时艺术也是有多个层次的，其实，在我们编写代码时，我们的脑海中也会有类似的感觉。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272319344.png"></p><p>艺术就是人类通过借助特殊的物质材料与工具，运用一定的审美能力和技巧，在精神与物质材料、心灵与审美对象的相互作用下，进行的充满激情与活力的创造性劳动，可以说它是一种精神文化的创造行为，是人的意识形态和生产形态的有机结合体。</p><p>写代码也恰恰要经历这样的一个过程。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272319626.png"></p><p>在编写代码的过程中：</p><p>我们<em>借助的物质是计算机系统，借助的工具是设计、编写、编译、调试、测试等</em>。</p><p>同样，编写代码需要激情。而且，编写代码是一件非常具有创造性的工作。</p><p>代码是人类智慧的结晶，代码反映了一个团队或一个人的精神。<em>代码可以被称为是艺术的。</em></p><h4 id="1-4-2-艺术可以从不同的角度进行解读、研究与创造"><a href="#1-4-2-艺术可以从不同的角度进行解读、研究与创造" class="headerlink" title="1.4.2 艺术可以从不同的角度进行解读、研究与创造"></a><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272320545.png">1.4.2 艺术可以从不同的角度进行解读、研究与创造</h4><p>达芬奇有多幅著名的画作。拿著名的《蒙娜丽莎》这幅画来举例：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272322121.png"></p><p>站在观众的角度，可能只是在欣赏画中的人物微笑。但是对于画家来说，可能就会考虑画画的手法、构图、光线明暗、色彩对比等等方面。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272323753.png"></p><p>在艺术方面，可以站在很多不同的角度进行解读。</p><p>但是如果要成为一名创作者，我们需要的不仅仅是欣赏的能力，更重要的是<em>从多角度进行解读、研究与创造的能力</em>。</p><h4 id="1-4-3-写代码如同艺术创作"><a href="#1-4-3-写代码如同艺术创作" class="headerlink" title="1.4.3 写代码如同艺术创作"></a>1.4.3 写代码如同艺术创作</h4><p>写代码的内涵是：</p><ol><li>写代码这个过程是一个<em>从无序到有序</em>的过程。</li><li>写代码需要把现实问题转化为数学模型。在写代码的过程中，我们需要有很好的模型能力。</li><li>写代码实际是一个认识的过程。很多时候，编码的过程也是我们认识未知问题的过程。</li><li>在写代码的过程中，我们需要综合的全方位的能力。包括把握问题的能力、建立模型的能力、沟通协助的能力、编码执行的能力等等。</li><li>在写好代码之前，首先需要建立品位。品味是指我们首先要知道什么是好的代码，什么是不好的代码。这样我们才能去不断地调整自己的行为，然后去学习，去提高我们的编码能力，写出具有艺术感的代码。</li></ol><h3 id="1-3-软件工程师不等于码农"><a href="#1-3-软件工程师不等于码农" class="headerlink" title="1.3 软件工程师不等于码农"></a>1.3 软件工程师不等于码农</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272336586.png"></p><p>软件工程师不能只会写代码，更需要具有综合的素质。这个综合的素质包括：</p><h4 id="1、技术"><a href="#1、技术" class="headerlink" title="1、技术"></a>1、技术</h4><p><em><strong>技术能力是基础。</strong></em>包括但不限于编码能力、数据结构和算法能力、系统结构知识、操作系统知识、计算机网络知识、分布式系统知识等等。</p><h4 id="2、产品"><a href="#2、产品" class="headerlink" title="2、产品"></a>2、产品</h4><p>要对产品业务有深刻的理解，需要了解产品交互设计、产品数据统计、产品业务运营等。</p><h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><p>要了解一些管理知识，需要知道项目是怎么管理的 ，如何去协调多个人一起去完成一个项目。有一些项目需要具有很强的研究与创新方面的能力。</p><p>以上这些能力素质，是一个软件工程师需要具有的综合素质。要成为一个全部掌握这些素质系统工程师至少需要8~10年的时间。</p><p>所以，软件工程师绝对不是一个只会简单编写代码就可以的职业。<em><strong>软件工程师不等于码农。</strong></em></p><h3 id="1-4-正确认识代码实践方面的问题"><a href="#1-4-正确认识代码实践方面的问题" class="headerlink" title="1.4 正确认识代码实践方面的问题"></a>1.4 正确认识代码实践方面的问题</h3><h4 id="1-4-1-什么是好代码，好的代码有哪些标准"><a href="#1-4-1-什么是好代码，好的代码有哪些标准" class="headerlink" title="1.4.1 什么是好代码，好的代码有哪些标准"></a>1.4.1 什么是好代码，好的代码有哪些标准</h4><p><strong>好代码的标准是：</strong></p><p>①高效、②鲁棒、③简洁、④简短、⑤可共享、</p><p>⑥可测试、⑦可移植、⑧可监控、⑨可运维、⑩可扩展。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292130734.png"></p><blockquote><p>将以上十条标准进行总结精简，可以归纳为：</p><p>（1）代码的正确和性能；</p><p>（2）代码的可读和可维护性；</p><p>（3）代码的可运维和可运营；</p><p>（4）代码的可共享和可重用。</p></blockquote><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280007786.png"></p><p>了解完好代码的标准，接下来我们来看一下不好的代码主要表现在哪些方面：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280005709.png"></p><ol><li>不好的函数名</li></ol><p>​    比如，在函数名中，加my等单词，这属于很不专业的用法。</p><ol start="2"><li>不好的变量名</li></ol><p>​    比如，看不出任何含义的a,b,c,j,k,temp等变量名。</p><ol start="3"><li>没有注释或注释不清晰</li></ol><p>​    没有注释的代码是非常难读懂的。注释不清晰往往是因为文字功底或者描述能力欠缺，从而导致无法通过注释把代码的执行原理讲解清楚。</p><ol start="4"><li>一个函数执行多个功能</li></ol><p>​    比如LoadFromFileAndCalculate()函数，它既执行了文件中去加载数据，还执行了计算功能。像这样的函数，我们建议把它切分成两个单独的函数。</p><ol start="5"><li>不好的代码样式排版</li></ol><p>​    代码的样式排版在某种程度上体现了代码的一种逻辑。好的代码排版能增强代码的可读性和逻辑性。我们在写代码时，要规避不好的代码样式排版。</p><ol start="6"><li>难以测试的代码</li></ol><p>​    代码没法测试，难写测试用例，这些都是一些不好的表现。</p><h4 id="1-4-2-好的代码从哪里来"><a href="#1-4-2-好的代码从哪里来" class="headerlink" title="1.4.2 好的代码从哪里来"></a>1.4.2 好的代码从哪里来</h4><p>代码不只是“写”出来的。实际上，在整个项目中，真正的编码时间约占项目整体时间的10%。<em>好的代码是多个环节工作共同作用的结果。</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280009655.png"></p><p>这些环节包括：</p><blockquote><ol><li>在编码前，要进行需求分析和系统设计。</li><li>在编码过程中，要注意做单元测试。</li><li>在编码后，要做集成测试，要上线，要持续运营，要迭代改进。</li></ol></blockquote><p>一个好的系统或产品，是以上几个环节持续循环的结果。</p><p>接下来我们着重介绍一下重点环节——<em>需求分析和系统设计</em>。</p><p><strong>1. 认识需求分析和系统设计的重要性</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280011841.png"></p><p>需求分析和系统设计在软件开发中经常被忽略或轻视，但是这两点都是非常重要的环节。</p><p>人们的直觉往往是拿到一个项目就想尽快把它写出来并运行，感觉这样的路径是最快的。</p><p>但是实际上在软件前期需求分析和系统设计投入更多的成本，会在后期节省更多的消耗。即：<em>前期更多的投入，收益往往最大</em>。</p><p>原因是：如果我们开始的设计做错的话，那么后期开发、测试、上线、调试这些成本都会被浪费掉。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280010793.png"></p><p><strong>2. 清楚需求分析和系统设计的差别</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292126264.png"></p><p>需求分析和系统设计是有泾渭分明的区别的，为了避免这两者相互混杂，我们需要清楚需求分析和系统设计各自的内涵。</p><p><em>需求分析主要是定义系统或软件的黑盒行为，即：外部行为。</em>比如，系统从外部来看能够执行什么功能。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280011809.png"></p><p><em>系统设计主要是设计系统或软件的白盒机制。即：内部行为。</em>比如，系统从内部来看，是怎么做出来的，为什么这么做。</p><p><strong>3.  需求分析的注意要点</strong></p><p>要点一：清楚怎么用寥寥数语勾勒出一个系统的功能。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280012501.png"></p><p>每个系统都有自己的定位，我们可以从简洁的总体描述，展开到具体的需求描述。</p><blockquote><p>需求描述的内容基本包括：</p><ol><li><p>系统类型描述</p></li><li><p>系统规模描述</p></li><li><p>系统定位和系统差异描述</p></li><li><p>系统对外接口功能描述</p></li></ol></blockquote><p>要点二：需求分析需要用精确的数字来描述。</p><p>需求分析中会涉及大量的数据分析，这些分析都需要精确的数字来进行支撑。</p><p><strong>4. 系统设计的注意要点</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280014355.png"></p><p><strong>要点一、清楚什么是系统架构</strong></p><p><em>系统架构，英文名 System Architectrue。</em>在wiki上有一个英文定义阐述了系统架构是一个概念的模型，它定义了系统的结构、行为、更多的视图。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280017695.png"></p><p>进一步解读系统架构，它的几个要素是：</p><p>①系统要完成哪些功能</p><p>②系统如何组成</p><p>③功能在这些组成部分之间如何划分</p><p><strong>要点二、注意系统设计的约束</strong></p><p><em>重点是资源的限制。</em>比如，计算的资源限制，存储的资源限制，IO网络的资源限制等。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280018199.png"></p><p><strong>要点三、清楚需求是系统设计决策的来源</strong></p><p>精确定义需求中的各个细节，以及量的定义，对系统设计的决策起着重要的作用。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292130393.png"></p><p><strong>要点四、系统设计的风格与哲学</strong></p><p><em>在同样的需求下，可能出现不同的设计方式。</em>即目的相同，设计不同。比如：复杂指令集和精简指令集的设计差异。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292130655.png"></p><p>一个好的系统是<em>在合适假设下的精确平衡</em>。一个通用的系统在某些方面是不如专用系统的。每个系统每个组件的功能都应该足够的专一和单一。每个组件是指子系统或模块等。功能的单一是复用和扩展的基础。倘若不单一，未来就有可能很难进行复用和扩展。</p><p>子系统或模块之间的关系应该是<em>简单而清晰的</em>。软件中最复杂的是耦合，如果各系统之间的接口定义非常复杂，那么未来便很难控制系统的健康发展。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280019144.png"></p><p>值得注意的是，使用全局变量就是在增加系统的耦合，从而增加系统的复杂性，所以<em>在系统中需要减少使用全局变量。</em></p><p><strong>要点五、清楚接口的重要性</strong></p><p><em>接口，英文名Interface。</em>系统对外的接口比系统实现本身还要更加重要，接口的设计开发不容忽视。</p><p><strong>接口主要包括：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280019599.png"></p><p><strong>接口重要的原因在于：</strong></p><p>①接口定义了功能。如果定义的功能不正确，那么系统的可用性与价值便会大打折扣。</p><p>②接口决定了系统和系统外部之间的关系。相对于内部而言，外部关系确定后非常难以修改。</p><p>接口的修改需要非常慎重且要考虑周全。</p><p><strong>后期接口修改时主要注意两点：</strong></p><ol><li>合理好用。新改的接口应该是非常合理好用的。不能使调度方感觉我们做的接口非常难以使用。</li><li>修改时需要向前兼容。新改的接口应该尽量实现前项的兼容。不能出现当新接口上线时其他程序无法使用的情况。</li></ol><h4 id="1-4-3-如何写好代码"><a href="#1-4-3-如何写好代码" class="headerlink" title="1.4.3 如何写好代码"></a>1.4.3 如何写好代码</h4><h5 id="1-代码也是一种表达方式"><a href="#1-代码也是一种表达方式" class="headerlink" title="1 代码也是一种表达方式"></a>1 代码也是一种表达方式</h5><p>在一个项目中，软件的维护成本远远高于开发成本，而且超过50%的项目时间都是用于沟通。</p><p>常规意义的沟通方式主要有面对面交流、Email、文档或网络电话会议等。但是其实 <em>代码也是一种沟通方式</em>。</p><p>在计算机早期，我们使用机器语言或汇编语言，更多的是考虑代码如何更高效率地执行。</p><p>然而，随着技术的进步，代码编译器的逐渐完善，我们写代码时更多的是要考虑如何让其他人看得懂、看得清楚。于是，<strong><em>编程规范应运而生</em>。</strong></p><p><strong>编程规范主要包含：</strong></p><ol><li>如何规范的表达代码。 </li><li>语言使用的相关注意事项。</li></ol><p><strong>基于编程规范，看代码的理想场景是：</strong></p><ol><li>看别人的代码，感觉和看自己的代码一样。</li><li>看代码时能够专注于逻辑，而不是格式方面。</li><li>看代码时不用想太多。</li></ol><h5 id="2-代码书写过程中的细节问题"><a href="#2-代码书写过程中的细节问题" class="headerlink" title="2 代码书写过程中的细节问题"></a>2 代码书写过程中的细节问题</h5><h6 id="1-关于模块"><a href="#1-关于模块" class="headerlink" title="1. 关于模块"></a>1. 关于模块</h6><p><strong>模块，是程序的基本组成单位</strong>。在一个模块内，会涉及它的数据、函数或类。对于Python、Go、C语言这样的程序来说，一个后缀名为.py 、 .c或.go的文件就是一个模块。</p><p>每一个模块需要有明确的功能。需要符合<em><strong>紧内聚，松耦合</strong></em>。模块切分的是否合理对于软件架构的稳定起着至关重要的左右。</p><p>切分模块的方法：</p><p>先区分数据类的模块和过程类的模块。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280041920.png"></p><p><strong>数据类的模块：</strong>主要是要完成<em><strong>对数据的封装</strong></em>。封装往往是通过模块内部变量或类的内部变量来实现的。</p><p><strong>过程类的模块：</strong>本身不含数据。过程类模块可以<em><strong>从文件中去读取一个数据</strong></em>，或者执行一些相关的操作。过程类模块可以调用其他数据类模块或过程类模块。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292131236.png"></p><p>编写程序时，我们需要注意减少模块间的耦合。<em><strong>减少模块间的耦合，有利于降低软件复杂性，明确接口关系</strong>。</em></p><h6 id="2-关于类和函数"><a href="#2-关于类和函数" class="headerlink" title="2. 关于类和函数"></a>2. 关于类和函数</h6><p>类和函数是两种不同的类型，有他们各自适用的范围。另外，遇见和类的成员变量无关的函数时，可以将该函数抽出来，作为一个独立的函数使用，这样便于未来的复用。</p><h6 id="3-关于面向对象"><a href="#3-关于面向对象" class="headerlink" title="3. 关于面向对象"></a>3. 关于面向对象</h6><p>面向对象，是一个优秀的编程方法和范式，但是真正理解的人并不多。</p><p>面向对象的<em><strong>本质是数据封装</strong></em>。这就要求我们在写程序的过程中应该<em><strong>从数据的角度开始想问题</strong></em>，而不是从执行过程的角度开始想问题。</p><p>我们需要注意一个普遍的错误认知，即：C语言是面向过程的，C++是面向对象的。</p><p>实际上，<strong><em>C语言是基于对象的，它和C++的区别主要是没有多态和继承</em>。</strong></p><p>C++是一个经常被滥用的语言。因为C++有太强的功能。</p><p>作为软件工程师，我们最重要的任务是去实现出我们所需要的功能，语言只是我们的工具。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280052593.png"></p><p>另外，在系统中，我们应该<em><strong>谨慎地使用多态和继承</strong></em>。如果一个系统中，类的继承超过三层，那么这个系统的复杂度便很难把握。</p><p>有这样一个悖论：很好的继承模型是基于对需求的准确把握，而在我们在初始设计阶段往往对需求理解的不透彻。系统在初始阶段可能只是一个很简单的原型，然后通过不断地迭代完善，才逐步发展起来变好的。</p><h6 id="4-关于模块内部的组成"><a href="#4-关于模块内部的组成" class="headerlink" title="4. 关于模块内部的组成"></a>4. 关于模块内部的组成</h6><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280051076.png"></p><p>一个模块，比如.py、.c或.go这样一个模块，它的内部组成主要是：在文件头中，需要对模块的功能进行简要说明。需要把文件的修改历史写清楚，包括修改时间、修改人和修改内容。在模块内，内容的顺序尽量保持一致，以方便未来对内容的搜索查询。</p><h6 id="5-关于函数"><a href="#5-关于函数" class="headerlink" title="5. 关于函数"></a>5. 关于函数</h6><p>函数的切分同样是非常重要的。对于一个函数来说，要有明确的单一功能。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280051088.png"></p><p>函数描述三要素包括<em><strong>功能、传入参数和返回值</strong></em>。</p><ol><li>功能描述是指描述这个函数是做什么的、实现了哪些功能。</li><li> 传入参数描述是指描述这个函数中传入参数的含义和限制条件。</li><li>返回值描述是指描述这个函数中返回值都有哪些可能性。</li></ol><p><em><strong>函数的规模要足够的短小</strong></em>，这是写好程序的秘诀之一。bug往往出现在那些非常长的函数里。</p><p>在函数头中，需要对函数的语义做出清晰和准确的说明。我们需要<em><strong>注意函数的返回值</strong></em>。在写函数时，要判断函数的语义，确定返回值的类型。</p><p><strong>基于函数的语义，函数的返回值有三种类型。</strong></p><p><em><strong>第一种类型</strong></em>：在“逻辑判断型”函数中，返回布尔类型的值——True或False，表示“真”或“假”。</p><p><em><strong>第二种类型</strong>：</em>在“操作型”函数中，作为一个动作，返回成功或失败的结果——SUCCESS或ERROR。</p><p><em><strong>第三种类型</strong>：</em>在“获取数据型”函数中，返回一个“数据”，或者返回“无数据/获取数据失败”。</p><p><em><strong>以“单入口、单出口”的方式书写</strong></em>的方式能够比较清晰地反映出函数的逻辑。尤其是在实现多线程的数据表中，推荐使用一个内部函数来实现“单入口单出口”的方式。</p><h6 id="6-关于代码注释"><a href="#6-关于代码注释" class="headerlink" title="6. 关于代码注释"></a>6. 关于代码注释</h6><p>要重视注释，书写注释要做到清晰明确。在编写程序的过程中，<strong><em>先写注释，后写代码</em>。</strong></p><h6 id="7-关于代码块"><a href="#7-关于代码块" class="headerlink" title="7. 关于代码块"></a>7. 关于代码块</h6><p>代码块的讨论范围是在一个函数内的代码实现。书写代码块的思路是<em><strong>先把代码中的段落分清楚</strong></em>。文章有段落，代码同样有段落。代码的段落背后表达的是我们对于代码的逻辑理解。包括<em><strong>代码的层次、段落划分、逻辑</strong></em>。代码中的空行或空格是帮助我们表达代码逻辑的，并非可有可无。好的代码可以使人在观看时做过一眼明了。</p><h6 id="8-关于命名"><a href="#8-关于命名" class="headerlink" title="8. 关于命名"></a>8. 关于命名</h6><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280053731.png"></p><p>命名包括系统命名、子系统命名、模块命名、函数命名、变量命名、常量命名等。</p><p>我们要清楚命名的重要性。<strong>命名重要的主要原因为：</strong></p><p>一是“望名生义”是人的自然反应。不准确的命名会使人产生误导。</p><p>二是概念是建立模型的出发点。好的命名是系统设计的基础。</p><p>命名中普遍存在的问题有：</p><p>一是名字中不携带任何信息。</p><p>二是名字携带的信息是错误的。</p><p>命名<strong><em>关系着代码的可读性</em>，</strong>需要仔细思考。<em><strong>命名的基本要求是准确、易懂。</strong></em>提高代码命名可读性的方式之一是：<em><strong>在名字的格式中加入下划线、驼峰等。</strong></em></p><h6 id="9-关于系统的运营"><a href="#9-关于系统的运营" class="headerlink" title="9. 关于系统的运营"></a>9. 关于系统的运营</h6><p>在互联网时代，系统非常依赖运营。并不是我们把代码写完调试通了就可以。</p><p>在系统运营过程中，<strong><em>代码的可监测性非常重要</em>。</strong>很多程序都是通过线上的不断运行、不断监测、不断优化而迭代完善的，所以我们在编写代码的过程中，要注意尽可能多地暴露出可监控接口。</p><p>对于一个系统来说，<strong><em>数据和功能同等重要</em>。</strong></p><p>数据收集很重要，数据量够大才能知道这个项目或这个系统的具体收益。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280056080.png"></p><p>关于系统的运营，我们在设计和编码阶段就需要考虑。即：在设计和编码阶段，提供足够的状态记录，提供方便的对外接口。</p><h3 id="1-5-怎样修炼成为优秀的软件工程师"><a href="#1-5-怎样修炼成为优秀的软件工程师" class="headerlink" title="1.5 怎样修炼成为优秀的软件工程师"></a>1.5 怎样修炼成为优秀的软件工程师</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280057161.png"></p><p>通常人们在判断一名软件工程师的水平时，都会用工作时间、代码量、学历、曾就职的公司等等这类外部因素作为评判标准。</p><p>修炼成为优秀的软件工程师，<strong>重要的因素有三点：</strong></p><ol><li>学习-思考-实践</li><li>知识-方法-精神</li><li>基础知识是根本</li></ol><h4 id="1-5-1-学习-思考-实践"><a href="#1-5-1-学习-思考-实践" class="headerlink" title="1.5.1 学习-思考-实践"></a>1.5.1 <strong>学习-思考-实践</strong></h4><h5 id="（1）多学习"><a href="#（1）多学习" class="headerlink" title="（1）多学习"></a><strong>（1）多学习</strong></h5><p>软件编写的历史已经超过半个世纪，有太多的经验可以借鉴学习。要不断的学习进步。</p><h5 id="（2）多思考"><a href="#（2）多思考" class="headerlink" title="（2）多思考"></a><strong>（2）多思考</strong></h5><p>学而不思则罔，思而不学则殆。对于做过的项目要去深入思考，复盘写心得。</p><h5 id="（3）多实践"><a href="#（3）多实践" class="headerlink" title="（3）多实践"></a><strong>（3）多实践</strong></h5><p>要做到知行合一，我们大部分的心得和成长其实是来自于实践中的经历。在学习和思考的基础之上，要多做项目，把学到的理论运用到真正的工作中。</p><h4 id="1-5-2-知识-方法-精神"><a href="#1-5-2-知识-方法-精神" class="headerlink" title="1.5.2 知识-方法-精神"></a>1.5.2 知识-方法-精神</h4><p>互联网的发展日新月异，对于软件开发来说，知识永远在增加，所以在变化快速的知识世界中，<strong><em>最好的方式是找到方法</em>。</strong></p><p>方法就是用来分析问题和解决问题的。虽然说起来简单，但是适合每个人的方法都需要自己去寻找和总结。</p><p>在大多数人的成长过程中，并不单单只是鲜花和掌声，更多的时候是在和困难荆棘做斗争。而真正能做出成就的人，都有着远大理想和宏伟志向。所以，光有知识和方法往往是不够的，还需要有精神作为支撑。</p><p>几个精神理念：</p><ol><li><strong>自由精神、独立思想。</strong></li></ol><p>人一定要有自己的思考。不要人云亦云，不要随波逐流。</p><ol start="2"><li><strong>对完美的不懈追求。</strong></li></ol><p>不要做到一定程度就满意了，而是要去不断的追求一个更好的结果。</p><h4 id="1-5-3-基础知识是根本"><a href="#1-5-3-基础知识是根本" class="headerlink" title="1.5.3 基础知识是根本"></a>1.5.3 基础知识是根本</h4><p>唐朝著名宰相魏征曾经对唐太宗说过：“求木之长者，必固其根本；欲流之远者，必浚其泉源”，充分表达了基础乃治学之根本。</p><p>对于一个软件工程师来说，需要掌握的基础是非常全面的。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280058449.png"></p><p>包括数据结构、算法、操作系统、系统结构、计算机网络。包括软件工程、编程思想。包括逻辑思维能力、归纳总结能力、表达能力。还包括研究能力、分析问题、解决问题的能力等。这些基础的建立，至少也要5~8年的时间。</p><h2 id="2-Mini-Spider实践"><a href="#2-Mini-Spider实践" class="headerlink" title="2 Mini-Spider实践"></a>2 Mini-Spider实践</h2><h3 id="2-1-多线程编程"><a href="#2-1-多线程编程" class="headerlink" title="2.1 多线程编程"></a>2.1 多线程编程</h3><h4 id="2-1-1-数据互斥访问"><a href="#2-1-1-数据互斥访问" class="headerlink" title="2.1.1 数据互斥访问"></a>2.1.1 数据互斥访问</h4><p>多线程中数据互斥访问的情况非常常见，在真实生产的环境中，经常有开发人员会将一张表的“添加”和“判断是否存在”分为两个接口，这是一种非常常见的错误。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281424954.png"></p><p>以图中的代码为例，左边的代码是正确的写法，<strong>将添加和判断写进一个函数中</strong>。右边的代码是典型的错误代码，编写了两个函数，分别是添加和判断函数。</p><p>事实上，这种将添加和判断写进一个函数并且运行的实现机制是同8086的底层指令集支持密不可分的。</p><h4 id="2-1-2-临界区的注意事项"><a href="#2-1-2-临界区的注意事项" class="headerlink" title="2.1.2 临界区的注意事项"></a>2.1.2 临界区的注意事项</h4><p>在代码中，<strong>有锁来保护的区域被称为临界区</strong>。以图中代码为例，临界区为self.lock.acquire()和self.lock.release()两句话之间的区域。在使用临界区的时候要注意，不要把耗费时间的操作放在临界区内执行。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281429165.png"></p><p>很多开发人员在编写多线程的时候会将耗费时间很多的逻辑放入临界区内，这样会导致无法发挥多线程对于硬件资源最大化利用的优势。</p><h4 id="2-1-3-I-O操作的处理"><a href="#2-1-3-I-O操作的处理" class="headerlink" title="2.1.3 I/O操作的处理"></a>2.1.3 I/O操作的处理</h4><p>在多线程编程中还要注意对于I/O操作的处理。首先在编写代码的时候要注意不能出现无捕捉的exception，以图中最左边的代码为例，如果不对异常进行捕捉，那么一旦出现问题就不会执行self.lock.release()语句，进而导致死锁的发生。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281444010.png"></p><p>其次，因为异常处理是非常消耗资源的，所以我们也不能像图中中间的代码一样，将异常放在临界区内，要像最右边的代码一样处理。</p><h3 id="2-2-细节处理"><a href="#2-2-细节处理" class="headerlink" title="2.2 细节处理"></a>2.2 细节处理</h3><h4 id="2-2-1-种子信息的读取"><a href="#2-2-1-种子信息的读取" class="headerlink" title="2.2.1 种子信息的读取"></a>2.2.1 种子信息的读取</h4><p>很多开发人员会将种子信息读取的逻辑和其他逻辑耦合在一起，这样是错误的。以图中代码为例，虽然通过_get_seeds函数直接读取文件中的信息并没有书写错误，但是如果后续的开发中文件的格式发生了变化，那就需要重新回来修改这部分的代码。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281445680.png"></p><p>通过上述代码可以发现，模块划分和逻辑的复杂程度是没有关系的。即使是逻辑简单的代码，如果没有做好模块划分，也会变得难于维护。</p><h4 id="2-2-2-程序优雅退出"><a href="#2-2-2-程序优雅退出" class="headerlink" title="2.2.2 程序优雅退出"></a>2.2.2 程序优雅退出</h4><p>在真实应用中，很多开发人员在实现程序退出功能的时候使用了非常复杂的机制，导致后期维护难度较高。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281446653.png"></p><p>在实际应用中可以使用python系统库中关于队列的task_done()和join()的机制。</p><p>以图中代码为例，左边的代码就是使用了task_done()，中间的代码是主程序中的一种常规逻辑使用。右边是对中间主程序的一种优化，增加了spider.wait()，让整个逻辑可读性更强，更容易被理解。</p><h4 id="2-2-3-爬虫的主逻辑编码"><a href="#2-2-3-爬虫的主逻辑编码" class="headerlink" title="2.2.3 爬虫的主逻辑编码"></a>2.2.3 爬虫的主逻辑编码</h4><p>很多开发人员编写的主逻辑非常的复杂且难懂。事实上，图中的代码就是一个爬虫的主逻辑的所有代码。可以看到，里面包含了六个步骤。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281448571.png"></p><p>第一步，从队列中拿到任务。</p><p>第二步，读取内容。如果读取失败，则重新读取。如果读取成功，则执行第三步。</p><p>第三步，存储数据。</p><p>第四步，检查数据深度。</p><p>第五步，如果数据深度不足，就进一步解析，并且放到队列中。</p><p>第六步，结束任务。</p><h2 id="3-代码检查规则背景及总体介绍"><a href="#3-代码检查规则背景及总体介绍" class="headerlink" title="3 代码检查规则背景及总体介绍"></a>3 代码检查规则背景及总体介绍</h2><h3 id="3-1-代码检查的意义"><a href="#3-1-代码检查的意义" class="headerlink" title="3.1 代码检查的意义"></a>3.1 代码检查的意义</h3><ol><li>提高代码可读性，统一规范，方便他人维护，长远来看符合公司内部开源战略。</li><li>帮助发现代码缺陷，弥补人工代码评审的疏漏，节省代码评审的时间与成本。</li><li>有助于提前发现问题，节约时间成本，降低缺陷修复成本。</li><li>促进公司编码规范的落地，在规范制定后借助工具进行准入检查。</li><li>提升编码规范的可运营性，针对反馈较多的不合理规范进行调整更新。</li></ol><h3 id="3-2-代码检查场景及工具"><a href="#3-2-代码检查场景及工具" class="headerlink" title="3.2 代码检查场景及工具"></a>3.2 代码检查场景及工具</h3><h4 id="3-2-1-代码检查场景"><a href="#3-2-1-代码检查场景" class="headerlink" title="3.2.1 代码检查场景"></a>3.2.1 代码检查场景</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281541973.png"></p><p>首先是<strong>本地研发环节</strong>，借助客户端工具，在push发起评审之前进行检查。</p><p>若本地代码扫描没有出现问题，就进入第二个环节：<strong>代码准入环节，即Code Review</strong>，这一环节进行增量检查，属于公司强制要求。</p><p>第三个环节：<strong>持续集成环节</strong>，当代码合入到代码库之后，进行全量检查，业务线根据自身需求来配置。</p><h4 id="3-2-2-代码检查工具与服务"><a href="#3-2-2-代码检查工具与服务" class="headerlink" title="3.2.2 代码检查工具与服务"></a>3.2.2 代码检查工具与服务</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281543538.png"></p><p>代码检查的产品，客户端、SCM(icode)、CI(Agile)之间具有交互性，共同构成整个代码检查环节。</p><h4 id="3-2-3-代码检查覆盖范围"><a href="#3-2-3-代码检查覆盖范围" class="headerlink" title="3.2.3 代码检查覆盖范围"></a>3.2.3 代码检查覆盖范围</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281544909.png"></p><p>在<strong>覆盖语言</strong>方面，代码检查目前已经覆盖了包括C++，Java/android, PHP, Python, Go, JS, OC, Kotlin在内的几乎所有主流语言。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281544915.png"></p><p>在<strong>检查维度</strong>方面，代码检查包括编码规范 代码缺陷，开源框架引用安全检查，可维护性(MI)。</p><h4 id="3-2-4-代码检查速度"><a href="#3-2-4-代码检查速度" class="headerlink" title="3.2.4 代码检查速度"></a>3.2.4 代码检查速度</h4><p>编码规范：只扫描变更文件，检查代码变更行是否符合规范，速度较快。</p><p>缺陷检查：需考虑文件依赖、函数调用关系、代码上下文等，相对耗时。</p><h3 id="3-3-代码检查规则分级"><a href="#3-3-代码检查规则分级" class="headerlink" title="3.3 代码检查规则分级"></a>3.3 代码检查规则分级</h3><h4 id="3-3-1-规则等级梳理"><a href="#3-3-1-规则等级梳理" class="headerlink" title="3.3.1 规则等级梳理"></a>3.3.1 规则等级梳理</h4><p>Code Review阶段，所有维度扫描出的问题可以分为以下3个等级：</p><ol><li><p>Error：属于需要强制解决的类型，影响代码合入，应视具体情况不同采取修复、临时豁免、标记误报等措施及时处理；</p></li><li><p>Warning：非强制解决类型，不影响代码含入，很可能存在风险，应尽量修复；</p></li><li><p>Advice：非强制解决类型，级别相对较低，不影响代码含入，可以选择性修复。</p></li></ol><h4 id="3-3-2-机检任务统一"><a href="#3-3-2-机检任务统一" class="headerlink" title="3.3.2 机检任务统一"></a>3.3.2 机检任务统一</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281548620.png"></p><h4 id="3-3-3-评审页行间提示"><a href="#3-3-3-评审页行间提示" class="headerlink" title="3.3.3 评审页行间提示"></a>3.3.3 评审页行间提示</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281550018.png"></p><h4 id="3-3-4-针对豁免、误报、咨询的说明"><a href="#3-3-4-针对豁免、误报、咨询的说明" class="headerlink" title="3.3.4 针对豁免、误报、咨询的说明"></a>3.3.4 针对豁免、误报、咨询的说明</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281550799.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281550899.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281550116.png"></p><h2 id="4-代码检查规则：Python语言案例详解"><a href="#4-代码检查规则：Python语言案例详解" class="headerlink" title="4 代码检查规则：Python语言案例详解"></a>4 代码检查规则：Python语言案例详解</h2><h3 id="4-1-Python的代码检查规则"><a href="#4-1-Python的代码检查规则" class="headerlink" title="4.1 Python的代码检查规则"></a>4.1 Python的代码检查规则</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281552034.png"></p><p>Python代码检查规则主要分为四个大类，分别是<strong>代码风格规范、引用规范、定义规范和异常处理规范</strong>。</p><h4 id="4-1-1-代码风格规范"><a href="#4-1-1-代码风格规范" class="headerlink" title="4.1.1 代码风格规范"></a>4.1.1 代码风格规范</h4><h5 id="（1）程序规模规范："><a href="#（1）程序规模规范：" class="headerlink" title="（1）程序规模规范："></a><strong>（1）程序规模规范：</strong></h5><ol><li><p>每行不得超过 120 个字符。</p></li><li><p>定义的函数长度不得超过 120 行。</p></li></ol><p>这意味着，在编写代码时，需要时刻注意自己的程序规模，避免冗余，确保写出简洁而高效的代码。</p><h5 id="（2）语句规范"><a href="#（2）语句规范" class="headerlink" title="（2）语句规范"></a><strong>（2）语句规范</strong></h5><p>因为Python与其他语言不同，可以不需要明确的标识符表示语句的结尾，所以规定：</p><ol start="3"><li><p>禁止以分号结束语句。</p></li><li><p>在任何情况下，一行只能写一条语句。</p></li></ol><h5 id="（3）括号使用规范"><a href="#（3）括号使用规范" class="headerlink" title="（3）括号使用规范"></a><strong>（3）括号使用规范</strong></h5><ol start="5"><li>除非用于明确算术表达式优先级、元组或者隐式行连接，否则尽量避免冗余的括号。</li></ol><h5 id="（4）缩进规范"><a href="#（4）缩进规范" class="headerlink" title="（4）缩进规范"></a><strong>（4）缩进规范</strong></h5><ol start="6"><li>禁止使用Tab进行缩进，而统一使用4个空格进行缩进</li></ol><p>需要将单行内容拆成多行写时规定：</p><ol start="7"><li>与首行保持对齐；或者首行留空，从第二行起统一缩进4个空格。</li></ol><h5 id="（5）空行规范"><a href="#（5）空行规范" class="headerlink" title="（5）空行规范"></a><strong>（5）空行规范</strong></h5><ol start="8"><li>文件级定义（类或全局函数）之间，相隔两个空行；类方法之间，相隔一个空行。</li></ol><h5 id="（6）空格规范"><a href="#（6）空格规范" class="headerlink" title="（6）空格规范"></a><strong>（6）空格规范</strong></h5><ol start="9"><li><p>括号之内均不添加空格。</p></li><li><p>参数列表、索引或切片的左括号前不应加空格。</p></li><li><p>逗号、分号、冒号之前均不添加空格，而是在它们之后添加一个空格。</p></li><li><p>所有二元运算符前后各加一个空格。</p></li><li><p>关键字参数或参数默认值的等号前后不加空格。</p></li></ol><h5 id="（7）注释规范"><a href="#（7）注释规范" class="headerlink" title="（7）注释规范"></a><strong>（7）注释规范</strong></h5><ol start="14"><li>每个文件都必须有文件声明，每个文件声明至少必须包括以下三个方面的信息：版权声明、功能和用途介绍、修改人及联系方式。</li></ol><p>另外在使用文档字符串（docstirng）进行注释时，规定：</p><ol start="15"><li><p>使用docstring描述模块、函数、类和类方法接口时，docstring必须用三个双引号括起来。</p></li><li><p>对外接口部分必须使用docstring描述，内部接口视情况自行决定是否写docstring。</p></li><li><p>接口的docstring描述内容至少包括以下三个方面的信息：功能简介、参数、返回值。如果可能抛出异常，必须特别注明。</p></li></ol><h4 id="4-1-2-引用规范"><a href="#4-1-2-引用规范" class="headerlink" title="4.1.2 引用规范"></a>4.1.2 引用规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281600533.png"></p><p><strong>严格而具体的规定：</strong></p><ol><li>禁止使用 from……import…… 句式直接导入类或函数，而应在导入库后再行调用。</li><li>每行只导入一个库。</li><li>按标准库、第三方库、应用程序自有库的顺序排列import，三个部分之间分别留一个空行。</li></ol><h4 id="4-1-3-定义规范"><a href="#4-1-3-定义规范" class="headerlink" title="4.1.3 定义规范"></a>4.1.3 定义规范</h4><p><strong>（1）在变量定义方面，我们有强制的规范规定：</strong></p><ol><li>局部变量使用全小写字母，单词间使用下划线分隔。</li><li>定义的全局变量必须写在文件头部。</li><li>常量使用全大写字母，单词间使用下划线分隔</li></ol><p><strong>（2）函数的定义规范主要体现在函数的返回值以及默认参数的定义上。</strong></p><p>为提高代码可读性，对于函数的返回值，规范要求为：</p><ol><li>函数返回值必须小于或等于3个。若返回值大于3个，则必须通过各种具名的形式进行包装。</li></ol><p>为了保障函数的运行效率以及降低后期维护和纠错的成本，对于函数默认参数的定义有如下要求：</p><ol start="2"><li>仅可使用以下基本类型的常量或字面常量作为默认参数：整数、bool、浮点数、字符串、None。</li></ol><p><strong>（3）类定义的规范包括了四个方面的内容：</strong></p><ol><li>类的命名使用首字母大写的驼峰式命名法。</li><li>对于类定义的成员：protected成员使用单下划线前缀；private成员使用双下划线前缀。</li><li>如果一个类没有基类，必须继承自object类。</li><li>类构造函数应尽量简单，不能包含可能失败或过于复杂的操作。</li></ol><h4 id="4-1-4-异常处理规范"><a href="#4-1-4-异常处理规范" class="headerlink" title="4.1.4 异常处理规范"></a>4.1.4 异常处理规范</h4><p>在代码编写中应该<strong>尽量避免出现代码异常状态</strong>，然而错误有时在所难免，对于这些异常状态的处理，有着明确的规范要求：</p><ol><li>禁止使用双参数形式或字符串形式的语法抛出异常。</li><li>如需自定义异常，应在模块内定义名为 Error 的异常基类。并且，该基类必须继承自 Exception 。其他异常均由该基类派生而来。</li><li>除非重新抛出异常，禁止使用 except：语句捕获所有异常， 一般情况下，应使except……：语句捕获具体的异常。</li><li>捕捉异常时，应当使用 as 语法，禁止使用逗号语法。</li></ol><h3 id="4-2-Python编码惯例"><a href="#4-2-Python编码惯例" class="headerlink" title="4.2 Python编码惯例"></a>4.2 Python编码惯例</h3><h4 id="4-2-1-让模块既可被导入又可被执行"><a href="#4-2-1-让模块既可被导入又可被执行" class="headerlink" title="4.2.1 让模块既可被导入又可被执行"></a>4.2.1 让模块既可被导入又可被执行</h4><p>python不同于编译型语言，而<strong>属于脚本语言</strong>，是动态的逐行解释运行，没有统一的程序入口。所以，为了方便模块之间的相互导入，我们通常<strong>自定义一个 main 函数，并使用一个if 语句</strong>， if 内置变量 <strong>name</strong> == ‘__main__’ ，在这个if 条件下，再去执行 main函数。这样，我们就能够实现，让模块既可被导入又可执行。</p><h4 id="4-2-2-in运算符的使用"><a href="#4-2-2-in运算符的使用" class="headerlink" title="4.2.2 in运算符的使用"></a>4.2.2 in运算符的使用</h4><p>in一种简洁而高效的运算符，很多时候，合理的使用in运算符，可以<strong>代替大量的重复判断过程</strong>，降低时间复杂度，提高代码的运行效率。</p><h4 id="4-2-3-不使用临时变量交换两个值"><a href="#4-2-3-不使用临时变量交换两个值" class="headerlink" title="4.2.3 不使用临时变量交换两个值"></a>4.2.3 不使用临时变量交换两个值</h4><p>Python有更简洁而高效的语句可以实现交换两个值的操作，并<strong>无必要引入临时变量</strong>来交换两个值。</p><h4 id="4-2-4-用序列构建字符串"><a href="#4-2-4-用序列构建字符串" class="headerlink" title="4.2.4 用序列构建字符串"></a>4.2.4 用序列构建字符串</h4><p>对于一个字符串列表、元组等，可以用序列来构建字符串，<strong>利用一个空字符串和join函数</strong>，就可以避免重复，高效完成相应字符串的构建。</p><h1 id="三、百度高效研发实战训练营Step3"><a href="#三、百度高效研发实战训练营Step3" class="headerlink" title="三、百度高效研发实战训练营Step3"></a>三、百度高效研发实战训练营Step3</h1><h2 id="1-质量意识"><a href="#1-质量意识" class="headerlink" title="1 质量意识"></a>1 质量意识</h2><h3 id="1-1-质量的基本概念"><a href="#1-1-质量的基本概念" class="headerlink" title="1.1 质量的基本概念"></a>1.1 质量的基本概念</h3><h4 id="1-1-1-质量重要性的认识"><a href="#1-1-1-质量重要性的认识" class="headerlink" title="1.1.1 质量重要性的认识"></a>1.1.1 质量重要性的认识</h4><p>随着技术更新，市场竞争的加剧，质量问题成为困扰不少企业的一大难题，也给一些企业造成了巨大的损失，这就使得项目质量的重要性不断凸显。</p><p>通过对于这些失败案例的分析不难发现，项目的质量保证是一个需要<strong>项目全体成员参与</strong>的重要工作，只有在项目团队的共同努力下，才能有效保证项目的质量，为企业和社会创造价值。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281614025.png"></p><p>项目管理三要素为<strong>质量、时间、成本</strong>，三个要素缺一不可、相互制约，一味追求某一要素的做法是不明智的。一个成功的项目必然是在三者的取舍间达成了一个平衡。</p><h4 id="1-1-2-质量保证和测试的关系"><a href="#1-1-2-质量保证和测试的关系" class="headerlink" title="1.1.2 质量保证和测试的关系"></a>1.1.2 质量保证和测试的关系</h4><p>质量问题有很多种，常见的有代码缺陷、产品缺陷、Bug、用户体验差、性能差、服务不稳、安全问题、可兼容性差等。我们经常通过测试来发现问题，并将发现的问题分<strong>功能性测试类问题和用户体验评估类问题。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281615870.png"></p><p>测试工作是质量保证工作中的重要一环，但是我们应该认识到，质量保证工作不能只依靠测试的反馈，而应该贯穿项目开发的整个过程。</p><h4 id="1-1-3-Bug的基本认识"><a href="#1-1-3-Bug的基本认识" class="headerlink" title="1.1.3 Bug的基本认识"></a>1.1.3 Bug的基本认识</h4><p><strong>Bug</strong>是程序中的缺陷和问题，<strong>属于功能性测试类问题的范畴</strong>， Bug是一种很常见的质量问题，也是我们在项目开发中应该尽量减少或避免的质量问题。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281617228.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281618840.png"></p><p>Bug的修复有一套完整的规定流程。</p><p>首先，测试人员或者用户发现Bug后，将其置为<strong>激活状态</strong>；开发人员收到激活状态的Bug后，对其进行修复，修复过程中， Bug状态为<strong>处理中</strong>；修复完成后，开发人员将其置为<strong>解决状态</strong>；测试人员再对其进行<strong>验证</strong>，若通过，则将其关闭，否则，重新激活Bug即重启状态，交予开发人员继续修复，直至验证通过。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292129042.png"></p><p>从这一流程可以看到，<strong>Bug有五种状态，Open（激活）、In Process（处理中）、Resolved（解决）、closed（关闭）、Reopen（重启）</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281621054.png"></p><p>Bug生命周期有一定规律性。以传统软件中的瀑布模型举例，85%的问题在项目初期的编码阶段引入，在后期测试阶段，发现Bug的数量会逐渐增多，与之对应的修复成本也会急剧增加。可见，降低<strong>修复成本最有效的方式，就是在Bug引入的阶段就及时发现并修复Bug。</strong></p><h3 id="1-2-Bug提交方法"><a href="#1-2-Bug提交方法" class="headerlink" title="1.2 Bug提交方法"></a>1.2 Bug提交方法</h3><blockquote><p>Bug提交需要反馈渠道，Bug的反馈渠道分为内部用户反馈渠道和外部用户反馈渠道两种。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281623796.png"></p><ol><li>内部用户反馈渠道包括：产品Icafe空间、产品论坛、Bugs邮件组、Bugs平台。</li><li>外部用户反馈渠道包括：产品自身反馈渠道和产品接入反馈平台。</li></ol></blockquote><p><strong>Bug的提交有严格的格式要求，提交的Bug反馈应包括以下七个方面的内容：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281624518.png"></p><p>正确提交Bug能确保负责人能够清晰了解问题，直接进行数据挖掘，找到Bug所有的属性，便于后续维护工作的开展。</p><h3 id="1-3-质量保证在项目各阶段的实现"><a href="#1-3-质量保证在项目各阶段的实现" class="headerlink" title="1.3 质量保证在项目各阶段的实现"></a>1.3 质量保证在项目各阶段的实现</h3><p>质量的保证不能仅仅依靠测试人员，而是需要贯穿项目的各个阶段。</p><p>Bug的发现和修复是项目质量保证的一个重要方面，但质量保证工作绝不仅仅是修复Bug这么简单。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281626934.png"></p><p>项目的开发整体路径包括：需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、上线阶段以及线上阶段。</p><p>在一个项目开发的各个不同阶段，质量保证工作的要求和思路均有一定的不同，下面我们来展现质量保证工作在各个阶段的具体实现。</p><h4 id="1-3-1-需求与设计阶段的质量保证工作"><a href="#1-3-1-需求与设计阶段的质量保证工作" class="headerlink" title="1.3.1 需求与设计阶段的质量保证工作"></a>1.3.1 需求与设计阶段的质量保证工作</h4><p>需求与设计阶段是项目开始的重要阶段，只有从客户真正的需求出发，才能设计出真正令客户满意的产品。</p><p>在一阶段，质量保证工作的关键点有三：</p><ol><li><p><strong>需求评审：</strong>站在用户的角度思考和挖掘需求，是设计和开发的前提性条件。</p></li><li><p><strong>需求的变更管理：</strong>用户的需求始终在改变，建立一套完善机制去及时适应需求的变更十分重要。</p></li><li><p><strong>设计评审：</strong>通过评审需求的可行性和设计的相关风险，可以极大降低设计风险，避免人力浪费。</p></li></ol><h4 id="1-3-2-开发与测试阶段的质量保证工作"><a href="#1-3-2-开发与测试阶段的质量保证工作" class="headerlink" title="1.3.2 开发与测试阶段的质量保证工作"></a>1.3.2 开发与测试阶段的质量保证工作</h4><p>在开发阶段，质量保证工作最重要的有两点：<strong>单元测试和代码评审。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281632782.png"></p><blockquote><p>单元测试的作用很多，主要有：</p><p>（1） 调试代码，确保代码实时可编译。</p><p>（2） 验证逻辑，减少代码中的Bug。</p><p>（3） 作为一个最细粒度回归测试，实时反馈代码的质量。</p></blockquote><blockquote><p>代码评审也同样十分重要，它的作用主要为：</p><p>（1） 保持代码风格的一致和可读性，利于贯彻编程规范。</p><p>（2） 提高代码质量，减少Bug。</p><p>（3） 促进互相交流学习，提升团队的整体研发能力，进而提高企业的整体竞争力。</p></blockquote><p>而在测试阶段，我们的主要任务是<strong>测试功能性测试类问题。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281632723.png"></p><blockquote><p>测试阶段一般流程为：</p><p>第一步：<strong>撰写测试方案</strong>。由测试人员编写方案并提交开发人员评审。</p><p>第二步：<strong>进行单元测试</strong>。由开发人员编写用例，并交给测试人员评审。</p><p>第三步：<strong>进行功能性测试</strong>。由测试人员设计和编写用例。</p><p>第四步：<strong>进行性能/压力等测试</strong>。测试人员根据项目情况决定是否进行。</p><p>第五步：<strong>自动化和持续集成</strong>。将测试自动化，并把流程加入持续集成。</p><p>第六步：<strong>撰写测试报告</strong>。测试人员要在大版本时编写测试报告。</p></blockquote><p>测试环节涉及很多的内容，包括了：</p><p>（1）测试方案。</p><p>（2）自动化/持续集成。</p><p>（3）测试报告。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281634364.png"></p><p>在这一环节中，<strong>撰写测试方案是对该阶段工作的整体规划。</strong>测试方案描绘了测试和质量保证的各种工作，规划了如何组织测试，方案中包括了：质量目标、风险评估、测试范围、测试优先级、测试方法、测试流程、测试计划和测试设计的内容。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281634848.png"></p><p><strong>常用的测试方法有</strong>：黑盒/白盒、静态测试/动态测试、自动化测试/手工测试、验收测试/α测试/β测试、单元测试/模块测试/集成测试/联调测试/系统测试、功能性测试/性能测试/压力测试/异常测试/安全测试、接口测试/用户场景测试、回归测试、探索性测试等。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281635604.png"></p><p>不同的测试方法有不同的特点和擅长解决的问题。测试的侧重点不同，发现的问题也不同。我们需要根据测试方案，来选择合适的测试方法，提高测试的效率。为此，在前期的测试和设计方案评审时要及早发现问题，避免无效劳动，提高测试效率。</p><p>同样，自动化和持续集成也是有效提高测试效率的方法。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281635791.png"></p><p><strong>自动化包括流程自动化和测试自动化。</strong>流程自动化包括编译、部署、发布、回滚、上线和测试阶段。测试自动化可以降低成本并保证测试结果，降低风险。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281636766.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281637773.png"></p><p>而基于自动化，我们可以搭建串联工作流，即持续集成，可以将代码提交、编译、模块测试、部署、系统测试、发布这一循环性流程集成在一起，从而提高工作效率，保证持续的质量反馈。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281637103.png"></p><p>测试完成后需要撰写详细的测试报告，以方便后期的持续维护和迭代，其内容包括：</p><p>测试结果、质量风险评估、质量评估、测试过程描述、缺陷分析、评估改进意见、测试版本/测试人员/测试时间。</p><h4 id="1-3-3-上线与线上阶段的质量保证工作"><a href="#1-3-3-上线与线上阶段的质量保证工作" class="headerlink" title="1.3.3 上线与线上阶段的质量保证工作"></a>1.3.3 上线与线上阶段的质量保证工作</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281638579.png" alt="image-20211128163800434"></p><p><strong>上线阶段包括上线过程和回滚过程。</strong></p><p>上线阶段的上线方案需要经过评审和测试，对于重点项目，还应有回滚方案和相应的评审和测试工作。</p><p>上线后，我们需要进行线上测试，常用的线上测试有三类：众包测试、用户反馈和业务监控、产品评测。</p><blockquote><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281641413.png"></p><p>（1）<strong>众包测试：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281642738.png">众包测试的目的是使更多的用户参与测试，降低测试成本。众测服务分为四类：测试类（包括探索性测试、用例组合爆炸测试），产品体验（包括产品建议、Badcase收集）、评估评测（包括大数据量评估标注、降低成本）、用户调研（产品需求调研、用户反馈)。一个众测平台：<a href="http://test.baidu.com/">http://test.baidu.com</a></p><p>（2）<strong>用户反馈和业务监控</strong>：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281642375.png">目的则是为了实现线上问题闭环，通过用户反馈和业务监控可以解决大部分的线上问题。步骤分为收集、分发、定位和解决。主要平台有反馈平台、Bugs平台和 Monitor平台。</p><p>（3）<strong>产品评测：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281643572.png"></p><p>包括用户反馈分析、产品Bug分析、Top问题梳理和竞品对比分析。</p><p>→ <strong>用户反馈分析</strong>是指对用户反馈的问题进行分析。→ 产品Bug分析是指对产品的Bug进行分析，然后解决问题最大的Bug。</p><p>→ <strong>Top问题梳理</strong>是指，对问题进行梳理分类，解决最突出的问题。</p><p>→ <strong>竞品对比分析</strong>是指对自家产品和市场上同类型产品进行分析。</p></blockquote><p>从对各个阶段质量保证工作的分析中，我们不难看出，每一个阶段的质量保证工作都需要多方角色的共同参与。可见，项目的出色质量来源于<strong>每个环节的严格把控和每个成员的共同参与，这是团队质量意识的两大核心。</strong></p><h3 id="1-4-质量保证意识的4个核心内容"><a href="#1-4-质量保证意识的4个核心内容" class="headerlink" title="1.4 质量保证意识的4个核心内容"></a>1.4 质量保证意识的4个核心内容</h3><h4 id="1-4-1-质量保证工作存在于每一个环节"><a href="#1-4-1-质量保证工作存在于每一个环节" class="headerlink" title="1.4.1 质量保证工作存在于每一个环节"></a>1.4.1 质量保证工作存在于每一个环节</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281647902.png"></p><h4 id="1-4-2-每一个成员都需要对质量负责"><a href="#1-4-2-每一个成员都需要对质量负责" class="headerlink" title="1.4.2 每一个成员都需要对质量负责"></a>1.4.2 每一个成员都需要对质量负责</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281647522.png"></p><h4 id="1-4-3-测试是一种核心的质量保证工作"><a href="#1-4-3-测试是一种核心的质量保证工作" class="headerlink" title="1.4.3 测试是一种核心的质量保证工作"></a>1.4.3 测试是一种核心的质量保证工作</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281646302.png"></p><h4 id="1-4-4-尽早发现问题，尽早解决问题"><a href="#1-4-4-尽早发现问题，尽早解决问题" class="headerlink" title="1.4.4 尽早发现问题，尽早解决问题"></a>1.4.4 尽早发现问题，尽早解决问题</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281647888.png"></p><h2 id="2-代码单元测试总体介绍"><a href="#2-代码单元测试总体介绍" class="headerlink" title="2 代码单元测试总体介绍"></a>2 代码单元测试总体介绍</h2><h3 id="2-1-单元测试基础"><a href="#2-1-单元测试基础" class="headerlink" title="2.1 单元测试基础"></a>2.1 单元测试基础</h3><h4 id="2-1-1-单元测试的误区"><a href="#2-1-1-单元测试的误区" class="headerlink" title="2.1.1 单元测试的误区"></a>2.1.1 单元测试的误区</h4><p>单元测试存在一些认识上的误区，包括：</p><ol><li>开发单元测试代码的工作量大。</li><li>做单元测试不属于开发人员的职责。</li><li>代码正确率高，进行单元测试必要性不大。</li><li>后期有集成测试，前期进行单元测试必要性不大。</li><li>单元测试无法带来显著收益，效率不高。</li></ol><h4 id="2-1-2-单元测试的概念"><a href="#2-1-2-单元测试的概念" class="headerlink" title="2.1.2 单元测试的概念"></a>2.1.2 单元测试的概念</h4><p><em><strong>在维基百科中，单元测试的定义为：一段代码调用另一段代码，随后检验一些假设的正确性。</strong></em></p><p><em><strong>在百度百科中，单元测试是指对软件中的最小可测试单元进行检查和验证。</strong></em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281653449.png"></p><p>那么我们不禁要问：一次编写的单元测试是否只是为了验证该次开发过程中对应的代码逻辑的正确性？</p><p>其实不然，单元测试不仅在于实现问题中的功能，优秀的单元测试作用长久，可以减少后续工作的负担，从而提升整体生产力。</p><h4 id="2-1-3-常见的单元测试问题"><a href="#2-1-3-常见的单元测试问题" class="headerlink" title="2.1.3 常见的单元测试问题"></a>2.1.3 常见的单元测试问题</h4><p>目前单元测试中存在一些常见的问题：</p><ol><li>使用System.out输出测试结果，依赖人去判断测试是否正确。</li><li>不使用Assert(断言)对测试结果进行判断。</li></ol><p><em>在以上两种情形都需要依赖人与电脑的交互来判断此case是否成功，人的工作量较大；**在实际的单元测试中，应当使用断言进行判断，使 case运行时自动输出结果。</em></p><ol start="3"><li>没有边界检查。</li><li>多个测试分支放入一个单元测试方法中。</li></ol><p><em>这种情况会导致一旦出现运行失败时，难以判断出现错误的分支所在。</em></p><ol start="5"><li>测试case环境相关（依赖已知库表、时间）。</li></ol><p><em>对于这种情况，应当做出修改，使输入参数为确定的值。</em></p><ol start="6"><li>测试方法执行有先后顺序。</li></ol><p><em>在实际测试过程中，由于不同的用于运行单元测试的测试框架对于case执行顺序有自己的行为，故单元测试实际执行顺序存在不确定性。</em></p><h4 id="2-1-4-优秀的单元测试"><a href="#2-1-4-优秀的单元测试" class="headerlink" title="2.1.4 优秀的单元测试"></a>2.1.4 优秀的单元测试</h4><p>优秀的单元测试需要以下原则：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281655957.png"></p><ol><li>单元测试彼此之间应具备<strong>独立性</strong>。一个单元测试应独立于其它测试及运行它的环境。</li><li>一个优秀的单元测试是<strong>可重复</strong>的。它需要具备多次运行的能力，若不可重复，则不能算作优秀的单元测试。</li><li>优秀的单元测试<strong>可自动化</strong>。自动化具备双重含义：第一，单元测试<strong>可依赖于现有工具自动化运行</strong>；第二，单元测试执行成功与否<strong>可自动进行判断</strong>，而不依赖于人为判断。</li><li>优秀的单元测试是<strong>彻底的</strong>。单元测试对于被测试对象而言需要覆盖全部的分支。</li></ol><h3 id="2-2-单元测试的意义与建议"><a href="#2-2-单元测试的意义与建议" class="headerlink" title="2.2 单元测试的意义与建议"></a>2.2 单元测试的意义与建议</h3><h4 id="2-2-1-什么情况下做单元测试"><a href="#2-2-1-什么情况下做单元测试" class="headerlink" title="2.2.1 什么情况下做单元测试"></a>2.2.1 什么情况下做单元测试</h4><p><strong>（1）单元测试的好处</strong></p><p>①带来<strong>更高的测试覆盖率</strong>：有些分支问题在集成测试过程中很难发现，但在单元测试中极易发现。</p><p>②<strong>提高团队效率</strong>：单元测试在开发完后立即执行，将测试提前一步，不必等集成测试时才发现问题。</p><p>③<strong>自信的重构和改进实现。</strong></p><p>④<strong>将预期的行为文档化</strong>：完整的单元测试是产品代码的最好文档。</p><p><strong>（2）不当的单元测试会降低生产力</strong></p><p>单元测试并不是越多越好，不当的单元测试会降低生产力。</p><p>①单元测试的工作量与普通代码的工作量的比例介于1:1~1.5:1。</p><p>②整体项目的单元测试运行时间随着单元测试case增多线性增长，测试的执行速度影响每次变更等待的时间。</p><p>③单元测试的代码，也需要长期维护。</p><p><strong>（3）如何选择单元测试的对象</strong></p><p>不写单元测试不好，单元测试写多了也不好，这就要求我们要细心选择单元测试的对象。</p><p>在进行单元测试的时候，应<strong>重点关注核心业务逻辑代码、重用性高的代码与调用频繁的代码</strong>，后两者较为相近。</p><h4 id="2-2-2-不同场景下的单元测试tips"><a href="#2-2-2-不同场景下的单元测试tips" class="headerlink" title="2.2.2 不同场景下的单元测试tips"></a>2.2.2 不同场景下的单元测试tips</h4><p>1）Java Web项目底层的BO\DAO大体都是工具自动生成，无需额外单测，但是<strong>Action(Controller)<strong>层不含有较多的业务逻辑，</strong>需要通过集成测试</strong>发现问题。要注意的是<strong>java web项目</strong>的核心业务逻辑主要存在于Service层代码中，需要<strong>着重进行单元测试</strong>。</p><p>（2）平台类Java项目虽然在单独的场景下几乎不会出现问题，但是交叉混合时可能存在问题。而且由于平台类项目更多的兼顾不同的复杂的应用场景，所以在测试时要尽量做到全面。值得注意的是平台类Java项目的分支较多，所以<strong>要求在单元测试时要做到覆盖分支全面</strong>。</p><p>（3）组件类Java项目和平台类项目类似，也需要侧重分支覆盖全面，包括异常调用情况的覆盖。</p><p>（4）Hadoop的MR任务属于特殊的JAVA程序，集成测试成本高，主要体现在时间成本上。在进行单测时，<strong>可以将核心逻辑代码抽取出来，单独测试。</strong></p><h2 id="3-Python单元测试"><a href="#3-Python单元测试" class="headerlink" title="3 Python单元测试"></a>3 Python单元测试</h2><h3 id="3-1-单元测试的概念、工具与方法"><a href="#3-1-单元测试的概念、工具与方法" class="headerlink" title="3.1 单元测试的概念、工具与方法"></a>3.1 单元测试的概念、工具与方法</h3><h4 id="3-1-1-单元测试的概念"><a href="#3-1-1-单元测试的概念" class="headerlink" title="3.1.1 单元测试的概念"></a>3.1.1 单元测试的概念</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281703584.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281704541.png"></p><p>测试具有许多种不同的类型，比如说单元测试、模块测试、联调测试、系统测试、交付测试等。在这些测试之中，<strong>单元测试是最先要完成的</strong>。单元测试通常是由开发者去完成，用来验证代码中的函数是否符合预期。因此，它聚焦于函数的逻辑以及核心的算法是否正确。<em><strong>通常而言，一个单元测试用例是用于判断在某个特定条件或场景下，某个特定函数的行为。</strong></em></p><h4 id="3-1-2-单元测试的意义"><a href="#3-1-2-单元测试的意义" class="headerlink" title="3.1.2 单元测试的意义"></a>3.1.2 单元测试的意义</h4><p><strong>单元测试的意义包括两个方面。</strong></p><p>（1）质量</p><blockquote><p>①单元测试主要针对函数，<strong>颗粒度小、测试针对性强</strong>，bug更容易暴露；</p><p>②由于单元测试覆盖面较窄，无需考虑其它函数或者所依赖的模块，所以它的<strong>场景易构造，核心功能验证更充分</strong>；</p><p>③进行单元测试保证整体代码结构良好，使代码就具有较高的可测性和可维护性。</p></blockquote><p>（2）效率</p><p>单元测试能够提高开发效率，主要表现在：</p><blockquote><p>①单元测试<strong>进行的时间较早，测试场景构建快</strong>，可有效减少调试时间。</p><p>②由于单元测试<strong>只针对修改的代码</strong>展开测试，无需考虑额外内容，所以在较短时间内即可把预期的逻辑测试充分。</p><p>③单元测试<strong>能够在项目开发初期发现的bug</strong>，bug发现的时间越早，所带来的收益越大。由于尽早发现bug能够节省整个项目开发的时间，所以单元测试可加快开发效率，缩短开发周期。</p></blockquote><h4 id="3-1-3-单元测试框架"><a href="#3-1-3-单元测试框架" class="headerlink" title="3.1.3 单元测试框架"></a>3.1.3 单元测试框架</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281706919.png"></p><p><strong>Unitest的基础概念</strong></p><blockquote><p>在做单元测试之前，需要先了解一下Unittest的几个基础概念。</p><p>①**Test(测试用例)**，针对一个特定场景，特定目的具体测试过程。</p><p><em>比如说一个函数通过一组输入测试它，就是一个测试用例；如果一个函数通过三组输入来测试，即为三个测试用例。</em></p><p>②<strong>TestCase（测试类）</strong>，可以包含同一个测试对象的多个测试用例。</p><p><em>如果一个函数通过三组输入来测试，也就是三个测试用例，这三个测试用例可以合成为一个测试类。</em></p><p>③<strong>TestSuite（测试集）</strong>，可以包含多个测试类的多个测试用例。</p><p>④<strong>Assertion（断言）</strong>，必须使用断言判断测试结果。</p><p>⑤<strong>TestFixture</strong>，为测试做统一的准备和清除工作，通常是初始化，连接数据库，准备数据，断开数据库，清除现场等。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281711746.png"></p><p>扩展来说，TestFixture有四种最常使用的作用范围，分别为：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281710167.png"></p><blockquote><ol><li>setUp：在测试类的每个测试用例执行前执行。</li><li>teardown：在测试类的每个测试用例执行后执行。</li><li>setUpClass：在测试类的第一个测试用例执行前执行。</li><li>tearDownClass：在测试类的最后一个测试用例执行后执行。</li></ol></blockquote><p>TestFixture可以让单元测试代码更简单，但并非必须使用，也不要求配对出现。</p></blockquote><h4 id="3-1-4-单元测试的规范"><a href="#3-1-4-单元测试的规范" class="headerlink" title="3.1.4 单元测试的规范"></a>3.1.4 单元测试的规范</h4><p>如下是单元测试涉及的规范。</p><p>（1）所有的单元测试<strong>必须使用断言（assert）判断结果</strong>，禁止出现无断言的测试用例；</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281712364.webp"></p><p>使用断言，不但有利于他人理解，而且一旦出现不符合预期的情况，可以立即找出问题。</p><p>可以使用assertEqual, assertNotEqual 来判断相等或不相等，assertTrue,assertFalse 来判断Boolean, assertRaises 判断抛出的异常是否符合预期。</p><p>（2）测试用例需要具有自表述能力，达到见名知意。</p><p>比如命名test_login_with_invalid_password()，通过它的名字便可知它是用一个非法的密码去测试登录功能，具有自表述能力；但是如果命名为 test_login_case_（），名字减少了很多信息，难以得知它具体在做什么，不具有自表述能力。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281714852.png"></p><p>（3）测试用例之间相互独立，不应相互依赖、相互调用。</p><p>（4）<strong>一个测试用例只测一个函数。</strong>一个测试用例里面可以包含这一个函数的多个场景，但不能包含有多个参数的函数。原因在于，复杂测试用例出现错误时，无法定位问题的出处。</p><h4 id="3-1-5-单元测试对编码的要求"><a href="#3-1-5-单元测试对编码的要求" class="headerlink" title="3.1.5  单元测试对编码的要求"></a>3.1.5  单元测试对编码的要求</h4><p>单元测试中代码需保持一致性，尽量不要出现结果不一致的情况。假设有的代码会带来不一致性，导致单元测试无法稳定运行。针对这种情况，有两种解决方案：</p><p><strong>第一，将带来不一致性的代码抽取出来，</strong>把它作为一种变量传入我们需要调用或使用一致性变量的时候；</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281715404.png"></p><p><strong>第二，借助第三部分即将讲到的一个工具——mock</strong>——来解决这种问题。</p><h3 id="3-2-Coverage-统计单元测试覆盖率的工具"><a href="#3-2-Coverage-统计单元测试覆盖率的工具" class="headerlink" title="3.2 Coverage 统计单元测试覆盖率的工具"></a>3.2 Coverage 统计单元测试覆盖率的工具</h3><p>单元测试做完之后如何评价我们单元测试的效果。此时需要用到覆盖率工具，即Coverage。Coverage是一个第三方的工具，需要提前下载安装。</p><h4 id="3-2-1-统计覆盖率方法"><a href="#3-2-1-统计覆盖率方法" class="headerlink" title="3.2.1 统计覆盖率方法"></a>3.2.1 统计覆盖率方法</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281719654.png"></p><p>把python替换为coverage run-branch，然后会生成coverage文件，文件里会记录所有我们需要的覆盖率信息。</p><h4 id="3-2-2-打印覆盖率信息"><a href="#3-2-2-打印覆盖率信息" class="headerlink" title="3.2.2 打印覆盖率信息"></a>3.2.2 打印覆盖率信息</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281718158.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281716523.webp"></p><p>执行coverage report-m 命令，读取当前目录下.coverage文件，打印覆盖率信息。输出Stmts(总行数), Miss(未覆盖行数), Branch（总分支数）, BrPart （未覆盖分支数）, Cover（覆盖率） , Missing（未覆盖具体信息）等信息。</p><h4 id="3-2-3-覆盖率中排除某些文件"><a href="#3-2-3-覆盖率中排除某些文件" class="headerlink" title="3.2.3 覆盖率中排除某些文件"></a>3.2.3 覆盖率中排除某些文件</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281718278.png"></p><p>执行coverage report-m—omit=file 1[,file 2,……] 命令, 在统计并打印覆盖率时，排除某些文件。若有多个文件用逗号分隔。</p><h4 id="3-2-4-生成HTML格式的覆盖率信息"><a href="#3-2-4-生成HTML格式的覆盖率信息" class="headerlink" title="3.2.4 生成HTML格式的覆盖率信息"></a>3.2.4 生成HTML格式的覆盖率信息</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281718034.png"></p><p>针对代码量较大，查找覆盖率信息难度较大、耗时较长的情况，执行coverage html [–omit=file1[,file2,……]]命令，将覆盖率信息以html格式显示。</p><h3 id="3-3-Mock-简化单元测试的工具"><a href="#3-3-Mock-简化单元测试的工具" class="headerlink" title="3.3 Mock 简化单元测试的工具"></a>3.3 Mock 简化单元测试的工具</h3><h4 id="3-3-1-使用mock工具的原因与其功能"><a href="#3-3-1-使用mock工具的原因与其功能" class="headerlink" title="3.3.1 使用mock工具的原因与其功能"></a>3.3.1 使用mock工具的原因与其功能</h4><p>Mock基于实际进行单元测试的场景而产生，以下三类场景非常具有代表性：</p><ol><li><p><strong>构造模块</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281724821.png">需要测试模块A,但它要调用的模块B还未开发，可是测试却不容推迟、需按时进行，面对这种情况，我们可以使用Mock生成一个还未写完的代码，即可进行相应的测试。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281724884.png"></p></li><li><p><strong>改变函数逻辑</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281725807.png">代码中含有结果不可预知的代码，例如time.time()(时间)， random.random()(随机数)。Mock可以改变含有结果不可预知代码的函数的逻辑，强行让其返回我们想要的返回值，使其结果可预知。</p></li><li><p><strong>减少依赖</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281725930.png" alt="image-20211128172546775">在所有模块代码都已完成，但无法保证代码稳定性的情况下。针对其他模块的质量不可靠的情况，可通过Mock工具构造一个相对稳定的模块，从而规避其他模块的问题。</p></li></ol><h4 id="3-3-2-Mock使用场景"><a href="#3-3-2-Mock使用场景" class="headerlink" title="3.3.2 Mock使用场景"></a>3.3.2 Mock使用场景</h4><p>通过以下10个场景来讲述Mock的常见用法。</p><p>场景01：通过 <strong>return_value</strong>，Mock可以强行修改，永远返回我们想要的返回值，支持的类型包括string,number,Boolean,list,dict等。</p><p>场景02：将前一个例子的<strong>实例名改为类名</strong>，可实现替换类方法的返回值。</p><p>场景03：通过 <strong>side_effect</strong>,根据调用次数返回想要的结果,当超出调用次数时抛StopIteration 异常。</p><p>场景04：通过 <strong>side_effect</strong>可以完全修改函数的逻辑，使用另一个函数来替换它，根据参数返回想要的结果。</p><p>场景05：通过 <strong>side_effect</strong>抛出想要的异常或错误。</p><p>场景06：针对需要mock在特定要求下生效的情况，通过<strong>with.patch.object</strong>设定一个作用域以达到限制mock作用域的目的。</p><p>场景07：<strong>获取调用信息</strong>，如函数是否被调用、函数被调用的次数、函数被调用的形式、函数调用的参数等。</p><p>场景08：通过<strong>create_autospec</strong>在返回值改变的同时，确保api不会因mock而改变。</p><p>场景09：针对需要调用的函数、调用的接口完全没有开发的情况，可以通过<strong>Mock从零构造依赖模块</strong>从而完成测试。</p><p>场景10 ：<strong>替换函数调用链。</strong>比如说用popen去执行一个命令，然后用read函数把它读取出来，再用split去做切分，这就是一个函数调用链(os.popen(cmd).read().split())。</p><h4 id="3-3-3-Mock对编码的要求"><a href="#3-3-3-Mock对编码的要求" class="headerlink" title="3.3.3 Mock对编码的要求"></a>3.3.3 Mock对编码的要求</h4><p>在模块引入方式上，推荐以import XXX的形式引入，以XXX.func()形式调用，不要from.xxx import *,因为需要一个链条指向它，否则无法达到我们的预期。</p><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281727442.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281727860.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281728367.png"></p><h2 id="4-单元测试实践"><a href="#4-单元测试实践" class="headerlink" title="4 单元测试实践"></a>4 单元测试实践</h2><h3 id="4-1-Unittest-简单应用"><a href="#4-1-Unittest-简单应用" class="headerlink" title="4.1 Unittest 简单应用"></a>4.1 Unittest 简单应用</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281736705.webp"></p><p>如图所示，这是一个要被测试的类，这个类代表了一个人，类中有一个函数为<strong>get_name()，作用是获取这个人的名字</strong>。围绕着这个函数首先想到的测试点就是函数能否正确输出人名。因此就有了如下图所示的单元测试代码。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281738269.webp"></p><p>第一步，将使用到的unittest框架和所需要的函数导入。</p><p>第二步，针对被测试的函数写一个测试类，这里要注意<strong>测试类必须继承自unittest和TestCase。</strong></p><p>第三步，构建实例化的函数，可以理解为生成两个人，一个叫张三，一个叫李四。</p><p>第四步，编写一个用于测试的函数，这里注意<strong>函数名必须是以test开头</strong>。通过图片里的代码可以看到，通过使用assertEqual断言来做相应的测试，断言中包括了两部分，第一部分是预期，第二部分是实际的值。通过对两个值的比较来完成测试。</p><h3 id="4-2-Unittest复杂应用"><a href="#4-2-Unittest复杂应用" class="headerlink" title="4.2 Unittest复杂应用"></a>4.2 Unittest复杂应用</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281736271.webp"></p><p>下面来看一个复杂的例子。如图所示，这个被测试的类是一个公司。这个公司的信息包含了公司的名字、公司的老板、公司的员工数。在这个公司的类中设置了三个函数，老板是谁、雇佣一个新员工、解雇一个员工。通过这些信息，可以想到的测试点有：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281735339.webp"></p><p>（1）who_is_boss()这个函数能够正确的返回老板的姓名；</p><p>（2）使用hire()函数雇佣新人，公司的员工总数+1；</p><p>（3）使用hire()函数重复雇佣一个人，函数会报错或者公司员工数量不变；</p><p>（4）使用fire()函数解雇一个人，公司的员工总数-1；</p><p>（5）使用fire()函数解雇非公司的员工，函数会报错或者员工数量不变。</p><p>针对以上的几个测试点，可以编写出相应的测试类。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281736693.webp"></p><p>首先将所需要的类库导入，并且测试类要继承自unittest和TestCase。然后使用setUpClass()函数构建一个公司，设置老板的姓名和公司的名字。在这里设置了一个tearDown()清理函数，是为了方便测试的时候将员工全部清理掉。</p><p>通过图片可以看到，下面的三个函数原理基本跟上一个案例相同，都是通过断言来进行测试。测试类编写完成之后，需要运行这个类进行测试。如果需要执行全部的测试用例，如图所示，使用unittest.main()这个函数且不需要添加任何参数。执行完成后会得到如下图所示的结果，测试结果分为几个部分：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281736738.webp"></p><p>第一部分的代码展示的是执行测试用例的结果，“.”说明测试用例执行通过，“E”说明测试用例发生了特殊情况异常中断，“F”说明测试用例执行失败。</p><p>第二部分则是打印的报错信息，当出现“E”或者“F”的时候，系统会打印出异常中断和执行失败的原因。</p><p>第三部分为统计信息，包括了共执行了几个测试用例，测试用例执行共花费了多少时间，测试用例执行成功或失败的数量。</p><h1 id="四、百度高效研发实战训练营Step4"><a href="#四、百度高效研发实战训练营Step4" class="headerlink" title="四、百度高效研发实战训练营Step4"></a>四、百度高效研发实战训练营Step4</h1><h2 id="1-代码检查规则：Java语言案例讲解"><a href="#1-代码检查规则：Java语言案例讲解" class="headerlink" title="1 代码检查规则：Java语言案例讲解"></a>1 代码检查规则：Java语言案例讲解</h2><h3 id="1-1-源文件规范"><a href="#1-1-源文件规范" class="headerlink" title="1.1 源文件规范"></a>1.1 源文件规范</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281859378.png"></p><h4 id="1-1-1-文件名"><a href="#1-1-1-文件名" class="headerlink" title="1.1.1 文件名"></a>1.1.1 文件名</h4><p>Java源文件名必须和它包含的顶层类名保持一致，包括大小写，并以**.java作为后缀名**。</p><h4 id="1-1-2-文件编码"><a href="#1-1-2-文件编码" class="headerlink" title="1.1.2 文件编码"></a>1.1.2 文件编码</h4><p>为保持编码风格的一致性，避免编码不一致导致的乱码问题，要求所有源文件编码<strong>必须使用UTF-8格式</strong>。</p><h4 id="1-1-3-特殊字符"><a href="#1-1-3-特殊字符" class="headerlink" title="1.1.3 特殊字符"></a>1.1.3 特殊字符</h4><p>特殊字符方面的规则主要是针对<strong>换行、缩进、空格</strong>等操作而制定，有以下强制规定：</p><ol><li>除换行符以外，<strong>ASCII空格（0x20）是唯一合法的空格字符</strong>。</li><li>由于不同系统将Tab转化成空格的数目不一致，统一使用空格进行缩进。</li><li>文件的换行符统一使用Unix格式（\n），而不要使用Windows格式（\r\n）。</li></ol><h3 id="1-2-源文件组织结构规范"><a href="#1-2-源文件组织结构规范" class="headerlink" title="1.2 源文件组织结构规范"></a>1.2 源文件组织结构规范</h3><blockquote><p>这一大类规则主要规定了源文件所应包含的具体组成部分和各个部分之间应遵循的一系列规则。</p><p><strong>对于源文件的组成部分，规定如下：</strong></p><p>源文件必须按顺序包含：许可证或版权声明、package语句、import语句、唯一的顶层类，四个方面的内容。</p><p>同时，每两个部分之间用一个空行进行分隔，不允许出现多余空行。对于以上四个方面的内容，每个组成部分又有相应的编码规则。</p></blockquote><h4 id="1-2-1-许可证或版权声明规范"><a href="#1-2-1-许可证或版权声明规范" class="headerlink" title="1.2.1 许可证或版权声明规范"></a>1.2.1 许可证或版权声明规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281903514.png"></p><h4 id="1-2-2-package语句规范"><a href="#1-2-2-package语句规范" class="headerlink" title="1.2.2 package语句规范"></a>1.2.2 package语句规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281911018.png"></p><h4 id="1-2-3-import语句规范"><a href="#1-2-3-import语句规范" class="headerlink" title="1.2.3 import语句规范"></a>1.2.3 import语句规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281904436.png"></p><h4 id="1-2-4-类声明规范"><a href="#1-2-4-类声明规范" class="headerlink" title="1.2.4 类声明规范"></a>1.2.4 类声明规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281905480.png"></p><h3 id="1-3-代码结构规范"><a href="#1-3-代码结构规范" class="headerlink" title="1.3 代码结构规范"></a>1.3 代码结构规范</h3><h4 id="1-3-1-花括号"><a href="#1-3-1-花括号" class="headerlink" title="1.3.1 花括号"></a>1.3.1 花括号</h4><p>花括号经常在<strong>类和方法定义以及代码块划分</strong>中使用，花括号在使用中常需要合理的换行操作进行配合。规定为：在非空代码块中使用花括号时要遵循<strong>K&amp;R风格（Kernighan and Ritchie Style）</strong>，三个主要原则为:</p><ol><li>在左花括号（{）前不能换行，在其后换行；</li><li>在右花括号（}）前应有换行；</li><li>表示终止的右花括号（}）后必须换行，否则，右花括号后不换行。</li></ol><h4 id="1-3-2-缩进与换行"><a href="#1-3-2-缩进与换行" class="headerlink" title="1.3.2 缩进与换行"></a>1.3.2 缩进与换行</h4><p>缩进与换行主要是为了保证代码风格的一致性，提升代码的可维护性。主要规范有：</p><ol><li><p>每次开始书写一个新代码块时，使用4个空格进行缩进，在代码块结束时，恢复之前的缩进级别。</p></li><li><p>每条语句之后都要换行，每行只能有一条完整语句。</p></li><li><p>除package语句和import语句外，代码单行字符数限制不超过120个。超出则需要换行，换行时，遵循如下五条原则：</p><blockquote><ol><li>第二行相对第一行缩进四个空格，从第三行开始，不再继续缩进。</li><li>运算符与下文一起换行，即运算符位于行首。</li><li>方法调用的标点符号与下文一起换行。</li><li>方法调用中的多个参数需要换行时，在逗号后进行。</li><li>在括号前不要换行。</li></ol></blockquote></li></ol><h4 id="1-3-3-空行"><a href="#1-3-3-空行" class="headerlink" title="1.3.3 空行"></a>1.3.3 空行</h4><p>合理使用空行可以提高代码的可读性，有利于后期维护。</p><p>对于空行的使用，有如下规范进行约束：</p><ol><li><strong>在类的不同成员间增加空行</strong>，包括：成员变量、构造函数、方法、内部类、静态初始化块、实例初始化块等。</li><li>两个成员变量声明之间可以不加空行。<strong>空行通常对于成员变量进行逻辑分组。</strong></li><li>方法体内，按需增加空行，以便从逻辑上对语句进行分组。</li><li>使用空行时，<strong>禁止使用连续的空行。</strong></li></ol><h4 id="1-3-4-其他说明"><a href="#1-3-4-其他说明" class="headerlink" title="1.3.4 其他说明"></a>1.3.4 其他说明</h4><p><strong><em>Java中有两种数组定义形式</em>，为规范代码书写形式，要求为：</strong></p><p>①类型与中括号紧挨相连来表示数组，即中括号写在数组名之前。</p><p><strong>而当注解与注释同时存在时，统一的规范要求为：</strong></p><p>②添加在类、方法、构造函数、成员属性上的注解直接写在注释块之后，每个注解独占一行。</p><p><strong>当同时存在多个修饰符时，需要<em>按照顺序书写</em>，顺序要求如下：</strong></p><p>public protected private abstract static final transient volatile synchronized native strictfp</p><p>排在首位的一定是访问修饰符，随后是abstract，即抽象类或抽象方法，紧接着是static、final。这是常见的几类修饰符，对于其他的修饰符，可以参考以上列举的顺序进行书写。</p><p><strong>为避免小写字母l与1混淆，有如下规定：</strong></p><p>长整型数字必须使用大写字母L结尾，以便于和数字1进行区分。</p><h3 id="1-4-命名规范"><a href="#1-4-命名规范" class="headerlink" title="1.4 命名规范"></a>1.4 命名规范</h3><h4 id="1-4-1-驼峰命名格式"><a href="#1-4-1-驼峰命名格式" class="headerlink" title="1.4.1 驼峰命名格式"></a>1.4.1 驼峰命名格式</h4><p>对于两种驼峰命名格式的使用范围，有如下规范：</p><ol><li>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，即首字母小写的驼峰命名格式。</li><li>类名使用UpperCamelCase风格，即首字母大写的驼峰命名格式，以下情形例外：DO/BO/DTO/VO/AO/PO/UID等。</li></ol><h4 id="1-4-2-类的命名格式"><a href="#1-4-2-类的命名格式" class="headerlink" title="1.4.2 类的命名格式"></a>1.4.2 类的命名格式</h4><p>除此之外，对于一些类，命名格式有更加具体的规范要求：</p><ol><li>抽象类命名使用Abstract或Base开头；</li><li>异常类命名使用Exception结尾；</li><li>测试类命名以它要测试的类的名称开始，以Test结尾。</li></ol><h4 id="1-4-3-常量命名格式"><a href="#1-4-3-常量命名格式" class="headerlink" title="1.4.3 常量命名格式"></a>1.4.3 常量命名格式</h4><p>常量的命名规范：</p><p>①常量命名全部大写，单词间用下划线隔开。</p><p>②不允许任何未经预先定义的常量直接出现在代码中。</p><h3 id="1-5-OOP规约"><a href="#1-5-OOP规约" class="headerlink" title="1.5 OOP规约"></a>1.5 OOP规约</h3><p><strong>OOP规约主要是针对面向对象编程过程中定义的一些类所制定的一些规则。</strong></p><p>包含的强制规范要求有：</p><ol><li>所有的POJO类属性<strong>必须使用包装数据类型</strong>，禁止使用基本类型。</li><li>所有的覆写方法，<strong>必须加@Override注解。</strong></li><li>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</li><li>定义DO/DTO/VO等POJO类时，均不要设定任何属性默认值。</li></ol><h3 id="1-6-集合处理规范"><a href="#1-6-集合处理规范" class="headerlink" title="1.6 集合处理规范"></a>1.6 集合处理规范</h3><p>集合和数组是我们开发过程中使用频度最高的两个数据结构，对于二者的使用也有严格的强制规范：</p><ol><li>当需要将集合转换为数组时，必须使用集合的toArray方法，传入的是类型完全一样的数组，大小是list.size()。</li><li>对一个集合求子集合时，需高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除，产生ConcurrentModificationException异常。应通过对子集合进行相应操作，来反射到原集合，从而避免异常的发生。</li><li>不要在循环体内部进行集合元素的remove/add操作。remove元素请使用Iterator（迭代器）方式，如果并发操作，需要对Iterator对象加锁。</li></ol><h3 id="1-7-控制语句规范"><a href="#1-7-控制语句规范" class="headerlink" title="1.7 控制语句规范"></a>1.7 控制语句规范</h3><p>Java中的控制语句主要有<strong>switch、if、else、while等</strong>，这些语句的使用在编码过程中需要遵循以下规范：</p><ol><li>在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch快内，都必须包含一个default语句并且放在最后。</li><li>使用if/else/for/while/do语句必须使用花括号。即使只有一行代码，避免采用单行的编码方式。</li><li>在高并发场景中，避免使用“等于”判断作为中断或退出的条件。防止在击穿现象下，程序无法正常中断或退出的情况发生。</li></ol><h3 id="1-8-注释规约"><a href="#1-8-注释规约" class="headerlink" title="1.8 注释规约"></a>1.8 注释规约</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282007834.png"></p><p>合理使用注释可以提高程序可读性，便于后期维护。注释可以是程序说明，也可以是编程思路。<strong>Java中的注释主要分三种形式：文档注释、单行注释和多行注释。</strong>注释规约包括：</p><p>①类、类属性、类方法的注释必须使用文档注释形式，即使用 /<strong>内容</strong>/ 格式，不得使用单行注释的格式。单行注释和多行注释主要使用在方法体内。</p><p>②方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释，使用/<em>内容</em>/注释，注意与代码对齐。</p><h3 id="1-9-异常处理规范"><a href="#1-9-异常处理规范" class="headerlink" title="1.9 异常处理规范"></a>1.9 异常处理规范</h3><p>在Java中，我们通常使用<strong>try catch来进行捕获异常处理</strong>，而Java中的异常又分为运行时异常和非运行时异常。</p><ol><li><strong>对于处理运行时异常，有如下规范：</strong>Java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过try catch的方式来处理，比如：空指针异常和数组越界异常等等。</li><li><strong>对于捕获后异常的处理，有如下规范：</strong>捕获异常是为了处理异常，不要捕获后不进行任何处理而将其抛弃。若不想进行异常的处理，应将该异常抛给它的调用者。最外层的业务使用者必须处理异常，将其转化为用户可以理解的内容。即对于捕获后的异常，要么继续向上抛，要么自己进行处理。</li><li><strong>异常处理的规范要求还包括：</strong>不能在finally块中使用return语句。</li></ol><h3 id="1-10-缺陷检查规则"><a href="#1-10-缺陷检查规则" class="headerlink" title="1.10 缺陷检查规则"></a>1.10 缺陷检查规则</h3><p>缺陷检查主要是<strong>对Java源代码进行静态分析</strong>，扫描其中潜在的缺陷，比如：空指针异常、死循环等，这一阶段所应遵循的规则包括：</p><ol><li>不能使用单个字符定义StringBuffer和StringBuilder。</li><li>任何上锁的对象均需保证其锁可以被释放。</li><li>严格避免死循环的发生。</li><li>对于字符串中的点号（“.”）、竖线（“|”）和文件分隔符（“File.separator”）进行替代时，需要注意其特殊含义。</li></ol><blockquote><p><strong>“.”：匹配任意单个字符。</strong>在replaceAll中使用，它匹配所有内容。</p><p><strong>“|”：通常用作选项分隔符，</strong>它匹配字符间的空格</p><p><strong>“File.separator”：匹配特定平台的文件路径分隔符。</strong>在Windows上，这将被视为转义字符。</p></blockquote><ol start="5"><li>当synchronize对成员变量进行上锁时，该成员变量必须是final类型的。</li><li>synchronize上锁的成员变量类型一定不能是装箱类型。</li><li>所有被spring托管的类，其成员属性的初始化<strong>均要使用注入的方式。</strong></li><li>当使用try catch方式进行异常捕获，且需要在catch中对异常信息进行输出时，不得使用printStackTrace的方式。这种方式会导致后期分析代码困难。而应<strong>采用一些Log框架，方便用户检索和浏览日志。</strong></li><li>方法返回值包含操作状态代码时，该状态码不应被忽略</li><li>【%s】数组具有协变性，元素赋值类型与初始化类型不一致，此种情况可通过编译，但运行阶段会发生错误。</li><li>对于用户名和密码不应直接写在Java的文件中，避免泄露。而应将相应关键信息写在配置文件中进行读取。</li><li>方法和成员变量的命名不应相同，也不应通过大小写来进行区分。</li></ol><h2 id="2-单元测试之Java实践"><a href="#2-单元测试之Java实践" class="headerlink" title="2 单元测试之Java实践"></a>2 单元测试之Java实践</h2><h3 id="2-1-如何写单元测试"><a href="#2-1-如何写单元测试" class="headerlink" title="2.1 如何写单元测试"></a>2.1 如何写单元测试</h3><h4 id="2-1-1-基本流程"><a href="#2-1-1-基本流程" class="headerlink" title="2.1.1 基本流程"></a>2.1.1 基本流程</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282024759.png"></p><p><strong>单元测试的基本流程如下：</strong></p><p>首先，环境初始化；</p><p>其次，准备输入参数；</p><p>再次，调用待测试方法；</p><p>然后，检查输出；</p><p>最后，测试完成后环境复原。</p><h4 id="2-1-2-测试替身"><a href="#2-1-2-测试替身" class="headerlink" title="2.1.2 测试替身"></a>2.1.2 测试替身</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282025752.png"></p><p><strong>测试替身可用于隔离被测试的代码、加速执行顺序、使得随机行为变得确定、模拟特殊情况以及能够使测试访问隐藏信息等。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282025297.png"></p><p>常见的测试替身有四类：桩（Stub)、伪造对象（Fake)、测试间谋（Spy)以及模拟对象（Mock)。</p><ol><li>Stub(桩）:一般什么都不做，实现空的方法调用或者简单的硬编码返回即可。</li><li>Fake(伪造对象）:真实数据的简单版本，伪造真实对象的行为，但是没有副作用或者使用真实事物的其它后果。比如替换数据库的对象，而得到虚假的伪造对象。</li><li>Spy(测试间谋）:需要得到封闭对象内部状态的时候，就要用到测试间谋，事先学会反馈消息，然后潜入对象内部去获取对象的状态。测试间谋是一种测试替身，它用于记录过去发生的情况，这样测试在事后就能知道所发生的一切。</li><li>Mock(模拟对象）:模拟对象是一个特殊的测试间谋。是一个在特定的情况下可以配置行为的对象，规定了在什么情况下，返回什么样的值的一种测试替身。Mock已经有了非常成熟的对象库，包括JMock、Mockito和EasyMock等。</li></ol><blockquote><p><strong>重点讲解一下模拟对象（Mock)：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282028940.png"></p><p>假如我们有业务逻辑→数据存取→数据这三层逻辑，现在需要对“业务逻辑”层进行单元测试，那么我们可以使用Mock对数据存取与数据层的内容进行模拟，从而使上面的单元测试是独立的。</p></blockquote><h4 id="2-1-3-设计思路"><a href="#2-1-3-设计思路" class="headerlink" title="2.1.3 设计思路"></a>2.1.3 设计思路</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282028962.png"></p><p><strong>如何设计单元测试：</strong></p><p>**单元测试case的核心:**结合具体的应用场景、具体的输入数据与当前函数的功能实现，对于输出数据作出具体的预期，即可把全部待测试的分支都罗列了出来。</p><p>即：<strong>应用场景+输入数据+功能实现=输出数据。</strong></p><h4 id="2-1-4-断言-Assertions"><a href="#2-1-4-断言-Assertions" class="headerlink" title="2.1.4 断言(Assertions)"></a>2.1.4 断言(Assertions)</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282029555.png"></p><p>断言是一种在java单元测试中经常使用的测试方法。在单元测试中，我们<strong>使用“断言”来检验当前的测试结果是成功还是失败。</strong></p><blockquote><p><strong>常见的断言：</strong></p><p>Assert.assertNotNull</p><p>Assert.assertEquals</p><p>Assert.assertTrue</p><p>Assert.assertFalse</p><p>Assert.fail     </p></blockquote><p><strong>在单元测试中使用断言可以令预测结果自动呈现，无需人工对单元测试结果进行判断。</strong></p><h3 id="2-2-单元测试的运行"><a href="#2-2-单元测试的运行" class="headerlink" title="2.2 单元测试的运行"></a>2.2 单元测试的运行</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282031441.png"></p><h4 id="2-2-1-手动"><a href="#2-2-1-手动" class="headerlink" title="2.2.1 手动"></a>2.2.1 手动</h4><ol><li><strong>直接在IDE中执行</strong></li></ol><p>在开发编码完成之后，开发人员可以直接在自己的环境和编译器内运行单元测试。</p><ol start="2"><li><strong>使用maven的mvn test</strong></li></ol><p>Maven是目前java开发中最流行的项目构建工具，它非常全面的包含了很多功能。mvn test这个测试模块就可以为我们的单元测试提供极大的便利。</p><h4 id="2-2-2-自动"><a href="#2-2-2-自动" class="headerlink" title="2.2.2 自动"></a>2.2.2 自动</h4><p><strong>持续集成（Jenkins）：</strong>自动化持续集成是我们在项目中常用的一种单元测试的方法。通用工具为Jenkins，Jenkins是一种持续集成的工具，它的功能非常强大。他的主要的功能有软件发布和版本测试、外部调用监控。</p><h3 id="2-3-如何判断单元测试的质量"><a href="#2-3-如何判断单元测试的质量" class="headerlink" title="2.3 如何判断单元测试的质量"></a>2.3 如何判断单元测试的质量</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282032798.png"></p><p>衡量标准：</p><p>从<strong>主观层面</strong>，优秀的单元测试可读性高、易于维护、值得信赖.</p><p>从<strong>客观层面</strong>，使用单元测试代码覆盖率来衡。覆盖率工具包括：集成IDE和单独布署。</p><h2 id="3-如何做好-Code-Review"><a href="#3-如何做好-Code-Review" class="headerlink" title="3 如何做好 Code Review"></a>3 如何做好 Code Review</h2><h3 id="3-1-为什么要做好-Code-Review"><a href="#3-1-为什么要做好-Code-Review" class="headerlink" title="3.1 为什么要做好 Code Review"></a>3.1 为什么要做好 Code Review</h3><h4 id="3-1-1-Code-Review是提升代码质量的最好方法"><a href="#3-1-1-Code-Review是提升代码质量的最好方法" class="headerlink" title="3.1.1 Code Review是提升代码质量的最好方法"></a>3.1.1 Code Review是提升代码质量的最好方法</h4><p>强化Code Review是<strong>提升代码质量的第一选择。</strong></p><p>在代码开发过程中，我们越早发现问题、定位问题，在修复问题时付出的成本越小。</p><p>大约有50%以上的bug，都是在做Code Review时发现的。前期做好Code Review，后期将会减少反复修改等不必要的复工。</p><h4 id="3-1-2-Code-Review能够在团队内传递知识"><a href="#3-1-2-Code-Review能够在团队内传递知识" class="headerlink" title="3.1.2 Code Review能够在团队内传递知识"></a>3.1.2 Code Review能够在团队内传递知识</h4><p>从知识传递的角度看，<strong>Code Review是极为重要的。</strong></p><p>做好Code Review，能够帮助团队传递知识、沟通交流、互相学习，能够提升学习能力、提升编写代码能力、提升代码质量、提升工作效率、降低项目风险。</p><p>另外，基于codebase可以使我们了解项目全局，培养系统的思考方式。</p><h4 id="3-1-3-Code-Review是辅导怎么写代码的最好方法"><a href="#3-1-3-Code-Review是辅导怎么写代码的最好方法" class="headerlink" title="3.1.3 Code Review是辅导怎么写代码的最好方法"></a>3.1.3 Code Review是辅导怎么写代码的最好方法</h4><p>我们要意识到，做Code Review可以学习到别人的经验，同时也可以向别人传递我们的经验。</p><p>如果我们想辅导别人，<strong>最好的办法就是让对方先写一段代码，我们对他的代码进行Code Review。</strong>在辅导他人的过程中，我们可以快速地发现问题，从而帮助改进。</p><h4 id="3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力"><a href="#3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力" class="headerlink" title="3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力"></a>3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力</h4><p>工作中是否有Code Review对于公司或团队来说非常重要。不但对于公司或团队内的人员有所提升，而且能够吸引出色的开发者加入开发团队。</p><p>未做好Code Review的公司或团队有如下特点：</p><ol><li>代码质量差。</li><li>团队内人员备份差。</li><li>团队开发人员得不到有效的辅导，提高慢。</li></ol><h4 id="3-1-5-为什么要提高代码质量？"><a href="#3-1-5-为什么要提高代码质量？" class="headerlink" title="3.1.5 为什么要提高代码质量？"></a>3.1.5 为什么要提高代码质量？</h4><ol><li>提高代码质量可以提高代码的可读性。</li><li>提高代码质量可以提高代码的复用性和参考性。</li><li>提高代码质量可以减少bug出现的风险。</li><li>提高代码质量可以减少后期补丁的风险。</li><li>提高代码质量可以降低代码失控的风险。</li><li>提高代码质量可以降低项目重构和升级的麻烦。</li></ol><h4 id="3-1-6-为什么要提高写代码的能力"><a href="#3-1-6-为什么要提高写代码的能力" class="headerlink" title="3.1.6 为什么要提高写代码的能力"></a>3.1.6 为什么要提高写代码的能力</h4><ol><li>代码能力如果停滞不前，对于个人而言，将导致职业危机。</li><li>代码能力如果停滞不前，对于团队而言，将意味着团队没有成长。</li></ol><p><strong>Code Review是一个非常重要的提升代码质量和代码能力的手段。</strong>无论是从个人发展角度，还是团队发展角度，我们都需要重视Code Review。</p><h3 id="3-2-如何做好-Code-Review"><a href="#3-2-如何做好-Code-Review" class="headerlink" title="3.2 如何做好 Code Review"></a>3.2 如何做好 Code Review</h3><h4 id="3-2-1-在Code-Review中可能发现的问题"><a href="#3-2-1-在Code-Review中可能发现的问题" class="headerlink" title="3.2.1 在Code Review中可能发现的问题"></a>3.2.1 在Code Review中可能发现的问题</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282043808.png"></p><h4 id="3-2-2-在Code-Review中应有的态度"><a href="#3-2-2-在Code-Review中应有的态度" class="headerlink" title="3.2.2 在Code Review中应有的态度"></a>3.2.2 在Code Review中应有的态度</h4><ol><li><p>对所有检查的代码逻辑要做到“完全看懂”，对于审核的代码，熟悉程度要做到“如数家珍”。如果在审核代码后，对代码的逻辑和背后的原因仍然很模糊，则是一个失败的Code Review。</p></li><li><p>好代码的标准，不仅仅是“可以运行通过”，在正确性、可读性、可重用性、可运维性等方面上，都需要综合考虑。</p></li><li><p>建立Code Review和写代码一样重要的意识。即：</p><blockquote><ol><li>Code Review和写代码一样，也有产出，即产出更高质量的代码。</li><li>审核代码在很多情况下比写代码还要辛苦，需要理解和找出问题等。</li></ol></blockquote></li><li><p>以提升代码质量为最终目标。</p></li><li><p>要投入足够的时间和精力。</p><blockquote><pre><code>        1. 审核代码花费的时间经常和写代码一样多，有时甚至比写代码的时间更多，要有时间意识。        1. 要有责任意识。如果出现bug，不仅仅是写代码人员的职责，也不仅仅是QA的职责，代码审核者也需要承担相当大的责任。</code></pre></blockquote></li></ol><h4 id="3-2-3-在Code-Review之前，需要了解一流代码的特性"><a href="#3-2-3-在Code-Review之前，需要了解一流代码的特性" class="headerlink" title="3.2.3 在Code Review之前，需要了解一流代码的特性"></a>3.2.3 在Code Review之前，需要了解一流代码的特性</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282046798.png" alt="一流代码的特性"></p><p><strong>一流代码有以下特性：①高效性；②鲁棒性；③简洁；④简短；⑤可共享；⑥可测试；⑦可移植；⑧可监控；⑨可运维；⑩可扩展。</strong></p><p>将以上十条标准进行总结精简归纳为：</p><blockquote><ol><li>代码的正确和性能；</li><li>代码的可读和可维护性；</li><li>代码的可运维和可运行；</li><li>代码的可共享和可重用；</li></ol></blockquote><p>在Code Review时，综合考虑以上一流代码的特性，可以快速提升代码质量、提升编写代码的能力等。</p><h4 id="3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力"><a href="#3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力" class="headerlink" title="3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力"></a>3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力</h4><p><strong>通常bad code有以下特点：</strong></p><ol><li>5分钟内不能看懂的代码。</li></ol><p>​        不能快速看懂的代码，一定是有问题的代码，可以先抛回给编写代码人员进行修正。<strong>一般一个函数的操作不能超过6个step</strong>，如果超过这个数量，则需要重新调整编码逻辑。</p><ol start="2"><li>需要思考才能看懂的代码。</li></ol><p>​        好的代码阅读时基本不用动脑子，甚至看注释就能看懂。</p><ol start="3"><li>需要来回翻屏才能看懂的代码。</li></ol><p>​        好的代码，经常在一屏内就是一个完整的逻辑。</p><ol start="4"><li>没有空行或注释的代码。</li></ol><p>​        在Code Review时，发现不会用段落、不会写注释的代码，肯定不是好的程序员写的代码，可以直接打回给编写代码人员进行修正。</p><h4 id="3-2-5-Code-Review的注意事项"><a href="#3-2-5-Code-Review的注意事项" class="headerlink" title="3.2.5 Code Review的注意事项"></a>3.2.5 Code Review的注意事项</h4><ol><li>在必要时，review的双方做<strong>面对面的沟通。</strong></li></ol><p>​        面对面沟通并不是单指当面沟通，还包括云共享、电话、视频沟通等。在沟通时，对于背景、关键点等应进行说明，便于reviewer的理解。在必要时，应提供设计文档。</p><ol start="2"><li>对于关键模块，应该建<strong>立owner制度。</strong></li></ol><p>​        所有提交的代码，必须由owner做最终确认。由owner掌握全局，并建立明确的责任关系。</p><ol start="3"><li><p>检查中发现的问题，要一追到底。</p></li><li><p>要<strong>注意细节。</strong>对每一行提交的代码，都要进行检查。</p></li><li><p><strong>Code Review的方式，要小步快跑。</strong>每次提交review的代码量不要太多，降低复杂度。在特殊情况时，比如一个新模块的构建，最好逐步完成，通过多次进行提交。</p></li><li><p>要为Code Review<strong>预留出足够的时间。</strong>Code Review VS Coding的时间，有时可能达到1:1。在这里需要考虑到有时会做大的修改，科学地规划工作量，尽量避免出现时间倒排。</p></li><li><p>注意每天 review代码的数量不宜过多。</p></li></ol><h4 id="3-2-6-Code-Review的步骤"><a href="#3-2-6-Code-Review的步骤" class="headerlink" title="3.2.6 Code Review的步骤"></a>3.2.6 Code Review的步骤</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282051436.png" alt="、"></p><p>Code Review的步骤为以下几点：</p><p><strong>Step1：先看系统全貌</strong></p><p>不深究细节，浏览系统全貌，理清模块划分的逻辑、模块间的关系、如何构成的整个系统等。</p><p><strong>Step2：进入模块级别</strong></p><p>同样不深究细节，浏览模块内的全貌，判断模块切分是否合理，理清模块内的逻辑，明确关键数据、关键的类和函数等。</p><p><strong>Step3：理清类、函数内部的逻辑。</strong></p><p><strong>Step4：进入细节。</strong></p><p>比如Layout、命名等。</p><h4 id="3-2-7-人为因素"><a href="#3-2-7-人为因素" class="headerlink" title="3.2.7 人为因素"></a>3.2.7 人为因素</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282053170.png"></p><p>除了代码上的问题，在Code Review过程中还会有一些人为因素，例如：</p><p><strong>①QA人员</strong></p><p>好的QA人员不仅仅会发现系统中的bug，还会质疑或提出产品需求，挑战或优化系统架构和实现方式。</p><p><strong>②Code Reviewer</strong></p><p>好的代码审核人员不仅仅指出代码表面的问题，还会检查系统需求分析的质量、接口或函数定义的合理性、模块划分的合理性、系统关键机制的合理性等。</p><h3 id="3-3-例子：Python-代码的-Code-Review"><a href="#3-3-例子：Python-代码的-Code-Review" class="headerlink" title="3.3 例子：Python 代码的 Code Review"></a>3.3 例子：Python 代码的 Code Review</h3><h4 id="3-3-1-Python的编码规范"><a href="#3-3-1-Python的编码规范" class="headerlink" title="3.3.1 Python的编码规范"></a>3.3.1 Python的编码规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282111474.png"></p><ul><li><p>代码要写的漂亮。</p></li><li><p>代码要<strong>明确直接</strong>，不要含蓄表达。</p></li><li><p>代码要<strong>简洁</strong>，一个函数可以实现的功能就不要写两个函数。</p></li><li><p><strong>代码深奥胜过代码复杂</strong>。代码可以写的深奥难懂，但是不能写的过于复杂。</p></li><li><p>代码要<strong>平铺直叙</strong>，不要层层嵌套。</p></li><li><p>代码要做到<strong>合理间隔。</strong></p></li><li><p>代码<strong>可读性</strong>非常重要。</p></li><li><p>代码要有普适性。尽量规避代码特殊性，用最简洁最通用的代码来实现。</p></li><li><p>代码要实用。</p></li><li><p>要重视所有发现的错误。</p></li><li><p>代码逻辑要清晰。在含糊混乱的面前，我们要拒绝猜测。读写代码时，不要出现“好像”、“可能”、“似乎”等猜测。当一段代码很难懂的时候，代码一定存在问题。</p></li><li><p>写代码要注重行动。</p></li><li><p>代码实现方法要简洁。如果一个方法很难解释，就意味着这个方法存在一定的问题。</p></li><li><p>要重视命名空间的使用。</p></li></ul><h4 id="3-3-2关于Python编程规范的部分说明"><a href="#3-3-2关于Python编程规范的部分说明" class="headerlink" title="3.3.2关于Python编程规范的部分说明"></a>3.3.2关于Python编程规范的部分说明</h4><p>Python编程规范有九个维度。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282113051.png"></p><h5 id="1-模块的划分"><a href="#1-模块的划分" class="headerlink" title="1 模块的划分"></a>1 模块的划分</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282118231.png"></p><p>我们要对模块有概念，这是整个系统的基础。</p><ol><li><p>一个.py文件是一个模块。</p></li><li><p>模块的划分对软件的长期维护非常重要。</p></li><li><p>每个模块都应该有特定的功能。</p></li></ol><blockquote><p>比如：配置文件的读取，网页文件的写入，网页文件的解析，一个内存数据表，一个抓取的线程等等。</p></blockquote><ol start="4"><li>多个本应独立的模块，写到一个.py文件中是常见的错误。从Code Review角度看，首先就是要看模块切分的对不对。</li></ol><h5 id="2-数据的封装"><a href="#2-数据的封装" class="headerlink" title="2 数据的封装"></a>2 数据的封装</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282117284.png"></p><p>在Code Review时，要着重注意数据是否封装这一问题。</p><h5 id="3-import"><a href="#3-import" class="headerlink" title="3 import"></a>3 import</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282118516.png"></p><p>Import在使用过程中，禁止使用from xxx import yyy语法直接导入类或函数。禁止使用from xxx import *这样的方法。这样做的目标是：容易判断代码中使用外部变量或函数的来源。</p><p>如果使用禁止中的语法，会大大增加判断来源的难度，以及代码阅读的难度。</p><p>在Code Review时，遇到这种情况，及时将代码打回给编程人员进行修正。</p><h5 id="4-异常"><a href="#4-异常" class="headerlink" title="4 异常"></a>4 异常</h5><p>对于异常的处理有以下几点需要注意：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282120853.png"></p><blockquote><ol><li>异常的使用</li></ol><p>​        使用异常前请需要详细了解异常的行为。不要主动抛出异常，使用返回值。如果一定要抛异常，需要注释进行说明。</p><ol start="2"><li>异常的获取强制</li></ol><p>​        除非重新抛出异常，否则禁止使用except:捕获所有异常，不建议捕获Exception或StandardError。</p><p>​        在实际编码中建议try中的代码尽可能少，避免catch住未预期的异常，掩藏掉真正的错误。底线是至少要打印异常的日志，而不是捕获后直接pass通过。</p><p>​        在对异常进行处理时尽量针对特定操作的特定异常来捕获。</p><ol start="3"><li>函数的返回值</li></ol><p>​        如果函数会抛出异常，需要在函数的注释中明确说明。</p></blockquote><p>在Code Review时，需要注意上述问题，及时返回给编程人员进行修正。</p><h5 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5 构造函数"></a>5 构造函数</h5><p>对于构造函数有以下几点需要注意：</p><ol><li>规范：</li></ol><p>类构造函数应该尽量简单，不能包含可能失败或过于复杂的操作。</p><ol start="2"><li>解读：</li></ol><p>在构造函数中常出现的错误是：无法判断、或捕获异常。</p><h5 id="6-函数返回值"><a href="#6-函数返回值" class="headerlink" title="6 函数返回值"></a>6 函数返回值</h5><p>对于函数返回值有以下几点需要注意：</p><ol><li>规范：</li></ol><blockquote><p>函数返回值必须小于等于3个。返回值超过3个时必须通过class/namedtuple/dict等具名形式进行包装。</p></blockquote><ol start="2"><li>解读：</li></ol><blockquote><p>a. 多数情况下的错误，是因为很多人不会思考和设计函数的语义。</p><p>函数描述涉及的三要素为：功能描述、传入参数描述和返回值描述。</p><p>每个函数都应该有足够明确的语义。基于函数的语义，函数的返回值有三种类型：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282122993.png"></p><p>b .另外，函数需要有返回值，对于正确或错误的情况，在返回值中要有体现。</p><p>c .还有一个问题是：Python的数据格式不需要定义，过于灵活。当程序规模变大、维护周期变长时，会导致后期极难维护。</p><p>应对措施是：多写注释，写清楚返回值说明、参数说明。</p></blockquote><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282123350.png"></p><p>在Code Review时，注释未写清楚的代码，一定要打回给编程人员，进行修正、补注释。</p><h5 id="7-代码长度"><a href="#7-代码长度" class="headerlink" title="7 代码长度"></a>7 代码长度</h5><p>关于代码长度有以下几点需要注意：</p><ol><li>每行不得超过120个字符。避免在终端上显示出现折行。</li><li>函数长度不得超过100行。函数过长会增加理解函数逻辑的难度。Python的函数应尽量控制在30~40行之间。</li></ol><p>在Code Review时，代码过长，建议全部打回给编程人员进行修正。</p><h5 id="8-空行、空格"><a href="#8-空行、空格" class="headerlink" title="8 空行、空格"></a>8 空行、空格</h5><p>关于空行、空格有以下几点需要注意：</p><ol><li>空行</li></ol><p>​        文件及定义之间隔两个空行。比如类或全局函数。类方法之间隔一个空行。</p><ol start="2"><li>空格</li></ol><p>​        逗号、分号、冒号前不加空格，后边加一个空格。所有二元运算符前后各加一个空格。</p><p>在Code Review时，需要着重注意空行和空格。空行和空格不是可有可无的。空行和空格的存在，是为了增加可读性。不好读的代码，一律打回给编程人员进行修正。</p><h5 id="9-注释"><a href="#9-注释" class="headerlink" title="9 注释"></a>9 注释</h5><p>关于注释有以下几点需要注意：</p><p>Python中的注释有一个特殊之处是docstring，<strong>docstring要和“＃”注意区分开。</strong></p><blockquote><p>相关规范有：</p><ol><li><p>使用docstring描述module、 function 、class和method接口时，<strong>docstring必须用三个双引号括起来。</strong></p></li><li><p>对外接口部分必须用docstring描述。内部接口视情况自行决定是否写docstring。</p></li><li><p>接口的docstring描述<strong>至少包括功能简介、参数、返回值。</strong>如果可能抛出异常，必须使用注释进行说明。</p></li><li><p><strong>每个文件都必须有文件声明</strong>，文件声明必须包括以下信息：版权声明、功能和用途简介、修改人及联系方式。</p></li></ol></blockquote><p>在Code Review时，不符合上述规范的，及时打回给编程人员进行修正。</p><h3 id="3-4-如何成为一个好的reviewer"><a href="#3-4-如何成为一个好的reviewer" class="headerlink" title="3.4 如何成为一个好的reviewer"></a>3.4 如何成为一个好的reviewer</h3><p>代码审核的质量，和审核者的代码能力直接相关。代码审核的质量差，反映的是审核者的代码水平。如果作为一个代码审核员不会写代码，就要承认真相，并且要不断提高自己的代码能力。</p><p>学习资料：</p><ol><li>关于代码的书籍：《编写可读代码的艺术》，《代码整洁之道》。</li><li>综合的书籍：《代码大全》，《201  principles of software development》。</li><li>其他：《代码的艺术》课程，Python Good Coder考试指南。</li></ol><h3 id="3-5-公司针对-Code-Review-的措施"><a href="#3-5-公司针对-Code-Review-的措施" class="headerlink" title="3.5 公司针对 Code Review 的措施"></a>3.5 公司针对 Code Review 的措施</h3><p><strong>1、建立高效可运营的代码审核机制，提升代码质量，降低代码评审成本。</strong></p><blockquote><p>①基于平台：icode+bugbye</p><p>②代码检查规则分级，分为ERROR、WARNING、ADVICE三类，对ERROR级别阻塞提交。</p><p>③通过统计数据驱动代码检测规则的优化。</p></blockquote><p><strong>2、通过工程能力地图考察项目的Code Review情况。</strong></p><p><strong>3、所有的Code Review行为，都基于icode平台进行。良好的工具可以帮助更好的进行代码审核</strong></p><h3 id="3-6-Code-Review-总结"><a href="#3-6-Code-Review-总结" class="headerlink" title="3.6 Code Review 总结"></a>3.6 Code Review 总结</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>百度高效研发实战训练营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>百度高效研发实战训练营Step4</title>
    <link href="/bitTraingClub4.html"/>
    <url>/bitTraingClub4.html</url>
    
    <content type="html"><![CDATA[<h1 id="百度高效研发实战训练营Step4"><a href="#百度高效研发实战训练营Step4" class="headerlink" title="百度高效研发实战训练营Step4"></a>百度高效研发实战训练营Step4</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-代码检查规则：Java语言案例讲解"><a href="#1-代码检查规则：Java语言案例讲解" class="headerlink" title="1 代码检查规则：Java语言案例讲解"></a>1 代码检查规则：Java语言案例讲解</h2><h3 id="1-1-源文件规范"><a href="#1-1-源文件规范" class="headerlink" title="1.1 源文件规范"></a>1.1 源文件规范</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281859378.png"></p><h4 id="1-1-1-文件名"><a href="#1-1-1-文件名" class="headerlink" title="1.1.1 文件名"></a>1.1.1 文件名</h4><p>Java源文件名必须和它包含的顶层类名保持一致，包括大小写，并以**.java作为后缀名**。</p><h4 id="1-1-2-文件编码"><a href="#1-1-2-文件编码" class="headerlink" title="1.1.2 文件编码"></a>1.1.2 文件编码</h4><p>为保持编码风格的一致性，避免编码不一致导致的乱码问题，要求所有源文件编码<strong>必须使用UTF-8格式</strong>。</p><h4 id="1-1-3-特殊字符"><a href="#1-1-3-特殊字符" class="headerlink" title="1.1.3 特殊字符"></a>1.1.3 特殊字符</h4><p>特殊字符方面的规则主要是针对<strong>换行、缩进、空格</strong>等操作而制定，有以下强制规定：</p><ol><li>除换行符以外，<strong>ASCII空格（0x20）是唯一合法的空格字符</strong>。</li><li>由于不同系统将Tab转化成空格的数目不一致，统一使用空格进行缩进。</li><li>文件的换行符统一使用Unix格式（\n），而不要使用Windows格式（\r\n）。</li></ol><h3 id="1-2-源文件组织结构规范"><a href="#1-2-源文件组织结构规范" class="headerlink" title="1.2 源文件组织结构规范"></a>1.2 源文件组织结构规范</h3><blockquote><p>这一大类规则主要规定了源文件所应包含的具体组成部分和各个部分之间应遵循的一系列规则。</p><p><strong>对于源文件的组成部分，规定如下：</strong></p><p>源文件必须按顺序包含：许可证或版权声明、package语句、import语句、唯一的顶层类，四个方面的内容。</p><p>同时，每两个部分之间用一个空行进行分隔，不允许出现多余空行。对于以上四个方面的内容，每个组成部分又有相应的编码规则。</p></blockquote><h4 id="1-2-1-许可证或版权声明规范"><a href="#1-2-1-许可证或版权声明规范" class="headerlink" title="1.2.1 许可证或版权声明规范"></a>1.2.1 许可证或版权声明规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281903514.png"></p><h4 id="1-2-2-package语句规范"><a href="#1-2-2-package语句规范" class="headerlink" title="1.2.2 package语句规范"></a>1.2.2 package语句规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281911018.png"></p><h4 id="1-2-3-import语句规范"><a href="#1-2-3-import语句规范" class="headerlink" title="1.2.3 import语句规范"></a>1.2.3 import语句规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281904436.png"></p><h4 id="1-2-4-类声明规范"><a href="#1-2-4-类声明规范" class="headerlink" title="1.2.4 类声明规范"></a>1.2.4 类声明规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281905480.png"></p><h3 id="1-3-代码结构规范"><a href="#1-3-代码结构规范" class="headerlink" title="1.3 代码结构规范"></a>1.3 代码结构规范</h3><h4 id="1-3-1-花括号"><a href="#1-3-1-花括号" class="headerlink" title="1.3.1 花括号"></a>1.3.1 花括号</h4><p>花括号经常在<strong>类和方法定义以及代码块划分</strong>中使用，花括号在使用中常需要合理的换行操作进行配合。规定为：在非空代码块中使用花括号时要遵循<strong>K&amp;R风格（Kernighan and Ritchie Style）</strong>，三个主要原则为:</p><ol><li>在左花括号（{）前不能换行，在其后换行；</li><li>在右花括号（}）前应有换行；</li><li>表示终止的右花括号（}）后必须换行，否则，右花括号后不换行。</li></ol><h4 id="1-3-2-缩进与换行"><a href="#1-3-2-缩进与换行" class="headerlink" title="1.3.2 缩进与换行"></a>1.3.2 缩进与换行</h4><p>缩进与换行主要是为了保证代码风格的一致性，提升代码的可维护性。主要规范有：</p><ol><li><p>每次开始书写一个新代码块时，使用4个空格进行缩进，在代码块结束时，恢复之前的缩进级别。</p></li><li><p>每条语句之后都要换行，每行只能有一条完整语句。</p></li><li><p>除package语句和import语句外，代码单行字符数限制不超过120个。超出则需要换行，换行时，遵循如下五条原则：</p><blockquote><ol><li>第二行相对第一行缩进四个空格，从第三行开始，不再继续缩进。</li><li>运算符与下文一起换行，即运算符位于行首。</li><li>方法调用的标点符号与下文一起换行。</li><li>方法调用中的多个参数需要换行时，在逗号后进行。</li><li>在括号前不要换行。</li></ol></blockquote></li></ol><h4 id="1-3-3-空行"><a href="#1-3-3-空行" class="headerlink" title="1.3.3 空行"></a>1.3.3 空行</h4><p>合理使用空行可以提高代码的可读性，有利于后期维护。</p><p>对于空行的使用，有如下规范进行约束：</p><ol><li><strong>在类的不同成员间增加空行</strong>，包括：成员变量、构造函数、方法、内部类、静态初始化块、实例初始化块等。</li><li>两个成员变量声明之间可以不加空行。<strong>空行通常对于成员变量进行逻辑分组。</strong></li><li>方法体内，按需增加空行，以便从逻辑上对语句进行分组。</li><li>使用空行时，<strong>禁止使用连续的空行。</strong></li></ol><h4 id="1-3-4-其他说明"><a href="#1-3-4-其他说明" class="headerlink" title="1.3.4 其他说明"></a>1.3.4 其他说明</h4><p><strong><em>Java中有两种数组定义形式</em>，为规范代码书写形式，要求为：</strong></p><p>①类型与中括号紧挨相连来表示数组，即中括号写在数组名之前。</p><p><strong>而当注解与注释同时存在时，统一的规范要求为：</strong></p><p>②添加在类、方法、构造函数、成员属性上的注解直接写在注释块之后，每个注解独占一行。</p><p><strong>当同时存在多个修饰符时，需要<em>按照顺序书写</em>，顺序要求如下：</strong></p><p>public protected private abstract static final transient volatile synchronized native strictfp</p><p>排在首位的一定是访问修饰符，随后是abstract，即抽象类或抽象方法，紧接着是static、final。这是常见的几类修饰符，对于其他的修饰符，可以参考以上列举的顺序进行书写。</p><p><strong>为避免小写字母l与1混淆，有如下规定：</strong></p><p>长整型数字必须使用大写字母L结尾，以便于和数字1进行区分。</p><h3 id="1-4-命名规范"><a href="#1-4-命名规范" class="headerlink" title="1.4 命名规范"></a>1.4 命名规范</h3><h4 id="1-4-1-驼峰命名格式"><a href="#1-4-1-驼峰命名格式" class="headerlink" title="1.4.1 驼峰命名格式"></a>1.4.1 驼峰命名格式</h4><p>对于两种驼峰命名格式的使用范围，有如下规范：</p><ol><li>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，即首字母小写的驼峰命名格式。</li><li>类名使用UpperCamelCase风格，即首字母大写的驼峰命名格式，以下情形例外：DO/BO/DTO/VO/AO/PO/UID等。</li></ol><h4 id="1-4-2-类的命名格式"><a href="#1-4-2-类的命名格式" class="headerlink" title="1.4.2 类的命名格式"></a>1.4.2 类的命名格式</h4><p>除此之外，对于一些类，命名格式有更加具体的规范要求：</p><ol><li>抽象类命名使用Abstract或Base开头；</li><li>异常类命名使用Exception结尾；</li><li>测试类命名以它要测试的类的名称开始，以Test结尾。</li></ol><h4 id="1-4-3-常量命名格式"><a href="#1-4-3-常量命名格式" class="headerlink" title="1.4.3 常量命名格式"></a>1.4.3 常量命名格式</h4><p>常量的命名规范：</p><p>①常量命名全部大写，单词间用下划线隔开。</p><p>②不允许任何未经预先定义的常量直接出现在代码中。</p><h3 id="1-5-OOP规约"><a href="#1-5-OOP规约" class="headerlink" title="1.5 OOP规约"></a>1.5 OOP规约</h3><p><strong>OOP规约主要是针对面向对象编程过程中定义的一些类所制定的一些规则。</strong></p><p>包含的强制规范要求有：</p><ol><li>所有的POJO类属性<strong>必须使用包装数据类型</strong>，禁止使用基本类型。</li><li>所有的覆写方法，<strong>必须加@Override注解。</strong></li><li>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</li><li>定义DO/DTO/VO等POJO类时，均不要设定任何属性默认值。</li></ol><h3 id="1-6-集合处理规范"><a href="#1-6-集合处理规范" class="headerlink" title="1.6 集合处理规范"></a>1.6 集合处理规范</h3><p>集合和数组是我们开发过程中使用频度最高的两个数据结构，对于二者的使用也有严格的强制规范：</p><ol><li>当需要将集合转换为数组时，必须使用集合的toArray方法，传入的是类型完全一样的数组，大小是list.size()。</li><li>对一个集合求子集合时，需高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除，产生ConcurrentModificationException异常。应通过对子集合进行相应操作，来反射到原集合，从而避免异常的发生。</li><li>不要在循环体内部进行集合元素的remove/add操作。remove元素请使用Iterator（迭代器）方式，如果并发操作，需要对Iterator对象加锁。</li></ol><h3 id="1-7-控制语句规范"><a href="#1-7-控制语句规范" class="headerlink" title="1.7 控制语句规范"></a>1.7 控制语句规范</h3><p>Java中的控制语句主要有<strong>switch、if、else、while等</strong>，这些语句的使用在编码过程中需要遵循以下规范：</p><ol><li>在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch快内，都必须包含一个default语句并且放在最后。</li><li>使用if/else/for/while/do语句必须使用花括号。即使只有一行代码，避免采用单行的编码方式。</li><li>在高并发场景中，避免使用“等于”判断作为中断或退出的条件。防止在击穿现象下，程序无法正常中断或退出的情况发生。</li></ol><h3 id="1-8-注释规约"><a href="#1-8-注释规约" class="headerlink" title="1.8 注释规约"></a>1.8 注释规约</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282007834.png"></p><p>合理使用注释可以提高程序可读性，便于后期维护。注释可以是程序说明，也可以是编程思路。<strong>Java中的注释主要分三种形式：文档注释、单行注释和多行注释。</strong>注释规约包括：</p><p>①类、类属性、类方法的注释必须使用文档注释形式，即使用 /<strong>内容</strong>/ 格式，不得使用单行注释的格式。单行注释和多行注释主要使用在方法体内。</p><p>②方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释，使用/<em>内容</em>/注释，注意与代码对齐。</p><h3 id="1-9-异常处理规范"><a href="#1-9-异常处理规范" class="headerlink" title="1.9 异常处理规范"></a>1.9 异常处理规范</h3><p>在Java中，我们通常使用<strong>try catch来进行捕获异常处理</strong>，而Java中的异常又分为运行时异常和非运行时异常。</p><ol><li><strong>对于处理运行时异常，有如下规范：</strong>Java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过try catch的方式来处理，比如：空指针异常和数组越界异常等等。</li><li><strong>对于捕获后异常的处理，有如下规范：</strong>捕获异常是为了处理异常，不要捕获后不进行任何处理而将其抛弃。若不想进行异常的处理，应将该异常抛给它的调用者。最外层的业务使用者必须处理异常，将其转化为用户可以理解的内容。即对于捕获后的异常，要么继续向上抛，要么自己进行处理。</li><li><strong>异常处理的规范要求还包括：</strong>不能在finally块中使用return语句。</li></ol><h3 id="1-10-缺陷检查规则"><a href="#1-10-缺陷检查规则" class="headerlink" title="1.10 缺陷检查规则"></a>1.10 缺陷检查规则</h3><p>缺陷检查主要是<strong>对Java源代码进行静态分析</strong>，扫描其中潜在的缺陷，比如：空指针异常、死循环等，这一阶段所应遵循的规则包括：</p><ol><li>不能使用单个字符定义StringBuffer和StringBuilder。</li><li>任何上锁的对象均需保证其锁可以被释放。</li><li>严格避免死循环的发生。</li><li>对于字符串中的点号（“.”）、竖线（“|”）和文件分隔符（“File.separator”）进行替代时，需要注意其特殊含义。</li></ol><blockquote><p><strong>“.”：匹配任意单个字符。</strong>在replaceAll中使用，它匹配所有内容。</p><p><strong>“|”：通常用作选项分隔符，</strong>它匹配字符间的空格</p><p><strong>“File.separator”：匹配特定平台的文件路径分隔符。</strong>在Windows上，这将被视为转义字符。</p></blockquote><ol start="5"><li>当synchronize对成员变量进行上锁时，该成员变量必须是final类型的。</li><li>synchronize上锁的成员变量类型一定不能是装箱类型。</li><li>所有被spring托管的类，其成员属性的初始化<strong>均要使用注入的方式。</strong></li><li>当使用try catch方式进行异常捕获，且需要在catch中对异常信息进行输出时，不得使用printStackTrace的方式。这种方式会导致后期分析代码困难。而应<strong>采用一些Log框架，方便用户检索和浏览日志。</strong></li><li>方法返回值包含操作状态代码时，该状态码不应被忽略</li><li>【%s】数组具有协变性，元素赋值类型与初始化类型不一致，此种情况可通过编译，但运行阶段会发生错误。</li><li>对于用户名和密码不应直接写在Java的文件中，避免泄露。而应将相应关键信息写在配置文件中进行读取。</li><li>方法和成员变量的命名不应相同，也不应通过大小写来进行区分。</li></ol><h2 id="2-单元测试之Java实践"><a href="#2-单元测试之Java实践" class="headerlink" title="2 单元测试之Java实践"></a>2 单元测试之Java实践</h2><h3 id="2-1-如何写单元测试"><a href="#2-1-如何写单元测试" class="headerlink" title="2.1 如何写单元测试"></a>2.1 如何写单元测试</h3><h4 id="2-1-1-基本流程"><a href="#2-1-1-基本流程" class="headerlink" title="2.1.1 基本流程"></a>2.1.1 基本流程</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282024759.png"></p><p><strong>单元测试的基本流程如下：</strong></p><p>首先，环境初始化；</p><p>其次，准备输入参数；</p><p>再次，调用待测试方法；</p><p>然后，检查输出；</p><p>最后，测试完成后环境复原。</p><h4 id="2-1-2-测试替身"><a href="#2-1-2-测试替身" class="headerlink" title="2.1.2 测试替身"></a>2.1.2 测试替身</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282025752.png"></p><p><strong>测试替身可用于隔离被测试的代码、加速执行顺序、使得随机行为变得确定、模拟特殊情况以及能够使测试访问隐藏信息等。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282025297.png"></p><p>常见的测试替身有四类：桩（Stub)、伪造对象（Fake)、测试间谋（Spy)以及模拟对象（Mock)。</p><ol><li>Stub(桩）:一般什么都不做，实现空的方法调用或者简单的硬编码返回即可。</li><li>Fake(伪造对象）:真实数据的简单版本，伪造真实对象的行为，但是没有副作用或者使用真实事物的其它后果。比如替换数据库的对象，而得到虚假的伪造对象。</li><li>Spy(测试间谋）:需要得到封闭对象内部状态的时候，就要用到测试间谋，事先学会反馈消息，然后潜入对象内部去获取对象的状态。测试间谋是一种测试替身，它用于记录过去发生的情况，这样测试在事后就能知道所发生的一切。</li><li>Mock(模拟对象）:模拟对象是一个特殊的测试间谋。是一个在特定的情况下可以配置行为的对象，规定了在什么情况下，返回什么样的值的一种测试替身。Mock已经有了非常成熟的对象库，包括JMock、Mockito和EasyMock等。</li></ol><blockquote><p><strong>重点讲解一下模拟对象（Mock)：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282028940.png"></p><p>假如我们有业务逻辑→数据存取→数据这三层逻辑，现在需要对“业务逻辑”层进行单元测试，那么我们可以使用Mock对数据存取与数据层的内容进行模拟，从而使上面的单元测试是独立的。</p></blockquote><h4 id="2-1-3-设计思路"><a href="#2-1-3-设计思路" class="headerlink" title="2.1.3 设计思路"></a>2.1.3 设计思路</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282028962.png"></p><p><strong>如何设计单元测试：</strong></p><p>**单元测试case的核心:**结合具体的应用场景、具体的输入数据与当前函数的功能实现，对于输出数据作出具体的预期，即可把全部待测试的分支都罗列了出来。</p><p>即：<strong>应用场景+输入数据+功能实现=输出数据。</strong></p><h4 id="2-1-4-断言-Assertions"><a href="#2-1-4-断言-Assertions" class="headerlink" title="2.1.4 断言(Assertions)"></a>2.1.4 断言(Assertions)</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282029555.png"></p><p>断言是一种在java单元测试中经常使用的测试方法。在单元测试中，我们<strong>使用“断言”来检验当前的测试结果是成功还是失败。</strong></p><blockquote><p><strong>常见的断言：</strong></p><p>Assert.assertNotNull</p><p>Assert.assertEquals</p><p>Assert.assertTrue</p><p>Assert.assertFalse</p><p>Assert.fail     </p></blockquote><p><strong>在单元测试中使用断言可以令预测结果自动呈现，无需人工对单元测试结果进行判断。</strong></p><h3 id="2-2-单元测试的运行"><a href="#2-2-单元测试的运行" class="headerlink" title="2.2 单元测试的运行"></a>2.2 单元测试的运行</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282031441.png"></p><h4 id="2-2-1-手动"><a href="#2-2-1-手动" class="headerlink" title="2.2.1 手动"></a>2.2.1 手动</h4><ol><li><strong>直接在IDE中执行</strong></li></ol><p>在开发编码完成之后，开发人员可以直接在自己的环境和编译器内运行单元测试。</p><ol start="2"><li><strong>使用maven的mvn test</strong></li></ol><p>Maven是目前java开发中最流行的项目构建工具，它非常全面的包含了很多功能。mvn test这个测试模块就可以为我们的单元测试提供极大的便利。</p><h4 id="2-2-2-自动"><a href="#2-2-2-自动" class="headerlink" title="2.2.2 自动"></a>2.2.2 自动</h4><p><strong>持续集成（Jenkins）：</strong>自动化持续集成是我们在项目中常用的一种单元测试的方法。通用工具为Jenkins，Jenkins是一种持续集成的工具，它的功能非常强大。他的主要的功能有软件发布和版本测试、外部调用监控。</p><h3 id="2-3-如何判断单元测试的质量"><a href="#2-3-如何判断单元测试的质量" class="headerlink" title="2.3 如何判断单元测试的质量"></a>2.3 如何判断单元测试的质量</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282032798.png"></p><p>衡量标准：</p><p>从<strong>主观层面</strong>，优秀的单元测试可读性高、易于维护、值得信赖.</p><p>从<strong>客观层面</strong>，使用单元测试代码覆盖率来衡。覆盖率工具包括：集成IDE和单独布署。</p><h2 id="3-如何做好-Code-Review"><a href="#3-如何做好-Code-Review" class="headerlink" title="3 如何做好 Code Review"></a>3 如何做好 Code Review</h2><h3 id="3-1-为什么要做好-Code-Review"><a href="#3-1-为什么要做好-Code-Review" class="headerlink" title="3.1 为什么要做好 Code Review"></a>3.1 为什么要做好 Code Review</h3><h4 id="3-1-1-Code-Review是提升代码质量的最好方法"><a href="#3-1-1-Code-Review是提升代码质量的最好方法" class="headerlink" title="3.1.1 Code Review是提升代码质量的最好方法"></a>3.1.1 Code Review是提升代码质量的最好方法</h4><p>强化Code Review是<strong>提升代码质量的第一选择。</strong></p><p>在代码开发过程中，我们越早发现问题、定位问题，在修复问题时付出的成本越小。</p><p>大约有50%以上的bug，都是在做Code Review时发现的。前期做好Code Review，后期将会减少反复修改等不必要的复工。</p><h4 id="3-1-2-Code-Review能够在团队内传递知识"><a href="#3-1-2-Code-Review能够在团队内传递知识" class="headerlink" title="3.1.2 Code Review能够在团队内传递知识"></a>3.1.2 Code Review能够在团队内传递知识</h4><p>从知识传递的角度看，<strong>Code Review是极为重要的。</strong></p><p>做好Code Review，能够帮助团队传递知识、沟通交流、互相学习，能够提升学习能力、提升编写代码能力、提升代码质量、提升工作效率、降低项目风险。</p><p>另外，基于codebase可以使我们了解项目全局，培养系统的思考方式。</p><h4 id="3-1-3-Code-Review是辅导怎么写代码的最好方法"><a href="#3-1-3-Code-Review是辅导怎么写代码的最好方法" class="headerlink" title="3.1.3 Code Review是辅导怎么写代码的最好方法"></a>3.1.3 Code Review是辅导怎么写代码的最好方法</h4><p>我们要意识到，做Code Review可以学习到别人的经验，同时也可以向别人传递我们的经验。</p><p>如果我们想辅导别人，<strong>最好的办法就是让对方先写一段代码，我们对他的代码进行Code Review。</strong>在辅导他人的过程中，我们可以快速地发现问题，从而帮助改进。</p><h4 id="3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力"><a href="#3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力" class="headerlink" title="3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力"></a>3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力</h4><p>工作中是否有Code Review对于公司或团队来说非常重要。不但对于公司或团队内的人员有所提升，而且能够吸引出色的开发者加入开发团队。</p><p>未做好Code Review的公司或团队有如下特点：</p><ol><li>代码质量差。</li><li>团队内人员备份差。</li><li>团队开发人员得不到有效的辅导，提高慢。</li></ol><h4 id="3-1-5-为什么要提高代码质量？"><a href="#3-1-5-为什么要提高代码质量？" class="headerlink" title="3.1.5 为什么要提高代码质量？"></a>3.1.5 为什么要提高代码质量？</h4><ol><li>提高代码质量可以提高代码的可读性。</li><li>提高代码质量可以提高代码的复用性和参考性。</li><li>提高代码质量可以减少bug出现的风险。</li><li>提高代码质量可以减少后期补丁的风险。</li><li>提高代码质量可以降低代码失控的风险。</li><li>提高代码质量可以降低项目重构和升级的麻烦。</li></ol><h4 id="3-1-6-为什么要提高写代码的能力"><a href="#3-1-6-为什么要提高写代码的能力" class="headerlink" title="3.1.6 为什么要提高写代码的能力"></a>3.1.6 为什么要提高写代码的能力</h4><ol><li>代码能力如果停滞不前，对于个人而言，将导致职业危机。</li><li>代码能力如果停滞不前，对于团队而言，将意味着团队没有成长。</li></ol><p><strong>Code Review是一个非常重要的提升代码质量和代码能力的手段。</strong>无论是从个人发展角度，还是团队发展角度，我们都需要重视Code Review。</p><h3 id="3-2-如何做好-Code-Review"><a href="#3-2-如何做好-Code-Review" class="headerlink" title="3.2 如何做好 Code Review"></a>3.2 如何做好 Code Review</h3><h4 id="3-2-1-在Code-Review中可能发现的问题"><a href="#3-2-1-在Code-Review中可能发现的问题" class="headerlink" title="3.2.1 在Code Review中可能发现的问题"></a>3.2.1 在Code Review中可能发现的问题</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282043808.png"></p><h4 id="3-2-2-在Code-Review中应有的态度"><a href="#3-2-2-在Code-Review中应有的态度" class="headerlink" title="3.2.2 在Code Review中应有的态度"></a>3.2.2 在Code Review中应有的态度</h4><ol><li><p>对所有检查的代码逻辑要做到“完全看懂”，对于审核的代码，熟悉程度要做到“如数家珍”。如果在审核代码后，对代码的逻辑和背后的原因仍然很模糊，则是一个失败的Code Review。</p></li><li><p>好代码的标准，不仅仅是“可以运行通过”，在正确性、可读性、可重用性、可运维性等方面上，都需要综合考虑。</p></li><li><p>建立Code Review和写代码一样重要的意识。即：</p><blockquote><ol><li>Code Review和写代码一样，也有产出，即产出更高质量的代码。</li><li>审核代码在很多情况下比写代码还要辛苦，需要理解和找出问题等。</li></ol></blockquote></li><li><p>以提升代码质量为最终目标。</p></li><li><p>要投入足够的时间和精力。</p><blockquote><pre><code>        1. 审核代码花费的时间经常和写代码一样多，有时甚至比写代码的时间更多，要有时间意识。        1. 要有责任意识。如果出现bug，不仅仅是写代码人员的职责，也不仅仅是QA的职责，代码审核者也需要承担相当大的责任。</code></pre></blockquote></li></ol><h4 id="3-2-3-在Code-Review之前，需要了解一流代码的特性"><a href="#3-2-3-在Code-Review之前，需要了解一流代码的特性" class="headerlink" title="3.2.3 在Code Review之前，需要了解一流代码的特性"></a>3.2.3 在Code Review之前，需要了解一流代码的特性</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282046798.png" alt="一流代码的特性"></p><p><strong>一流代码有以下特性：①高效性；②鲁棒性；③简洁；④简短；⑤可共享；⑥可测试；⑦可移植；⑧可监控；⑨可运维；⑩可扩展。</strong></p><p>将以上十条标准进行总结精简归纳为：</p><blockquote><ol><li>代码的正确和性能；</li><li>代码的可读和可维护性；</li><li>代码的可运维和可运行；</li><li>代码的可共享和可重用；</li></ol></blockquote><p>在Code Review时，综合考虑以上一流代码的特性，可以快速提升代码质量、提升编写代码的能力等。</p><h4 id="3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力"><a href="#3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力" class="headerlink" title="3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力"></a>3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力</h4><p><strong>通常bad code有以下特点：</strong></p><ol><li>5分钟内不能看懂的代码。</li></ol><p>​        不能快速看懂的代码，一定是有问题的代码，可以先抛回给编写代码人员进行修正。<strong>一般一个函数的操作不能超过6个step</strong>，如果超过这个数量，则需要重新调整编码逻辑。</p><ol start="2"><li>需要思考才能看懂的代码。</li></ol><p>​        好的代码阅读时基本不用动脑子，甚至看注释就能看懂。</p><ol start="3"><li>需要来回翻屏才能看懂的代码。</li></ol><p>​        好的代码，经常在一屏内就是一个完整的逻辑。</p><ol start="4"><li>没有空行或注释的代码。</li></ol><p>​        在Code Review时，发现不会用段落、不会写注释的代码，肯定不是好的程序员写的代码，可以直接打回给编写代码人员进行修正。</p><h4 id="3-2-5-Code-Review的注意事项"><a href="#3-2-5-Code-Review的注意事项" class="headerlink" title="3.2.5 Code Review的注意事项"></a>3.2.5 Code Review的注意事项</h4><ol><li>在必要时，review的双方做<strong>面对面的沟通。</strong></li></ol><p>​        面对面沟通并不是单指当面沟通，还包括云共享、电话、视频沟通等。在沟通时，对于背景、关键点等应进行说明，便于reviewer的理解。在必要时，应提供设计文档。</p><ol start="2"><li>对于关键模块，应该建<strong>立owner制度。</strong></li></ol><p>​        所有提交的代码，必须由owner做最终确认。由owner掌握全局，并建立明确的责任关系。</p><ol start="3"><li><p>检查中发现的问题，要一追到底。</p></li><li><p>要<strong>注意细节。</strong>对每一行提交的代码，都要进行检查。</p></li><li><p><strong>Code Review的方式，要小步快跑。</strong>每次提交review的代码量不要太多，降低复杂度。在特殊情况时，比如一个新模块的构建，最好逐步完成，通过多次进行提交。</p></li><li><p>要为Code Review<strong>预留出足够的时间。</strong>Code Review VS Coding的时间，有时可能达到1:1。在这里需要考虑到有时会做大的修改，科学地规划工作量，尽量避免出现时间倒排。</p></li><li><p>注意每天 review代码的数量不宜过多。</p></li></ol><h4 id="3-2-6-Code-Review的步骤"><a href="#3-2-6-Code-Review的步骤" class="headerlink" title="3.2.6 Code Review的步骤"></a>3.2.6 Code Review的步骤</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282051436.png" alt="、"></p><p>Code Review的步骤为以下几点：</p><p><strong>Step1：先看系统全貌</strong></p><p>不深究细节，浏览系统全貌，理清模块划分的逻辑、模块间的关系、如何构成的整个系统等。</p><p><strong>Step2：进入模块级别</strong></p><p>同样不深究细节，浏览模块内的全貌，判断模块切分是否合理，理清模块内的逻辑，明确关键数据、关键的类和函数等。</p><p><strong>Step3：理清类、函数内部的逻辑。</strong></p><p><strong>Step4：进入细节。</strong></p><p>比如Layout、命名等。</p><h4 id="3-2-7-人为因素"><a href="#3-2-7-人为因素" class="headerlink" title="3.2.7 人为因素"></a>3.2.7 人为因素</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282053170.png"></p><p>除了代码上的问题，在Code Review过程中还会有一些人为因素，例如：</p><p><strong>①QA人员</strong></p><p>好的QA人员不仅仅会发现系统中的bug，还会质疑或提出产品需求，挑战或优化系统架构和实现方式。</p><p><strong>②Code Reviewer</strong></p><p>好的代码审核人员不仅仅指出代码表面的问题，还会检查系统需求分析的质量、接口或函数定义的合理性、模块划分的合理性、系统关键机制的合理性等。</p><h3 id="3-3-例子：Python-代码的-Code-Review"><a href="#3-3-例子：Python-代码的-Code-Review" class="headerlink" title="3.3 例子：Python 代码的 Code Review"></a>3.3 例子：Python 代码的 Code Review</h3><h4 id="3-3-1-Python的编码规范"><a href="#3-3-1-Python的编码规范" class="headerlink" title="3.3.1 Python的编码规范"></a>3.3.1 Python的编码规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282111474.png"></p><ul><li><p>代码要写的漂亮。</p></li><li><p>代码要<strong>明确直接</strong>，不要含蓄表达。</p></li><li><p>代码要<strong>简洁</strong>，一个函数可以实现的功能就不要写两个函数。</p></li><li><p><strong>代码深奥胜过代码复杂</strong>。代码可以写的深奥难懂，但是不能写的过于复杂。</p></li><li><p>代码要<strong>平铺直叙</strong>，不要层层嵌套。</p></li><li><p>代码要做到<strong>合理间隔。</strong></p></li><li><p>代码<strong>可读性</strong>非常重要。</p></li><li><p>代码要有普适性。尽量规避代码特殊性，用最简洁最通用的代码来实现。</p></li><li><p>代码要实用。</p></li><li><p>要重视所有发现的错误。</p></li><li><p>代码逻辑要清晰。在含糊混乱的面前，我们要拒绝猜测。读写代码时，不要出现“好像”、“可能”、“似乎”等猜测。当一段代码很难懂的时候，代码一定存在问题。</p></li><li><p>写代码要注重行动。</p></li><li><p>代码实现方法要简洁。如果一个方法很难解释，就意味着这个方法存在一定的问题。</p></li><li><p>要重视命名空间的使用。</p></li></ul><h4 id="3-3-2关于Python编程规范的部分说明"><a href="#3-3-2关于Python编程规范的部分说明" class="headerlink" title="3.3.2关于Python编程规范的部分说明"></a>3.3.2关于Python编程规范的部分说明</h4><p>Python编程规范有九个维度。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282113051.png"></p><h5 id="1-模块的划分"><a href="#1-模块的划分" class="headerlink" title="1 模块的划分"></a>1 模块的划分</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282118231.png"></p><p>我们要对模块有概念，这是整个系统的基础。</p><ol><li><p>一个.py文件是一个模块。</p></li><li><p>模块的划分对软件的长期维护非常重要。</p></li><li><p>每个模块都应该有特定的功能。</p></li></ol><blockquote><p>比如：配置文件的读取，网页文件的写入，网页文件的解析，一个内存数据表，一个抓取的线程等等。</p></blockquote><ol start="4"><li>多个本应独立的模块，写到一个.py文件中是常见的错误。从Code Review角度看，首先就是要看模块切分的对不对。</li></ol><h5 id="2-数据的封装"><a href="#2-数据的封装" class="headerlink" title="2 数据的封装"></a>2 数据的封装</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282117284.png"></p><p>在Code Review时，要着重注意数据是否封装这一问题。</p><h5 id="3-import"><a href="#3-import" class="headerlink" title="3 import"></a>3 import</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282118516.png"></p><p>Import在使用过程中，禁止使用from xxx import yyy语法直接导入类或函数。禁止使用from xxx import *这样的方法。这样做的目标是：容易判断代码中使用外部变量或函数的来源。</p><p>如果使用禁止中的语法，会大大增加判断来源的难度，以及代码阅读的难度。</p><p>在Code Review时，遇到这种情况，及时将代码打回给编程人员进行修正。</p><h5 id="4-异常"><a href="#4-异常" class="headerlink" title="4 异常"></a>4 异常</h5><p>对于异常的处理有以下几点需要注意：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282120853.png"></p><blockquote><ol><li>异常的使用</li></ol><p>​        使用异常前请需要详细了解异常的行为。不要主动抛出异常，使用返回值。如果一定要抛异常，需要注释进行说明。</p><ol start="2"><li>异常的获取强制</li></ol><p>​        除非重新抛出异常，否则禁止使用except:捕获所有异常，不建议捕获Exception或StandardError。</p><p>​        在实际编码中建议try中的代码尽可能少，避免catch住未预期的异常，掩藏掉真正的错误。底线是至少要打印异常的日志，而不是捕获后直接pass通过。</p><p>​        在对异常进行处理时尽量针对特定操作的特定异常来捕获。</p><ol start="3"><li>函数的返回值</li></ol><p>​        如果函数会抛出异常，需要在函数的注释中明确说明。</p></blockquote><p>在Code Review时，需要注意上述问题，及时返回给编程人员进行修正。</p><h5 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5 构造函数"></a>5 构造函数</h5><p>对于构造函数有以下几点需要注意：</p><ol><li>规范：</li></ol><p>类构造函数应该尽量简单，不能包含可能失败或过于复杂的操作。</p><ol start="2"><li>解读：</li></ol><p>在构造函数中常出现的错误是：无法判断、或捕获异常。</p><h5 id="6-函数返回值"><a href="#6-函数返回值" class="headerlink" title="6 函数返回值"></a>6 函数返回值</h5><p>对于函数返回值有以下几点需要注意：</p><ol><li>规范：</li></ol><blockquote><p>函数返回值必须小于等于3个。返回值超过3个时必须通过class/namedtuple/dict等具名形式进行包装。</p></blockquote><ol start="2"><li>解读：</li></ol><blockquote><p>a. 多数情况下的错误，是因为很多人不会思考和设计函数的语义。</p><p>函数描述涉及的三要素为：功能描述、传入参数描述和返回值描述。</p><p>每个函数都应该有足够明确的语义。基于函数的语义，函数的返回值有三种类型：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282122993.png"></p><p>b .另外，函数需要有返回值，对于正确或错误的情况，在返回值中要有体现。</p><p>c .还有一个问题是：Python的数据格式不需要定义，过于灵活。当程序规模变大、维护周期变长时，会导致后期极难维护。</p><p>应对措施是：多写注释，写清楚返回值说明、参数说明。</p></blockquote><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111282123350.png"></p><p>在Code Review时，注释未写清楚的代码，一定要打回给编程人员，进行修正、补注释。</p><h5 id="7-代码长度"><a href="#7-代码长度" class="headerlink" title="7 代码长度"></a>7 代码长度</h5><p>关于代码长度有以下几点需要注意：</p><ol><li>每行不得超过120个字符。避免在终端上显示出现折行。</li><li>函数长度不得超过100行。函数过长会增加理解函数逻辑的难度。Python的函数应尽量控制在30~40行之间。</li></ol><p>在Code Review时，代码过长，建议全部打回给编程人员进行修正。</p><h5 id="8-空行、空格"><a href="#8-空行、空格" class="headerlink" title="8 空行、空格"></a>8 空行、空格</h5><p>关于空行、空格有以下几点需要注意：</p><ol><li>空行</li></ol><p>​        文件及定义之间隔两个空行。比如类或全局函数。类方法之间隔一个空行。</p><ol start="2"><li>空格</li></ol><p>​        逗号、分号、冒号前不加空格，后边加一个空格。所有二元运算符前后各加一个空格。</p><p>在Code Review时，需要着重注意空行和空格。空行和空格不是可有可无的。空行和空格的存在，是为了增加可读性。不好读的代码，一律打回给编程人员进行修正。</p><h5 id="9-注释"><a href="#9-注释" class="headerlink" title="9 注释"></a>9 注释</h5><p>关于注释有以下几点需要注意：</p><p>Python中的注释有一个特殊之处是docstring，<strong>docstring要和“＃”注意区分开。</strong></p><blockquote><p>相关规范有：</p><ol><li><p>使用docstring描述module、 function 、class和method接口时，<strong>docstring必须用三个双引号括起来。</strong></p></li><li><p>对外接口部分必须用docstring描述。内部接口视情况自行决定是否写docstring。</p></li><li><p>接口的docstring描述<strong>至少包括功能简介、参数、返回值。</strong>如果可能抛出异常，必须使用注释进行说明。</p></li><li><p><strong>每个文件都必须有文件声明</strong>，文件声明必须包括以下信息：版权声明、功能和用途简介、修改人及联系方式。</p></li></ol></blockquote><p>在Code Review时，不符合上述规范的，及时打回给编程人员进行修正。</p><h3 id="3-4-如何成为一个好的reviewer"><a href="#3-4-如何成为一个好的reviewer" class="headerlink" title="3.4 如何成为一个好的reviewer"></a>3.4 如何成为一个好的reviewer</h3><p>代码审核的质量，和审核者的代码能力直接相关。代码审核的质量差，反映的是审核者的代码水平。如果作为一个代码审核员不会写代码，就要承认真相，并且要不断提高自己的代码能力。</p><p>学习资料：</p><ol><li>关于代码的书籍：《编写可读代码的艺术》，《代码整洁之道》。</li><li>综合的书籍：《代码大全》，《201  principles of software development》。</li><li>其他：《代码的艺术》课程，Python Good Coder考试指南。</li></ol><h3 id="3-5-公司针对-Code-Review-的措施"><a href="#3-5-公司针对-Code-Review-的措施" class="headerlink" title="3.5 公司针对 Code Review 的措施"></a>3.5 公司针对 Code Review 的措施</h3><p><strong>1、建立高效可运营的代码审核机制，提升代码质量，降低代码评审成本。</strong></p><blockquote><p>①基于平台：icode+bugbye</p><p>②代码检查规则分级，分为ERROR、WARNING、ADVICE三类，对ERROR级别阻塞提交。</p><p>③通过统计数据驱动代码检测规则的优化。</p></blockquote><p><strong>2、通过工程能力地图考察项目的Code Review情况。</strong></p><p><strong>3、所有的Code Review行为，都基于icode平台进行。良好的工具可以帮助更好的进行代码审核</strong></p><h3 id="3-6-Code-Review-总结"><a href="#3-6-Code-Review-总结" class="headerlink" title="3.6 Code Review 总结"></a>3.6 Code Review 总结</h3><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>百度高效研发实战训练营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>百度高效研发实战训练营Step3</title>
    <link href="/bitTraingClub3.html"/>
    <url>/bitTraingClub3.html</url>
    
    <content type="html"><![CDATA[<h1 id="百度高效研发实战训练营Step3"><a href="#百度高效研发实战训练营Step3" class="headerlink" title="百度高效研发实战训练营Step3"></a>百度高效研发实战训练营Step3</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-质量意识"><a href="#1-质量意识" class="headerlink" title="1 质量意识"></a>1 质量意识</h2><h3 id="1-1-质量的基本概念"><a href="#1-1-质量的基本概念" class="headerlink" title="1.1 质量的基本概念"></a>1.1 质量的基本概念</h3><h4 id="1-1-1-质量重要性的认识"><a href="#1-1-1-质量重要性的认识" class="headerlink" title="1.1.1 质量重要性的认识"></a>1.1.1 质量重要性的认识</h4><p>随着技术更新，市场竞争的加剧，质量问题成为困扰不少企业的一大难题，也给一些企业造成了巨大的损失，这就使得项目质量的重要性不断凸显。</p><p>通过对于这些失败案例的分析不难发现，项目的质量保证是一个需要<strong>项目全体成员参与</strong>的重要工作，只有在项目团队的共同努力下，才能有效保证项目的质量，为企业和社会创造价值。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281614025.png"></p><p>项目管理三要素为<strong>质量、时间、成本</strong>，三个要素缺一不可、相互制约，一味追求某一要素的做法是不明智的。一个成功的项目必然是在三者的取舍间达成了一个平衡。</p><h4 id="1-1-2-质量保证和测试的关系"><a href="#1-1-2-质量保证和测试的关系" class="headerlink" title="1.1.2 质量保证和测试的关系"></a>1.1.2 质量保证和测试的关系</h4><p>质量问题有很多种，常见的有代码缺陷、产品缺陷、Bug、用户体验差、性能差、服务不稳、安全问题、可兼容性差等。我们经常通过测试来发现问题，并将发现的问题分<strong>功能性测试类问题和用户体验评估类问题。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281615870.png"></p><p>测试工作是质量保证工作中的重要一环，但是我们应该认识到，质量保证工作不能只依靠测试的反馈，而应该贯穿项目开发的整个过程。</p><h4 id="1-1-3-Bug的基本认识"><a href="#1-1-3-Bug的基本认识" class="headerlink" title="1.1.3 Bug的基本认识"></a>1.1.3 Bug的基本认识</h4><p><strong>Bug</strong>是程序中的缺陷和问题，<strong>属于功能性测试类问题的范畴</strong>， Bug是一种很常见的质量问题，也是我们在项目开发中应该尽量减少或避免的质量问题。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281617228.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281618840.png"></p><p>Bug的修复有一套完整的规定流程。</p><p>首先，测试人员或者用户发现Bug后，将其置为<strong>激活状态</strong>；开发人员收到激活状态的Bug后，对其进行修复，修复过程中， Bug状态为<strong>处理中</strong>；修复完成后，开发人员将其置为<strong>解决状态</strong>；测试人员再对其进行<strong>验证</strong>，若通过，则将其关闭，否则，重新激活Bug即重启状态，交予开发人员继续修复，直至验证通过。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292217099.png"></p><p>从这一流程可以看到，<strong>Bug有五种状态，Open（激活）、In Process（处理中）、Resolved（解决）、closed（关闭）、Reopen（重启）</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281621054.png"></p><p>Bug生命周期有一定规律性。以传统软件中的瀑布模型举例，85%的问题在项目初期的编码阶段引入，在后期测试阶段，发现Bug的数量会逐渐增多，与之对应的修复成本也会急剧增加。可见，降低<strong>修复成本最有效的方式，就是在Bug引入的阶段就及时发现并修复Bug。</strong></p><h3 id="1-2-Bug提交方法"><a href="#1-2-Bug提交方法" class="headerlink" title="1.2 Bug提交方法"></a>1.2 Bug提交方法</h3><blockquote><p>Bug提交需要反馈渠道，Bug的反馈渠道分为内部用户反馈渠道和外部用户反馈渠道两种。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281623796.png"></p><ol><li>内部用户反馈渠道包括：产品Icafe空间、产品论坛、Bugs邮件组、Bugs平台。</li><li>外部用户反馈渠道包括：产品自身反馈渠道和产品接入反馈平台。</li></ol></blockquote><p><strong>Bug的提交有严格的格式要求，提交的Bug反馈应包括以下七个方面的内容：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281624518.png"></p><p>正确提交Bug能确保负责人能够清晰了解问题，直接进行数据挖掘，找到Bug所有的属性，便于后续维护工作的开展。</p><h3 id="1-3-质量保证在项目各阶段的实现"><a href="#1-3-质量保证在项目各阶段的实现" class="headerlink" title="1.3 质量保证在项目各阶段的实现"></a>1.3 质量保证在项目各阶段的实现</h3><p>质量的保证不能仅仅依靠测试人员，而是需要贯穿项目的各个阶段。</p><p>Bug的发现和修复是项目质量保证的一个重要方面，但质量保证工作绝不仅仅是修复Bug这么简单。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281626934.png"></p><p>项目的开发整体路径包括：需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、上线阶段以及线上阶段。</p><p>在一个项目开发的各个不同阶段，质量保证工作的要求和思路均有一定的不同，下面我们来展现质量保证工作在各个阶段的具体实现。</p><h4 id="1-3-1-需求与设计阶段的质量保证工作"><a href="#1-3-1-需求与设计阶段的质量保证工作" class="headerlink" title="1.3.1 需求与设计阶段的质量保证工作"></a>1.3.1 需求与设计阶段的质量保证工作</h4><p>需求与设计阶段是项目开始的重要阶段，只有从客户真正的需求出发，才能设计出真正令客户满意的产品。</p><p>在一阶段，质量保证工作的关键点有三：</p><ol><li><p><strong>需求评审：</strong>站在用户的角度思考和挖掘需求，是设计和开发的前提性条件。</p></li><li><p><strong>需求的变更管理：</strong>用户的需求始终在改变，建立一套完善机制去及时适应需求的变更十分重要。</p></li><li><p><strong>设计评审：</strong>通过评审需求的可行性和设计的相关风险，可以极大降低设计风险，避免人力浪费。</p></li></ol><h4 id="1-3-2-开发与测试阶段的质量保证工作"><a href="#1-3-2-开发与测试阶段的质量保证工作" class="headerlink" title="1.3.2 开发与测试阶段的质量保证工作"></a>1.3.2 开发与测试阶段的质量保证工作</h4><p>在开发阶段，质量保证工作最重要的有两点：<strong>单元测试和代码评审。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281632782.png"></p><blockquote><p>单元测试的作用很多，主要有：</p><p>（1） 调试代码，确保代码实时可编译。</p><p>（2） 验证逻辑，减少代码中的Bug。</p><p>（3） 作为一个最细粒度回归测试，实时反馈代码的质量。</p></blockquote><blockquote><p>代码评审也同样十分重要，它的作用主要为：</p><p>（1） 保持代码风格的一致和可读性，利于贯彻编程规范。</p><p>（2） 提高代码质量，减少Bug。</p><p>（3） 促进互相交流学习，提升团队的整体研发能力，进而提高企业的整体竞争力。</p></blockquote><p>而在测试阶段，我们的主要任务是<strong>测试功能性测试类问题。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281632723.png"></p><blockquote><p>测试阶段一般流程为：</p><p>第一步：<strong>撰写测试方案</strong>。由测试人员编写方案并提交开发人员评审。</p><p>第二步：<strong>进行单元测试</strong>。由开发人员编写用例，并交给测试人员评审。</p><p>第三步：<strong>进行功能性测试</strong>。由测试人员设计和编写用例。</p><p>第四步：<strong>进行性能/压力等测试</strong>。测试人员根据项目情况决定是否进行。</p><p>第五步：<strong>自动化和持续集成</strong>。将测试自动化，并把流程加入持续集成。</p><p>第六步：<strong>撰写测试报告</strong>。测试人员要在大版本时编写测试报告。</p></blockquote><p>测试环节涉及很多的内容，包括了：</p><p>（1）测试方案。</p><p>（2）自动化/持续集成。</p><p>（3）测试报告。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281634364.png"></p><p>在这一环节中，<strong>撰写测试方案是对该阶段工作的整体规划。</strong>测试方案描绘了测试和质量保证的各种工作，规划了如何组织测试，方案中包括了：质量目标、风险评估、测试范围、测试优先级、测试方法、测试流程、测试计划和测试设计的内容。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281634848.png"></p><p><strong>常用的测试方法有</strong>：黑盒/白盒、静态测试/动态测试、自动化测试/手工测试、验收测试/α测试/β测试、单元测试/模块测试/集成测试/联调测试/系统测试、功能性测试/性能测试/压力测试/异常测试/安全测试、接口测试/用户场景测试、回归测试、探索性测试等。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281635604.png"></p><p>不同的测试方法有不同的特点和擅长解决的问题。测试的侧重点不同，发现的问题也不同。我们需要根据测试方案，来选择合适的测试方法，提高测试的效率。为此，在前期的测试和设计方案评审时要及早发现问题，避免无效劳动，提高测试效率。</p><p>同样，自动化和持续集成也是有效提高测试效率的方法。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281635791.png"></p><p><strong>自动化包括流程自动化和测试自动化。</strong>流程自动化包括编译、部署、发布、回滚、上线和测试阶段。测试自动化可以降低成本并保证测试结果，降低风险。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281636766.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281637773.png"></p><p>而基于自动化，我们可以搭建串联工作流，即持续集成，可以将代码提交、编译、模块测试、部署、系统测试、发布这一循环性流程集成在一起，从而提高工作效率，保证持续的质量反馈。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281637103.png"></p><p>测试完成后需要撰写详细的测试报告，以方便后期的持续维护和迭代，其内容包括：</p><p>测试结果、质量风险评估、质量评估、测试过程描述、缺陷分析、评估改进意见、测试版本/测试人员/测试时间。</p><h4 id="1-3-3-上线与线上阶段的质量保证工作"><a href="#1-3-3-上线与线上阶段的质量保证工作" class="headerlink" title="1.3.3 上线与线上阶段的质量保证工作"></a>1.3.3 上线与线上阶段的质量保证工作</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281638579.png" alt="image-20211128163800434"></p><p><strong>上线阶段包括上线过程和回滚过程。</strong></p><p>上线阶段的上线方案需要经过评审和测试，对于重点项目，还应有回滚方案和相应的评审和测试工作。</p><p>上线后，我们需要进行线上测试，常用的线上测试有三类：众包测试、用户反馈和业务监控、产品评测。</p><blockquote><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281641413.png"></p><p>（1）<strong>众包测试：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281642738.png">众包测试的目的是使更多的用户参与测试，降低测试成本。众测服务分为四类：测试类（包括探索性测试、用例组合爆炸测试），产品体验（包括产品建议、Badcase收集）、评估评测（包括大数据量评估标注、降低成本）、用户调研（产品需求调研、用户反馈)。一个众测平台：<a href="http://test.baidu.com/">http://test.baidu.com</a></p><p>（2）<strong>用户反馈和业务监控</strong>：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281642375.png">目的则是为了实现线上问题闭环，通过用户反馈和业务监控可以解决大部分的线上问题。步骤分为收集、分发、定位和解决。主要平台有反馈平台、Bugs平台和 Monitor平台。</p><p>（3）<strong>产品评测：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281643572.png"></p><p>包括用户反馈分析、产品Bug分析、Top问题梳理和竞品对比分析。</p><p>→ <strong>用户反馈分析</strong>是指对用户反馈的问题进行分析。→ 产品Bug分析是指对产品的Bug进行分析，然后解决问题最大的Bug。</p><p>→ <strong>Top问题梳理</strong>是指，对问题进行梳理分类，解决最突出的问题。</p><p>→ <strong>竞品对比分析</strong>是指对自家产品和市场上同类型产品进行分析。</p></blockquote><p>从对各个阶段质量保证工作的分析中，我们不难看出，每一个阶段的质量保证工作都需要多方角色的共同参与。可见，项目的出色质量来源于<strong>每个环节的严格把控和每个成员的共同参与，这是团队质量意识的两大核心。</strong></p><h3 id="1-4-质量保证意识的4个核心内容"><a href="#1-4-质量保证意识的4个核心内容" class="headerlink" title="1.4 质量保证意识的4个核心内容"></a>1.4 质量保证意识的4个核心内容</h3><h4 id="1-4-1-质量保证工作存在于每一个环节"><a href="#1-4-1-质量保证工作存在于每一个环节" class="headerlink" title="1.4.1 质量保证工作存在于每一个环节"></a>1.4.1 质量保证工作存在于每一个环节</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281647902.png"></p><h4 id="1-4-2-每一个成员都需要对质量负责"><a href="#1-4-2-每一个成员都需要对质量负责" class="headerlink" title="1.4.2 每一个成员都需要对质量负责"></a>1.4.2 每一个成员都需要对质量负责</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281647522.png"></p><h4 id="1-4-3-测试是一种核心的质量保证工作"><a href="#1-4-3-测试是一种核心的质量保证工作" class="headerlink" title="1.4.3 测试是一种核心的质量保证工作"></a>1.4.3 测试是一种核心的质量保证工作</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281646302.png"></p><h4 id="1-4-4-尽早发现问题，尽早解决问题"><a href="#1-4-4-尽早发现问题，尽早解决问题" class="headerlink" title="1.4.4 尽早发现问题，尽早解决问题"></a>1.4.4 尽早发现问题，尽早解决问题</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281647888.png"></p><h2 id="2-代码单元测试总体介绍"><a href="#2-代码单元测试总体介绍" class="headerlink" title="2 代码单元测试总体介绍"></a>2 代码单元测试总体介绍</h2><h3 id="2-1-单元测试基础"><a href="#2-1-单元测试基础" class="headerlink" title="2.1 单元测试基础"></a>2.1 单元测试基础</h3><h4 id="2-1-1-单元测试的误区"><a href="#2-1-1-单元测试的误区" class="headerlink" title="2.1.1 单元测试的误区"></a>2.1.1 单元测试的误区</h4><p>单元测试存在一些认识上的误区，包括：</p><ol><li>开发单元测试代码的工作量大。</li><li>做单元测试不属于开发人员的职责。</li><li>代码正确率高，进行单元测试必要性不大。</li><li>后期有集成测试，前期进行单元测试必要性不大。</li><li>单元测试无法带来显著收益，效率不高。</li></ol><h4 id="2-1-2-单元测试的概念"><a href="#2-1-2-单元测试的概念" class="headerlink" title="2.1.2 单元测试的概念"></a>2.1.2 单元测试的概念</h4><p><em><strong>在维基百科中，单元测试的定义为：一段代码调用另一段代码，随后检验一些假设的正确性。</strong></em></p><p><em><strong>在百度百科中，单元测试是指对软件中的最小可测试单元进行检查和验证。</strong></em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281653449.png"></p><p>那么我们不禁要问：一次编写的单元测试是否只是为了验证该次开发过程中对应的代码逻辑的正确性？</p><p>其实不然，单元测试不仅在于实现问题中的功能，优秀的单元测试作用长久，可以减少后续工作的负担，从而提升整体生产力。</p><h4 id="2-1-3-常见的单元测试问题"><a href="#2-1-3-常见的单元测试问题" class="headerlink" title="2.1.3 常见的单元测试问题"></a>2.1.3 常见的单元测试问题</h4><p>目前单元测试中存在一些常见的问题：</p><ol><li>使用System.out输出测试结果，依赖人去判断测试是否正确。</li><li>不使用Assert(断言)对测试结果进行判断。</li></ol><p><em>在以上两种情形都需要依赖人与电脑的交互来判断此case是否成功，人的工作量较大；**在实际的单元测试中，应当使用断言进行判断，使 case运行时自动输出结果。</em></p><ol start="3"><li>没有边界检查。</li><li>多个测试分支放入一个单元测试方法中。</li></ol><p><em>这种情况会导致一旦出现运行失败时，难以判断出现错误的分支所在。</em></p><ol start="5"><li>测试case环境相关（依赖已知库表、时间）。</li></ol><p><em>对于这种情况，应当做出修改，使输入参数为确定的值。</em></p><ol start="6"><li>测试方法执行有先后顺序。</li></ol><p><em>在实际测试过程中，由于不同的用于运行单元测试的测试框架对于case执行顺序有自己的行为，故单元测试实际执行顺序存在不确定性。</em></p><h4 id="2-1-4-优秀的单元测试"><a href="#2-1-4-优秀的单元测试" class="headerlink" title="2.1.4 优秀的单元测试"></a>2.1.4 优秀的单元测试</h4><p>优秀的单元测试需要以下原则：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281655957.png"></p><ol><li>单元测试彼此之间应具备<strong>独立性</strong>。一个单元测试应独立于其它测试及运行它的环境。</li><li>一个优秀的单元测试是<strong>可重复</strong>的。它需要具备多次运行的能力，若不可重复，则不能算作优秀的单元测试。</li><li>优秀的单元测试<strong>可自动化</strong>。自动化具备双重含义：第一，单元测试<strong>可依赖于现有工具自动化运行</strong>；第二，单元测试执行成功与否<strong>可自动进行判断</strong>，而不依赖于人为判断。</li><li>优秀的单元测试是<strong>彻底的</strong>。单元测试对于被测试对象而言需要覆盖全部的分支。</li></ol><h3 id="2-2-单元测试的意义与建议"><a href="#2-2-单元测试的意义与建议" class="headerlink" title="2.2 单元测试的意义与建议"></a>2.2 单元测试的意义与建议</h3><h4 id="2-2-1-什么情况下做单元测试"><a href="#2-2-1-什么情况下做单元测试" class="headerlink" title="2.2.1 什么情况下做单元测试"></a>2.2.1 什么情况下做单元测试</h4><p><strong>（1）单元测试的好处</strong></p><p>①带来<strong>更高的测试覆盖率</strong>：有些分支问题在集成测试过程中很难发现，但在单元测试中极易发现。</p><p>②<strong>提高团队效率</strong>：单元测试在开发完后立即执行，将测试提前一步，不必等集成测试时才发现问题。</p><p>③<strong>自信的重构和改进实现。</strong></p><p>④<strong>将预期的行为文档化</strong>：完整的单元测试是产品代码的最好文档。</p><p><strong>（2）不当的单元测试会降低生产力</strong></p><p>单元测试并不是越多越好，不当的单元测试会降低生产力。</p><p>①单元测试的工作量与普通代码的工作量的比例介于1:1~1.5:1。</p><p>②整体项目的单元测试运行时间随着单元测试case增多线性增长，测试的执行速度影响每次变更等待的时间。</p><p>③单元测试的代码，也需要长期维护。</p><p><strong>（3）如何选择单元测试的对象</strong></p><p>不写单元测试不好，单元测试写多了也不好，这就要求我们要细心选择单元测试的对象。</p><p>在进行单元测试的时候，应<strong>重点关注核心业务逻辑代码、重用性高的代码与调用频繁的代码</strong>，后两者较为相近。</p><h4 id="2-2-2-不同场景下的单元测试tips"><a href="#2-2-2-不同场景下的单元测试tips" class="headerlink" title="2.2.2 不同场景下的单元测试tips"></a>2.2.2 不同场景下的单元测试tips</h4><p>1）Java Web项目底层的BO\DAO大体都是工具自动生成，无需额外单测，但是<strong>Action(Controller)<strong>层不含有较多的业务逻辑，</strong>需要通过集成测试</strong>发现问题。要注意的是<strong>java web项目</strong>的核心业务逻辑主要存在于Service层代码中，需要<strong>着重进行单元测试</strong>。</p><p>（2）平台类Java项目虽然在单独的场景下几乎不会出现问题，但是交叉混合时可能存在问题。而且由于平台类项目更多的兼顾不同的复杂的应用场景，所以在测试时要尽量做到全面。值得注意的是平台类Java项目的分支较多，所以<strong>要求在单元测试时要做到覆盖分支全面</strong>。</p><p>（3）组件类Java项目和平台类项目类似，也需要侧重分支覆盖全面，包括异常调用情况的覆盖。</p><p>（4）Hadoop的MR任务属于特殊的JAVA程序，集成测试成本高，主要体现在时间成本上。在进行单测时，<strong>可以将核心逻辑代码抽取出来，单独测试。</strong></p><h2 id="3-Python单元测试"><a href="#3-Python单元测试" class="headerlink" title="3 Python单元测试"></a>3 Python单元测试</h2><h3 id="3-1-单元测试的概念、工具与方法"><a href="#3-1-单元测试的概念、工具与方法" class="headerlink" title="3.1 单元测试的概念、工具与方法"></a>3.1 单元测试的概念、工具与方法</h3><h4 id="3-1-1-单元测试的概念"><a href="#3-1-1-单元测试的概念" class="headerlink" title="3.1.1 单元测试的概念"></a>3.1.1 单元测试的概念</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281703584.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281704541.png"></p><p>测试具有许多种不同的类型，比如说单元测试、模块测试、联调测试、系统测试、交付测试等。在这些测试之中，<strong>单元测试是最先要完成的</strong>。单元测试通常是由开发者去完成，用来验证代码中的函数是否符合预期。因此，它聚焦于函数的逻辑以及核心的算法是否正确。<em><strong>通常而言，一个单元测试用例是用于判断在某个特定条件或场景下，某个特定函数的行为。</strong></em></p><h4 id="3-1-2-单元测试的意义"><a href="#3-1-2-单元测试的意义" class="headerlink" title="3.1.2 单元测试的意义"></a>3.1.2 单元测试的意义</h4><p><strong>单元测试的意义包括两个方面。</strong></p><p>（1）质量</p><blockquote><p>①单元测试主要针对函数，<strong>颗粒度小、测试针对性强</strong>，bug更容易暴露；</p><p>②由于单元测试覆盖面较窄，无需考虑其它函数或者所依赖的模块，所以它的<strong>场景易构造，核心功能验证更充分</strong>；</p><p>③进行单元测试保证整体代码结构良好，使代码就具有较高的可测性和可维护性。</p></blockquote><p>（2）效率</p><p>单元测试能够提高开发效率，主要表现在：</p><blockquote><p>①单元测试<strong>进行的时间较早，测试场景构建快</strong>，可有效减少调试时间。</p><p>②由于单元测试<strong>只针对修改的代码</strong>展开测试，无需考虑额外内容，所以在较短时间内即可把预期的逻辑测试充分。</p><p>③单元测试<strong>能够在项目开发初期发现的bug</strong>，bug发现的时间越早，所带来的收益越大。由于尽早发现bug能够节省整个项目开发的时间，所以单元测试可加快开发效率，缩短开发周期。</p></blockquote><h4 id="3-1-3-单元测试框架"><a href="#3-1-3-单元测试框架" class="headerlink" title="3.1.3 单元测试框架"></a>3.1.3 单元测试框架</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281706919.png"></p><p><strong>Unitest的基础概念</strong></p><blockquote><p>在做单元测试之前，需要先了解一下Unittest的几个基础概念。</p><p>①**Test(测试用例)**，针对一个特定场景，特定目的具体测试过程。</p><p><em>比如说一个函数通过一组输入测试它，就是一个测试用例；如果一个函数通过三组输入来测试，即为三个测试用例。</em></p><p>②<strong>TestCase（测试类）</strong>，可以包含同一个测试对象的多个测试用例。</p><p><em>如果一个函数通过三组输入来测试，也就是三个测试用例，这三个测试用例可以合成为一个测试类。</em></p><p>③<strong>TestSuite（测试集）</strong>，可以包含多个测试类的多个测试用例。</p><p>④<strong>Assertion（断言）</strong>，必须使用断言判断测试结果。</p><p>⑤<strong>TestFixture</strong>，为测试做统一的准备和清除工作，通常是初始化，连接数据库，准备数据，断开数据库，清除现场等。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281711746.png"></p><p>扩展来说，TestFixture有四种最常使用的作用范围，分别为：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281710167.png"></p><blockquote><ol><li>setUp：在测试类的每个测试用例执行前执行。</li><li>teardown：在测试类的每个测试用例执行后执行。</li><li>setUpClass：在测试类的第一个测试用例执行前执行。</li><li>tearDownClass：在测试类的最后一个测试用例执行后执行。</li></ol></blockquote><p>TestFixture可以让单元测试代码更简单，但并非必须使用，也不要求配对出现。</p></blockquote><h4 id="3-1-4-单元测试的规范"><a href="#3-1-4-单元测试的规范" class="headerlink" title="3.1.4 单元测试的规范"></a>3.1.4 单元测试的规范</h4><p>如下是单元测试涉及的规范。</p><p>（1）所有的单元测试<strong>必须使用断言（assert）判断结果</strong>，禁止出现无断言的测试用例；</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281712364.webp"></p><p>使用断言，不但有利于他人理解，而且一旦出现不符合预期的情况，可以立即找出问题。</p><p>可以使用assertEqual, assertNotEqual 来判断相等或不相等，assertTrue,assertFalse 来判断Boolean, assertRaises 判断抛出的异常是否符合预期。</p><p>（2）测试用例需要具有自表述能力，达到见名知意。</p><p>比如命名test_login_with_invalid_password()，通过它的名字便可知它是用一个非法的密码去测试登录功能，具有自表述能力；但是如果命名为 test_login_case_（），名字减少了很多信息，难以得知它具体在做什么，不具有自表述能力。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281714852.png"></p><p>（3）测试用例之间相互独立，不应相互依赖、相互调用。</p><p>（4）<strong>一个测试用例只测一个函数。</strong>一个测试用例里面可以包含这一个函数的多个场景，但不能包含有多个参数的函数。原因在于，复杂测试用例出现错误时，无法定位问题的出处。</p><h4 id="3-1-5-单元测试对编码的要求"><a href="#3-1-5-单元测试对编码的要求" class="headerlink" title="3.1.5  单元测试对编码的要求"></a>3.1.5  单元测试对编码的要求</h4><p>单元测试中代码需保持一致性，尽量不要出现结果不一致的情况。假设有的代码会带来不一致性，导致单元测试无法稳定运行。针对这种情况，有两种解决方案：</p><p><strong>第一，将带来不一致性的代码抽取出来，</strong>把它作为一种变量传入我们需要调用或使用一致性变量的时候；</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281715404.png"></p><p><strong>第二，借助第三部分即将讲到的一个工具——mock</strong>——来解决这种问题。</p><h3 id="3-2-Coverage-统计单元测试覆盖率的工具"><a href="#3-2-Coverage-统计单元测试覆盖率的工具" class="headerlink" title="3.2 Coverage 统计单元测试覆盖率的工具"></a>3.2 Coverage 统计单元测试覆盖率的工具</h3><p>单元测试做完之后如何评价我们单元测试的效果。此时需要用到覆盖率工具，即Coverage。Coverage是一个第三方的工具，需要提前下载安装。</p><h4 id="3-2-1-统计覆盖率方法"><a href="#3-2-1-统计覆盖率方法" class="headerlink" title="3.2.1 统计覆盖率方法"></a>3.2.1 统计覆盖率方法</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281719654.png"></p><p>把python替换为coverage run-branch，然后会生成coverage文件，文件里会记录所有我们需要的覆盖率信息。</p><h4 id="3-2-2-打印覆盖率信息"><a href="#3-2-2-打印覆盖率信息" class="headerlink" title="3.2.2 打印覆盖率信息"></a>3.2.2 打印覆盖率信息</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281718158.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281716523.webp"></p><p>执行coverage report-m 命令，读取当前目录下.coverage文件，打印覆盖率信息。输出Stmts(总行数), Miss(未覆盖行数), Branch（总分支数）, BrPart （未覆盖分支数）, Cover（覆盖率） , Missing（未覆盖具体信息）等信息。</p><h4 id="3-2-3-覆盖率中排除某些文件"><a href="#3-2-3-覆盖率中排除某些文件" class="headerlink" title="3.2.3 覆盖率中排除某些文件"></a>3.2.3 覆盖率中排除某些文件</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281718278.png"></p><p>执行coverage report-m—omit=file 1[,file 2,……] 命令, 在统计并打印覆盖率时，排除某些文件。若有多个文件用逗号分隔。</p><h4 id="3-2-4-生成HTML格式的覆盖率信息"><a href="#3-2-4-生成HTML格式的覆盖率信息" class="headerlink" title="3.2.4 生成HTML格式的覆盖率信息"></a>3.2.4 生成HTML格式的覆盖率信息</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281718034.png"></p><p>针对代码量较大，查找覆盖率信息难度较大、耗时较长的情况，执行coverage html [–omit=file1[,file2,……]]命令，将覆盖率信息以html格式显示。</p><h3 id="3-3-Mock-简化单元测试的工具"><a href="#3-3-Mock-简化单元测试的工具" class="headerlink" title="3.3 Mock 简化单元测试的工具"></a>3.3 Mock 简化单元测试的工具</h3><h4 id="3-3-1-使用mock工具的原因与其功能"><a href="#3-3-1-使用mock工具的原因与其功能" class="headerlink" title="3.3.1 使用mock工具的原因与其功能"></a>3.3.1 使用mock工具的原因与其功能</h4><p>Mock基于实际进行单元测试的场景而产生，以下三类场景非常具有代表性：</p><ol><li><p><strong>构造模块</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281724821.png">需要测试模块A,但它要调用的模块B还未开发，可是测试却不容推迟、需按时进行，面对这种情况，我们可以使用Mock生成一个还未写完的代码，即可进行相应的测试。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281724884.png"></p></li><li><p><strong>改变函数逻辑</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281725807.png">代码中含有结果不可预知的代码，例如time.time()(时间)， random.random()(随机数)。Mock可以改变含有结果不可预知代码的函数的逻辑，强行让其返回我们想要的返回值，使其结果可预知。</p></li><li><p><strong>减少依赖</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281725930.png" alt="image-20211128172546775">在所有模块代码都已完成，但无法保证代码稳定性的情况下。针对其他模块的质量不可靠的情况，可通过Mock工具构造一个相对稳定的模块，从而规避其他模块的问题。</p></li></ol><h4 id="3-3-2-Mock使用场景"><a href="#3-3-2-Mock使用场景" class="headerlink" title="3.3.2 Mock使用场景"></a>3.3.2 Mock使用场景</h4><p>通过以下10个场景来讲述Mock的常见用法。</p><p>场景01：通过 <strong>return_value</strong>，Mock可以强行修改，永远返回我们想要的返回值，支持的类型包括string,number,Boolean,list,dict等。</p><p>场景02：将前一个例子的<strong>实例名改为类名</strong>，可实现替换类方法的返回值。</p><p>场景03：通过 <strong>side_effect</strong>,根据调用次数返回想要的结果,当超出调用次数时抛StopIteration 异常。</p><p>场景04：通过 <strong>side_effect</strong>可以完全修改函数的逻辑，使用另一个函数来替换它，根据参数返回想要的结果。</p><p>场景05：通过 <strong>side_effect</strong>抛出想要的异常或错误。</p><p>场景06：针对需要mock在特定要求下生效的情况，通过<strong>with.patch.object</strong>设定一个作用域以达到限制mock作用域的目的。</p><p>场景07：<strong>获取调用信息</strong>，如函数是否被调用、函数被调用的次数、函数被调用的形式、函数调用的参数等。</p><p>场景08：通过<strong>create_autospec</strong>在返回值改变的同时，确保api不会因mock而改变。</p><p>场景09：针对需要调用的函数、调用的接口完全没有开发的情况，可以通过<strong>Mock从零构造依赖模块</strong>从而完成测试。</p><p>场景10 ：<strong>替换函数调用链。</strong>比如说用popen去执行一个命令，然后用read函数把它读取出来，再用split去做切分，这就是一个函数调用链(os.popen(cmd).read().split())。</p><h4 id="3-3-3-Mock对编码的要求"><a href="#3-3-3-Mock对编码的要求" class="headerlink" title="3.3.3 Mock对编码的要求"></a>3.3.3 Mock对编码的要求</h4><p>在模块引入方式上，推荐以import XXX的形式引入，以XXX.func()形式调用，不要from.xxx import *,因为需要一个链条指向它，否则无法达到我们的预期。</p><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281727442.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281727860.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281728367.png"></p><h2 id="4-单元测试实践"><a href="#4-单元测试实践" class="headerlink" title="4 单元测试实践"></a>4 单元测试实践</h2><h3 id="4-1-Unittest-简单应用"><a href="#4-1-Unittest-简单应用" class="headerlink" title="4.1 Unittest 简单应用"></a>4.1 Unittest 简单应用</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281736705.webp"></p><p>如图所示，这是一个要被测试的类，这个类代表了一个人，类中有一个函数为<strong>get_name()，作用是获取这个人的名字</strong>。围绕着这个函数首先想到的测试点就是函数能否正确输出人名。因此就有了如下图所示的单元测试代码。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281738269.webp"></p><p>第一步，将使用到的unittest框架和所需要的函数导入。</p><p>第二步，针对被测试的函数写一个测试类，这里要注意<strong>测试类必须继承自unittest和TestCase。</strong></p><p>第三步，构建实例化的函数，可以理解为生成两个人，一个叫张三，一个叫李四。</p><p>第四步，编写一个用于测试的函数，这里注意<strong>函数名必须是以test开头</strong>。通过图片里的代码可以看到，通过使用assertEqual断言来做相应的测试，断言中包括了两部分，第一部分是预期，第二部分是实际的值。通过对两个值的比较来完成测试。</p><h3 id="4-2-Unittest复杂应用"><a href="#4-2-Unittest复杂应用" class="headerlink" title="4.2 Unittest复杂应用"></a>4.2 Unittest复杂应用</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281736271.webp"></p><p>下面来看一个复杂的例子。如图所示，这个被测试的类是一个公司。这个公司的信息包含了公司的名字、公司的老板、公司的员工数。在这个公司的类中设置了三个函数，老板是谁、雇佣一个新员工、解雇一个员工。通过这些信息，可以想到的测试点有：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281735339.webp"></p><p>（1）who_is_boss()这个函数能够正确的返回老板的姓名；</p><p>（2）使用hire()函数雇佣新人，公司的员工总数+1；</p><p>（3）使用hire()函数重复雇佣一个人，函数会报错或者公司员工数量不变；</p><p>（4）使用fire()函数解雇一个人，公司的员工总数-1；</p><p>（5）使用fire()函数解雇非公司的员工，函数会报错或者员工数量不变。</p><p>针对以上的几个测试点，可以编写出相应的测试类。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281736693.webp"></p><p>首先将所需要的类库导入，并且测试类要继承自unittest和TestCase。然后使用setUpClass()函数构建一个公司，设置老板的姓名和公司的名字。在这里设置了一个tearDown()清理函数，是为了方便测试的时候将员工全部清理掉。</p><p>通过图片可以看到，下面的三个函数原理基本跟上一个案例相同，都是通过断言来进行测试。测试类编写完成之后，需要运行这个类进行测试。如果需要执行全部的测试用例，如图所示，使用unittest.main()这个函数且不需要添加任何参数。执行完成后会得到如下图所示的结果，测试结果分为几个部分：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281736738.webp"></p><p>第一部分的代码展示的是执行测试用例的结果，“.”说明测试用例执行通过，“E”说明测试用例发生了特殊情况异常中断，“F”说明测试用例执行失败。</p><p>第二部分则是打印的报错信息，当出现“E”或者“F”的时候，系统会打印出异常中断和执行失败的原因。</p><p>第三部分为统计信息，包括了共执行了几个测试用例，测试用例执行共花费了多少时间，测试用例执行成功或失败的数量。</p><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>百度高效研发实战训练营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>百度高效研发实战训练营Step2</title>
    <link href="/bitTraingClub2.html"/>
    <url>/bitTraingClub2.html</url>
    
    <content type="html"><![CDATA[<h1 id="百度高效研发实战训练营Step2"><a href="#百度高效研发实战训练营Step2" class="headerlink" title="百度高效研发实战训练营Step2"></a>百度高效研发实战训练营Step2</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-代码的艺术"><a href="#1-代码的艺术" class="headerlink" title="1 代码的艺术"></a>1 代码的艺术</h2><h3 id="1-1-《代码的艺术》目的解读"><a href="#1-1-《代码的艺术》目的解读" class="headerlink" title="1.1 《代码的艺术》目的解读"></a>1.1 《代码的艺术》目的解读</h3><h4 id="1-1-1-了解公司与学校写代码的不同"><a href="#1-1-1-了解公司与学校写代码的不同" class="headerlink" title="1.1.1 了解公司与学校写代码的不同"></a>1.1.1 了解公司与学校写代码的不同</h4><p>在公司写程序和在学校写程序有很大的不同。</p><p>在学校写程序时，对于代码的质量要求比较低。</p><p>当进入公司之后，做的是工业级的产品，服务用户量可能会到达亿万级，所以相对而言对于代码的质量要求比较高。<em>一些伟大产品中的代码，甚至可以被称为艺术品。</em></p><h4 id="1-1-2-消除对于程序员这个职业的误解"><a href="#1-1-2-消除对于程序员这个职业的误解" class="headerlink" title="1.1.2 消除对于程序员这个职业的误解"></a>1.1.2 消除对于程序员这个职业的误解</h4><p>很多人都对程序员这个职业有误解，认为程序员就是码农，认为程序员35岁之后就写不出代码了。还有人认为程序员未来的唯一出路是以后做管理。</p><p>希望通过这门课程的学习，能使大家对于程序员有一个新的认识，消除误解。</p><h4 id="1-1-3-建立对软件编程的正确认识"><a href="#1-1-3-建立对软件编程的正确认识" class="headerlink" title="1.1.3 建立对软件编程的正确认识"></a>1.1.3 建立对软件编程的正确认识</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272315701.png"></p><p>在做一件事物时，我们常说“知”与“行”要合一。即：我们需要对这件事物有一个正确的认识，才会有正确的行动。同理，<em>写出好代码的前提，是对软件编程有正确的认识</em>。</p><h4 id="1-1-4-明确作为软件工程师的修炼方向"><a href="#1-1-4-明确作为软件工程师的修炼方向" class="headerlink" title="1.1.4 明确作为软件工程师的修炼方向"></a>1.1.4 明确作为软件工程师的修炼方向</h4><p>艺术品是由艺术家创造的。艺术家的修炼是有方式方法的。同样，软件工程师的修炼也是方式有方法的。希望通过这门课程，能使大家对软件工程师这个职业有一个全新的认识。</p><h3 id="1-2-代码与艺术之间的关系"><a href="#1-2-代码与艺术之间的关系" class="headerlink" title="1.2 代码与艺术之间的关系"></a>1.2 代码与艺术之间的关系</h3><h4 id="1-2-1-代码是可以被称为艺术的"><a href="#1-2-1-代码是可以被称为艺术的" class="headerlink" title="1.2.1 代码是可以被称为艺术的"></a>1.2.1 代码是可以被称为艺术的</h4><p>艺术，是多种多样、丰富多彩的。同时艺术也是有多个层次的，其实，在我们编写代码时，我们的脑海中也会有类似的感觉。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272319344.png"></p><p>艺术就是人类通过借助特殊的物质材料与工具，运用一定的审美能力和技巧，在精神与物质材料、心灵与审美对象的相互作用下，进行的充满激情与活力的创造性劳动，可以说它是一种精神文化的创造行为，是人的意识形态和生产形态的有机结合体。</p><p>写代码也恰恰要经历这样的一个过程。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272319626.png"></p><p>在编写代码的过程中：</p><p>我们<em>借助的物质是计算机系统，借助的工具是设计、编写、编译、调试、测试等</em>。</p><p>同样，编写代码需要激情。而且，编写代码是一件非常具有创造性的工作。</p><p>代码是人类智慧的结晶，代码反映了一个团队或一个人的精神。<em>代码可以被称为是艺术的。</em></p><h4 id="1-4-2-艺术可以从不同的角度进行解读、研究与创造"><a href="#1-4-2-艺术可以从不同的角度进行解读、研究与创造" class="headerlink" title="1.4.2 艺术可以从不同的角度进行解读、研究与创造"></a><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272320545.png">1.4.2 艺术可以从不同的角度进行解读、研究与创造</h4><p>达芬奇有多幅著名的画作。拿著名的《蒙娜丽莎》这幅画来举例：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272322121.png"></p><p>站在观众的角度，可能只是在欣赏画中的人物微笑。但是对于画家来说，可能就会考虑画画的手法、构图、光线明暗、色彩对比等等方面。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272323753.png"></p><p>在艺术方面，可以站在很多不同的角度进行解读。</p><p>但是如果要成为一名创作者，我们需要的不仅仅是欣赏的能力，更重要的是<em>从多角度进行解读、研究与创造的能力</em>。</p><h4 id="1-4-3-写代码如同艺术创作"><a href="#1-4-3-写代码如同艺术创作" class="headerlink" title="1.4.3 写代码如同艺术创作"></a>1.4.3 写代码如同艺术创作</h4><p>写代码的内涵是：</p><ol><li>写代码这个过程是一个<em>从无序到有序</em>的过程。</li><li>写代码需要把现实问题转化为数学模型。在写代码的过程中，我们需要有很好的模型能力。</li><li>写代码实际是一个认识的过程。很多时候，编码的过程也是我们认识未知问题的过程。</li><li>在写代码的过程中，我们需要综合的全方位的能力。包括把握问题的能力、建立模型的能力、沟通协助的能力、编码执行的能力等等。</li><li>在写好代码之前，首先需要建立品位。品味是指我们首先要知道什么是好的代码，什么是不好的代码。这样我们才能去不断地调整自己的行为，然后去学习，去提高我们的编码能力，写出具有艺术感的代码。</li></ol><h3 id="1-3-软件工程师不等于码农"><a href="#1-3-软件工程师不等于码农" class="headerlink" title="1.3 软件工程师不等于码农"></a>1.3 软件工程师不等于码农</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111272336586.png"></p><p>软件工程师不能只会写代码，更需要具有综合的素质。这个综合的素质包括：</p><h4 id="1、技术"><a href="#1、技术" class="headerlink" title="1、技术"></a>1、技术</h4><p><em><strong>技术能力是基础。</strong></em>包括但不限于编码能力、数据结构和算法能力、系统结构知识、操作系统知识、计算机网络知识、分布式系统知识等等。</p><h4 id="2、产品"><a href="#2、产品" class="headerlink" title="2、产品"></a>2、产品</h4><p>要对产品业务有深刻的理解，需要了解产品交互设计、产品数据统计、产品业务运营等。</p><h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><p>要了解一些管理知识，需要知道项目是怎么管理的 ，如何去协调多个人一起去完成一个项目。有一些项目需要具有很强的研究与创新方面的能力。</p><p>以上这些能力素质，是一个软件工程师需要具有的综合素质。要成为一个全部掌握这些素质系统工程师至少需要8~10年的时间。</p><p>所以，软件工程师绝对不是一个只会简单编写代码就可以的职业。<em><strong>软件工程师不等于码农。</strong></em></p><h3 id="1-4-正确认识代码实践方面的问题"><a href="#1-4-正确认识代码实践方面的问题" class="headerlink" title="1.4 正确认识代码实践方面的问题"></a>1.4 正确认识代码实践方面的问题</h3><h4 id="1-4-1-什么是好代码，好的代码有哪些标准"><a href="#1-4-1-什么是好代码，好的代码有哪些标准" class="headerlink" title="1.4.1 什么是好代码，好的代码有哪些标准"></a>1.4.1 什么是好代码，好的代码有哪些标准</h4><p><strong>好代码的标准是：</strong></p><p>①高效、②鲁棒、③简洁、④简短、⑤可共享、</p><p>⑥可测试、⑦可移植、⑧可监控、⑨可运维、⑩可扩展。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292216019.png"></p><blockquote><p>将以上十条标准进行总结精简，可以归纳为：</p><p>（1）代码的正确和性能；</p><p>（2）代码的可读和可维护性；</p><p>（3）代码的可运维和可运营；</p><p>（4）代码的可共享和可重用。</p></blockquote><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280007786.png"></p><p>了解完好代码的标准，接下来我们来看一下不好的代码主要表现在哪些方面：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280005709.png"></p><ol><li>不好的函数名</li></ol><p>​    比如，在函数名中，加my等单词，这属于很不专业的用法。</p><ol start="2"><li>不好的变量名</li></ol><p>​    比如，看不出任何含义的a,b,c,j,k,temp等变量名。</p><ol start="3"><li>没有注释或注释不清晰</li></ol><p>​    没有注释的代码是非常难读懂的。注释不清晰往往是因为文字功底或者描述能力欠缺，从而导致无法通过注释把代码的执行原理讲解清楚。</p><ol start="4"><li>一个函数执行多个功能</li></ol><p>​    比如LoadFromFileAndCalculate()函数，它既执行了文件中去加载数据，还执行了计算功能。像这样的函数，我们建议把它切分成两个单独的函数。</p><ol start="5"><li>不好的代码样式排版</li></ol><p>​    代码的样式排版在某种程度上体现了代码的一种逻辑。好的代码排版能增强代码的可读性和逻辑性。我们在写代码时，要规避不好的代码样式排版。</p><ol start="6"><li>难以测试的代码</li></ol><p>​    代码没法测试，难写测试用例，这些都是一些不好的表现。</p><h4 id="1-4-2-好的代码从哪里来"><a href="#1-4-2-好的代码从哪里来" class="headerlink" title="1.4.2 好的代码从哪里来"></a>1.4.2 好的代码从哪里来</h4><p>代码不只是“写”出来的。实际上，在整个项目中，真正的编码时间约占项目整体时间的10%。<em>好的代码是多个环节工作共同作用的结果。</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280009655.png"></p><p>这些环节包括：</p><blockquote><ol><li>在编码前，要进行需求分析和系统设计。</li><li>在编码过程中，要注意做单元测试。</li><li>在编码后，要做集成测试，要上线，要持续运营，要迭代改进。</li></ol></blockquote><p>一个好的系统或产品，是以上几个环节持续循环的结果。</p><p>接下来我们着重介绍一下重点环节——<em>需求分析和系统设计</em>。</p><p><strong>1. 认识需求分析和系统设计的重要性</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280011841.png"></p><p>需求分析和系统设计在软件开发中经常被忽略或轻视，但是这两点都是非常重要的环节。</p><p>人们的直觉往往是拿到一个项目就想尽快把它写出来并运行，感觉这样的路径是最快的。</p><p>但是实际上在软件前期需求分析和系统设计投入更多的成本，会在后期节省更多的消耗。即：<em>前期更多的投入，收益往往最大</em>。</p><p>原因是：如果我们开始的设计做错的话，那么后期开发、测试、上线、调试这些成本都会被浪费掉。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280010793.png"></p><p><strong>2. 清楚需求分析和系统设计的差别</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292216299.png"></p><p>需求分析和系统设计是有泾渭分明的区别的，为了避免这两者相互混杂，我们需要清楚需求分析和系统设计各自的内涵。</p><p><em>需求分析主要是定义系统或软件的黑盒行为，即：外部行为。</em>比如，系统从外部来看能够执行什么功能。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280011809.png"></p><p><em>系统设计主要是设计系统或软件的白盒机制。即：内部行为。</em>比如，系统从内部来看，是怎么做出来的，为什么这么做。</p><p><strong>3.  需求分析的注意要点</strong></p><p>要点一：清楚怎么用寥寥数语勾勒出一个系统的功能。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280012501.png"></p><p>每个系统都有自己的定位，我们可以从简洁的总体描述，展开到具体的需求描述。</p><blockquote><p>需求描述的内容基本包括：</p><ol><li><p>系统类型描述</p></li><li><p>系统规模描述</p></li><li><p>系统定位和系统差异描述</p></li><li><p>系统对外接口功能描述</p></li></ol></blockquote><p>要点二：需求分析需要用精确的数字来描述。</p><p>需求分析中会涉及大量的数据分析，这些分析都需要精确的数字来进行支撑。</p><p><strong>4. 系统设计的注意要点</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280014355.png"></p><p><strong>要点一、清楚什么是系统架构</strong></p><p><em>系统架构，英文名 System Architectrue。</em>在wiki上有一个英文定义阐述了系统架构是一个概念的模型，它定义了系统的结构、行为、更多的视图。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280017695.png"></p><p>进一步解读系统架构，它的几个要素是：</p><p>①系统要完成哪些功能</p><p>②系统如何组成</p><p>③功能在这些组成部分之间如何划分</p><p><strong>要点二、注意系统设计的约束</strong></p><p><em>重点是资源的限制。</em>比如，计算的资源限制，存储的资源限制，IO网络的资源限制等。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280018199.png"></p><p><strong>要点三、清楚需求是系统设计决策的来源</strong></p><p>精确定义需求中的各个细节，以及量的定义，对系统设计的决策起着重要的作用。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292216422.png"></p><p><strong>要点四、系统设计的风格与哲学</strong></p><p><em>在同样的需求下，可能出现不同的设计方式。</em>即目的相同，设计不同。比如：复杂指令集和精简指令集的设计差异。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292216443.png"></p><p>一个好的系统是<em>在合适假设下的精确平衡</em>。一个通用的系统在某些方面是不如专用系统的。每个系统每个组件的功能都应该足够的专一和单一。每个组件是指子系统或模块等。功能的单一是复用和扩展的基础。倘若不单一，未来就有可能很难进行复用和扩展。</p><p>子系统或模块之间的关系应该是<em>简单而清晰的</em>。软件中最复杂的是耦合，如果各系统之间的接口定义非常复杂，那么未来便很难控制系统的健康发展。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280019144.png"></p><p>值得注意的是，使用全局变量就是在增加系统的耦合，从而增加系统的复杂性，所以<em>在系统中需要减少使用全局变量。</em></p><p><strong>要点五、清楚接口的重要性</strong></p><p><em>接口，英文名Interface。</em>系统对外的接口比系统实现本身还要更加重要，接口的设计开发不容忽视。</p><p><strong>接口主要包括：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280019599.png"></p><p><strong>接口重要的原因在于：</strong></p><p>①接口定义了功能。如果定义的功能不正确，那么系统的可用性与价值便会大打折扣。</p><p>②接口决定了系统和系统外部之间的关系。相对于内部而言，外部关系确定后非常难以修改。</p><p>接口的修改需要非常慎重且要考虑周全。</p><p><strong>后期接口修改时主要注意两点：</strong></p><ol><li>合理好用。新改的接口应该是非常合理好用的。不能使调度方感觉我们做的接口非常难以使用。</li><li>修改时需要向前兼容。新改的接口应该尽量实现前项的兼容。不能出现当新接口上线时其他程序无法使用的情况。</li></ol><h4 id="1-4-3-如何写好代码"><a href="#1-4-3-如何写好代码" class="headerlink" title="1.4.3 如何写好代码"></a>1.4.3 如何写好代码</h4><h5 id="1-代码也是一种表达方式"><a href="#1-代码也是一种表达方式" class="headerlink" title="1 代码也是一种表达方式"></a>1 代码也是一种表达方式</h5><p>在一个项目中，软件的维护成本远远高于开发成本，而且超过50%的项目时间都是用于沟通。</p><p>常规意义的沟通方式主要有面对面交流、Email、文档或网络电话会议等。但是其实 <em>代码也是一种沟通方式</em>。</p><p>在计算机早期，我们使用机器语言或汇编语言，更多的是考虑代码如何更高效率地执行。</p><p>然而，随着技术的进步，代码编译器的逐渐完善，我们写代码时更多的是要考虑如何让其他人看得懂、看得清楚。于是，<strong><em>编程规范应运而生</em>。</strong></p><p><strong>编程规范主要包含：</strong></p><ol><li>如何规范的表达代码。 </li><li>语言使用的相关注意事项。</li></ol><p><strong>基于编程规范，看代码的理想场景是：</strong></p><ol><li>看别人的代码，感觉和看自己的代码一样。</li><li>看代码时能够专注于逻辑，而不是格式方面。</li><li>看代码时不用想太多。</li></ol><h5 id="2-代码书写过程中的细节问题"><a href="#2-代码书写过程中的细节问题" class="headerlink" title="2 代码书写过程中的细节问题"></a>2 代码书写过程中的细节问题</h5><h6 id="1-关于模块"><a href="#1-关于模块" class="headerlink" title="1. 关于模块"></a>1. 关于模块</h6><p><strong>模块，是程序的基本组成单位</strong>。在一个模块内，会涉及它的数据、函数或类。对于Python、Go、C语言这样的程序来说，一个后缀名为.py 、 .c或.go的文件就是一个模块。</p><p>每一个模块需要有明确的功能。需要符合<em><strong>紧内聚，松耦合</strong></em>。模块切分的是否合理对于软件架构的稳定起着至关重要的左右。</p><p>切分模块的方法：</p><p>先区分数据类的模块和过程类的模块。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280041920.png"></p><p><strong>数据类的模块：</strong>主要是要完成<em><strong>对数据的封装</strong></em>。封装往往是通过模块内部变量或类的内部变量来实现的。</p><p><strong>过程类的模块：</strong>本身不含数据。过程类模块可以<em><strong>从文件中去读取一个数据</strong></em>，或者执行一些相关的操作。过程类模块可以调用其他数据类模块或过程类模块。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292217173.png"></p><p>编写程序时，我们需要注意减少模块间的耦合。<em><strong>减少模块间的耦合，有利于降低软件复杂性，明确接口关系</strong>。</em></p><h6 id="2-关于类和函数"><a href="#2-关于类和函数" class="headerlink" title="2. 关于类和函数"></a>2. 关于类和函数</h6><p>类和函数是两种不同的类型，有他们各自适用的范围。另外，遇见和类的成员变量无关的函数时，可以将该函数抽出来，作为一个独立的函数使用，这样便于未来的复用。</p><h6 id="3-关于面向对象"><a href="#3-关于面向对象" class="headerlink" title="3. 关于面向对象"></a>3. 关于面向对象</h6><p>面向对象，是一个优秀的编程方法和范式，但是真正理解的人并不多。</p><p>面向对象的<em><strong>本质是数据封装</strong></em>。这就要求我们在写程序的过程中应该<em><strong>从数据的角度开始想问题</strong></em>，而不是从执行过程的角度开始想问题。</p><p>我们需要注意一个普遍的错误认知，即：C语言是面向过程的，C++是面向对象的。</p><p>实际上，<strong><em>C语言是基于对象的，它和C++的区别主要是没有多态和继承</em>。</strong></p><p>C++是一个经常被滥用的语言。因为C++有太强的功能。</p><p>作为软件工程师，我们最重要的任务是去实现出我们所需要的功能，语言只是我们的工具。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280052593.png"></p><p>另外，在系统中，我们应该<em><strong>谨慎地使用多态和继承</strong></em>。如果一个系统中，类的继承超过三层，那么这个系统的复杂度便很难把握。</p><p>有这样一个悖论：很好的继承模型是基于对需求的准确把握，而在我们在初始设计阶段往往对需求理解的不透彻。系统在初始阶段可能只是一个很简单的原型，然后通过不断地迭代完善，才逐步发展起来变好的。</p><h6 id="4-关于模块内部的组成"><a href="#4-关于模块内部的组成" class="headerlink" title="4. 关于模块内部的组成"></a>4. 关于模块内部的组成</h6><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280051076.png"></p><p>一个模块，比如.py、.c或.go这样一个模块，它的内部组成主要是：在文件头中，需要对模块的功能进行简要说明。需要把文件的修改历史写清楚，包括修改时间、修改人和修改内容。在模块内，内容的顺序尽量保持一致，以方便未来对内容的搜索查询。</p><h6 id="5-关于函数"><a href="#5-关于函数" class="headerlink" title="5. 关于函数"></a>5. 关于函数</h6><p>函数的切分同样是非常重要的。对于一个函数来说，要有明确的单一功能。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280051088.png"></p><p>函数描述三要素包括<em><strong>功能、传入参数和返回值</strong></em>。</p><ol><li>功能描述是指描述这个函数是做什么的、实现了哪些功能。</li><li> 传入参数描述是指描述这个函数中传入参数的含义和限制条件。</li><li>返回值描述是指描述这个函数中返回值都有哪些可能性。</li></ol><p><em><strong>函数的规模要足够的短小</strong></em>，这是写好程序的秘诀之一。bug往往出现在那些非常长的函数里。</p><p>在函数头中，需要对函数的语义做出清晰和准确的说明。我们需要<em><strong>注意函数的返回值</strong></em>。在写函数时，要判断函数的语义，确定返回值的类型。</p><p><strong>基于函数的语义，函数的返回值有三种类型。</strong></p><p><em><strong>第一种类型</strong></em>：在“逻辑判断型”函数中，返回布尔类型的值——True或False，表示“真”或“假”。</p><p><em><strong>第二种类型</strong>：</em>在“操作型”函数中，作为一个动作，返回成功或失败的结果——SUCCESS或ERROR。</p><p><em><strong>第三种类型</strong>：</em>在“获取数据型”函数中，返回一个“数据”，或者返回“无数据/获取数据失败”。</p><p><em><strong>以“单入口、单出口”的方式书写</strong></em>的方式能够比较清晰地反映出函数的逻辑。尤其是在实现多线程的数据表中，推荐使用一个内部函数来实现“单入口单出口”的方式。</p><h6 id="6-关于代码注释"><a href="#6-关于代码注释" class="headerlink" title="6. 关于代码注释"></a>6. 关于代码注释</h6><p>要重视注释，书写注释要做到清晰明确。在编写程序的过程中，<strong><em>先写注释，后写代码</em>。</strong></p><h6 id="7-关于代码块"><a href="#7-关于代码块" class="headerlink" title="7. 关于代码块"></a>7. 关于代码块</h6><p>代码块的讨论范围是在一个函数内的代码实现。书写代码块的思路是<em><strong>先把代码中的段落分清楚</strong></em>。文章有段落，代码同样有段落。代码的段落背后表达的是我们对于代码的逻辑理解。包括<em><strong>代码的层次、段落划分、逻辑</strong></em>。代码中的空行或空格是帮助我们表达代码逻辑的，并非可有可无。好的代码可以使人在观看时做过一眼明了。</p><h6 id="8-关于命名"><a href="#8-关于命名" class="headerlink" title="8. 关于命名"></a>8. 关于命名</h6><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280053731.png"></p><p>命名包括系统命名、子系统命名、模块命名、函数命名、变量命名、常量命名等。</p><p>我们要清楚命名的重要性。<strong>命名重要的主要原因为：</strong></p><p>一是“望名生义”是人的自然反应。不准确的命名会使人产生误导。</p><p>二是概念是建立模型的出发点。好的命名是系统设计的基础。</p><p>命名中普遍存在的问题有：</p><p>一是名字中不携带任何信息。</p><p>二是名字携带的信息是错误的。</p><p>命名<strong><em>关系着代码的可读性</em>，</strong>需要仔细思考。<em><strong>命名的基本要求是准确、易懂。</strong></em>提高代码命名可读性的方式之一是：<em><strong>在名字的格式中加入下划线、驼峰等。</strong></em></p><h6 id="9-关于系统的运营"><a href="#9-关于系统的运营" class="headerlink" title="9. 关于系统的运营"></a>9. 关于系统的运营</h6><p>在互联网时代，系统非常依赖运营。并不是我们把代码写完调试通了就可以。</p><p>在系统运营过程中，<strong><em>代码的可监测性非常重要</em>。</strong>很多程序都是通过线上的不断运行、不断监测、不断优化而迭代完善的，所以我们在编写代码的过程中，要注意尽可能多地暴露出可监控接口。</p><p>对于一个系统来说，<strong><em>数据和功能同等重要</em>。</strong></p><p>数据收集很重要，数据量够大才能知道这个项目或这个系统的具体收益。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280056080.png"></p><p>关于系统的运营，我们在设计和编码阶段就需要考虑。即：在设计和编码阶段，提供足够的状态记录，提供方便的对外接口。</p><h3 id="1-5-怎样修炼成为优秀的软件工程师"><a href="#1-5-怎样修炼成为优秀的软件工程师" class="headerlink" title="1.5 怎样修炼成为优秀的软件工程师"></a>1.5 怎样修炼成为优秀的软件工程师</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280057161.png"></p><p>通常人们在判断一名软件工程师的水平时，都会用工作时间、代码量、学历、曾就职的公司等等这类外部因素作为评判标准。</p><p>修炼成为优秀的软件工程师，<strong>重要的因素有三点：</strong></p><ol><li>学习-思考-实践</li><li>知识-方法-精神</li><li>基础知识是根本</li></ol><h4 id="1-5-1-学习-思考-实践"><a href="#1-5-1-学习-思考-实践" class="headerlink" title="1.5.1 学习-思考-实践"></a>1.5.1 <strong>学习-思考-实践</strong></h4><h5 id="（1）多学习"><a href="#（1）多学习" class="headerlink" title="（1）多学习"></a><strong>（1）多学习</strong></h5><p>软件编写的历史已经超过半个世纪，有太多的经验可以借鉴学习。要不断的学习进步。</p><h5 id="（2）多思考"><a href="#（2）多思考" class="headerlink" title="（2）多思考"></a><strong>（2）多思考</strong></h5><p>学而不思则罔，思而不学则殆。对于做过的项目要去深入思考，复盘写心得。</p><h5 id="（3）多实践"><a href="#（3）多实践" class="headerlink" title="（3）多实践"></a><strong>（3）多实践</strong></h5><p>要做到知行合一，我们大部分的心得和成长其实是来自于实践中的经历。在学习和思考的基础之上，要多做项目，把学到的理论运用到真正的工作中。</p><h4 id="1-5-2-知识-方法-精神"><a href="#1-5-2-知识-方法-精神" class="headerlink" title="1.5.2 知识-方法-精神"></a>1.5.2 知识-方法-精神</h4><p>互联网的发展日新月异，对于软件开发来说，知识永远在增加，所以在变化快速的知识世界中，<strong><em>最好的方式是找到方法</em>。</strong></p><p>方法就是用来分析问题和解决问题的。虽然说起来简单，但是适合每个人的方法都需要自己去寻找和总结。</p><p>在大多数人的成长过程中，并不单单只是鲜花和掌声，更多的时候是在和困难荆棘做斗争。而真正能做出成就的人，都有着远大理想和宏伟志向。所以，光有知识和方法往往是不够的，还需要有精神作为支撑。</p><p>几个精神理念：</p><ol><li><strong>自由精神、独立思想。</strong></li></ol><p>人一定要有自己的思考。不要人云亦云，不要随波逐流。</p><ol start="2"><li><strong>对完美的不懈追求。</strong></li></ol><p>不要做到一定程度就满意了，而是要去不断的追求一个更好的结果。</p><h4 id="1-5-3-基础知识是根本"><a href="#1-5-3-基础知识是根本" class="headerlink" title="1.5.3 基础知识是根本"></a>1.5.3 基础知识是根本</h4><p>唐朝著名宰相魏征曾经对唐太宗说过：“求木之长者，必固其根本；欲流之远者，必浚其泉源”，充分表达了基础乃治学之根本。</p><p>对于一个软件工程师来说，需要掌握的基础是非常全面的。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111280058449.png"></p><p>包括数据结构、算法、操作系统、系统结构、计算机网络。包括软件工程、编程思想。包括逻辑思维能力、归纳总结能力、表达能力。还包括研究能力、分析问题、解决问题的能力等。这些基础的建立，至少也要5~8年的时间。</p><h2 id="2-Mini-Spider实践"><a href="#2-Mini-Spider实践" class="headerlink" title="2 Mini-Spider实践"></a>2 Mini-Spider实践</h2><h3 id="2-1-多线程编程"><a href="#2-1-多线程编程" class="headerlink" title="2.1 多线程编程"></a>2.1 多线程编程</h3><h4 id="2-1-1-数据互斥访问"><a href="#2-1-1-数据互斥访问" class="headerlink" title="2.1.1 数据互斥访问"></a>2.1.1 数据互斥访问</h4><p>多线程中数据互斥访问的情况非常常见，在真实生产的环境中，经常有开发人员会将一张表的“添加”和“判断是否存在”分为两个接口，这是一种非常常见的错误。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281424954.png"></p><p>以图中的代码为例，左边的代码是正确的写法，<strong>将添加和判断写进一个函数中</strong>。右边的代码是典型的错误代码，编写了两个函数，分别是添加和判断函数。</p><p>事实上，这种将添加和判断写进一个函数并且运行的实现机制是同8086的底层指令集支持密不可分的。</p><h4 id="2-1-2-临界区的注意事项"><a href="#2-1-2-临界区的注意事项" class="headerlink" title="2.1.2 临界区的注意事项"></a>2.1.2 临界区的注意事项</h4><p>在代码中，<strong>有锁来保护的区域被称为临界区</strong>。以图中代码为例，临界区为self.lock.acquire()和self.lock.release()两句话之间的区域。在使用临界区的时候要注意，不要把耗费时间的操作放在临界区内执行。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281429165.png"></p><p>很多开发人员在编写多线程的时候会将耗费时间很多的逻辑放入临界区内，这样会导致无法发挥多线程对于硬件资源最大化利用的优势。</p><h4 id="2-1-3-I-O操作的处理"><a href="#2-1-3-I-O操作的处理" class="headerlink" title="2.1.3 I/O操作的处理"></a>2.1.3 I/O操作的处理</h4><p>在多线程编程中还要注意对于I/O操作的处理。首先在编写代码的时候要注意不能出现无捕捉的exception，以图中最左边的代码为例，如果不对异常进行捕捉，那么一旦出现问题就不会执行self.lock.release()语句，进而导致死锁的发生。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281444010.png"></p><p>其次，因为异常处理是非常消耗资源的，所以我们也不能像图中中间的代码一样，将异常放在临界区内，要像最右边的代码一样处理。</p><h3 id="2-2-细节处理"><a href="#2-2-细节处理" class="headerlink" title="2.2 细节处理"></a>2.2 细节处理</h3><h4 id="2-2-1-种子信息的读取"><a href="#2-2-1-种子信息的读取" class="headerlink" title="2.2.1 种子信息的读取"></a>2.2.1 种子信息的读取</h4><p>很多开发人员会将种子信息读取的逻辑和其他逻辑耦合在一起，这样是错误的。以图中代码为例，虽然通过_get_seeds函数直接读取文件中的信息并没有书写错误，但是如果后续的开发中文件的格式发生了变化，那就需要重新回来修改这部分的代码。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281445680.png"></p><p>通过上述代码可以发现，模块划分和逻辑的复杂程度是没有关系的。即使是逻辑简单的代码，如果没有做好模块划分，也会变得难于维护。</p><h4 id="2-2-2-程序优雅退出"><a href="#2-2-2-程序优雅退出" class="headerlink" title="2.2.2 程序优雅退出"></a>2.2.2 程序优雅退出</h4><p>在真实应用中，很多开发人员在实现程序退出功能的时候使用了非常复杂的机制，导致后期维护难度较高。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281446653.png"></p><p>在实际应用中可以使用python系统库中关于队列的task_done()和join()的机制。</p><p>以图中代码为例，左边的代码就是使用了task_done()，中间的代码是主程序中的一种常规逻辑使用。右边是对中间主程序的一种优化，增加了spider.wait()，让整个逻辑可读性更强，更容易被理解。</p><h4 id="2-2-3-爬虫的主逻辑编码"><a href="#2-2-3-爬虫的主逻辑编码" class="headerlink" title="2.2.3 爬虫的主逻辑编码"></a>2.2.3 爬虫的主逻辑编码</h4><p>很多开发人员编写的主逻辑非常的复杂且难懂。事实上，图中的代码就是一个爬虫的主逻辑的所有代码。可以看到，里面包含了六个步骤。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281448571.png"></p><p>第一步，从队列中拿到任务。</p><p>第二步，读取内容。如果读取失败，则重新读取。如果读取成功，则执行第三步。</p><p>第三步，存储数据。</p><p>第四步，检查数据深度。</p><p>第五步，如果数据深度不足，就进一步解析，并且放到队列中。</p><p>第六步，结束任务。</p><h2 id="3-代码检查规则背景及总体介绍"><a href="#3-代码检查规则背景及总体介绍" class="headerlink" title="3 代码检查规则背景及总体介绍"></a>3 代码检查规则背景及总体介绍</h2><h3 id="3-1-代码检查的意义"><a href="#3-1-代码检查的意义" class="headerlink" title="3.1 代码检查的意义"></a>3.1 代码检查的意义</h3><ol><li>提高代码可读性，统一规范，方便他人维护，长远来看符合公司内部开源战略。</li><li>帮助发现代码缺陷，弥补人工代码评审的疏漏，节省代码评审的时间与成本。</li><li>有助于提前发现问题，节约时间成本，降低缺陷修复成本。</li><li>促进公司编码规范的落地，在规范制定后借助工具进行准入检查。</li><li>提升编码规范的可运营性，针对反馈较多的不合理规范进行调整更新。</li></ol><h3 id="3-2-代码检查场景及工具"><a href="#3-2-代码检查场景及工具" class="headerlink" title="3.2 代码检查场景及工具"></a>3.2 代码检查场景及工具</h3><h4 id="3-2-1-代码检查场景"><a href="#3-2-1-代码检查场景" class="headerlink" title="3.2.1 代码检查场景"></a>3.2.1 代码检查场景</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281541973.png"></p><p>首先是<strong>本地研发环节</strong>，借助客户端工具，在push发起评审之前进行检查。</p><p>若本地代码扫描没有出现问题，就进入第二个环节：<strong>代码准入环节，即Code Review</strong>，这一环节进行增量检查，属于公司强制要求。</p><p>第三个环节：<strong>持续集成环节</strong>，当代码合入到代码库之后，进行全量检查，业务线根据自身需求来配置。</p><h4 id="3-2-2-代码检查工具与服务"><a href="#3-2-2-代码检查工具与服务" class="headerlink" title="3.2.2 代码检查工具与服务"></a>3.2.2 代码检查工具与服务</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281543538.png"></p><p>代码检查的产品，客户端、SCM(icode)、CI(Agile)之间具有交互性，共同构成整个代码检查环节。</p><h4 id="3-2-3-代码检查覆盖范围"><a href="#3-2-3-代码检查覆盖范围" class="headerlink" title="3.2.3 代码检查覆盖范围"></a>3.2.3 代码检查覆盖范围</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281544909.png"></p><p>在<strong>覆盖语言</strong>方面，代码检查目前已经覆盖了包括C++，Java/android, PHP, Python, Go, JS, OC, Kotlin在内的几乎所有主流语言。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281544915.png"></p><p>在<strong>检查维度</strong>方面，代码检查包括编码规范 代码缺陷，开源框架引用安全检查，可维护性(MI)。</p><h4 id="3-2-4-代码检查速度"><a href="#3-2-4-代码检查速度" class="headerlink" title="3.2.4 代码检查速度"></a>3.2.4 代码检查速度</h4><p>编码规范：只扫描变更文件，检查代码变更行是否符合规范，速度较快。</p><p>缺陷检查：需考虑文件依赖、函数调用关系、代码上下文等，相对耗时。</p><h3 id="3-3-代码检查规则分级"><a href="#3-3-代码检查规则分级" class="headerlink" title="3.3 代码检查规则分级"></a>3.3 代码检查规则分级</h3><h4 id="3-3-1-规则等级梳理"><a href="#3-3-1-规则等级梳理" class="headerlink" title="3.3.1 规则等级梳理"></a>3.3.1 规则等级梳理</h4><p>Code Review阶段，所有维度扫描出的问题可以分为以下3个等级：</p><ol><li><p>Error：属于需要强制解决的类型，影响代码合入，应视具体情况不同采取修复、临时豁免、标记误报等措施及时处理；</p></li><li><p>Warning：非强制解决类型，不影响代码含入，很可能存在风险，应尽量修复；</p></li><li><p>Advice：非强制解决类型，级别相对较低，不影响代码含入，可以选择性修复。</p></li></ol><h4 id="3-3-2-机检任务统一"><a href="#3-3-2-机检任务统一" class="headerlink" title="3.3.2 机检任务统一"></a>3.3.2 机检任务统一</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281548620.png"></p><h4 id="3-3-3-评审页行间提示"><a href="#3-3-3-评审页行间提示" class="headerlink" title="3.3.3 评审页行间提示"></a>3.3.3 评审页行间提示</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281550018.png"></p><h4 id="3-3-4-针对豁免、误报、咨询的说明"><a href="#3-3-4-针对豁免、误报、咨询的说明" class="headerlink" title="3.3.4 针对豁免、误报、咨询的说明"></a>3.3.4 针对豁免、误报、咨询的说明</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281550799.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281550899.png"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281550116.png"></p><h2 id="4-代码检查规则：Python语言案例详解"><a href="#4-代码检查规则：Python语言案例详解" class="headerlink" title="4 代码检查规则：Python语言案例详解"></a>4 代码检查规则：Python语言案例详解</h2><h3 id="4-1-Python的代码检查规则"><a href="#4-1-Python的代码检查规则" class="headerlink" title="4.1 Python的代码检查规则"></a>4.1 Python的代码检查规则</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281552034.png"></p><p>Python代码检查规则主要分为四个大类，分别是<strong>代码风格规范、引用规范、定义规范和异常处理规范</strong>。</p><h4 id="4-1-1-代码风格规范"><a href="#4-1-1-代码风格规范" class="headerlink" title="4.1.1 代码风格规范"></a>4.1.1 代码风格规范</h4><h5 id="（1）程序规模规范："><a href="#（1）程序规模规范：" class="headerlink" title="（1）程序规模规范："></a><strong>（1）程序规模规范：</strong></h5><ol><li><p>每行不得超过 120 个字符。</p></li><li><p>定义的函数长度不得超过 120 行。</p></li></ol><p>这意味着，在编写代码时，需要时刻注意自己的程序规模，避免冗余，确保写出简洁而高效的代码。</p><h5 id="（2）语句规范"><a href="#（2）语句规范" class="headerlink" title="（2）语句规范"></a><strong>（2）语句规范</strong></h5><p>因为Python与其他语言不同，可以不需要明确的标识符表示语句的结尾，所以规定：</p><ol start="3"><li><p>禁止以分号结束语句。</p></li><li><p>在任何情况下，一行只能写一条语句。</p></li></ol><h5 id="（3）括号使用规范"><a href="#（3）括号使用规范" class="headerlink" title="（3）括号使用规范"></a><strong>（3）括号使用规范</strong></h5><ol start="5"><li>除非用于明确算术表达式优先级、元组或者隐式行连接，否则尽量避免冗余的括号。</li></ol><h5 id="（4）缩进规范"><a href="#（4）缩进规范" class="headerlink" title="（4）缩进规范"></a><strong>（4）缩进规范</strong></h5><ol start="6"><li>禁止使用Tab进行缩进，而统一使用4个空格进行缩进</li></ol><p>需要将单行内容拆成多行写时规定：</p><ol start="7"><li>与首行保持对齐；或者首行留空，从第二行起统一缩进4个空格。</li></ol><h5 id="（5）空行规范"><a href="#（5）空行规范" class="headerlink" title="（5）空行规范"></a><strong>（5）空行规范</strong></h5><ol start="8"><li>文件级定义（类或全局函数）之间，相隔两个空行；类方法之间，相隔一个空行。</li></ol><h5 id="（6）空格规范"><a href="#（6）空格规范" class="headerlink" title="（6）空格规范"></a><strong>（6）空格规范</strong></h5><ol start="9"><li><p>括号之内均不添加空格。</p></li><li><p>参数列表、索引或切片的左括号前不应加空格。</p></li><li><p>逗号、分号、冒号之前均不添加空格，而是在它们之后添加一个空格。</p></li><li><p>所有二元运算符前后各加一个空格。</p></li><li><p>关键字参数或参数默认值的等号前后不加空格。</p></li></ol><h5 id="（7）注释规范"><a href="#（7）注释规范" class="headerlink" title="（7）注释规范"></a><strong>（7）注释规范</strong></h5><ol start="14"><li>每个文件都必须有文件声明，每个文件声明至少必须包括以下三个方面的信息：版权声明、功能和用途介绍、修改人及联系方式。</li></ol><p>另外在使用文档字符串（docstirng）进行注释时，规定：</p><ol start="15"><li><p>使用docstring描述模块、函数、类和类方法接口时，docstring必须用三个双引号括起来。</p></li><li><p>对外接口部分必须使用docstring描述，内部接口视情况自行决定是否写docstring。</p></li><li><p>接口的docstring描述内容至少包括以下三个方面的信息：功能简介、参数、返回值。如果可能抛出异常，必须特别注明。</p></li></ol><h4 id="4-1-2-引用规范"><a href="#4-1-2-引用规范" class="headerlink" title="4.1.2 引用规范"></a>4.1.2 引用规范</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111281600533.png"></p><p><strong>严格而具体的规定：</strong></p><ol><li>禁止使用 from……import…… 句式直接导入类或函数，而应在导入库后再行调用。</li><li>每行只导入一个库。</li><li>按标准库、第三方库、应用程序自有库的顺序排列import，三个部分之间分别留一个空行。</li></ol><h4 id="4-1-3-定义规范"><a href="#4-1-3-定义规范" class="headerlink" title="4.1.3 定义规范"></a>4.1.3 定义规范</h4><p><strong>（1）在变量定义方面，我们有强制的规范规定：</strong></p><ol><li>局部变量使用全小写字母，单词间使用下划线分隔。</li><li>定义的全局变量必须写在文件头部。</li><li>常量使用全大写字母，单词间使用下划线分隔</li></ol><p><strong>（2）函数的定义规范主要体现在函数的返回值以及默认参数的定义上。</strong></p><p>为提高代码可读性，对于函数的返回值，规范要求为：</p><ol><li>函数返回值必须小于或等于3个。若返回值大于3个，则必须通过各种具名的形式进行包装。</li></ol><p>为了保障函数的运行效率以及降低后期维护和纠错的成本，对于函数默认参数的定义有如下要求：</p><ol start="2"><li>仅可使用以下基本类型的常量或字面常量作为默认参数：整数、bool、浮点数、字符串、None。</li></ol><p><strong>（3）类定义的规范包括了四个方面的内容：</strong></p><ol><li>类的命名使用首字母大写的驼峰式命名法。</li><li>对于类定义的成员：protected成员使用单下划线前缀；private成员使用双下划线前缀。</li><li>如果一个类没有基类，必须继承自object类。</li><li>类构造函数应尽量简单，不能包含可能失败或过于复杂的操作。</li></ol><h4 id="4-1-4-异常处理规范"><a href="#4-1-4-异常处理规范" class="headerlink" title="4.1.4 异常处理规范"></a>4.1.4 异常处理规范</h4><p>在代码编写中应该<strong>尽量避免出现代码异常状态</strong>，然而错误有时在所难免，对于这些异常状态的处理，有着明确的规范要求：</p><ol><li>禁止使用双参数形式或字符串形式的语法抛出异常。</li><li>如需自定义异常，应在模块内定义名为 Error 的异常基类。并且，该基类必须继承自 Exception 。其他异常均由该基类派生而来。</li><li>除非重新抛出异常，禁止使用 except：语句捕获所有异常， 一般情况下，应使except……：语句捕获具体的异常。</li><li>捕捉异常时，应当使用 as 语法，禁止使用逗号语法。</li></ol><h3 id="4-2-Python编码惯例"><a href="#4-2-Python编码惯例" class="headerlink" title="4.2 Python编码惯例"></a>4.2 Python编码惯例</h3><h4 id="4-2-1-让模块既可被导入又可被执行"><a href="#4-2-1-让模块既可被导入又可被执行" class="headerlink" title="4.2.1 让模块既可被导入又可被执行"></a>4.2.1 让模块既可被导入又可被执行</h4><p>python不同于编译型语言，而<strong>属于脚本语言</strong>，是动态的逐行解释运行，没有统一的程序入口。所以，为了方便模块之间的相互导入，我们通常<strong>自定义一个 main 函数，并使用一个if 语句</strong>， if 内置变量 <strong>name</strong> == ‘__main__’ ，在这个if 条件下，再去执行 main函数。这样，我们就能够实现，让模块既可被导入又可执行。</p><h4 id="4-2-2-in运算符的使用"><a href="#4-2-2-in运算符的使用" class="headerlink" title="4.2.2 in运算符的使用"></a>4.2.2 in运算符的使用</h4><p>in一种简洁而高效的运算符，很多时候，合理的使用in运算符，可以<strong>代替大量的重复判断过程</strong>，降低时间复杂度，提高代码的运行效率。</p><h4 id="4-2-3-不使用临时变量交换两个值"><a href="#4-2-3-不使用临时变量交换两个值" class="headerlink" title="4.2.3 不使用临时变量交换两个值"></a>4.2.3 不使用临时变量交换两个值</h4><p>Python有更简洁而高效的语句可以实现交换两个值的操作，并<strong>无必要引入临时变量</strong>来交换两个值。</p><h4 id="4-2-4-用序列构建字符串"><a href="#4-2-4-用序列构建字符串" class="headerlink" title="4.2.4 用序列构建字符串"></a>4.2.4 用序列构建字符串</h4><p>对于一个字符串列表、元组等，可以用序列来构建字符串，<strong>利用一个空字符串和join函数</strong>，就可以避免重复，高效完成相应字符串的构建。</p><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>百度高效研发实战训练营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>百度高效研发实战训练营Step1</title>
    <link href="/bitTraingClub1.html"/>
    <url>/bitTraingClub1.html</url>
    
    <content type="html"><![CDATA[<h1 id="百度高效研发实战训练营Step1"><a href="#百度高效研发实战训练营Step1" class="headerlink" title="百度高效研发实战训练营Step1"></a>百度高效研发实战训练营Step1</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-设计方法与实践"><a href="#1-设计方法与实践" class="headerlink" title="1 设计方法与实践"></a>1 设计方法与实践</h2><h3 id="1-1-软件设计原则"><a href="#1-1-软件设计原则" class="headerlink" title="1.1 软件设计原则"></a>1.1 软件设计原则</h3><ol><li><p>软件设计的目的</p><blockquote><p>软件设计是为了使软件在长期范围内能够容易的进行变化。我们从下面这三个点来理解这句话。</p><blockquote><ol><li>变化：<em>软件不是一成不变的</em>，无论是软件本身的需求、软件依赖的其他软件资源都是一直在发生变化的，唯一不变的就是变化。</li><li>容易：任何一个软件的变化都需要成本，要尽可能的降低变化的成本，使得软件可以很容易应对软件的变化。</li><li>长期：事实上需要长期进行维护的软件更应该做好软件设计，因为软件长期的变化非常多，难以提前作出预测，需要良好的软件设计来应对。</li></ol></blockquote></blockquote></li><li><p>软件设计原则</p></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111232319206.png"></p><blockquote><p>软件设计有着很多的原则，<em>最基本的原则是高内聚低耦合，它也是软件设计追求的最高目标</em>。 <em><strong>内聚</strong></em> 指的是一个软件内部间元素相关联的程度。</p><p><em><strong>高内聚</strong></em>追求的是紧密相关联的元素要放在一起。</p><p><em><strong>低耦合</strong></em>指的是单位之间尽可能少地关联，依赖。</p></blockquote><blockquote><p>在高内聚低耦合之上有很多其他的原则：如SOLID原则、简单设计、正交设计，在这之上还会有设计模式作为最高层的软件设计原则。</p></blockquote><h3 id="1-2-clean-code"><a href="#1-2-clean-code" class="headerlink" title="1.2 clean code"></a>1.2 clean code</h3><ol><li><p>clean code的概念</p><blockquote><p>clean code中文解释为<em>整洁代码</em>，是指写的代码能够在尽可能短的时间内被别人读懂，且代码看上去排版整洁、逻辑清晰、扩展性好。</p></blockquote></li><li><p>命名规则</p><blockquote><p>代码中命名需要遵循以下的几个规则：</p><blockquote><ol><li>表达它是什么，不要表达怎么做。</li><li>代码要做到自注释。</li><li>使用有意义的循环迭代变量。</li><li>避免缩写，尤其拼音缩写。</li><li>不要使用非约定俗成的缩写。</li><li>避免使用魔法数。</li><li>不要害怕长变量名。</li></ol></blockquote></blockquote></li><li><p>注释</p><blockquote><p>注释对于代码来说是必不可少的。通常情况下，<em>好的注释包含：版权信息，设计意图，警示信息。</em></p><p>不好的注释则具有以下一个或几个特点：同义反复、隐晦关联关系、套用模板、提供历史修改记录以及注释掉的代码。</p></blockquote></li><li><p>函数</p><blockquote><p>在写函数时，应当注意，<em>每个函数只做一件事</em>，每个函数应是单一职责。</p><p>函数分为骨架函数和步骤函数。</p><ul><li><em>骨架函数</em> 是业务逻辑和算法是在高层次上的抽象描述。</li><li><em>步骤函数</em> 是业务逻辑和算法的一些实现细节，是被隐藏起来的。</li></ul></blockquote></li><li><p>编码细节</p><blockquote><p>在编码细节方面，需要遵循以下几点规则：</p><blockquote><ol><li>使用自然的比较顺序。</li><li>简化逻辑层次，避免多层嵌套。</li><li>在写三元表达式时不要出现复杂的逻辑和过长的条件。</li><li>需要控制变量的作用域，也就是缩小变量作用域的范围，越小越好。</li></ol></blockquote></blockquote></li></ol><h3 id="1-3-单元测试"><a href="#1-3-单元测试" class="headerlink" title="1.3 单元测试"></a>1.3 单元测试</h3><ol><li><p>为什么进行单元测试</p><blockquote><p>测试是分为不同层次的：最底层是单元测试，中间是基于模块级、组件级的测试，再往上则是系统级别的测试。</p><p><em>越底层的测试，越能够快速地发现问题。</em>底层的测试集成性更好，能够安全的进行代码修改。上层的测试一般情况下获得反馈的速度比较慢，测试过程也比较笨重。</p><p>所以单元测试具有<em>更早发现问题，更容易集成，更安全地代码修改的优点</em>。</p></blockquote></li><li><p>写好单元测试的重要性</p><blockquote><p>写好单元很费时。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111232334866.webp"></p><p><em>好的单元测试能够降低产品开发的成本。</em> 然而单元测试写得不好的话，不但会增加产品开发的成本，而且还会增加单元测试成本。</p></blockquote></li><li><p>单元测试原则与模式</p><p><strong>第一个原则：Tests As Documentation</strong></p><p>将测试当成一个文档工作，也就是说我们需要把测试写得像文档一样简洁，通过一些描述，可以清晰地知道这个测试的作用。在之后对项目修改时，只需要查看单元测试即可。</p><p><strong>第二个原则：Fully Automated and Self-Checking</strong></p><p>单元测试都是可以进行自我检查、自我校验的，通过代码的编写，能够知道测试是否成功，不需要人为判定。</p><p><strong>第三个原则：Do No Harm，不可破坏性。</strong></p><p>部分开发人员在进行测试时，为了完成目的，会基于测试代码创立一些逻辑，这种做法是错误的。在写测试时不能单独为测试创建特别的逻辑，更不能破坏原有代码的逻辑。</p><p><strong>第四个原则：Keep tests as simple as possible，简洁性。</strong></p><p>单元测试虽然是用来保证代码的正确性，但单元测试也是一份代码，为了避免过多的测试代码相覆盖，要尽可能地把单元测试的代码写得简单，保证其不会出错。</p></li></ol><h3 id="1-4-重构"><a href="#1-4-重构" class="headerlink" title="1.4 重构"></a>1.4 重构</h3><pre><code>重构时需要遵循的规则如下:</code></pre><blockquote><ol><li><strong>业务导向</strong></li></ol><p>重构一定是要解决实际的业务问题的，而不是为了重构去重构。</p><ol start="2"><li><p><strong>小步快跑</strong></p><p> 通常重构是需要多人同时参与，重构过程中开发人员要随时对比主干与分支的情况。当某一个开发人员在分支上进行了大量改动并准备将其合并到主干时，有可能主干和分支的代码有很大的差异。所以进行重构时，要<em>将问题拆分成多个小的单元进行修改，并且每修改一个就进行一次分支合并</em>。这种小步快跑的模式可以随时同步主干上的代码，减少出错的可能。</p></li><li><p><strong>演进式设计</strong></p><p> 在进行代码重构之前，我们不可能知道重构的最终结果是什么。为了保证能够得到一个比较好的结果，我们采用演进式设计方法。在重构过程中<em>遵循包括高内聚低耦合、正交设计原则、SOLID原则等软件设计原则，不断地用小步快跑的方式去重构</em>，只有这样结果才能令人满意。</p></li><li><p><strong>正交设计原则</strong></p><p>分离关注点、消除重复、缩小依赖范围、向着稳定的方向依赖。</p></li></ol></blockquote><pre><code>在代码中，根据功能的不同，将其分为不同的变化方向。每个变化方向都是一个职责，我们把每一个不同的变化方向称作关注点，根据它的变化方向来进行相应的处理。</code></pre><h3 id="1-5-配置化架构"><a href="#1-5-配置化架构" class="headerlink" title="1.5 配置化架构"></a>1.5 配置化架构</h3><ol><li><strong>配置化架构的定义：</strong></li></ol><p>以可配置的方式构建软件的方法。它是在领域建模的基础上，以配置表述业务，以配置组织架构元素，比如服务、组件、数据等，并对配置进行规范化、自动化的管理。</p><p>定义的原因：</p><blockquote><ol><li>通常情况下配置指的是对数据的抽象，需要架构上的描述；</li><li>架构上描述的配置指的是对架构元素的抽象，描述配置化不完整；</li><li>配置化包括对业务的抽象，尤其是逻辑；</li><li>配置化还包括对配置的管理以及分支。</li></ol></blockquote><ol start="2"><li><strong>如何应用配置化架构</strong></li></ol><p>应用配置化架构包括三方面：从业务上改造，提高配置本身的开发效率，降低配置的维护成本。</p><blockquote><ol><li><strong>业务配置化改造</strong></li></ol><blockquote><ol><li>组件配置化</li></ol><p>组件配置化表达<em>是业务层面上非常重要的一环</em>，组件是一个独立升级发布的单元，这样的单元关联了很多配置，可将这些配置分为两类。一类是<em>组件内部的配置</em>，另二类是<em>描述组件与组件间关系的配置</em>。只有组件配置化是不够的，往往还需要构建DSL来帮助。</p><ol start="2"><li>构建DSL：</li></ol><p>DSL是工程师针对不同的领域创建的语言。具有很强的针对性，在专业领域有时很长的代码只需要将其改为一行配置就足够了。</p></blockquote><ol start="2"><li><strong>提高配置的开发效率</strong></li></ol><p>通过下面的持续发布的系统，能够很好地提高配置的开发效率。它只针对配置，可以独立的发布配置。在系统中：需要配置前端编辑逻辑，后端校验逻辑，当存储发生变更时，触发测试流水线，当测试流水线无异常后，才会借用部署的工具，将配置分发到线上去。</p><ol start="3"><li><strong>降低配置的维护成本</strong></li></ol><p>通常来说，代码数量很大的项目，配置也会很多。这样的配置在维护起来需要花费大量的成本。所以在设计配置的时候，要满足以下这些规则：</p><blockquote><ol><li>让配置尽可能地在部署、数据版本、业务属性和架构描述这四个不同维度间参数能够共用。把部署的配置和策略的配置分离开来。</li><li>针对配置本身的语法，让配置支持合并.</li><li>减少冗余信。</li><li>消除信息重复。</li><li>使用配置的默认值。</li></ol></blockquote></blockquote><h2 id="2-高效研发流程脚本"><a href="#2-高效研发流程脚本" class="headerlink" title="2. 高效研发流程脚本"></a>2. 高效研发流程脚本</h2><h3 id="2-1-从产品目标到产品路线图"><a href="#2-1-从产品目标到产品路线图" class="headerlink" title="2.1 从产品目标到产品路线图"></a><strong>2.1 从产品目标到产品路线图</strong></h3><blockquote><p>满足用户诉求是产品的基础功能，在此之上还有一个更高的期望，即产品的目标。通常情况下产品目标与产品的收益、市场份额、流水有关。在制定具体产品目标时，需要考虑产品的商业模式以及产品所处的阶段。<em>好的产品目标是具体的、可衡量的、相对稳定的。</em></p><p>在进行产品目标阶段性地拆解时，需要考虑拆解的维度与方法。除了根据阶段性的时间维度进行拆分外，还可以根据产品的里程碑进行拆分。</p></blockquote><h3 id="2-2-从产品路线图到发布计划"><a href="#2-2-从产品路线图到发布计划" class="headerlink" title="2.2 从产品路线图到发布计划"></a>2.2 <strong>从产品路线图到发布计划</strong></h3><p>在了解如何制定产品发布计划之前，我们需要先了解一个工具：<em>用户故事地图</em>。用户故事地图实际上是一个完整的用户故事。它可以帮助我们增强团队协作、洞察真实需求、打磨优良产品。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242041157.png" alt="image-20211124204157089"></p><p>想要创建用户故事地图，首先要有用户故事地图的框架。它的核心是一条从左到右的时间线，然后从上到下按照归纳结构分为三个层级。这一条时间线上方的一级粒度的功能需求，在工作中，我们称之为Epic，也就是橙色卡片。这条时间线下方的第一行为二级粒度的功能需求，在工作中，称之为Feature，是黄色卡片。在二级粒度功能下，蓝色的卡片为三级粒度的需求，工作中，称之为Story，是蓝色卡片。</p><p>用户故事地图创建中五个重要的步骤：</p><blockquote><ol><li>一步一步写出你的故事</li><li>组织情节</li><li>探索替代故事</li><li>提取故事地图的主干</li><li>切分出能帮你达成特定目标的任务</li></ol></blockquote><p><strong>“训练智能机器人小A从起床到出门”</strong>的简单例子</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242043740.png" alt="image-20211124204337683"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242053569.png"></p><p><em>首先我们使用蓝色卡片</em> 按照步骤写出每个任务，每张卡片只写一个任务，任务以动词开头，如“睁眼”、“关闹钟”、“穿拖鞋”、“叠被子”等等。然后按照任务的发生顺序从左到右的组织卡片摆放。</p><p>接下来第二步，对所有的任务进行提取，得到概括性的行为，把这些<em>行为放到黄色卡片</em>上，也就是feature。如：“睁眼”、“关闹钟”这些行为可以归为“醒来”后要做的事情；“穿拖鞋”、“叠被子”这两个行为可以归为“起来”后要做的事情。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242055033.png"></p><p>接下来进入第三步：探索替代故事。细节、替代、变化和异常构成故事地图的主题。比如：时间充裕可以睡个回笼觉，楼上装修被提前吵醒等等可能发生的变化和异常。我们需要将这些任务补充进地图。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242057602.png"></p><p>然后进入第四步：将一系列类似的任务提取出来，形成更大的目标。在类似任务的上方，放一张<em>橙色的卡片,也就是之前提到的Epic,卡片贴上一个动词短语</em>，使其足以覆盖其下方所有任务卡片所要表达的意思。例如：“起床”可以概括“醒来”和“起来”；“如厕”可以概括“如厕”和“刷牙”。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242058456.png"></p><p>此时已经完成了较为完整的故事地图。然后进入第五步，切分出能达成特定目标的任务。先确定本次迭代需要完成的特性/目标，使用切分来识别和特定相关的所有任务和细节。</p><p>在“训练智能机器人小A从起床到出门”这个例子中，分为了三个版本。在第一个版本15分钟起床，回笼觉这张卡片明显是不需要放到其中的。在这些的story中选出满足15分钟起床的事务并将其放入都第一个版本中。至此我们也就完成了一个简单的用户故事地图的创建。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242002082.webp"></p><p>上面这张图片是实际工作中对用户故事地图的应用，可以看到在实际工作中完整的用户故事地图所包含的内容非常庞杂。</p><p>完成用户故事地图之后，就需要制订发布计划。在创建用户故事地图的第五步中，我们切分出了达成特定功能的任务目标，每一个发布计划都对应着一个版本。具体的步骤如下：</p><blockquote><ol><li>Big Story进行细化讨论</li><li>按照价值和重要程度进行版本规划</li><li>确定每个版本的期望达成目标</li><li>确定每个版本的内容</li><li>团队达成共识</li></ol></blockquote><p>通过以上步骤，就基本确定了用户故事地图的发布计划。</p><h3 id="2-3-从发布计划到迭代计划"><a href="#2-3-从发布计划到迭代计划" class="headerlink" title="2.3 从发布计划到迭代计划"></a>2.3 <strong>从发布计划到迭代计划</strong></h3><p>第三部分主要讲解 <em>集中发布式模式</em> 这一常用的模式，在集中发布式模式中<em>，一次发布包含多次迭代</em>；在迭代发布模式中，一次发布等于一次迭代。</p><p>很多大型项目都在使用这一模式，通常是每月发布一次，<em>一次发布包含四个迭代</em>，四个迭代之后，发布一次版本。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242101886.png"></p><p>从发布计划到迭代计划共包括四个内容。</p><ol><li><strong>用户故事拆分</strong></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242101974.png"></p><pre><code>用户故事的拆分*对迭代速率有一定影响*。对用户故事的拆分要做到拆分出的故事尽量小，但是要适当，并不是越小越好。避免出现一个迭代内无法完成的故事。</code></pre><ol start="2"><li><strong>用户故事优先级</strong></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242104291.webp"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242006342.webp"></p><pre><code>在完成用户故事拆分后，需要对用户故事的优先级进行排序。用户故事的排序其实是对需求的一个排序，优先级排序有许多方法，如高中低、数字排序、衣服尺码L、XL等方式。*优先级决定排入迭代的顺序。*以一个两周的迭代时间为例，假设我们有这样一个需求，前面的数字是需求卡片的序号，后面的数字从100到45，这是项目优先级排序的一个方式。每一次迭代能做4个卡片时，我们就会*把优先级最高的卡片放入迭代池*。而当第二次迭代时，需求发生了变化，出现了x和y两个新的需求，x和y有着较高的优先级，那么我们仍然将优先级最高的四个卡片放入迭代池中。第三次迭代中又插入了新需求z，需求z也有较高的优先级，那么当我们进行迭代的时候，需求z就会顶替另一个需求被放入迭代池中。通过以上的例子可以看到，在原本的迭代计划中，12张卡片会被按顺序放入迭代池中，而真实情况是插入了更高优先级的需求，替换了低优先级的需求，把低优先级的需求放入了下一次迭代中。这就是优先级排序对迭代计划的影响。</code></pre><ol start="3"><li><strong>用户故事估算</strong></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242105269.png"></p><pre><code>在迭代之前，需要对用户故事进行估算，*用户故事估算实际上是对工作量的估算*。这个工作量体现的是团队均值能力。通常在公司内有不同级别的员工，高级别的员工和低级别的员工完成同一任务所需的时间是不同的。所以在进行用户故事估算时就需要规避掉技能的差异，根据团队的均值能力来进行估算。</code></pre><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242106613.png"></p><ol start="4"><li><strong>迭代计划制定</strong></li></ol><p>当前面三步全部完成后，才能开始指定迭代计划。</p><p>将已拆分好的用户故事按照优先级依次放入迭代池中，对每个要进行迭代的用户故事进行估算，确定好迭代的时间期限。所以我们就制定出了迭代计划。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242107859.png"></p><p><em>推荐采用范围调整、需求置换</em>方式，即插入高优先级用户故事，顺延低优先级故事到下一次迭代。</p><h3 id="2-4-从迭代计划到迭代的落地执行"><a href="#2-4-从迭代计划到迭代的落地执行" class="headerlink" title="2.4 从迭代计划到迭代的落地执行"></a>2.4 <strong>从迭代计划到迭代的落地执行</strong></h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242108710.png" alt="迭代计划会、站会、需求评审会、迭代回顾会"></p><p>在整个过程中开发和测试以story的力度进行。<em>分析、开发与测试三个步骤并行。</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242110996.png" alt="卡片墙"></p><p>团队可以使用卡片墙标注完成的任务和未完成的任务以及遇到的bug等。通过这种方式，能够对执行情况有清晰的认知，对执行过程产生积极的影响。</p><h2 id="3-研发工具链介绍"><a href="#3-研发工具链介绍" class="headerlink" title="3 研发工具链介绍"></a>3 研发工具链介绍</h2><h3 id="3-1-项目管理工具-iCafe"><a href="#3-1-项目管理工具-iCafe" class="headerlink" title="3.1 项目管理工具: iCafe"></a>3.1 项目管理工具: iCafe</h3><h4 id="3-1-1-需求管理"><a href="#3-1-1-需求管理" class="headerlink" title="3.1.1 需求管理"></a>3.1.1 需求管理</h4><p><strong>需求管理是一个项目的基石。</strong>在互联网行业中，因为产品需求迭代快速这一特点，需求管理一直非常令人头疼。所以如何对需求进行更好的管理，更好的做出产品规划对互联网行业的项目来说是一个重要的问题。</p><blockquote><p>传统的需求管理方法有以下几种：</p><ol><li>直接将需求写在文档上面，</li><li>将需求制作成需求卡片，通过这样的方式让研发人员与需求人员保持信息的一致。</li><li>使用Excel进行需求管理和排序。</li></ol></blockquote><p>这三种方法都存在很多的缺点，如撰写文档耗时长、文档编写需求较多人力、文档维护成本高、文档使用过程中沟通不畅等等。文字因为其阅读特性，不方便对任务进行直观的展现。所以在很多项目开发过程中，经常会出现文档交给研发人员后，开发出的产品与文档设计不一致的问题。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111250059343.png"></p><p>互联网的需求管理需要具有<strong>需求完整性、沟通高效性、表达准确性，沟通便捷性</strong>等特点。</p><p>研究表明，不同的沟通方式产生的沟通效果各有不同。在所有的沟通方式中，文档沟通是最低效的沟通方式，而面对面使用白板沟通是最高效的沟通方式。结合多种高效沟通方式，就产生了用户故事地图这种新颖的需求管理、排序的方式。</p><p><strong>用户故事地图是敏捷项目管理中一种重要的管理方式。</strong></p><p>首先<strong>使用卡片在白板上将所有的需求列出来，</strong>这样有助于展现产品全貌，而且将需求转化为可视的卡片能更好的根据用户反馈对任务需求进行排序；</p><p>然后<strong>使用不同的颜色对卡片进行分层。</strong>蓝色卡片是第一层，黄色卡片是第二层，白色卡片是第三层。将颗粒度最小的需求放在白色卡片这一层，低颗粒度的需求更容易被研发人员接受。</p><p>最后通过横向的分组，把迭代计划每一期的每一版本的<strong>需求进行归类分组。</strong>这样有利于打通产品视图和研发计划视图。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292215228.png"></p><p>通过以上步骤可以得到一个较为完整的用户故事地图。</p><h4 id="3-1-2-迭代计划"><a href="#3-1-2-迭代计划" class="headerlink" title="3.1.2 迭代计划"></a>3.1.2 迭代计划</h4><p>在完成产品的版本规划后，研发团队需要制定相应的迭代计划。敏捷、快速、合理地迭代计划能够更高效地促进项目的迭代。</p><p>基于用户故事地图，可以在制定迭代计划的过程中中直接对需求进行<strong>上下拖拽修改优先级，左右拖拽更改计划。</strong>这样可以更清晰的展现迭代计划，使开发团队更好定位到的里程碑，完善整个迭代计划。</p><h4 id="3-1-3-进度追踪"><a href="#3-1-3-进度追踪" class="headerlink" title="3.1.3 进度追踪"></a>3.1.3 进度追踪</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111250103932.png"></p><p>进度跟踪的三大法宝：<strong>站会、卡片墙、燃尽图。</strong></p><p>站会同卡片墙相结合，在站会过程中可以直接通过电子看板共享项目进度和项目问题，提升站会沟通效率。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270116972.png"></p><p><strong>用户故事地图是一种非常高效需求管理方式，</strong>目前所有的研发团队都可以在效率云上不受物理条件限制的直接使用它进行需求管理和追踪。</p><h4 id="3-1-4-持续改进"><a href="#3-1-4-持续改进" class="headerlink" title="3.1.4 持续改进"></a>3.1.4 持续改进</h4><p>针对持续改进，有卡片状态时长散点图和卡片状态累积流图这两种工具。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270127171.png"></p><p><strong>卡片状态时长散点图</strong>能够精确展示团队工作速率，从需求提出到需求上线的单个周期时长和平均周期时长，精确的展示团队在每一个状态的工作速率及工作速率的变化。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270128848.png"></p><p><strong>卡片状态累积流图</strong>能够宏观展示项目各流程效率趋势，颜色的色块宽表示该流程积压的需求和任务比较多，色条变窄表明团队状态流动速率提高。</p><p>基于这两幅图工具，研发团队可以周期性地进行自检，对过去一段时间的工作进行自我审视，然后持续改进。</p><h3 id="3-2-代码管理工具-iCode"><a href="#3-2-代码管理工具-iCode" class="headerlink" title="3.2 代码管理工具:iCode"></a>3.2 代码管理工具:iCode</h3><h4 id="3-2-1-工作流"><a href="#3-2-1-工作流" class="headerlink" title="3.2.1 工作流"></a>3.2.1 工作流</h4><p>运转无序，开发混乱是困扰很多团队的一个问题，严重影响产品的交付。</p><p>典型的问题有：代码处理随意、bug重复发生、测试不完善、发布版本混乱等。</p><p>支持以下两种标准的工作流，用来保障团队有序协作。</p><h5 id="1-基于主干的工作流"><a href="#1-基于主干的工作流" class="headerlink" title="1.  基于主干的工作流"></a>1.  基于主干的工作流</h5><pre><code>在基于主干的工作流中，整个团队维护一条主干分支。为了保证主干分支的质量，需要配套严    格的准入机制，变更点在合入前需要经过机器、人工的双重评审，通过后才能合入主干。需要发布的时候，会基于主干拉取发布分支，这个分支其实是主干特定点的快照，单纯用于发        布，如果发布问题过程中发现问题，回到主干修复Bug或进行功能增强，必要时再将主干提交拣        选到相应的发布分支上。分支发布和主干并行不悖，不用担心开发中的功能被带到线上，发布完成后恢复到一条主干的        简明模式。</code></pre><blockquote><p>基于主干的工作流<strong>优点</strong>有：</p><ol><li>主干质量高，随时可以发布。</li><li>模型简单，只有一条主干，节省分支合并的成本。</li></ol></blockquote><pre><code>缺点: 在开发高质量的工程项目时，团队需要建设完备的测试用例，在提交环节要求提交人保持原子提交，即功能和提交一一对应。</code></pre><h5 id="2-基于分支的工作流"><a href="#2-基于分支的工作流" class="headerlink" title="2. 基于分支的工作流"></a>2. 基于分支的工作流</h5><p>在基于分支的工作流中，<strong>主干用于存储线上代码</strong>，需要变更时，基于主干最新代码开分支完成功能的开发、测试和发布；分支发布前，需要先同步主干的更新；上线之后，需要将分支合并回主干。</p><blockquote><p>基于分支的工作流的<strong>优点</strong>有：</p><ol><li>分支并行，独立开发，分支不会相互影响；</li><li>对团队而言，使用门槛低，分支贯穿一个独立功能开发、测试、发布的整个过程，给予团队充分的时间完善测试用例及完成人工测试；</li><li>容易上手，系统会引导开发人员完成新建分支、同步主干、合会主干等全部操作。</li></ol></blockquote><p>缺点：需要花费分支合并的成本、需要不断地同步主干，来发现分支的冲突风险点并提前解决。</p><h3 id="3-2-2-评审"><a href="#3-2-2-评审" class="headerlink" title="3.2.2 评审"></a>3.2.2 评审</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270327159.png"></p><p>评审是<strong>保证团队工程质量</strong>的一个重要的过程。如果不经过评审直接提交代码，可能会污染代码历史，增加后期维护成本，严重时可能还会产生代码质量问题。</p><p>在项目开发过程中，可能会出现本地运行正常的代码，在测试环境或者线上环境突然崩溃的情况。针对这样的问题，可以使用<strong>质量防护网</strong>。质量防护网包括代码扫描、持续集成、人工评审三个层次。</p><p><strong>代码扫描</strong>能够找出不符合代码规范的地方，在行间距中插入代码评论，同时出具一个风格报告，方便工程师对代码风格问题进行修改。</p><p><strong>持续集成</strong>会配置一个云端构建，通过云端构建，快速探测出代码初期Bug，帮助开发人员提早修复。</p><p>在前两步做好后，团队的资深成员就可以就架构、逻辑、设计等问题进行深入评审。</p><p>通过这三步，实现了机器、人工双重评审，层层递进，确保团队的工程质量。</p><h3 id="3-3-交付平台-iPipe"><a href="#3-3-交付平台-iPipe" class="headerlink" title="3.3 交付平台:iPipe"></a>3.3 交付平台:iPipe</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270329017.png"></p><h4 id="3-3-1-固化端到端的交付流程"><a href="#3-3-1-固化端到端的交付流程" class="headerlink" title="3.3.1 固化端到端的交付流程"></a>3.3.1 固化端到端的交付流程</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270333279.png"></p><p>标准的软件交付的过程包括以下几点：</p><blockquote><ol><li>会有一个明确的发布版本的输入，</li><li>基于这个发布版本，会进行代码提交。</li><li>代码提交之后会进行编译、测试。其中测试环节可能包含模块级的测试和系统级的测试。</li><li>进行发布。发布上线的过程可能会分为预上线、生产灰度、生产全量几个环节。</li></ol></blockquote><p>为了使代码变更流程标准化，需要<strong>使用交付流水线的方式来落地</strong>。通过标准化交付过程从而达到可靠、可重复的作用。交付流水线是<strong>串行执行</strong>的，上一个阶段成功执行后，就会触发下一个阶段。执行阶段由任务组成，这些任务可以是穿行的也可是并行的。任务的执行状态决定阶段执行状态。</p><p><strong>iPipe这一工具目前包含了标准的交付流水线</strong>，用户可以在iPipe中看到流水线的构建情况。在使用交付流水线的过程中，如果当前阶段失败，后面的阶段就不会继续进行，这样可以节省资源并且快速的发现问题，及时修复问题。</p><h4 id="3-3-2-插件化现有工具和服务"><a href="#3-3-2-插件化现有工具和服务" class="headerlink" title="3.3.2 插件化现有工具和服务"></a>3.3.2 插件化现有工具和服务</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292215685.png"></p><p>在交付流水线中执行各种任务时需要依赖很多工具和服务，比如maven，docker、jenkins、git等工具和服务。</p><p>我们通过一套<strong>标准的插件化开发规范</strong>将这些工具和服务集成到了流水线中，用户在使用流水线的过程中就可以很方便的使用这些插件和服务。如果流水线中没有想使用的插件、服务或工具，可以根据效率云提供的插件规范，自行扩展以满足项目需求。</p><h4 id="3-3-3-数据度量驱动过程改进"><a href="#3-3-3-数据度量驱动过程改进" class="headerlink" title="3.3.3 数据度量驱动过程改进"></a>3.3.3 数据度量驱动过程改进</h4><p>通过交付流水线，可以快速获取项目所有的数据和信息，如：一个版本从代码提交到交付上线的周期或者一个项目各个阶段发现的缺陷数量等等。</p><p>用户可以通过调用API获取数据来进行数据的度量，从而推动交付过程的改进。在后续的发展中，平台会识别项目中关键的数据指标并且自动化的形成更加鲜明的数据报表。这样就可以持续的进行数据度量，给个人及团队提供一个维度丰富的平台。</p><h2 id="4-持续交付方法与实践"><a href="#4-持续交付方法与实践" class="headerlink" title="4 持续交付方法与实践"></a>4 持续交付方法与实践</h2><h3 id="4-1-为什么要做持续交付"><a href="#4-1-为什么要做持续交付" class="headerlink" title="4.1 为什么要做持续交付"></a>4.1 为什么要做持续交付</h3><h4 id="4-1-1-软件交付流程"><a href="#4-1-1-软件交付流程" class="headerlink" title="4.1.1 软件交付流程"></a>4.1.1 软件交付流程</h4><p>传统软件交付流程通常包括四个步骤：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271338880.png"></p><ol><li>首先业务人员会诞生一个软件的想法；</li><li>然后开发人员将这个想法变为一个产品或者功能；</li><li>经过测试人员的测试之后提交给用户使用并产生收益；</li><li>最后运维人员参与产品或功能的后期运维。</li></ol><h4 id="4-1-2-传统软件交付的问题和困境"><a href="#4-1-2-传统软件交付的问题和困境" class="headerlink" title="4.1.2 传统软件交付的问题和困境"></a>4.1.2 传统软件交付的问题和困境</h4><p>通过分析以上流程，可以发现一些传统软件交付流程<strong>存在的问题</strong>。</p><ol><li><strong>业务人员产生的需求文档沟通效率较低</strong>，有时会产生需求文档描述不明确、需求文档变更频繁等问题。</li><li>随着开发进度的推进，测试人员的工作量会逐步增加，测试工作的比重会越来越大。而且由于测试方法和测试工具有限，自动化测试程度低，<strong>无法很好地把控软件质量</strong>。</li><li>真实项目中运维的排期经常会被挤占，又因为手工运维繁琐复杂，<strong>时间和技术上的双重压迫</strong>会导致运维质量难以保证。</li></ol><p>因为存在以上问题，所以传统的软件交付经常会出现开发团队花费大量成本开发出的功能或产品并不能满足客户需求这一双输的局面。由此可以总结出传统的软件交付存在<strong>两个层面的困境：</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271339450.png"></p><p>从<strong>表现层</strong>来看，传统软件交付存在进度不可控；流程不可靠；环境不稳定；协作不顺畅等困境。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271339695.png"></p><p>表现层的问题其实都是由<strong>底层问题</strong>引起的，从根源上来说，存在分支冗余导致合并困难；缺陷过多导致阻塞测试；开发环境、测试环境、部署环境不统一导致的未知错误；代码提交版本混乱无法回溯；等待上线周期过长；项目部署操作复杂经常失败；上线之后出现问题需要紧急回滚；架构设计不合理导致发生错误之后无法准确定位等困境。</p><h4 id="4-1-3-持续交付的流程与优势"><a href="#4-1-3-持续交付的流程与优势" class="headerlink" title="4.1.3 持续交付的流程与优势"></a>4.1.3 持续交付的流程与优势</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271340504.png"></p><p>经过对传统软件交付问题的分析和总结，持续交付应运而生，持续交付是一系列开发实践方法，用来确保让代码能够快速、安全的部署到生产环境中。持续交付是一个完全自动化的过程，当业务开发完成的时候，可以做到一键部署。持续交付提供了一套更为完善的解决传统软件开发流程的方案。</p><ol><li>在需求阶段，抛弃了传统的需求文档的方式，使用便于开发人员理解的用户故事。</li><li>在开发测试阶段，做到持续集成，让测试人员尽早进入项目开始测试。</li><li>在运维阶段，打通开发和运维之间的通路，保持开发环境和运维环境的统一。</li></ol><p><strong>持续交付具备以下几个优势：</strong></p><blockquote><ol><li>持续交付能够有效缩短提交代码到正式部署上线的时间，降低部署风险。</li><li>持续交付能够自动的、快速的提供反馈，及时发现和修复缺陷。</li><li>持续交付让软件在整个生命周期内都处于可部署的状态。</li><li>持续交付能够简化部署步骤，使软件版本更加清晰。</li><li>持续交付能够让交付过程成为一种可靠的、可预期的、可视化的过程。</li></ol></blockquote><h4 id="4-1-4-敏捷开发与Devops"><a href="#4-1-4-敏捷开发与Devops" class="headerlink" title="4.1.4 敏捷开发与Devops"></a>4.1.4 敏捷开发与Devops</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271341155.png"></p><p>持续交付依靠<strong>敏捷开发（Agile）</strong>和<strong>Devops</strong>两个组件的支撑可以更好地发挥作用。</p><p>敏捷开发（Agile）主要作用于需求阶段和研发阶段。</p><p>Devops主要作用于开发测试和运维部署阶段。</p><blockquote><p>了解Devops的相关知识。</p><blockquote><ol><li><p>Devops的趋势</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271341165.png"></p><p>根据最近的一项集体研究，DevOps的市场在2020年创造了约50亿美元的产值，预计到2022年，这个数字将达到约66亿美元。随着Devops的影响力不断扩大，目前DevOps已经成为软件工程的主流模式。</p></li></ol></blockquote><blockquote><ol start="2"><li><p>Devops效能</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271342341.png"></p><p>Devops的效能跟发布频率、部署时间、平均修复故障的时间点、部署变更的失败率四个因素紧密相关。通常在高效的团队内，发布频率会达到每天多次发布、部署时间和平均修复故障时间都小于一小时，部署变更的失败率也能维持在15%以下。</p></li></ol></blockquote></blockquote><h4 id="4-1-5-软件交付能力指标"><a href="#4-1-5-软件交付能力指标" class="headerlink" title="4.1.5 软件交付能力指标"></a>4.1.5 软件交付能力指标</h4><p>在评价互联网公司的软件交付能力的时候，通常会使用两个指标：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271343658.png"></p><ol><li>仅涉及一行代码的改动需要花费多少时间才能部署上线，这也是<strong>核心指标</strong>。</li><li>开发团队是否在以一种可重复、可靠的方式在执行软件交付。</li></ol><p>目前，国外的主流互联网企业部署周期都以分钟为单位， Amazon、Google这些头部互联网企业单日的部署频率都在20000次以上。国内以百度、阿里、腾讯三大互联网巨头的数据来看，单日部署的频率也达到了单日8000次以上。高频率的部署代表着能够更快更好的响应客户的需求。</p><h3 id="4-2-如何做到高效的持续交付"><a href="#4-2-如何做到高效的持续交付" class="headerlink" title="4.2 如何做到高效的持续交付"></a>4.2 如何做到高效的持续交付</h3><h4 id="4-2-1-持续交付方法"><a href="#4-2-1-持续交付方法" class="headerlink" title="4.2.1 持续交付方法"></a>4.2.1 持续交付方法</h4><p>为了能更好的做到高效的持续交付。在此我们提供了一个<strong>三层叠加的持续交付方法</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271345629.png"></p><p>首先最上层，持续交付的<strong>总目标是价值交付</strong>，要为用户交付有价值的内容。</p><p>然后第二层包含了业务、流程、组织三个维度。</p><p>在业务这一维度，主要通过精益、用户故事地图、看板三种方式来减少业务部门与开发部门的沟通困难。</p><p>在流程这一维度，主要集中于创建一个供开发、测试、运维人员使用的可靠、可重复的流水线，将这种流水线应用于项目的流程中。</p><p>在组织这一维度，要求加强团队协作，提高项目质量和项目改进能力，并且引入了成熟度模型用于评估团队的能力层级。</p><p>如果没有技术能力的支撑，仅依靠方法和指导思想不足以做到高效持续交付。所以<strong>第三层也是最重要的底层是技术层</strong>。技术层包括了基础架构和应用架构。<strong>基础架构</strong>引入了容器集群管理、研发工具平台、持续交付工具链。<strong>应用框架</strong>引入了浮现式设计、微服务框架还有能够抽离出来的配置化架构。</p><h4 id="4-2-2-持续交付、持续集成、持续部署的关系"><a href="#4-2-2-持续交付、持续集成、持续部署的关系" class="headerlink" title="4.2.2 持续交付、持续集成、持续部署的关系"></a>4.2.2 持续交付、持续集成、持续部署的关系</h4><p>要进一步构建可靠可重复的流水线，首先就是要理清持续交付、持续集成和持续部署三者之间的关系。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271348755.png"></p><p>简单来说<strong>持续集成和持续部署是持续交付的基础，持续交付包括但不限于持续集成和持续部署。</strong></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271350656.png"></p><p>持续集成是包含了代码的编译、近代检查、单元测试任务的集成，虽然持续集成也能构成一条流水线，但是这条流水线并不完整，而且集成并没有明确的目标。</p><p>近几年得益于虚拟机技术和容器技术的迅速发展，持续部署也逐渐变得简单高效，能够运用这些工具快速将项目部署到例如准入环境、预生产环境等等各种环境中。</p><h4 id="4-2-3-如何构建一个可靠可重复的流水线"><a href="#4-2-3-如何构建一个可靠可重复的流水线" class="headerlink" title="4.2.3 如何构建一个可靠可重复的流水线"></a>4.2.3 如何构建一个可靠可重复的流水线</h4><p>在理清持续交付的关系后，需要通过持续交付来构建一条可靠可重复的流水线，构建这条流水线的目的是为了让开发人员、测试人员、运维人员能更好的协作完成整个项目并上线到生产环境。</p><p>通过对比传统流水线和持续交付流水线，能更加清晰地展现出持续交付流水线的强大。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271351747.png"></p><p>在传统流水线中，首先代码提交要用过填写表单的形式进行版本申请，然后开发人员在离线环境上手工进行代码编译和单元测试，单元测试完成后需要撰写对应的测试报告文档并且向上提测，在系统测试环节需要测试人员手动构建和部署测试环境，完成测试之后再次撰写测试报告，并且申请上线，在通过上线审批之后，在线上生产环境需要再次手动构建环境以及进行生产环境的测试，最终完成整体的开发。</p><p>在持续交付流水线中，代码合入到主干之后会直接触发自动编译，自动编译完成之后会进行初步的自动化单元测试、模块测试和系统测试，在测试过程中持续交付可以自动构建和部署环境。完成系统测试之后会将问题抛出来，解决完成后再次提测，会自动化的再次进行系统测试，通过系统测试之后可以一键操作进行项目发布，并进行预上线，在完成预上线后，可以再次进行一键操作完成正式生产环境的上线。</p><p>通过两种流水线的对比，可以看出来，持续交付的流水线有显著的优势。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271352109.png"></p><p>实际生产中的产品级流水线，可以视为多个模块级流水线的组合，多个模块级流水线组合成为复杂的多线并发的产品级流水线，最终可以完成整个项目的持续交付。</p><h4 id="4-2-4-交付流水线落地工具"><a href="#4-2-4-交付流水线落地工具" class="headerlink" title="4.2.4 交付流水线落地工具"></a>4.2.4 交付流水线落地工具</h4><p>交付流水线的落地需要依靠<strong>落地方案</strong>和<strong>落地工具</strong>，目前常用的落地方案有GoCD，这是thoughtworks的一个产品。还有目前广泛应用的Jenkins和Spinnakeer。</p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271354818.png" style="zoom:50%;" /><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271354355.png" style="zoom:50%;" /><p>常用的交付流水线落地工具有效率云平台中的iPipe工具，在这个工具中可以根据需求创建流水线，并且将相关内容全都关联到流水线中，这样可以让开发人员、测试人员和运维人员在这个工具中直观的看到产品的状态以及质量情况。</p><h3 id="4-3-持续部署"><a href="#4-3-持续部署" class="headerlink" title="4.3 持续部署"></a>4.3 持续部署</h3><p>对于持续交付整体来说，持续部署非常重要。</p><h4 id="4-3-1-持续部署方案"><a href="#4-3-1-持续部署方案" class="headerlink" title="4.3.1 持续部署方案"></a>4.3.1 持续部署方案</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292215446.png"></p><p>容器技术目前是部署中最流行的技术，常用的持续部署方案有Kubernetes+Docker和Matrix系统两种。容器技术一经推出就被广泛的接受和应用，主要原因是对比传统的虚拟机技术有以下几个<strong>优点</strong>：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292215715.png"></p><ol><li>容器技术上手简单，轻量级架构，体积很小。</li><li>容器技术的集合性更好，能更容易对环境和软件进行打包复制和发布。</li></ol><p>容器技术的引入为软件的部署带来了前所未有的改进，不但<strong>解决了复制和部署麻烦</strong>的问题，还能<strong>更精准的将环境中的各种依赖进行完整的打包。</strong></p><h4 id="4-3-2-部署原则"><a href="#4-3-2-部署原则" class="headerlink" title="4.3.2 部署原则"></a>4.3.2 部署原则</h4><p><strong>在持续部署管理的时候，需要遵循一定的原则，内容包括以下几点：</strong></p><ol><li>部署包全部来自统一的存储库。</li><li>所有的环境使用相同的部署方式。</li><li>所有的环境使用相同的部署脚本。</li><li>部署流程编排阶梯式晋级，即在部署过程中需要设置多个检查点，一旦发生问题可以有序的进行回滚操作。</li><li>整体部署由运维人员执行。</li><li>仅通过流水线改变生产环境，防止配置漂移。</li><li>不可变服务器。部署方式采用蓝绿部署或金丝雀部署。</li></ol><h4 id="4-3-3-部署层次"><a href="#4-3-3-部署层次" class="headerlink" title="4.3.3 部署层次"></a>4.3.3 部署层次</h4><p>部署层次的设置对于部署管理来说也是非常重要的。首先要明确部署的目的并不是部署一个可工作的软件，而是<strong>部署一套可正常运行的环境</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271634406.png"></p><p><strong>完整的镜像部署包括三个环节：Build – Ship – Run。</strong></p><p>Build跟传统的编译类似，将软件编译形成RPM包或者Jar包。</p><p>Ship则是将所需的第三方依赖和第三方插件安装到环境中。</p><p>Run就是在不同的地方启动整套环境。</p><p>制作完成部署包之后，每次需要变更软件或者第三方依赖、插件升级的时候，不需要重新打包，直接更新部署包即可。</p><h4 id="4-3-4-不可变服务器"><a href="#4-3-4-不可变服务器" class="headerlink" title="4.3.4 不可变服务器"></a>4.3.4 不可变服务器</h4><p>在部署原则中提到的不可变服务器原则对于部署管理来说非常重要。不可变服务器<strong>是技术逐步演化的结果。</strong></p><p>在早期阶段，软件的部署是在物理机上进行的，每一台服务器的网络、存储、软件环境都是不同的，物理机的不稳定让环境重构变得异常困难。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271635334.png"></p><p>后来逐渐发展为虚拟机部署，在虚拟机上借助流程化的部署能较好的构建软件环境，但是第三方依赖库的重构不稳定为整体部署带来了困难。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292216469.png"></p><p>现阶段使用容器部署不但继承和优化了虚拟机部署的优点，而且很好的解决了第三方依赖库的重构问题，容器部署就像一个集装箱，直接把所有需要的内容全部打包进行复制和部署。</p><h4 id="4-3-5-蓝绿部署和金丝雀部署"><a href="#4-3-5-蓝绿部署和金丝雀部署" class="headerlink" title="4.3.5 蓝绿部署和金丝雀部署"></a>4.3.5 蓝绿部署和金丝雀部署</h4><p>在部署原则中提到两大部署方式分别为蓝绿部署和金丝雀部署。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271635700.png"></p><p><strong>蓝绿部署</strong>是指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速的将用户环境切回旧版本，并对新版本进行修复和调整。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271636728.png"></p><p><strong>金丝雀部署</strong>是指当有新版本发布的时候，先让少量的用户使用新版本并且观察新版本是否存在问题，如果出现问题，就及时处理并重新发布，如果一切正常，就稳步的将新版本适配给所有的用户。</p><h4 id="4-3-6-服务描述"><a href="#4-3-6-服务描述" class="headerlink" title="4.3.6 服务描述"></a>4.3.6 服务描述</h4><p>服务描述要实现的目标是当软件部署到不同的环境中时，通过服务描述来<strong>规避环境配置的差异</strong>。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637518.png"></p><p>在服务描述中，通常会对不同的环境下所需的配置进行描述，例如所需要的CPU、内存、网络等。当实际部署的时候，如果出现环境差异，调度工具就可以按照服务描述的配置发放资源，使环境能够正常运行。</p><h4 id="4-3-7-流程控制"><a href="#4-3-7-流程控制" class="headerlink" title="4.3.7 流程控制"></a>4.3.7 流程控制</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637506.png"></p><p>在部署阶段，为了防止意外问题的发生，会在一些环节<strong>加入人工审核</strong>。例如在灰度发布工具中，就会先对线上机器进行分组部署，然后由人工去分组检查，如果没有问题，就进行下一组的部署，如果出现问题，人工就可以及时的进行回滚操作，避免问题扩大到更多地线上环境中。</p><h4 id="4-3-8-数据度量和分析"><a href="#4-3-8-数据度量和分析" class="headerlink" title="4.3.8 数据度量和分析"></a>4.3.8 数据度量和分析</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637498.png"></p><p>在完成持续部署或持续交付之后，需要结合多个维度的数据对项目整体的<strong>研发效率和部署效率进行分析</strong>。例如通过交付时间周期的长短变化来反映流水线为团队带来的价值。再比如通过筛选和展示团队的相关数据，方便团队来进行决策。还有通过环比汇总数据来分析变化的趋势。系统也会通过数据的自动分析和异常报表监控一些关键指标，一旦关键数据出现问题，系统能够及时联系关键人员关注。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271640201.png"></p><p>通过以上的例子能够发现，<strong>持续交付与量化驱动改进是密不可分的</strong>，团队能够在度量中发现问题，在度量中看到进步。持续交付就是这样一个不断改进不断优化的过程，通过数据可以量化产出并且指引团队找到痛点并且进一步的深化改进。</p><!-- flag of hidden posts -->]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>百度高效研发实战训练营</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在服务器上搭建jupyter notebook</title>
    <link href="/buildJupyterOnServer.html"/>
    <url>/buildJupyterOnServer.html</url>
    
    <content type="html"><![CDATA[<h1 id="如何在服务器上搭建jupyter-notebook"><a href="#如何在服务器上搭建jupyter-notebook" class="headerlink" title="如何在服务器上搭建jupyter notebook"></a>如何在服务器上搭建jupyter notebook</h1><h2 id="1-准备一台Linux云服务器"><a href="#1-准备一台Linux云服务器" class="headerlink" title="1. 准备一台Linux云服务器"></a>1. 准备一台Linux云服务器</h2><h2 id="2-新建一个用户"><a href="#2-新建一个用户" class="headerlink" title="2. 新建一个用户"></a>2. 新建一个用户</h2><p>我的习惯是是不在root用户下运行 jupyter notebook 服务,</p><p>因此我建议新建一个<code>jupyter</code>的用户:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adduser jupyter</span><br></code></pre></td></tr></table></figure><p>然后切换到此用户</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su jupyter</span><br></code></pre></td></tr></table></figure><h2 id="3-安装-Anaconda"><a href="#3-安装-Anaconda" class="headerlink" title="3. 安装 Anaconda"></a>3. 安装 Anaconda</h2><p>下载Anaconda最新安装程序 <a href="https://www.anaconda.com/products/individual#Downloads">https://www.anaconda.com/products/individual#Downloads</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>运行安装程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh Anaconda3-2021.05-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>安装过程中敲回车和输入yes同意许可即可</p><p>安装完成重新登录即可</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111082211398.png" alt="image-20211108221130339"></p><h2 id="4-搭建-Jupyter-Notebook-环境"><a href="#4-搭建-Jupyter-Notebook-环境" class="headerlink" title="4. 搭建 Jupyter Notebook 环境"></a>4. 搭建 Jupyter Notebook 环境</h2><ul><li>安装jupyter包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install jupyter <br></code></pre></td></tr></table></figure><ul><li>生成默认配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook --generate-config<br></code></pre></td></tr></table></figure><ul><li>随后我们往配置文件写入一些内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置可以访问的ip, 默认是localhost, 将其改为 &#x27;*&#x27;</span><br>c.NotebookApp.ip = <span class="hljs-string">&#x27;*&#x27;</span><br><br><span class="hljs-comment"># 笔记本的默认打开目录, 自己设置</span><br>c.NotebookApp.notebook_dir = <span class="hljs-string">&#x27;/home/jupyter/documents/jupyter_notebook&#x27;</span><br><br><span class="hljs-comment"># 笔记本启动后是否打开浏览器, 设为 False即可</span><br>c.NotebookApp.open_browser = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 默认访问端口, 可自己修改</span><br>c.NotebookApp.port = <span class="hljs-number">8888</span><br><br><span class="hljs-comment"># jupyterlab是否显示quit按钮,我设为false以免自己不小心按到把服务停了</span><br>c.NotebookApp.quit_button = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 如果使用root用户运行,将下列值改为True即可, 运行时也可加参数将其改为True</span><br>c.NotebookApp.allow_root = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><ul><li>修改好配置文件之后, 运行如下命令启动笔记本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook<br></code></pre></td></tr></table></figure><ul><li>第一次运行会给出带token的链接, 复制到浏览器中打开, 点击登出</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111082241916.png" alt="image-20211108224139818"></p><ul><li><p>随后进入login界面, 输入刚刚链接中的 token值和新密码即可修改密码:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111082243891.png" alt="image-20211108224309795"></p></li><li><p>设置好密码之后我们重启jupyter服务, 再次进入,发现就能用我们刚刚设置的密码登录了</p></li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111082245031.png" alt="image-20211108224540995"></p><ul><li>随便上传一个笔记本试试</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111082326683.png" alt="image-20211108232637635"></p><ul><li>发现已经ok了</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111082327360.png" alt="image-20211108232733266"></p><h2 id="5-让-jupyter-在服务器上持久运行"><a href="#5-让-jupyter-在服务器上持久运行" class="headerlink" title="5. 让 jupyter 在服务器上持久运行"></a>5. 让 jupyter 在服务器上持久运行</h2><ul><li>发现断开 SSH 连接之后, jupyter服务就会停止运行,我们利用<code>screen</code> 命令让jupyter服务一直运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S notebook<br></code></pre></td></tr></table></figure><ul><li>然后启动jupyter服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook<br></code></pre></td></tr></table></figure><ul><li>随后按 <code>Ctrl + A + D </code>将服务挂到后台即可</li></ul><h2 id="6-End"><a href="#6-End" class="headerlink" title="6. End"></a>6. End</h2><p>本次教程简单记录而已, 如有帮助,本人不胜感激.</p><blockquote><p>如有错误或不当之处, 请在下方评论, 我看到将对其进行修改和改进</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ModelArts平台花卉分类识别实验报告</title>
    <link href="/FlowerIdentificationByModelarts.html"/>
    <url>/FlowerIdentificationByModelarts.html</url>
    
    <content type="html"><![CDATA[<h1 id="华为云ModelArts平台花卉分类识别实验报告"><a href="#华为云ModelArts平台花卉分类识别实验报告" class="headerlink" title="华为云ModelArts平台花卉分类识别实验报告"></a>华为云ModelArts平台花卉分类识别实验报告</h1><blockquote><p><a href="https://activity.huaweicloud.com/discount_area_v5/index.html?fromacct=5a4cbb43-f85f-4427-ba12-3630ac71d4fe&utm_source=Y2t4Z3p4YWJlc3Q==&utm_medium=cps&utm_campaign=201905">【华为云11.11上云嘉年华，注册领10000元上云礼包，满额送华为X2折叠屏】</a></p></blockquote><h2 id="1-准备数据集"><a href="#1-准备数据集" class="headerlink" title="1. 准备数据集"></a>1. 准备数据集</h2><p>​        我们在官网下载好TensorFlow官网提供的[花卉数据集](<a href="https://www.tensorflow.org/datasets/catalog/tf_flowers">tf_flowers  | TensorFlow Datasets</a>)并在我们电脑上解压, </p><p>发现 文件的结构如下所示:</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111051955239.png" alt="image-20211105195521063"></p><p>flower_photos内共有5个文件夹,分别是雏菊(daisy)，dandelion(蒲公英)， roses(玫瑰)， sunflowers(向日葵)， tulips(郁金香)， 每个文件夹中存放有若干张该分类的图片。</p><h2 id="2-创建OBS桶"><a href="#2-创建OBS桶" class="headerlink" title="2. 创建OBS桶"></a>2. 创建OBS桶</h2><p>用ModelArts训练需要华为的对象存储服务OBS来保存我们的数据，</p><ul><li><p>首先在华为云搜索obs服务，然后点击进入</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052031054.png" alt="image-20211105203119822"></p></li><li><p>进入之后点击创建桶</p></li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052030323.png" alt="image-20211105203016075"></p><ul><li><p>然后选择单AZ存储，地区选择离你最近的地区即可，选择好之后点击立即创建：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052036482.png" alt="image-20211105203646291"></p></li><li><p>这样我们的OBS桶就创建好了</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052041210.png" alt="image-20211105204107093"></p></li></ul><h2 id="3-获取访问密钥"><a href="#3-获取访问密钥" class="headerlink" title="3. 获取访问密钥"></a>3. 获取访问密钥</h2><p>需要获取访问密钥然后用访问密钥登录obs-brower来方便的将我们的训练数据上传到OBS桶</p><ul><li><p>获取OBS密钥</p><ol><li><p>点击我的凭证</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052113742.png" alt="image-20211105211345664"></p></li><li><p>点击新增访问密钥</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052114923.png" alt="image-20211105211453706"></p></li><li><p>输入密钥名称就可以下载一个名为credentials.csv的文件，里面存放的就是访问密钥，请不要泄露</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052117971.png"></p></li></ol><h2 id="4-获取OBS-Browser-工具"><a href="#4-获取OBS-Browser-工具" class="headerlink" title="4. 获取OBS Browser+ 工具"></a>4. 获取OBS Browser+ 工具</h2><ol><li><p>随后我们进入如下的网址下载 obs browser+ 工具</p><p>下载OBS Browser+：<a href="https://support.huaweicloud.com/browsertg-obs/obs_03_1003.html">https://support.huaweicloud.com/browsertg-obs/obs_03_1003.html</a></p><p>下载安装好之后我们打开它之后使用上一步获取到的密钥登录：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052121218.png" alt="image-20211105212127102"></p></li><li><p>随后我们在桶内新建4个文件夹(flower_photos, flower_input, flower_output, train_output)用于接下来的实验</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052122159.png" alt="image-20211105212256032"></p></li></ol></li></ul><h2 id="5-上传数据集"><a href="#5-上传数据集" class="headerlink" title="5. 上传数据集"></a>5. 上传数据集</h2><p>在flower_photos中上传我们解压出来的花卉数据集</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052128053.png" alt="image-20211105212805937"></p><p>​     </p><h2 id="6-创建数据集"><a href="#6-创建数据集" class="headerlink" title="6. 创建数据集"></a>6. 创建数据集</h2><ul><li><p>进入ModelArts控制台界面，进入数据集管理，然后点击创建数据集</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052131676.png" alt="image-20211105213120461"></p></li><li><p>选择图像分类标注类型，输入为止和输出位置选择我们刚刚在 obs browser中新建的两个空文件夹</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052133067.png" alt="image-20211105213303824"></p></li><li><p>随后点击创建数据集即可</p></li><li><p>返回进入此数据集管理界面，点击导入，由于我已经创建过数据集了，因此里面是有标记数据的</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052135413.png" alt="image-20211105213510211"></p></li><li><p>点击我们刚开始上传花卉数据集的位置确定即可</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052136171.png" alt="image-20211105213608064"></p></li><li><p>导入完成之后，我们点击发布，设置数据切分训练集比例为0.8即可</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052137278.png" alt="image-20211105213729194"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052138484.png" alt="image-20211105213811387"></p></li></ul><h2 id="7-使用算法进行模型训练"><a href="#7-使用算法进行模型训练" class="headerlink" title="7. 使用算法进行模型训练"></a>7. 使用算法进行模型训练</h2><ul><li><p>首先进入如下的网址订阅图像分类算法</p><p><a href="https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0">图像分类-MobileNet_v2链接</a>：<a href="https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0)">https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0)</a></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052139825.png" alt="image-20211105213954489"></p></li><li><p>订阅完成之后我们返回ModelArts控制台的训练管理界面，点击创建训练作业</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052143872.png" alt="image-20211105214329543"></p></li><li><p>算法选择刚刚我们刚刚订阅的算法，训练输入选择我们刚刚创建的数据集，训练输出选择我们刚开始创建的输出文件夹即可，下面有免费的GPU资源可以供我们选择。点击提交并等待训练完成。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052145627.png" alt="image-20211105214541511"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052147929.png" alt="image-20211105214734741"></p></li><li><p>模型训练完成大概需要二十多分钟</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052211783.png" alt="image-20211105221118637"></p></li></ul><h2 id="8-模型的部署和验证"><a href="#8-模型的部署和验证" class="headerlink" title="8. 模型的部署和验证"></a>8. 模型的部署和验证</h2><ul><li><p>点击模型管理，然后进行在线服务的部署，选择免费资源即可</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052153987.png" alt="image-20211105215342790"></p></li><li><p>部署完成之后点击在线服务的预测</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052156506.png" alt="image-20211105215616340"></p><p>在这里可以对应用接口进行调试，同样地你也可以利用POSTMAN等工具对它进行调试，官网有详细的文档可以查看</p></li><li><p>我们上传一些花卉图片对它进行测试</p><ol><li><p>这张图片的结果是玫瑰的可能性是1，识别正确。<img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052159806.png" alt="image-20211105215908408"></p></li><li><p>这张蒲公英的图片也是识别正确的。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052202530.png" alt="image-20211105220235211"></p></li><li><p>这张图片是向日葵的概率也是100%</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111052206769.png"></p></li></ol></li><li><p>我们发现这个训练出来的95.87%准确率的花卉分类模型还是能准确分辨这五种花卉图片的，结果不错。</p></li></ul><h2 id="9-注意事项"><a href="#9-注意事项" class="headerlink" title="9. 注意事项"></a>9. 注意事项</h2><ul><li>华为的OBS对象存储服务是要花钱的，不过训练完成之后也只扣了1分钱，其他的服务都是免费的，充值的费用如果没用完也是能提现的，所以不用担心，这点还是非常不错的。</li></ul><h2 id="10-心得和体会"><a href="#10-心得和体会" class="headerlink" title="10. 心得和体会"></a>10. 心得和体会</h2><p>通过这次利用华为云ModelArts平台进行的花卉识别实验，我发现华为ModelArts平台为机器学习与深度学习提供海量数据预处理及交互式智能标注、大规模分布式训练、自动化模型生成等等一些功能，这些功能全是华为云线上帮你完成的，我们用户根本不用编写一些复杂的代码，从而可以帮助用户快速创建和部署模型，即使你毫无编码基础，也能通过这些图形化的界面进行模型的搭建和训练并快速的部署发布到实际应用当中，推进了人工智能和机器学习的普及和大众化，并使用场景化的AI案例，使得AI落地零门槛，这样的话普通人也能利用华为的这个平台使用人工智能技术改变世界。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第1章 什么是对象?</title>
    <link href="/3-WhatIsAnObject.html"/>
    <url>/3-WhatIsAnObject.html</url>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-什么是对象"><a href="#第-1-章-什么是对象" class="headerlink" title="第 1 章　什么是对象"></a>第 1 章　什么是对象</h1><blockquote><p>“我们并未意识到惯用语言结构的强大之处。甚至可以毫不夸张地说，惯用语言通过语义反应机制奴役了我们。而一门语言所展现出的结构，潜移默化地影响着我们，并自动映射至我们所生活的世界。”</p><p>——Alfred Korzybski（1930）</p></blockquote><p>计算机革命起源于一台机器，而编程语言就好比是那台机器。</p><p>然而计算机并不只是机器而已，它们还是扩展思维的工具（就像乔布斯喜欢说的一句话：计算机是“思维的自行车”），也是一种与众不同的表达媒介。结果就是，工具已经越来越不像机器，而是越来越像思维的一部分。</p><p>编程语言是用于创建应用程序的思维模式。语言本身可以从写作、绘画、雕塑、动画、电影制作等表达方式中获取灵感，而<strong>面向对象编程</strong>（Object-Oriented Programming, OOP）则是用计算机作为表达媒介的一种尝试。</p><p>许多人并不了解面向对象编程的思想框架，他们在进行编程时会感到举步维艰。因此，本章会简要的介绍一些面向对象编程的基础概念。还有一些人在接触相关机制之前可能无法理解这些概念，在看不到代码的情况下就会迷失。如果你属于后者并且渴望尽早接触到具体的语言特性，你完全可以跳过这一章，这样做并不会影响你学习编程语言或者写代码。不过，之后你可以再回到这里补充相关知识，这样有助于你理解对象如此重要的原因，以及如何利用对象做程序设计。</p><p>本章的内容假设你具有一定的编程基础，但不一定是C语言的经验。在全面学习本书之前，如果你需要补充一些基础的编程知识，可以在 On Java 8 网站下载多媒体课程“Thinking in C”来学习。</p><h2 id="1-1-抽象的历程"><a href="#1-1-抽象的历程" class="headerlink" title="1.1　抽象的历程"></a>1.1　抽象的历程</h2><p>所有编程语言都是一种抽象。甚至可以说，我们能够解决的问题的复杂程度直接取决于抽象的类型和质量。这里提到的“类型”的含义是“你要抽象的是什么”。比如，汇编语言是对计算机底层的一个极简化的抽象。还有许多所谓的命令式编程语言（比如 FORTRAN、BASIC 和 C 语言等）都是各自对汇编语言的抽象。虽然这些语言已经取得了长足的进步，但它们主要的抽象方式依然要求你根据计算机的结构而非问题的结构来思考。于是，程序员必须在机器模型（也叫作“解决方案空间”，即实际解决问题的方式，比如计算机）和实际解决的问题模型（也叫作“问题空间”，即问题实际存在之处，比如来源于某个业务）之间建立关联。建立这种关联需要耗费很大的精力，而且它是与编程语言无关的，这一切都导致程序难以编写且不易维护。</p><p>构建机器模型的一种代替方案是针对需要解决的问题构建问题模型。早期的一些编程语言（比如 LISP 和 APL）会采取特定的视角看待周遭问题（例如，“所有问题最终都可以用列表呈现”或者“所有问题都是算法问题”），Prolog 语言则会将所有问题都转换为决策链。这些语言要么是基于约束性的编程语言，要么是专门用来操作图形符号的编程语言。这些编程语言都能够出色地解决一些特定的问题，因为它们正是为此而生的。然而，一旦遇到它们专属领域以外的问题，它们就显得无能为力了。</p><p>面向对象编程则更进一步，它为程序员提供了一些能够呈现问题空间元素的工具。这种呈现方式具备足够的通用性，使得程序员不再局限于特定的问题。而这些问题空间中的元素及其解决方案空间中的具体呈现，我们称其为“对象”（需要注意的是，有些对象并不支持问题空间的类比）。其背后的理念则是，通过添加各种新的对象，程序可以将自己改编为一种描述问题的语言。于是，你阅读的既是解决方案的代码，也是表述问题的文字。这种灵活且强大的语言抽象能力是前所未有的。因此，面向对象编程描述问题的依据是实际的问题，而非用于执行解决方案的计算机。不过，它们之间依然存在联系，这是因为从某种意义上来说，对象也类似于一台小型计算机——每一个对象都具有状态，并且可以执行一些特定的操作。这一特点与现实中的事物极为相似，它们都具有各自的行为和特征。</p><p>SmallTalk 是历史上第一门获得成功的面向对象语言，并且为后续出现的 Java 语言提供了灵感。Alan Kay 总结了 SmallTalk 语言的 5 个基本特征，这些特征代表了纯粹的面向对象编程的方式。</p><ol><li><strong>万物皆对象。</strong>你可以把对象想象为一种神奇的变量，它可以存储数据，同时你可以“发出请求”，让它执行一些操作。对于你想要解决的问题中的任何元素，你都可以在程序中用对象来呈现（比如狗、建筑、服务等）。</li><li><strong>一段程序实际上就是多个对象通过发送消息来通知彼此要干什么。</strong>当你向一个对象“发送消息”时，实际情况是你发送了一个请求去调用该对象的某个方法。</li><li><strong>从内存角度而言，每一个对象都是由其他更为基础的对象组成的。</strong>换句话说，通过将现有的几个对象打包在一起，你就创建了一种新的对象。这种做法展现了对象的简单性，同时隐藏了程序的复杂性。</li><li><strong>每一个对象都有类型。</strong>具体而言，每一个对象都是通过某个<strong>类</strong>生成的<strong>实例</strong>，这里说的“类”就（几乎）等同于“类型”。一个类最为显著的特性是“你可以发送什么消息给它”。</li><li><strong>同一类型的对象可以接收相同的消息。</strong>稍后你就会意识到这句话的丰富含义。举例来说，因为一个“圆形”对象同样也是一个“形状”对象，所以“圆形”也可以接收“形状”类型的消息。这就意味着，你为“形状”对象编写的代码<strong>自然</strong>可以适用于任何的“形状”子类对象。这种可替换性是面向对象编程的一个基石。</li></ol><p>Grady Booch 对对象做了一种更为简洁的描述：</p><blockquote><p>对象具有状态、行为及标识。</p></blockquote><p>这意味着对象可以拥有属于自己的内部数据（赋予其状态）、方法（用于产生行为），同时每一个对象都有别于其他对象。也就是说，每一个对象在内存中都有唯一的地址。**$^1$**</p><blockquote><p>**$^1$**这个说法实际上不太全面。这是因为对象可以保存在不同的机器或内存地址中，甚至还可以保存在磁盘上。在上述情况中，对象的标识（identity）就需要用其他方式而非内存地址来表示。</p></blockquote><h2 id="1-2-对象具有接口"><a href="#1-2-对象具有接口" class="headerlink" title="1.2　对象具有接口"></a>1.2　对象具有接口</h2><p>亚里士多德可能是第一个仔细研究<strong>类型</strong>这一概念的人，他曾经提出过“鱼的类别和鸟的类别”。所有的对象，哪怕是相当独特的对象，都能够被归为某一类，并且同一类对象拥有一些共同的行为和特征。作为有史以来第一门面向对象编程语言，Simula-67 引入了上述的“类别”概念，并且允许通过关键字 <code>class</code> 在程序中创建新的类型。</p><p>Simula 语言恰如其名，其诞生的目的是用于“模拟”，比如模拟经典的“银行出纳问题”。这个问题的元素包括大量的出纳员、顾客、账户、交易，以及各种货币单位等，这些都是“对象”。而那些状态不同但结构相同的对象汇聚在一起，就变成了“同一类对象”（classes of objects），这就是关键字 <code>class</code>的由来。</p><p>创建抽象数据类型（即“类”）是面向对象编程的一个基本概念。抽象数据类型的工作原理和内置类型几乎一样：你可以创建某种类型的变量（在面向对象领域，这些变量叫作“对象”或“实例”），随后你就可以操作这些变量（叫作“发送消息”或“发送请求”，即你发送指令给对象，然后对象自行决定怎么处理）。同一类型的所有成员（或元素）都具有一些共性，比如：每一个账户都有余额，每一位出纳员都能处理存款业务。同时，每一个成员都具有自己的专属状态，比如：每一个账户的余额都是不同的，每一位出纳员都有名字。因此，对于所有这些成员，包括每一位出纳员、每一位顾客、每一个账户，以及每一笔交易等，我们都能够在程序中用一个唯一的实体来表示。这种实体就是对象，同时每一个对象所归属的类决定了对象具有何种行为特征。</p><p>虽然我们在面向对象编程中会创建新的数据类型，但实际上所有面向对象编程语言都会使用 <code>class</code> 这个关键字。所以当你看到“类型”（type）这个词的时候，请第一时间想到“类”（class），反之亦然。**$^2$**</p><blockquote><p>**$^2$**有时候我们会将两者加以区分，将类型（type）定义为接口，而类（class）则是接口的具体实现。</p></blockquote><p>因为类描述了一系列具有相同特征（即数据元素）和行为（即功能方法）的对象，而即便是浮点数这种内置数据类型也具有一系列的行为和特征，所以类其实就是数据类型。抽象数据类型和内置数据类型的区别是，程序员可以通过定义一个新的类来解决问题，而非受限于已有的数据类型。这些已有的数据类型其设计本意是为了呈现机器内的存储单元，你可以根据实际的需求创建新的数据类型，同时扩展编程语言的能力。此外，编程系统对于新的类十分友好，比如也会为新的类提供类型检查等功能，就像对待内置数据类型一样。</p><p>面向对象编程的作用并不局限于模拟。无论你是否同意“任何程序都是对系统的一种模拟”，面向对象编程技巧都可以帮你将众多复杂的问题简化。</p><p>一旦创建了一个类，就可以用它创建任意多个对象，然后在操作这些对象时，可以把它们视为存在于问题空间的元素。实话实说，面向对象编程的一大挑战就是，如何在问题空间的元素和解决方案空间的对象之间建立一对一的关联。</p><p>那么，如何能让一个对象真正发挥其作用呢？答案是向对象发送请求，比如让它完成一次交易、在屏幕上画个图形或者打开一个开关等。对象能够接受什么请求，是由它的“接口”（interface）决定的，而对象所归属的类定义了这些接口。接下来以电灯泡为例，如下图所示。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281506403.png"></p><hr><blockquote><p>插图翻译:<br>Type Name：类型名<br>Interface：接口</p></blockquote><hr><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Light <span class="hljs-literal">lt</span> = <span class="hljs-literal">new</span> Light();<br><span class="hljs-literal">lt</span>.<span class="hljs-keyword">on</span>();<br></code></pre></td></tr></table></figure><p>图中的接口定义了你能够向这个对象发送的请求。此外，也必然存在一些代码用于响应这些请求。这些代码再加上隐藏的数据，叫作“实现”（implementation）。对于每一个请求，类都有一个方法与之对应。当你向一个对象发送特定的请求时，对应的方法就会被调用。我们通常会这样描述该过程：向对象“发送消息”（即发出请求），然后由对象决定如何处理（即运行对应的代码）。</p><p>在上面的例子中，类的名字是 <code>Light</code>，<code>Light</code> 所生成的对象的名字是 <code>lt</code>，我们能够对 <code>Light</code> 对象发出的请求是开灯（<code>on()</code>）、关灯（<code>off()</code>）、灯光变亮（<code>brighten()</code>）以及灯光变暗（<code>dim()</code>）。通过定义一个“引用”即 <code>lt</code>，以及用 <code>new</code> 关键字生成一个新对象，我们就创建了一个 <code>Light</code> 对象。此外，如果你需要向对象发送消息，可以用一个英文句号（<code>.</code>）将对象名和请求（即方法）连接起来。如果我们只是使用内置类，那么基本上关于对象编程的内容就是以上了。</p><p>此外，前面的图示遵循了<strong>统一建模语言</strong>（Unified Modeling Language, UML）的规范。在此规范下，每一个类都表示为一个方块，方块头部是类名，方块中部是你想要描述的<strong>数据成员</strong>，而<strong>方法</strong>（即该对象的函数，负责接收发送至对象的请求）则位居方块的底部。通常，UML 图中只会展示类名和公有方法，所以在上图的例子中，方块中部的内容并没有展示出来。如果你只关心类名，方块底部的内容也可以不显示。</p><h2 id="1-3-对象可以提供服务"><a href="#1-3-对象可以提供服务" class="headerlink" title="1.3　对象可以提供服务"></a>1.3　对象可以提供服务</h2><p>当你开发一个面向对象程序或理解其设计时，一个上佳的方法是将对象想象成“服务提供者”。你的程序本身也是为用户提供服务的，它通过使用其他对象提供的服务来做到这一点。所以，你的任务是创建（更好的情况是，从已有的库中找到）一些提供对应服务以解决问题的对象。</p><p>可以先从一个问题开始：“如果我能从魔术帽里变出一些对象，究竟什么对象才能解决我的问题呢？”比如，你要创建一个记账系统，于是你可能会需要一些预设的输入页面对象、负责计算的对象，以及连接各种打印机以打印支票和发票的对象。其中有些对象也许已经存在，那么其他不存在的对象应该是什么样的呢？它们应该提供哪些服务，同时它们还需要哪些其他对象的支持呢？如果继续深入的话，到了最后，你要么会说“编写这个对象的代码应该很简单”，要么会说“我确信这个对象早已存在”。这种将问题拆解为一系列对象的方法确实行之有效。</p><p>把对象视为服务提供商还有一个额外的好处，即提升了对象的聚合程度。说到这里，就需要提到软件设计领域中一个体现基础品质的术语——“高内聚性”（high cohesion），这指的是设计的组件（比如对象、方法或者对象库等）无论从哪个方面看都整合得很好。人们在设计对象时很容易犯的一个错误就是为对象添加太多的功能。例如，在一个打印支票的程序里，你一开始可能会认为需要一个既能排版又能打印的对象。然后，你发现这些功能对于一个对象而言太多了，其实你需要 3 个或者更多对象来负责这些功能。比如，一个对象包含了所有可能的打印布局，通过查找它可以知道如何打印一张支票。另一个或一组对象则作为通用打印接口，负责连接所有不同型号的打印机（但不负责记账，也许你需要购买该功能而非自行创建）。还有一个对象负责整合前两个对象提供的服务以完成打印任务。因此，每一个对象都提供了一种配套服务。在面向对象领域，出色的设计往往意味着一个对象只做好一件事，绝不贪多。这条原则不只适用于那些从外部购买的对象（比如打印接口对象），也适用于那些可复用的对象（比如支票排版对象）。</p><p>把对象视为服务提供商，不仅对你设计对象的过程有所帮助，也有利于他人阅读你的代码或复用这些对象。换句话说，如果别人因为对象提供的服务而认识到它的价值，那么他就会更加轻松地在自己的设计中使用这个对象。</p><h2 id="1-4-隐藏的实现"><a href="#1-4-隐藏的实现" class="headerlink" title="1.4　隐藏的实现"></a>1.4　隐藏的实现</h2><p>我们可以把程序员划分为两大阵营：一是“类的创建者”（负责创建新数据类型的人），二是“客户程序员” **$^3$**（在自己的应用程序里使用现有数据类型的人）。客户程序员的诉求是收集一个装满了各种类的工具箱，以便自己能够快速开发应用程序。而类的创建者则负责在创建新的类时，只暴露必要的接口给客户程序员，同时隐藏其他所有不必要的信息。为什么要这么做呢？这是因为，如果这些信息对于客户程序员而言是不可见的，那么类的创建者就可以任意修改隐藏的信息，而无须担心对其他任何人造成影响。隐藏的代码通常代表着一个对象内部脆弱的部分，如果轻易暴露给粗心或经验不足的客户程序员，就可能在顷刻之间被破坏殆尽。所以，隐藏代码的具体实现可以有效减少程序 bug。</p><blockquote><p>**$^3$**关于这个称谓，我需要感谢我的老朋友 Scott Meyers。</p></blockquote><p>所有的关系都需要被相关各方一致遵守的边界。当你创建了一个库，那么你就和使用它的客户程序员建立了一种关系。该客户程序员通过使用你的代码来构建一个应用，也可能将其用于构建成一个更大的库。如果一个类的所有成员都对所有人可见，那么客户程序员就可以恣意妄为，而且我们无法强制他遵守规定。也许你的预期是客户程序员不会直接操作任何类的成员，但是如果没有访问控制的话，你就无法实现这一点，因为所有的一切都暴露在对方面前了。</p><p>所以我们设置访问控制的首要原因就是防止客户程序员接触到他们本不该触碰的内容，即那些用于数据类型内部运转的代码，而非那些用于解决特定问题的接口部分。这种做法实际上为客户程序员提供了一种服务，因为他们很容易就可以知道哪些信息对他们来说是重要的，哪些则是无须关心的（请注意这也是一个富有哲理的决策。比如有些编程语言认为，如果程序员希望访问底层信息，就应该允许他们访问）。</p><p>设置访问控制的第二个原因则是，让类库的设计者在改变类的内部工作机制时，不用担心影响到使用该类的客户程序员。例如，你为了开发方便而创建了一个简单的类，之后你发现必须重写这个类以提升它的运行效率。如果接口部分和实现部分已经被分离和保护起来了，那么你就可以轻松地重写它。</p><p>Java 提供了 3 个显式关键字来设置这种访问控制，即 <code>public</code>、<code>private</code> 以及 <code>protected</code>。这些关键字叫作“访问修饰符”（access specifier），它们决定了谁可以使用修饰符之后的内容。<code>public</code>表示定义的内容可以被所有人访问。<code>private</code> 表示定义的内容只能被类的创建者通过该类自身的方法访问，而其他任何人都无法访问。所以，<code>private</code> 就是一道横亘在你和客户程序员之间的高墙，任何人从外部访问 <code>private</code> 数据都会得到一个编译时报错。最后，<code>protected</code> 类似于 <code>private</code>，两者的区别是继承的子类可以访问 <code>protected</code> 成员，但不可以访问 <code>private</code> 成员。至于继承的概念，本书稍后会讲述。</p><p>如果你不使用上述任意一种访问修饰符，Java 会提供一种“默认”访问权限，通常叫作“包访问”（package access），意思是一个类可以访问同一个包（库组件）里的其他类，但是如果从外部访问这些类的话，它们就像 <code>private</code> 内容一样不可访问了。</p><h2 id="1-5-复用实现"><a href="#1-5-复用实现" class="headerlink" title="1.5　复用实现"></a>1.5　复用实现</h2><p>如果一个类经过了充分测试，其代码就应该是有效且可复用的（理想情况）。不过，要实现这种复用性并不像想象的那么简单。创建可复用的对象设计需要大量的经验和洞见。然而，一旦你拥有了可复用的设计，不复用就可惜了。代码复用是我们使用面向对象编程的理由之一。</p><p>复用一个类最简单的方法是直接使用这个类所生成的对象，不过你也可以把这个对象放到另一个新类里面。新创建的类可以由任意数量和类型的对象组成，也可以任意组合这些对象，以满足想要的功能。因为利用已有的类组合成一个新的类，所以这个概念叫作“组合”（composition）。如果组合是动态的，通常叫作“聚合”（aggregation）。组合通常代表一种“有”（has-a）的关系，比如“汽车有发动机”（见下图）。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281506039.png"></p><blockquote><p>图中文字：<br>Car 汽车<br>Engine 发动机</p></blockquote><p>上图中用箭头表示了一辆汽车的组合关系。而我习惯用一种更简单的方式，即一条没有箭头的直线来表达两者之间的关联。**$^4$**</p><blockquote><p>**$^4$**这些信息对于大多数图来说已经足够了，也无须特别说明使用的是聚合还是组合。</p></blockquote><p>组合为我们提供了极大的灵活性。这些在你的类内部创建的对象通常具有 <code>private</code> 属性，所以其他使用这个类的客户程序员无法访问它们。这也意味着，就算我们修改了这些内部对象，也不会影响外部已有的代码。此外，你还可以在运行时改变这些内部对象，从而动态调整程序的行为。下一节要讲述的继承机制则不具备这种灵活性，因为编译器对使用继承创建的类设置了一些编译时的限制。</p><p>继承常被视为面向对象编程的重中之重，因此容易给新手程序员留下这样的印象：处处都应该使用继承。而实际上，这种全盘继承的做法会导致设计变得十分别扭和过于复杂。所以相比之下，在创建新类时应该首先考虑组合，因为使用组合更为简单灵活，设计也更为清晰简洁。一旦你拥有了足够的经验，何时使用继承就会变得非常清晰了。</p><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6　继承"></a>1.6　继承</h2><p>对象本身的理念是提供一种便捷的工具。对象可以根据定义的概念来封装数据和功能，从而展现给人们对应的问题空间的概念，而不是强迫程序员操作机器底层。在编程语言里，这些基础概念通过关键字 <code>class</code> 得以呈现。</p><p>然而，当我们大费周折才创建了一个类之后，如果不得不再创建一个与之前功能极为相近的类，这种滋味一定不太好受。如果我们能够复制现有的类，并且在该复制类的基础上再做一些增补的话，那就太妙了。实际上，这就是继承给我们带来的好处，除了一点：如果最初的类（叫作“基类”“超类”或“父类”）发生了变化，那么被修改的“复制”类（叫作“衍生类”“继承类”或“子类”）同样会发生变化（见下图）。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281506157.png"></p><blockquote><p>图字翻译：<br>Base 基类<br>Derived 子类</p></blockquote><p>上图中的箭头从子类指向其基类。之后你将看到，子类通常会有多个。</p><p>一个类呈现的内容不只是对象能做什么、不能做什么，它还可以关联其他的类。两个类可以拥有相同的行为和特征，但一个类可以比另一个类拥有更多的特征，以及处理更多的消息（或者用不同的方式处理消息）。继承通过基类和子类的概念来表述这种相似性，即基类拥有的所有特征和行为都可以与子类共享。也就是说，你可以通过基类呈现核心思想，从基类所派生出的众多子类则为其核心思想提供了不同的实现方式。</p><p>举个例子。一个垃圾收集器需要对垃圾进行分类。我们创建的基类是“垃圾”，具体的每一件垃圾都有各自不同的重量、价值，并且可以被切碎、溶解或者分解等。于是，更为具体的垃圾子类就出现了，并且带有额外的特征（比如，一个瓶子有颜色，一块金属有磁性等）和行为（比如你可以压扁一个铝罐）。此外，有些行为还可以产生不同的效果（比如纸质垃圾的价值取决于它的类型和状态）。通过继承，我们创建了一种“类型层次”（type hierarchy）以表述那些需要根据具体类型来解决的问题。</p><p>还有一个常见的例子是形状，你可能在计算机辅助设计系统或模拟游戏中碰过到。具体来说，基类就是“形状”（<code>Shape</code>），而每一个具体的形状都具有大小、颜色、位置等信息，并且可以被绘制（<code>draw()</code>）、清除（<code>erase()</code>）、移动（<code>move()</code>）、着色（<code>getColor</code> 或 <code>setColor</code>）等。接下来，基类 <code>Shape</code> 可以派生出特定类型的形状，比如圆形（<code>Circle</code>）、矩形（<code>Square</code>）、三角形（<code>Triangle</code>）等，每一个具体形状都可以拥有额外的行为和特征，比如某些形状可以被翻转（见下图）。有些行为背后的逻辑是不同的，比如计算不同形状的面积的方法就各不相同。所以，类型层次既体现了不同类之间的相似性，又展现了它们之间的差异。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281505322.png"></p><p>问题和解决方案都使用相同的表达方式是非常有用的，因为这样就不再需要一个中间模型将问题翻译为解决方案。在面向对象领域，类型层次是该模型的一个重要特征，它让你可以方便地从现实世界中的系统转换到代码世界的系统。不过现实情况是，有些人由于习惯了复杂的解决方案，因此对于面向对象的简约性反而会有些不适应。</p><p>继承已有的类将产生新类。这个新的子类不但会继承其基类的所有成员（虽然 <code>private</code> 成员是隐藏且不可访问的），而且更重要的是，子类也会继承基类的接口。也就是说，所有基类对象能够接收的消息，子类对象也一样能够接收。我们可以通过一个类所接收的消息来确定其类型，所以从这一点来说，子类和基类拥有相同的类型。引用之前的例子，就是“圆形是一个形状”。所以，掌握这种通过继承表现出来的类型相同的特性，是理解面向对象编程的基础方法之一。</p><p>既然基类和子类拥有相同的基础接口，就必然存在接口的具体实现。这意味着，当一个对象接收到特定的消息时，就会执行对应的代码。如果你继承了一个类并且不做任何修改的话，这个基类的方法就会原封不动地被子类所继承。也就是说，子类的对象不但和基类具有相同的类型，而且不出所料的是，它们的行为也是相同的。</p><p>有两种方法可以区分子类和基类。第一种方法非常简单直接：为子类添加新的方法（见下图）。因为这些方法并非来自基类，所以背后的逻辑可能是，基类的行为和你的预期不符，于是你添加了新的方法以满足自己的需求。有时候，继承的这种基础用法能够完美地解决你面临的问题。不过，你需要慎重考虑是否基类也需要这些新的方法（还有一个替代方案是考虑使用“组合”）。在面向对象编程领域里，这种对设计进行发现和迭代的情况非常普遍。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281505835.png"></p><p>虽然有时候继承意味着需要为子类添加新的方法[Java 尤其如此，其用于继承的关键字就是“扩展”（<code>extends</code>）]，但这不是必需的。还有一种让新类产生差异化的方法更为重要，即修改基类已有方法的行为，我们称之为“重写”该方法（见下图）。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281505375.png"></p><p>如果想要重写一个方法，你可以在子类中对其进行重新定义。也就是说，你的预期是“我想通过相同的接口调用该方法，但是我希望它可以在新的类中实现不同的效果”。</p><h3 id="is-a关系与is-like-a关系"><a href="#is-a关系与is-like-a关系" class="headerlink" title="is-a关系与is-like-a关系"></a>is-a关系与is-like-a关系</h3><p>继承机制存在一个有待商榷的问题：<strong>只应该</strong>重写基类中定义的方法吗？（并且不能添加基类中不存在的新方法）如果是，就意味着子类和基类的类型是<strong>完全</strong>相同的，因为它们的接口一模一样。结果就是，你可以直接用子类的对象代替基类的对象。这种<strong>纯替换关系</strong>通常叫作“替换原则” **$^5$**。从某种意义上说，这是一种理想的继承方式。这种情况下基类和子类之间的关系通常叫作“is-a”关系，意思是“A 是 B”，比如“圆形是一个形状”。甚至有一种测试是否是继承关系的方法是，判断你的类之间是否满足这种“is-a”关系。</p><blockquote><p>**$^5$**也叫作“里氏替换原则”（Liskov Substitution Principle），这一理论最初由 Barbara Liskov 提出。</p></blockquote><p>有时候，你会为子类的接口添加新的内容，从而扩展了原有的接口。在这种情况下，子类的对象依然可以代替基类的对象，但是这种代替方案并不完美，因为不能通过基类的接口获取子类的新方法。我将这种关系描述为“is-like-a”关系（这是我自创的词），意思是“A 像 B”，即子类在拥有基类接口的同时，也拥有一些新的接口，所以不能说两者是完全等同的。以空调为例，假设你的房间里已经安装了空调，也就是拥有能够降低温度的接口。现在发挥一下想象力，万一空调坏了，你还可以用热泵作为替代品，因为热泵既可以制冷也可以制热（见下图）。在这种情况下，热泵“就像是”空调，只不过热泵能做的事情更多而已。此外，由于设计房间的温度控制系统时，功能仅限于制冷，所以系统和新对象交互时也只有制冷的功能。虽然新对象的接口有所扩展，但现有系统也只能识别原有的接口。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281505457.png"></p><blockquote><p>图字翻译<br>Thermostat 恒温器<br>Controls 控制<br>Cooling System 制冷系统<br>Air conditioner 空调<br>Heat Pump 热泵</p></blockquote><p>观察上图你就能知道，基类“制冷系统”通用性并不高，最好可以将其改名为“温度调节系统”，使其同时包含制热功能。这样一来，之前提及的替换原则就可以派上用场了。不过话说回来，这张图也反映了真实世界中的设计方式。</p><p>当你充分理解了替换原则之后，可能会认为这种纯替换方式才是唯一正确的方式。如果你的设计能够应用纯替换原则，那就<strong>太棒了</strong>。然而实际情况是，你会发现经常需要为子类的接口添加新方法。只要稍加观察，就很容易分辨出这两种情况的应用场合。</p><h2 id="1-7-多态"><a href="#1-7-多态" class="headerlink" title="1.7　多态"></a>1.7　多态</h2><p>在编程中涉及类型层次时，我们通常会将一个对象视为其基类的一个实例，而不是对象实际的类。这种方式可以让你在编写代码时不依赖于具体的类。在形状的例子中，方法都是作用于通用的形状，而不需要关心该形状具体是圆形、矩形、三角形，还是一个没有明确定义的形状。因为所有的形状都可以被绘制、清除、移动，所以当这些方法发送消息至对象的时候，就无须关注对象是如何处理这条消息的。</p><p>当我们添加新的类时，这些代码是不受影响的，添加新的类可以扩展面向对象程序的能力，从而能够处理一些新的情况。比如，你为基类“形状”创建了一个子类“五边形”，并且不改变那些基于通用形状的方法。这种通过派生子类就可以轻松扩展程序设计的能力，是封装变化的一种基础方式。这种方式在改善设计的同时，也降低了软件维护的成本。</p><p>当你尝试用派生的子类替代通用基类（比如，把圆形当作形状，把自行车当作交通工具，把鸬鹚当作鸟等）时会发现一个问题，即调用方法来绘制这个通用的形状、驾驶这辆通用的交通工具或者让这只鸟飞翔时，编译器并不知道在编译时具体需要执行哪一段代码。那么重点来了，当消息被发送时，程序员并不<strong>关心</strong>具体执行的是哪一段代码。也就是说，当负责绘制的方法应用于圆形、矩形或者三角形时，这些对象将能够根据其类型执行对应的正确代码。</p><p>如果你并不关心具体执行的是哪一段代码，那么当你添加新的子类时，即使不对其基类的代码做任何修改，该子类实际执行的代码可能也会有所不同。但如果编译器无法得知应该具体执行哪一段代码，它会怎么做呢？比如下图中的 <code>BirdController</code> 对象，它可以和通用的 <code>Bird</code> 对象协同工作，同时它并不知道这些对象具体是什么类型的鸟。对于 <code>BirdController</code> 来说，这种方式非常方便，因为它无须额外编写代码来确定这些对象的具体类型和行为。那么问题来了，当一个 <code>Bird</code> 对象的 <code>move()</code> 方法被调用时，如果我们并不清楚其具体的类型，该如何确保最终执行的是符合预期的正确行为呢[比如 <code>Goose</code> 对象执行的是行走、飞翔或游泳，<code>Penguin</code> 对象则是移动或游泳；见下图]？</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281505516.png"></p><hr><blockquote><p>图字翻译<br>What happens when move() is called？<br>如果move()被调用，究竟会发生什么呢？</p></blockquote><hr><p>答案来自继承机制的一种重要技巧：编译器并非通过传统方式来调用方法。对于非面向对象编译器而言，其生成的函数调用会触发“前期绑定”（early binding），这是一个你可能从来都没听说过的词，因为你从未考虑过使用这种方式。前期绑定意味着编译器会生成对一个具体方法名的调用，该方法名决定了被执行代码的绝对地址。但是对于继承而言，程序直到运行时才能明确代码的地址，所以就需要引入其他可行的方案以确保消息可以顺利发送至对象。</p><p>为了解决上面提及的问题，面向对象语言使用的机制是“后期绑定”（late binding）。也就是说，当你向某个对象发送消息时，直到运行时才会确定哪一段代码会被调用。编译器会确保被调用的方法是真实存在的，并对该方法的参数和返回值进行类型检查，但是它并不知道具体执行的是哪一段代码。</p><p>为了实现后期绑定，Java 使用了一些极为特殊的代码以代替直接的函数调用，这段代码使用存储在对象中的信息来计算方法体的地址（第 9 章会详细地描述这个过程）。其结果就是，在这些特殊代码的作用下，每一个对象会有不同的表现。通俗地讲，当你向一个对象发送消息时，该对象自己会找到解决之道。</p><p>顺便一提，在某些编程语言里，你必须显式地为方法赋予这种后期绑定特性。比如，C++ 使用 <code>virtual</code> 关键字来达到此目的。在这些编程语言中，方法<strong>并不</strong>默认具备动态绑定特性。不过，Java 默认具备动态绑定特性，所以你无须借助于其他关键字或代码来实现多态。</p><p>我们再来看一下形状的例子。之前的图中展示了一些形状的类（这些类都基于统一的接口），为了更好地描述多态，我们编写一小段只关注基类而不关注具体子类的代码。由于这段代码<strong>不关注</strong>类的细节，因此非常简单易懂。此外，如果我们通过继承添加了一个新的子类“六边形”，我们的代码仍然适用于这个新的 <code>Shape</code> 类，就像适用于其他已有子类一样。因此可以说，这段程序具备<strong>扩展性</strong>。</p><p>如果你用 Java 编写一个方法（你马上就会学到具体应该怎么做）：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span>(Shape <span class="hljs-built_in">shape</span>) &#123;<br>  <span class="hljs-built_in">shape</span>.<span class="hljs-property">erase</span>();<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">shape</span>.<span class="hljs-property">draw</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法适用于任何 <code>Shape</code> 对象，所以它不关心进行绘制和清除的对象具体是什么类型。如果程序的其他地方调用了 <code>doSomething()</code> 方法，比如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Circle circle = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Circle()</span>;<br>Triangle triangle = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Triangle()</span>;<br>Line line = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Line()</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">circle</span>)</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">triangle</span>)</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">line</span>)</span>;<br></code></pre></td></tr></table></figure><p>不管对象具体属于哪个类，<code>doSomething()</code> 方法都可以正常运行。</p><p>简直妙不可言。我们再看这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">doSomething(circle);<br></code></pre></td></tr></table></figure><p>在这段代码里，原本我们需要传递一个 <code>Shape</code> 对象作为参数，而实际传递的参数却是一个 <code>Circle</code> 类的对象。因为 <code>Circle</code> 也是一个 <code>Shape</code>，所以 <code>doSomething()</code> 也可以接受 <code>Circle</code>。也就是说，<code>doSomething()</code> 发送给 <code>Shape</code> 对象的任何消息也可以发送给 <code>Circle</code> 对象。这是一种非常安全且逻辑清晰的做法。</p><p>这种将子类视为基类的过程叫作“向上转型”（upcasting）。这里的“转型”指的是转变对象的类型，而“向上”沿用的是继承图的常规构图，即基类位于图的顶部，数个子类则扇形分布于下方。因此，转变为基类在继承图中的路径就是一路向上，也就叫作“向上转型”。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202110281505699.png"></p><hr><blockquote><p>图字翻译：<br>“Upcasting”：“向上转型”</p></blockquote><hr><p>面向对象程序总会包含一些向上转型的代码，因为这样就可以让我们无须关心对象具体的类是什么。再看一下 <code>doSomething()</code> 方法中包含的代码：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">shape.erase<span class="hljs-comment">()</span>;<br><span class="hljs-comment">// ...</span><br>shape.draw<span class="hljs-comment">()</span>;<br></code></pre></td></tr></table></figure><p>需要注意的是，代码并没有告诉我们，“如果是一个 <code>Circle</code> 请这样做，如果是一个 <code>Square</code> 请那样做，诸如此类”。如果你真的编写了一段代码用于检查所有可能出现的形状，那么这段代码必然是一团糟，并且每当你为 <code>Shape</code> 添加一个新的子类时，都必须修改这段代码。所以，上面的代码实际上做的是：“这是一个 <code>Shape</code>，我知道它可以进行绘制和清除，那就这么干吧，具体细节交给形状自己处理就好”。</p><p><code>doSomething()</code> 方法的神奇之处在于，代码运行的结果是符合预期的。如果直接通过 <code>Circle</code>、<code>Square</code> 或者 <code>Line</code> 对象调用 <code>draw()</code> 方法，运行的代码自然是不同的。如果调用 <code>draw()</code> 方法时并不知道 <code>Shape</code> 对象的具体类型，它也能正常工作，即执行其实际子类的代码。这一点十分了不起，因为当 Java 编译器编译 <code>doSomething()</code> 的代码时，它并不知道对象的类型是什么。通常来说，你可能会想当然地认为被调用的是基类 <code>Shape</code> 的 <code>erase()</code> 和 <code>draw()</code> 方法，而非具体的 <code>Circle</code>、<code>Square</code> 或者 <code>Line</code> 子类，然而实际情况是，确实是具体的子类被调用了，这就是多态。编译器和运行时系统负责处理各种细节，你需要了解的就是多态机制的存在，更重要的是要知道如何利用多态进行设计。当你向一个对象发送消息时，哪怕需要用到向上转型，该对象也能够正确地处理该消息。</p><h2 id="1-8-单根层次结构"><a href="#1-8-单根层次结构" class="headerlink" title="1.8　单根层次结构"></a>1.8　单根层次结构</h2><p>自从 C++ 语言出现以来，面向对象中是否所有的类都应该默认继承自某个基类的问题变得尤为突出。Java 则给出了肯定的答案（<strong>除了</strong> C++ 以外，实际上几乎所有动态面向对象编程语言都是如此），这个终极基类的名字是 <code>Object</code>。</p><p>这种“单根层次结构”（singly-rooted hierarchy）具备很多明显的优势。由于所有对象都具有共同的接口，因此它们都属于同一个终极基类。另一种方案（来自 C++）则无法确保所有对象都属于同一个基类。从向后兼容的角度来看，这种限制性较小的设计方式对C语言更为友好，但是从完全的面向对象编程的角度来看，你就必须自己手动构建类的层次，这样才能拥有其他面向对象编程语言默认提供的便捷性。此外，你在使用任何新的库时，都有可能遇到一些不兼容的接口。如果你希望这些接口为你所用，就必须额外花费一些精力来改造它们。所以，C++ 这种额外的“灵活性”真的物有所值吗？如果需要的话，比如你已经花费了大量心血编写C语言代码，那么答案就是肯定的。而如果你是从头开始，那么使用 Java 或者其他替代方案则会高效许多。</p><p>单根层次结构有利于实现垃圾收集器（garbage collector），这也是 Java 对比 C++ 的一个重要改进。既然所有对象都拥有类型信息，你就再也不用发愁不知道某个对象具体是什么类型了。这一特性对于系统级别的操作而言尤为重要，比如异常处理（exception handling，一种用于处理错误的语言机制）等，同时也极大地提升了编程时的灵活性。</p><h2 id="1-9-集合"><a href="#1-9-集合" class="headerlink" title="1.9　集合"></a>1.9　集合</h2><p>一般来说，你并不知道解决一个特定的问题需要用到多少个对象，也不知道这些对象会存在多久，你甚至不知道该如何保存这些对象。问题是，如果你无法在程序运行前确切地知道这些信息，那你应该申请多少内存空间呢？</p><p>在面向对象设计领域，大多数问题的解决方案看似极为简单粗暴：创建一种新类型的对象，这种对象通过保存其他对象的引用来解决这个问题。而在大多数编程语言里，你也可以用<strong>数组</strong>（array）做到这一点。</p><p>这种新对象通常叫作<strong>集合</strong>（也可以叫做“容器”，不过 Java 的库普遍使用的是“集合”），它会根据你放入其中的内容自行调整空间。也就是说，你无须关注集合里会有多少对象，直接创建集合就好了，剩下的细节交给它自己处理就可以。</p><p>幸运的是，优秀的面向对象语言都会提供一些集合作为语言的基础功能。在 C++ 里，集合是 C++ 标准库的一部分，通常叫作“标准模板库”（Standard Template Library, STL）。SmallTalk 提供了一系列完整的集合。Java 在其标准库中也提供了大量的集合。在有些语言的库中，通常会有一两个集合能够适用于所有需求。而在另外一些语言（比如 Java）的库中，不同的集合具有不同的用途。比如，有几个不同的 <code>List</code> 类（用于保存序列），几个 <code>Map</code> 类（也叫“关联数组”，用于关联对象），几个 <code>Set</code> 类（用于保存不同类型的对象），以及一些队列（queue）、树（tree）、栈（stack）等。</p><p>从程序设计的角度而言，你真正需要的是能够解决实际问题的集合。一旦某种集合能够满足你的需求，你就不再需要其他集合了。之所以需要选择集合，可能有以下两个原因。</p><ol><li>不同的集合提供了不同类型的接口和行为。比如，栈和队列的用途就与 <code>Set</code> 以及 <code>List</code> 完全不同。针对你的问题，其中的某个集合也许可以提供比另一个集合更灵活的解决方案。</li><li>不同的集合在特定操作的执行效率方面也会有差异。比如，<code>List</code> 有两种基础类型的集合：<code>ArrayList</code> 和 <code>LinkedList</code>。虽然两者可以具有相同的接口和行为，但是某些操作的执行效率却存在明显的差异。比如用 <code>ArrayList</code> 随机获取元素是一种耗费固定时间的操作，意思是不管你选择获取哪个元素，耗费的时间都是相同的。但是对于 <code>LinkedList</code> 来说，在列表中随机选择元素是一种代价很大的操作，查找列表更深处的元素也会耗费更多的时间。另外，如果需要在列表中插入元素，<code>LinkedList</code> 耗费的时间会比 <code>ArrayList</code> 更少。取决于两者底层架构的不同实现方式，其他一些操作的执行效率也各有不同。你也可以先用 <code>LinkedList</code> 编写代码，然后为了追求效率而转投 <code>ArrayList</code> 的怀抱。由于两者都是基于 <code>List</code> 接口的子类，因此只需要改动少量代码就可以切换集合。</li></ol><h3 id="参数化类型（泛型）"><a href="#参数化类型（泛型）" class="headerlink" title="参数化类型（泛型）"></a>参数化类型（泛型）</h3><p>在 Java 5 之前，Java 语言的集合所支持的是通用类型 <code>Object</code>。因为单根层次结构决定了所有对象都属于 <code>Object</code> 类型，所以一个持有 <code>Object</code> 的集合就可以持有任何对象**$^6$**，这就使得集合十分易于复用。</p><p><strong>6</strong>其实并不能保存原始类型，不过“自动装箱”（autoboxing）机制从某种程度上缓解了这个问题。相关细节将在后续章节介绍。</p><p>为了使用这样一个集合，你要将对象引用添加到集合中，然后再将其取出。但由于该集合只能持有 <code>Object</code> 类型，因此当你添加一个对象引用到集合时，该对象会向上转型为 <code>Object</code>，从而失去了其原本的特征。当你需要将其取出时，会获得一个 <code>Object</code> 类型的对象引用，这就不是当初的类型了。那么问题来了，当初被放入集合中的对象如何才能转换回原来的类型呢？</p><p>这里需要再一次用到转型，只不过这次不是向上转为更通用的类型，而是向下转为更具体的类型，这种转型叫作“向下转型”（downcasting）。当使用向上转型时，我们知道 <code>Circle</code> 对象属于 <code>Shape</code> 类型，所以这种向上转型是安全的。但是反过来，我们并不知道一个 <code>Object</code> 对象实际上是 <code>Circle</code> 还是 <code>Shape</code> 类型，所以除非你明确知道对象的具体类型是什么，否则向下转型是不安全的。</p><p>不过，也不是说向下转型一定是危险的。如果向下转型失败，你会得到一个运行时的错误提示，这叫作“异常”（exception），后面你很快就会看到相关的介绍。不过话说回来，当你从集合中获取对象引用时，需要通过一些方法明确对象的类型，这样的话才能正确的向下转型。</p><p>当一段程序在运行时，向下转型和与其关联的运行时检查都会耗费额外的时间，同时程序员也需要关注这种向下转型。为什么我们创建的集合就不能明确地知道所包含的对象类型呢？如果知道的话，我们就不再需要向下转型，也避免了在此期间可能出现的报错。这个问题的解决方案就是“参数化类型”（parameterized type）机制。一个被参数化的类型是一种特殊的类，可以让编译器自动适配特定的类型。比如，对于参数化的集合而言，编译器可以将集合定义为只接受放入 <code>Shape</code> 的对象，因此从集合也只能取出 <code>Shape</code> 对象。</p><p>Java 5 新增的主要特性之一是支持参数化类型，也叫作“泛型”（generics）。你可以通过在一对尖括号中间加上类名来定义泛型，比如，你可以这样创建一个放置 <code>Shape</code> 对象的 <code>ArrayList</code>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ArrayList&lt;Shape&gt; shapes <span class="hljs-operator">=</span> new ArrayList&lt;&gt;()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>泛型带来的好处促使许多标准库组件都进行了相应的调整。此外，你在本书所列举的许多代码示例中都会看到泛型的作用。</p><h2 id="1-10-对象的创建和生命周期"><a href="#1-10-对象的创建和生命周期" class="headerlink" title="1.10　对象的创建和生命周期"></a>1.10　对象的创建和生命周期</h2><p>和对象打交道时有一个至关重要的问题，那就是它们的创建和销毁方式。每个对象的创建都要消耗一些资源，尤其是内存资源。当我们不再需要一个对象时，就要及时清理它，这样它占用的资源才能被释放并重复使用。在一些环境简单的场景下，清理对象似乎不是一个难题：你创建了一个对象，根据自己的需要使用，不再使用的时候就将其销毁。然而不幸的是，我们经常会遇到更为复杂的情况。</p><p>假设你需要为某个机场设计一个航空管制系统（你也可以用同样的方式管理仓库中的箱子、录像带租赁系统，甚至还有装宠物的笼子）。刚开始的时候，一切都是如此简单：新建一个用于保存飞机对象的集合，然后每当有飞机需要进入航空管制区域的时候，就新建一个飞机对象并将其放入集合中。而每当有飞机离开航空管制区域时，就清理对应的飞机对象。</p><p>再做一个假设：还有其他系统也会记录飞机的数据，而这些数据不需要像主控制程序那样及时更新，比如只会对离开机场的小型飞机做记录。于是，你需要创建一个新的集合用于保存小飞机对象，并且每当新建的飞机对象是小型飞机时，需要将其放入这个新的集合中。当有后台进程处于空闲状态时，就会操作这些对象。</p><p>现在问题变得更加棘手了，你怎么判断什么时候需要清理对象？当你不再需要一个对象时，系统的其他部分也许还在使用该对象。更糟糕的是，在许多其他情况下也会遇到同样的问题。而对于诸如 C++ 这样需要显式删除对象的编程语言来说，这绝对是一个相当让人头疼的问题。</p><p>对象的数据保存在哪里，系统又是如何控制对象的生命周期的呢？C++ 语言的宗旨是效率优先，所以它交给程序员来选择。如果要最大化运行时效率，可以通过栈区（也叫作“自动变量”或“局部变量”）保存对象，或者将对象保存在静态存储区里，这样在编写程序时就可以明确地知道对象的内存分配和生命周期。这种做法会优先考虑分配和释放内存的速度，在有些情况下是极为有利的。但是，代价就是牺牲了灵活性，因为你必须在编写代码时就明确对象的数量、生命周期以及类型。如果你希望解决一个更为普遍的问题，比如计算机辅助设计、仓库管理或者航空管制等，这种做法的限制性就太大了。</p><p>还有一种方案是在内存池里动态创建对象，这个内存池叫作“堆”（heap）。如果使用这个方案，直到运行时你才能知道需要多少对象，以及它们的生命周期和确切的类型是什么。也就是说，这些信息要等到程序运行时才能确定。如果你需要创建一个新对象，可以直接通过堆来创建。因为堆是在运行时动态管理内存的，所以堆分配内存所花费的时间通常会比栈多一些（不过也不一定）。栈通常利用汇编指令向下或向上移动栈指针（stack pointer）来管理内存，而堆何时分配内存则取决于内存机制的实现方式。</p><p>动态创建对象的方案基于一个普遍接受的逻辑假设，即对象往往是复杂的。所以在创建对象时，查找和释放内存空间所带来的额外开销不会造成严重的影响。此外，更大的灵活性才是解决常规编程问题的关键。</p><p>Java 只允许动态分配内存<strong>7</strong>。每当你创建一个对象时，都需要使用 <code>new</code> 操作符创建一个对象的动态实例。</p><p><strong>7</strong>你之后将学习到的原始类型（primitive type）是一个特例。</p><p>然而还有另一个问题——对象的生命周期。对于那些允许在栈上创建对象的编程语言，编译器会判断对象将会存在多久以及负责自动销毁该对象。但是如果你是在堆上创建对象，编译器就无从得知对象的生命周期了。对于像 C++ 这样的语言来说，你必须在编码时就明确何时销毁对象，否则万一你的代码出了差错，就会造成内存泄漏。而 Java 语言的底层支持<strong>垃圾收集器</strong>（garbage collector）机制，它会自动找到无用的对象并将其销毁。垃圾收集器带来了很大的便利性，因为它显著减少了你必须关注的问题数量以及需要编写的代码。因此，垃圾收集器提供了一种更高级的保障以防止潜在的内存泄漏，而正是内存泄漏导致了许多 C++ 项目的失败。</p><p>Java 设计垃圾收集器的意图就是处理内存释放的相关问题（虽然不包括清理对象所涉及的其他内容）。垃圾收集器“知道”一个对象何时不再有用，并且会自动释放该对象占用的内存。再加上所有对象都继承自顶层基类 <code>Object</code>，以及只能在堆上创建对象等特点，使得 Java 编程比 C++ 简单了不少。一言以蔽之，需要你介入的决策和阻碍都大大减少了。</p><h2 id="1-11-异常处理"><a href="#1-11-异常处理" class="headerlink" title="1.11　异常处理"></a>1.11　异常处理</h2><p>自从有编程语言起，错误处理就是一项极为困难的工作。设计一个优秀的错误处理系统是如此困难，以至于许多编程语言忽视了这个问题，而将问题抛给库的设计者。这些设计者只能采取一些折中措施来填补漏洞，这些举措虽然在有很多场景中都有效，但很容易通过忽略提示的错误而轻易绕过。大多数错误处理方案存在的一个显著的问题是，这些方案并非编程语言强制要求的，而是依赖于程序员同意并遵守相关约定。如果遇到警惕性不高的程序员（通常都是因为需要赶进度而放松了警惕），这些方案就形同虚设了。</p><p><strong>异常处理</strong>则是将编程语言甚至是操作系统和错误处理机制直接捆绑在一起。异常是从错误发生之处“抛出”的对象，而根据错误类型，它可以被对应的异常处理程序所“捕获”。而每当代码出现错误时，似乎异常处理机制会使用一条特殊的、并行的执行路径来处理这些错误。这是因为它确实采取了一条单独的运行路径，所以不影响正常执行的代码。同时这一点也降低了你编写代码的成本，因为你不用经常反复检查各种错误了。此外，抛出的异常也不同于方法返回的错误值或者方法设置的错误标识，因为这两者是可以被忽略的，但是异常不允许被忽略，所以这就确保了异常一定会在必要的时候被处理。最后，异常为我们提供了一种可以让程序从糟糕的情况中恢复过来的方法。即便发生了意外，我们也还有机会修正问题以及让程序重新恢复运行，而不是只能结束程序了事，而这一点无疑会增强许多程序的稳健性。</p><p>Java 的异常处理机制在众多编程语言之中几乎可以说是鹤立鸡群，这是因为 Java 从一开始就内置了异常处理，并且强制你必须使用它，这一点没有任何商量的余地，同时这也是Java唯一允许的报错方式。如果你的代码没有正确地处理各种异常，就会得到一条编译时的报错消息。这种有保障的一致性使得错误处理的工作简单了许多。</p><p>值得我们留意的是，虽然面向对象语言里的异常一般用对象的形式来呈现，异常处理却并不是面向对象语言的特性。其实，异常处理远在面向对象语言诞生之前就已经存在了。</p><h2 id="1-12-总结"><a href="#1-12-总结" class="headerlink" title="1.12　总结"></a>1.12　总结</h2><p>一段过程式程序（procedural program）包含了数据定义和函数调用。如果你想要搞清楚这种程序究竟做了什么，就必须仔细研究，比如查看它的函数调用以及底层代码等，以便在你的脑海中勾勒出一幅完整的蓝图。而这就解释了在设计过程式程序时，为什么还需要中间表示（intermediate representation, IR）。实话实说，过程式程序的理解成本确实很高，因其设计的表达方式更多是面向计算机，而不是你要解决的问题。</p><p>因为面向对象编程在过程式编程语言的基础上增加了许多新特性，所以你可能会想当然地认为同等效果的 Java 程序会远比过程式程序复杂。然而你会惊喜地发现，编写良好的 Java 程序通常比过程式程序更简单，也更易于理解。这是因为在 Java 中，对象的定义所呈现的是问题空间（而非计算机式的呈现）的概念，而发送至对象的消息则代表问题空间的具体活动。面向对象编程的一个令人愉悦之处在于，那些设计良好的程序，其代码总是易于阅读的。另外，因为许多问题都能够通过复用已有的库来解决，所以通常来说代码行数也不会太多。</p><p>面向对象编程和 Java 不一定适合所有人。有一点非常重要，那就是你必须仔细评估自己的需求，然后再判断 Java 是不是满足这些需求的最佳方案，也许使用其他编程语言是更好的选择（说不定就是你现在使用的编程语言）。如果在可预见的将来，你的需求非常专业并且具有一些 Java 无法满足的特殊条件，那么你就有必要研究一下其他可代替的编程语言（我尤其推荐 Python）。这样一来，就算你依然选择 Java 作为你的编程语言，至少你清楚还有哪些可选项，以及为什么选择它。</p>]]></content>
    
    
    <categories>
      
      <category>Books</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OnJava8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本书导读</title>
    <link href="/2-Introduction.html"/>
    <url>/2-Introduction.html</url>
    
    <content type="html"><![CDATA[<h1 id="本书导读"><a href="#本书导读" class="headerlink" title="本书导读"></a>本书导读</h1><blockquote><p>“我的语言之局限，即我的世界之局限。”</p><p>​                                                   ——Ludwig Wittgenstein（1889—1951）</p></blockquote><p>这句话不仅适用于我们日常读写的语言，也适用于编程语言。很微妙的一件事是，一门语言会悄然无息地引导你进入某种思维模式，同时远离其他思维模式。Java尤其如此。</p><p>Java是一门派生语言。当时的情况是，早期的语言设计师不想用C++来开发项目，于是创建了一门和C++极为相似的新编程语言，不过也做出了一些改进（遗憾的是，他们的项目最终没有上线）。这种新编程语言最主要的改动是加入了<strong>虚拟机</strong>和<strong>垃圾收集</strong>机制，本书后续章节会对这两点进行详细介绍。此外，Java还在其他方面推动着行业的持续发展，比如现在大多数语言应该支持文档标记语法，以及生成HTML文档的工具。</p><p>Java最主要的概念之一来自SmallTalk，这门语言强调“对象”（详细内容请见第1章）是编程的基本单位，所以任何一个东西都必须是对象。经历过长时间的洗礼之后，这个概念被证明是有些激进的，有些人甚至断定对象的概念是彻头彻尾的失败，应该果断丢弃。我个人认为，把所有内容都封装为对象不仅是一种负担，而且还会将许多程序设计推向错误的方向。然而不可否认的是，在一些情况下对象依然十分有用。所以，将一切都封装为对象（尤其是深入到最底层的时候）是一种设计失误，而完全抛弃对象同样太过极端。</p><p>Java还有一些决策也没有达成预期目标。关于这一点，本书中会陆续加以说明，以确保你不但可以理解这些语言特性，还能明白为什么你会觉得如鲠在喉。我并不是要将Java盖棺定论为一门优秀或拙劣的语言，我想表达的是，当了解了一门语言的不足之处和局限性之后，你将能够做到以下两点。</p><ol><li>当遇到某个语言特性不可用时，不会被卡住以致无法继续。</li><li>因为了解局限性所在，所以可以更好地进行程序设计和编程。</li></ol><p>编程是一门管理复杂性的艺术，而问题的复杂程度取决于机器的复杂程度。由于这种复杂性的存在，导致了大多数编程项目的失败。</p><p>许多编程语言在设计时充分考虑了复杂性的问题，然而有时候，其他问题才是更为本质的问题。几乎不可避免的是，那些“其他问题”才是让使用该语言的程序员最终碰壁的原因。例如，C++语言不得不向后兼容C语言（这是为了让C语言程序员更容易上手），同时还要保证运行效率。不可否认的是，这两者都是非常实用的设计目标，并且成了C++语言获得成功的功臣。但是随之也带来了大量额外的复杂性，使得许多项目因此而失败。当然，你可以责备程序员技艺不精或者管理方式有问题，但是如果一门语言可以协助你捕获程序中的错误，那么何乐而不为呢？</p><p>Visual Basic（VB）语言依赖于BASIC语言，而BASIC语言本身并不是一种扩展性良好的语言。这导致VB在扩展时经常出现各种非常难以维护的语法。Perl语言能够向后兼容<code>awk</code>、<code>sed</code>、<code>grep</code>以及其他UNIX工具，然而这些旧时代的工具本身就是需要被替换和更新的。结果就是，Perl程序里面充斥着大量的“只读代码”（意思是你自己都搞不懂自己写的代码是什么意思）。不过话说回来，C++、VB、Perl以及其他一些语言（比如SmallTalk）都提供了一些能够处理复杂性的设计方案，并且从解决特定问题的角度来看，它们做得还相当不错。</p><p>信息革命让我们所有人可以更为便捷地交流，不管是一对一、群组对群组还是星球对星球。我听说下一次革命将促生一个由足够多的人和连接组合而成的全球化的大脑。Java会不会成为这种革命所需的工具之一呢？一切皆有可能。</p><h2 id="阅读前提"><a href="#阅读前提" class="headerlink" title="阅读前提"></a>阅读前提</h2><p>本书假设你有一定的编程基础，即你应该了解以下内容。</p><ul><li>程序是一些计算机语句的集合。</li><li>子程序、函数、宏的概念。</li><li>了解<code>if</code>等控制语句，以及<code>while</code>等循环结构的用法。</li><li>其他相关知识点。</li></ul><p>也许你已经通过学校、图书或者互联网掌握了以上知识点。只要你能够理解编程的基本概念，就可以顺畅地阅读本书了。</p><p>如果你对以上基本概念不甚了解的话，可以通过On Java 8网站上的免费多媒体课程“Thinking in C”获取学习Java语言所需的基础知识。本书会重点介绍面向对象编程（Object-Oriented Programming, OOP）的概念，以及Java语言的基本控制机制。</p><p>我偶尔会提及一些C和C++的语言特性（有时也会提及其他语言），但是并不代表你必须熟悉C/C++语言，其目的是帮助大家理解和对比Java与两者的异同，毕竟Java是在它们的基础上发展而来的。我会尽量用简单的方式来引用这些概念，同时也会对非C/C++程序员所不熟悉的概念进行讲解。</p><h2 id="JDK-HTML文档"><a href="#JDK-HTML文档" class="headerlink" title="JDK HTML文档"></a>JDK HTML文档</h2><p>Oracle公司为Java开发工具集（Java Development Kit, JDK）提供了电子文档，你用Web浏览器就可以查看。除非必要，本书不会重复文档的内容，因为你用浏览器查看一个类的详细说明要比在本书中查找快得多（此外，在线文档的内容还是即时更新的）。所以在本书中，通常我只会提及需要参考“JDK文档”。除非需要补充文档内容才能让你理解某个特定的示例，否则一般情况下我不会提供额外的说明。</p><h2 id="“Thinking-in-C”课程"><a href="#“Thinking-in-C”课程" class="headerlink" title="“Thinking in C”课程"></a>“Thinking in C”课程</h2><p>“Thinking in C”课程介绍了C语言的一些基础知识，如语法、运算符、函数等，而这些内容同样也是Java语言的基础知识。此外，该课程还提供了一些编程的入门级知识，这些知识点适用于编程经验甚至比本书读者还要少的学生。</p><p>我委托Chuck Allison开发了“Thinking in C”这门独立的课程，之后将其收录在光碟里，再后来它变成了免费下载的形式。通过在网络上免费提供该课程，我可以确保所有人都具备阅读本书的知识基础。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>本书所有源代码都属于受版权保护的自由软件，并且都可以在GitHub网站上获取：<a href="https://github.com/BruceEckel/Onjava8-examples%E3%80%82%E4%B8%BA%E4%BA%86%E7%A1%AE%E4%BF%9D%E4%BD%A0%E4%BD%BF%E7%94%A8%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E6%98%AF%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E8%AF%B7%E8%AE%A4%E5%87%86%E8%BF%99%E4%B8%AA%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E3%80%82%E8%BF%99%E4%BA%9B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E5%9C%A8%E6%A0%A1%E5%AD%A6%E4%B9%A0%E6%88%96%E8%80%85%E6%95%99%E8%82%B2%E7%94%A8%E9%80%94%E3%80%82">https://github.com/BruceEckel/Onjava8-examples。为了确保你使用的源代码是最新版本，请认准这个官方下载地址。这些源代码可以用于在校学习或者教育用途。</a></p><p>源代码的版权保护主要是为了确保这些源代码可以被正确地引用，以及防止在未经授权的情况下被随意发布。（只要是本书中引用了版权信息的源代码，在大多数情况下，使用是没有问题的。）</p><p>在所有源代码文件里，你都会发现类似以下的版权信息说明：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>P14-P16代码<br></code></pre></td></tr></table></figure><p>在编程过程中，只要你在每一个源代码文件里都保留了上面提及的版权信息，这些源代码就可以用于在校学习或者教育用途（包括幻灯片演示等文件）。</p><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>在本书中，各种标识符（关键字、方法名、变量名、类名等）会以等宽字体显示。</p><p>本书示例会采用一种特定的编程风格。在尽可能满足本书格式要求的前提下，这种编程风格和Oracle网站上提供的编程风格几乎完全一致，同时能够兼容大多数Java开发环境。鉴于编程风格这个话题足以引发长达数小时的激烈争论，我需要在此澄清的是，我并没有试图通过我的代码示例来指导何为正确的编程风格，我使用的编程风格完全只是根据自己的意愿而为之。Java是一种形态自由的编程语言，所以你可以按照自己的喜好选择编程风格。此外，在使用诸如IntelliJ IDEA、Eclipse或者NetBeans等IDE（Integrated Development Environment，集成开发环境）时，你可以设置自己熟悉的编程风格，以此解决编程风格不一致的问题。</p><p>本书的源代码都通过了自动化测试，最新版本的Java应该可以正常运行这些源代码（除了被特别标识的内容以外）。</p><p>本书的内容聚焦于Java 8，并且所有源代码都在Java 8环境下测试通过。如果你一心想要学习本书未曾提及的Java早期版本的内容，也可以在On Java 8网站下载《Java编程思想》（第4版）。</p><h2 id="bug反馈"><a href="#bug反馈" class="headerlink" title="bug反馈"></a>bug反馈</h2><p>就算作者本人用尽各种办法来检测编程错误，依然可能会有漏网之鱼，通常新的读者可能会有所发现。在阅读本书的过程中，只要你确信自己发现了某处错误，不管是文字还是代码示例问题，请第一时间将该错误以及你修正后的内容提交到：<a href="https://github.com/BruceEckel/Onjava8-examples/issues%E3%80%82%E6%84%9F%E8%B0%A2%E4%BD%A0%E7%9A%84%E5%B8%AE%E5%8A%A9%EF%BC%81">https://github.com/BruceEckel/Onjava8-examples/issues。感谢你的帮助！</a></p><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>如果你希望获取相关新闻和通知，可以在On Java 8网站上订阅一个只包含少量内容的邮件列表。我不会发送任何广告，并且我会尽我所能保持其内容的正确性。</p><h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><p>对于Java而言，图形用户界面（GUI）和桌面编程代表着一段动荡甚至有些悲惨的历史。</p><p>在Java 1.0时代，GUI库最初的设计目的是让程序员可以创建一种在所有平台上看起来都光鲜亮丽的GUI。遗憾的是，这个目标并没有达成。取而代之的是，Java 1.0通过<strong>抽象窗口工具集</strong>（Abstract Windowing Toolkit, AWT）创建了一种在所有平台上都表现平平的GUI。不仅如此，这套GUI还有一些局限性。比如，你最多只能使用4种字体，而且你不能调用操作系统中任何成熟的GUI组件。此外，Java 1.0 AWT的编程模式最令人尴尬的是，它甚至不支持面向对象编程。我的研讨班中的一名学生（他曾经在Sun公司经历过最初创造Java语言的那段时光）曾经对此情况做出过解释：最初的AWT是在一个月之内构想、设计和实现出来的。这样的产能效率纵然让人称奇，却也是体现框架设计重要性的一份反面教材。</p><p>随后发展到Java 1.1 AWT事件模型的时期，情况终于有所改善。这次的AWT使用一种更为清晰且面向对象的编程方式，同时添加了一种名为JavaBeans的组件编程模式（现在已经不复存在），其目的是可以轻松创建可视化的编程环境。到了Java 2（也叫Java 1.2）时代，Java不再继续改进Java 1.0 AWT，而是用<strong>Java基础类</strong>（Java Foundation Classes, JFC）重写了一切，其中GUI部分称为“Swing”。通过JavaBeans及其丰富的代码库，用户可以创建出效果不错的GUI。只不过这一次，软件产业的“三个版本定律”（只有改良到第三个版本的才是好产品）似乎在编程语言领域也适用了。</p><p>Swing看起来似乎是Java语言GUI库的最终解决方案，然而这个假设最终也不攻自破了。随后，Sun公司又做出了最后一次努力，推出了JavaFX。当Oracle公司收购Sun公司后，Java的设计者们将这个野心勃勃的项目（其中甚至还包含了一种脚本语言）调整为Java的一个库，现在它似乎是唯一一个得以继续开发的UI工具包（详细请参考维基百科关于JavaFX的文章）。然而即便是这种程度的开发力度也难以为继，于是JavaFX和它的几个前辈一样，最终也难逃覆灭的命运。</p><p>现如今，Swing依然是Java的一部分（不过只是维护而没有再开发新内容）。由于Java现在已经是开源项目，所以也可以轻松获取到Swing。此外，Swing和JavaFX之间有一些有限的交互，其原本的目的是将Swing的功能移植到JavaFX中。</p><p>归根结底，Java在桌面领域从未真正强大过，甚至从未触及设计师的雄心壮志。至于其他，比如JavaBeans，也总是雷声大雨点小（不幸的是，有不少作者花费了大量心血来编写关于Swing的书，甚至是仅仅关于JavaBeans的书），始终没有获得大众的青睐。结果就是，Java在桌面领域的大多数应用场景是IDE以及一些企业内部的应用程序。虽然人们确实也会用Java开发用户界面，但是你要清楚地意识到这只是Java语言的一个小众需求。</p><p>如果你一定要学习Swing，可以在On Java 8网站上免费下载《Java编程思想》（第4版）并学习相关内容，或者参考其他专门讲解Swing的图书。</p>]]></content>
    
    
    <categories>
      
      <category>Books</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OnJava8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>腾讯云新号注册教程</title>
    <link href="/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%96%B0%E5%8F%B7%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B.html"/>
    <url>/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%96%B0%E5%8F%B7%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<h1 id="腾讯云新号注册教程"><a href="#腾讯云新号注册教程" class="headerlink" title="腾讯云新号注册教程"></a>腾讯云新号注册教程</h1><p><img src="/img/TencentCloudNewAccount.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络习题第一章(网络体系结构)</title>
    <link href="/ComputerNetworkingProblem1.html"/>
    <url>/ComputerNetworkingProblem1.html</url>
    
    <content type="html"><![CDATA[<ol><li><p>假定有一个通信协议，每个分组都引入100字节的开销用于头和成帧。现在使用这个协议发送 $10^6$ 字节的数据，然而在传送的过程中有一个字节被破坏了，因而包含该字节的那个分组被丢弃。试对于1000字节和20000字节的分组的有效数据大小分别计算“开销+丢失”字节的总数目。分组数据大小的最佳值是多少?</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/IMG_20211027_144348.png"></p></li><li><p>考虑一个最大距离为2km的局域网，当带宽等于多大时 传播延时（传播速度为$2\times10^8m/s$ )等于100B分组的发送延时?对于512B分组结果又当如何?</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/0571ddc1c8ecc9360933b1968027a05.jpg"></p></li><li><p>在两台计算机之间传输一个文件有两种可行的确认策略。第一种策略把文件截成分组，接收方逐个地确认分组，但就整体而言，文件没有得到确认。第二种策略不确认单个分组，但当文件全部收到后，对整个文件予以确认。请讨论这两种方式的优缺点。</p><blockquote><table><thead><tr><th><strong>方案1</strong></th><th>出错后不必从头开始，只传出错的分组</th><th>速度慢,需要分割和拼接</th></tr></thead><tbody><tr><td><strong>方案2</strong></td><td><strong>速度较快，不用分割和拼接分组</strong></td><td><strong>出错后整个文件重传</strong></td></tr></tbody></table><p>如果网络容易丢失分组，选方案一，此时仅重传丢失的分组。<br>如果网络高度可靠，那么在不发生差错的情况下，选方案二.从而减少了确认次数，节省了带宽。不过,即使只有单个分组丢失也要重传整个文件,因此更适用于小文件。</p></blockquote></li><li><p>试在下列条件下比较电路交换和分组交换。要传送的报文共x比特。从源点到终点共经过k段链路，每段链路的传播时延为d秒，数据传输速率为b比特每秒。在电路交换时电路的建立时间为s秒。在分组交换时分组长度为p比特，且各结点的排队等待时间可忽略不计。问在怎样的条件下，分组交换的时延比电路交换的要小?(提示:画一下草图观察k段链路共有几个结点。)</p><blockquote><p>电路交换时延:  $s + \frac{x}{b} + k \cdot d$</p><p>分组交换时延: $\frac{p}{b}\cdot k + \frac{p}{b} (\frac{x}{p} - 1) + k \cdot d$</p><p>由 </p><p>$$<br>\frac{p}{b}\cdot k + \frac{p}{b} (\frac{x}{p} - 1) + k \cdot d &lt; s + \frac{x}{b} + k \cdot d<br>$$</p><p>可得:</p><p>$$<br>k &lt; \frac {\frac{p}{b}+s}{\frac{p}{b}+d-1}<br>$$</p></blockquote></li><li><p>在上题的分组交换网中，设报文长度和分组长度分别为x和( p+h )比特，其中p为分组的数据部分的长度，而h为每个分组所带的控制信息固定长度，与p的大小无关。通信的两端共经过k段链路。链路的数据传输速率为b比特每秒，但传播时延、结点的排队时延和处理时延均可忽略不计。若打算使总的时延为最小，问分组的数据部分长度p应取为多大?</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/f165ba22bc8debf251158a105358b4d.jpg"></p></li><li><p>在下列情况下，计算传送1000KB文件所需要的总时间，即从开始传送时起直到文件的最后一位到达目的地为止的时间。假定往返时间RTT为100ms，一个分组是1KB(即1024B)的数据，在开始传送整个文件数据之前进行的起始握手过程需要2RTT的时间。<br>1）带宽是1.5Mb/s，数据分组可连续发送。<br>2）带宽是1.5Mb/s，但在发送完每一个数据分组后，必须等待一个RTT （等待来自接收方的确认）才能发送下一个数据分组。<br>3 )假设带宽是无限大的值，即我们取发送时间为0，并且在等待每个RTT后可以发送多达20个分组。</p></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/a25cf59fb4897e1480ab29929476142.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>习题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输延迟和传播延迟的区别</title>
    <link href="/TransmissionDelayandProgationDelay.html"/>
    <url>/TransmissionDelayandProgationDelay.html</url>
    
    <content type="html"><![CDATA[<h1 id="传输延迟和传播延迟的区别"><a href="#传输延迟和传播延迟的区别" class="headerlink" title="传输延迟和传播延迟的区别"></a>传输延迟和传播延迟的区别</h1><blockquote><p>类比: 车队</p></blockquote><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/20211026232700.png"></p><ul><li>车速为 100 km/hr ~ 信号传播速度</li><li>收费站放行一台车用时 12 秒 ~ 比特传输时间</li><li>车 ~ 比特；车队 ~ 分组</li><li>车队通过收费站时间 ~ <strong>传输延迟</strong> （120秒）</li><li>每台车从第一个收费站跑到第二个收费站用时 ~ <strong>传播延迟</strong> （1小时）</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中秋之行_下午_故宫博物院</title>
    <link href="/2021MidAutumnFestival2.html"/>
    <url>/2021MidAutumnFestival2.html</url>
    
    <content type="html"><![CDATA[<h1 id="中秋之行-下午-故宫博物院"><a href="#中秋之行-下午-故宫博物院" class="headerlink" title="中秋之行_下午_故宫博物院"></a>中秋之行_下午_故宫博物院</h1><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zAqLaebNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="西华门"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zAqLaefNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="西华门"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9WF6evNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="午门"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxp2lafHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="午门"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_je6fXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRUJr6frNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="太和殿"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSq9R6f7NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="太和殿"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSq9R6gLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://static.dingtalk.com/media/lADPDhmOw-dNZ4nNA8DNBQA_1280_960.jpg_720x720q90g.jpg?bizType=im" alt="太和殿"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zAqmZ5HNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTDaZ5zNA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9Wg56bNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQowT563NA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="中和殿"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTDaZ73NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="保和殿"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zAqmZ8zNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="皇建有极"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_j559nNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQow41HjNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="乾清门"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9XF1H3NA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="乾清宫"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zArLVIbNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="正大光明"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQow41R_NA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_ke1SPNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="乾清宫介绍"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRUKr1SXNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="无为"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSq-R1SfNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="无为"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRUKr1SnNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="坤宁宫"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRUKr1SzNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="体和殿介绍"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zArcE-_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="翔凤为林"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9XWk_LNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSq-ik_jNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="钟表馆"><a href="#钟表馆" class="headerlink" title="钟表馆"></a>钟表馆</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxqIq6jDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="钟表馆"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9XWk__NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金奖杯式寒暑三面表_19世纪末_法国"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9XWlAPNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜轮船模型表_19世纪末_法国"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-eDFAfNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜灯塔式座钟_19世纪_法国"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zArcFA7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金珐琅座钟_19世纪末_法国慕让制造"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-eDFBLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜热气球式钟_19世纪末_法国"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zArcFBfNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9X3V3vNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9X3V4LNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-ej13bNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxp4W14nNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金饰蓝瓷瓶式钟_19世纪末_法国巴黎"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_lQV4_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金珐琅围屏式钟_19世纪末_法国马蒂公司制造)"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zAr815rNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金石座水法穹式钟_19世纪末_法国"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-ej16PNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鸟音山石钟_19世纪_瑞士"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoxqV6nNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSq_DV7HNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金转花自鸣过枝雀笼钟"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zAsreLjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTFfeL3NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金园于莳花钟"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoyY-NbNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTFfeOLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金人指时刻分钟"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-fSeO3NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://static.dingtalk.com/media/lADPDiQ3P9Yl-PvNBQDNA8A_960_1280.jpg_720x720q90g.jpg?bizType=im"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyVS4eQXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRUML-RHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-f-llTNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTGLlljNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9ZSFl7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-f-lmLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_mrFoDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金七政仪表"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_mrFmzNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9ZSFnTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金象拉战车钟"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxp5xlo_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_mxVEHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-u36hXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9oLahjNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金写字人钟_1780年_英国伦敦威廉森制造"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyVid6hnNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="铜镀金写字人钟"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTVE6hrNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyVid6hvNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="彩漆描金自开门群仙祝寿楼阁式钟"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxqIq6hzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyVid6h3NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSrPXah7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSrPXah_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTVE6i_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="珍宝馆"><a href="#珍宝馆" class="headerlink" title="珍宝馆"></a>珍宝馆</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9oLajLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="珍宝馆入口"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyVid6jTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="九龙壁介绍"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyVid6jXNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="九龙壁1"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpB-ajbNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="九龙壁2"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTVE6jrNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="皇极殿介绍"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyVid6jfNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="皇极殿"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxqIq6jvNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="仁德大隆"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-vRLo_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="门"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSrPwro7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="门特写"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRUcKrpHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRUcKrpLNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCX_aDNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="大肥猫"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCXrpXNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxqJELpjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9okrpnNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-vRLprNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCXOlLNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSrPwOlTNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-vQulXNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw-vQulfNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSrPwOlnNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxqJDulrNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="御花园"><a href="#御花园" class="headerlink" title="御花园"></a>御花园</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCXOrrNA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zA8purvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCXOrzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCXOr7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鱼"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9okOr_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鱼"></p><hr><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCYQ8HNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxqJEw8LNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="神武门"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9olQ8TNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="神武门"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9olQ8XNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="刘老板"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9olQ8fNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="神武门_全"></p><hr><p><img src="https://static.dingtalk.com/media/lADPDg7mR_2CJ1zNA8DNBQA_1280_960.jpg_720x720q90g.jpg?bizType=im" alt="明思宗殉国处"></p><hr><h2 id="夜景"><a href="#夜景" class="headerlink" title="夜景"></a>夜景</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSrP1J8zNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwTVip83NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCcJ87NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="月"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQpCcJ9DNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zA8up9LNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P9olQ8nNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="晚饭,比中饭好吃,还有一个菜没拍"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zA8qw8vNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="wow"></p>]]></content>
    
    
    <categories>
      
      <category>个人记实</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021中秋节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中秋之行_上午_中国地质博物馆</title>
    <link href="/2021MidAutumnFestival1.html"/>
    <url>/2021MidAutumnFestival1.html</url>
    
    <content type="html"><![CDATA[<h1 id="中秋之行-上午-中国地质博物馆"><a href="#中秋之行-上午-中国地质博物馆" class="headerlink" title="中秋之行_上午_中国地质博物馆"></a>中秋之行_上午_中国地质博物馆</h1><h2 id="参观指南"><a href="#参观指南" class="headerlink" title="参观指南"></a>参观指南</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/ea272b7e29ac1914605940da8f4b2f3.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/3c8f10fd9d5673c3391c4fcdd13db42.jpg"></p><h2 id="2F矿物岩石厅"><a href="#2F矿物岩石厅" class="headerlink" title="2F矿物岩石厅"></a>2F矿物岩石厅</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9-baoXNEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P83u6oHNEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P83u6n_NEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwSkoanrNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRTrU6nXNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9-banHNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRTrU6m3NFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9-bamvNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P830x6rNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxpYdUPzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxpYdUP7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRTrj0QLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwSk3UQPNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSqfJ0QfNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyUyQUQnNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwSk3UQvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zAMDUQ3NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P8390Q7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSqfJ0R7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><h2 id="3F史前生物厅"><a href="#3F史前生物厅" class="headerlink" title="3F史前生物厅"></a>3F史前生物厅</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxpYgID7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_FZoD_NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoRzoEHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoRzoELNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P84AoETNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxpYgIEbNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgQ9zAMGIEjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyUyTIEvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P84AoE7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><h5 id="鹦鹉嘴龙"><a href="#鹦鹉嘴龙" class="headerlink" title="鹦鹉嘴龙"></a>鹦鹉嘴龙</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwSk989nNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRTrmhd7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxpYgBd_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwSk6BeHNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9-tBeLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="中国鹦鹉嘴龙"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSqfMhePNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_FZheTNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="翼龙"></p><h5 id="三里庙树枝蛋"><a href="#三里庙树枝蛋" class="headerlink" title="三里庙树枝蛋"></a>三里庙树枝蛋</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9-tBebNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="三里庙树枝蛋"></p><h5 id="满洲满洲龟"><a href="#满洲满洲龟" class="headerlink" title="满洲满洲龟"></a>满洲满洲龟</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRTrmhefNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="满洲满洲龟"></p><h5 id="猛犸象"><a href="#猛犸象" class="headerlink" title="猛犸象"></a>猛犸象</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwSlBdr7NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="猛犸象"></p><h5 id="柄杯鹿"><a href="#柄杯鹿" class="headerlink" title="柄杯鹿"></a>柄杯鹿</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoR69r_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="柄杯鹿"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_Fg9sDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="一些哺乳动物的牙齿"></p><h5 id="西峡巨型长型蛋"><a href="#西峡巨型长型蛋" class="headerlink" title="西峡巨型长型蛋"></a>西峡巨型长型蛋</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyUyZ_tLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="西峡巨型长型蛋"></p><h5 id="披毛犀"><a href="#披毛犀" class="headerlink" title="披毛犀"></a>披毛犀</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P84H9sHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="披毛犀"></p><h5 id="头骨"><a href="#头骨" class="headerlink" title="头骨"></a>头骨</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9-0dsPNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="头骨"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRTrt9sTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="头骨"></p><h5 id="巨型禄丰龙骨架模型"><a href="#巨型禄丰龙骨架模型" class="headerlink" title="巨型禄丰龙骨架模型"></a>巨型禄丰龙骨架模型</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwSlBdsfNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="巨型禄丰龙骨架模型"></p><h2 id="3F临时展厅"><a href="#3F临时展厅" class="headerlink" title="3F临时展厅"></a>3F临时展厅</h2><h5 id="徐悲鸿-愚公移山"><a href="#徐悲鸿-愚公移山" class="headerlink" title="徐悲鸿_愚公移山"></a>徐悲鸿_愚公移山</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoR69snNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="徐悲鸿_愚公移山"></p><h5 id="铁工厂锻压插件-水彩-1951-孙宗慰"><a href="#铁工厂锻压插件-水彩-1951-孙宗慰" class="headerlink" title="铁工厂锻压插件_水彩_1951_孙宗慰"></a>铁工厂锻压插件_水彩_1951_孙宗慰</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9-5MoHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="铁工厂锻压插件\_水彩\_1951_孙宗慰"></p><h5 id="愚公移山单人-1940-徐悲鸿"><a href="#愚公移山单人-1940-徐悲鸿" class="headerlink" title="愚公移山单人_1940_徐悲鸿"></a>愚公移山单人_1940_徐悲鸿</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSqfYsoLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山单人_1940_徐悲鸿"></p><h5 id="愚公移山手稿-1940-徐悲鸿"><a href="#愚公移山手稿-1940-徐悲鸿" class="headerlink" title="愚公移山手稿_1940_徐悲鸿"></a>愚公移山手稿_1940_徐悲鸿</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSqfYsoTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山手稿_1940_徐悲鸿"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgfLSqfYsoXNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山手稿_徐悲鸿"></p><h2 id="4F临时展厅"><a href="#4F临时展厅" class="headerlink" title="4F临时展厅"></a>4F临时展厅</h2><h5 id="柴达木之宝"><a href="#柴达木之宝" class="headerlink" title="柴达木之宝"></a>柴达木之宝</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxpYsMobNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="柴达木之宝"></p><h5 id="朱德收藏标本"><a href="#朱德收藏标本" class="headerlink" title="朱德收藏标本"></a>朱德收藏标本</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyUyfMofNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="朱德收藏标本"></p><h5 id="原油"><a href="#原油" class="headerlink" title="原油"></a>原油</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhYBRTrysojNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="原油"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiQ3P84MsonNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="原油"></p><h5 id="雌黄"><a href="#雌黄" class="headerlink" title="雌黄"></a>雌黄</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoR_sovNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="雌黄"></p><h5 id="萤石、白云石、水晶"><a href="#萤石、白云石、水晶" class="headerlink" title="萤石、白云石、水晶"></a>萤石、白云石、水晶</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9_BF7LNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="萤石、白云石、水晶"></p><h5 id="石英、白钨矿、云母"><a href="#石英、白钨矿、云母" class="headerlink" title="石英、白钨矿、云母"></a>石英、白钨矿、云母</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoSHl7PNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="石英、白钨矿、云母"></p><h5 id="石膏"><a href="#石膏" class="headerlink" title="石膏"></a>石膏</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDiCpwSlOF7bNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="石膏"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDg7mR_Ftl7jNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhmOw9_BF7rNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><h5 id="石油书籍"><a href="#石油书籍" class="headerlink" title="石油书籍"></a>石油书籍</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDgtYyUynF73NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="石油书籍"></p><h2 id="出馆与李四光像合影"><a href="#出馆与李四光像合影" class="headerlink" title="出馆与李四光像合影"></a>出馆与李四光像合影</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDh0cQoSHl77NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="照片"></p><h2 id="中饭"><a href="#中饭" class="headerlink" title="中饭"></a>中饭</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/lADPDhJzxpY0F8DNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="中饭,这面太难吃了"></p>]]></content>
    
    
    <categories>
      
      <category>个人记实</category>
      
    </categories>
    
    
    <tags>
      
      <tag>2021中秋节</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些绕口令</title>
    <link href="/%E4%B8%80%E4%BA%9B%E7%BB%95%E5%8F%A3%E4%BB%A4.html"/>
    <url>/%E4%B8%80%E4%BA%9B%E7%BB%95%E5%8F%A3%E4%BB%A4.html</url>
    
    <content type="html"><![CDATA[<h1 id="一些绕口令"><a href="#一些绕口令" class="headerlink" title="一些绕口令"></a>一些绕口令</h1><ol><li><p>==八了百了标了兵了奔了北了坡，炮了兵了并了排了北了边了跑， 炮了兵了怕了把了标了兵了碰，标了兵了怕了碰了炮了兵了炮。（双唇及舌）==</p></li><li><p>==巴老爷有八十八棵芭蕉树，来了八十八个把式要在巴老爷八十八棵芭蕉树下住。巴老爷拔了八十八棵芭蕉树，不让八十八个把式在八十八棵芭蕉树下住。八十八个把式烧了八十八棵芭蕉树，巴老爷在八十八棵树边哭。（锻炼唇力）==</p></li><li><p>==门口吊刀，刀倒吊着。……（反复说，锻炼舌的顶力）==</p></li><li><p>==山前有个催粗腿，山后有个催腿粗，俩人山前来比腿，不知是催粗腿比催腿粗的腿粗，还是催腿粗比催粗腿的腿粗。==</p></li><li><p>==粉红墙上画凤凰，凤凰画在粉红墙。红凤凰、粉凤凰，红粉凤凰花凤凰。==</p></li></ol><h3 id="主持人播音员专业八级绕口令考试试卷"><a href="#主持人播音员专业八级绕口令考试试卷" class="headerlink" title="主持人播音员专业八级绕口令考试试卷"></a>主持人播音员专业八级绕口令考试试卷</h3><h4 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h4><p>老龙恼怒闹老农，老农恼怒闹老龙。农怒龙恼农更怒，龙恼农怒龙怕农。</p><h4 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h4><p>牛郎恋刘娘，刘娘念牛郞，牛郎年年念刘娘，刘娘牛年恋牛郎，郎念娘来娘恋娘</p><h4 id="第三题："><a href="#第三题：" class="headerlink" title="第三题："></a>第三题：</h4><p>七巷一个漆匠，西巷一个锡匠。七巷漆匠用了西巷锡匠的锡，西巷锡匠拿了七巷漆匠的漆，七巷漆匠气西巷锡匠用了漆，西巷锡匠讥七巷漆匠拿了锡。</p><h4 id="第四题："><a href="#第四题：" class="headerlink" title="第四题："></a>第四题：</h4><p>初级 大声说20遍(红凤凰)<br>中级 大声说20遍(粉红凤凰)<br>高级 大声说10遍(红凤凰，黄凤凰，粉红凤凰花凤凰)</p><hr><p>丝瓜藤上绕满绳，<br>瓜藤绕着绳架伸。<br>绳长藤伸瓜儿长，<br>绳粗藤壮瓜儿沉。</p><p>风吹银铃叮铃铃<br>小琳琳，爱银铃，<br>琳琳用劲摇银铃，<br>银铃的铃声真好听。<br>风吹银铃叮铃铃，<br>小琳以为铃失灵，<br>银铃笑琳琳真是不机灵！</p><p>蓝教练是女教练，吕教练是男教练<br>蓝教练不是男教练，吕教练不是男教练<br>蓝南是男篮主力，吕楠是女篮主力。吕教练在男篮训练蓝南，蓝教练在女篮训练吕楠。</p><p>小盈林，爱银铃，<br>盈林用劲摇银铃，<br>银铃声音真动听。<br>风吹银铃叮铃铃，<br>盈林心中喜盈盈，<br>笑声尽情赛银玲。</p><hr><ol><li>初入江湖：化肥会挥发</li><li>小有名气：黑化肥发灰，灰化肥发黑</li><li>名动一方：黑化肥发灰会挥发；灰化肥挥发会发黑</li><li>天下闻名：黑化肥挥发发灰会花飞；灰化肥挥发发黑会飞花</li><li>一代宗师：黑灰化肥会挥发发灰黑讳为花飞；灰黑化肥会挥发发黑灰为讳飞花</li><li>超凡入圣：黑灰化肥灰会挥发发灰黑讳为黑灰花会飞；灰黑化肥会会挥发发黑灰为讳飞花化为灰</li><li>天外飞仙：黑化黑灰化肥灰会挥发发灰黑讳为黑灰花会回飞；灰化灰黑化肥会会挥发发黑灰为讳飞花回化为灰</li></ol><h3 id="绕口令"><a href="#绕口令" class="headerlink" title="绕口令"></a>绕口令</h3><h4 id="单韵母练习"><a href="#单韵母练习" class="headerlink" title="单韵母练习"></a>单韵母练习</h4><ol><li>坡上立着一只鹅，坡下就是一条河。宽宽的河，肥肥的鹅，鹅要过河，河要渡鹅，不知是鹅过河，还是河渡鹅？</li><li>山上五棵树，架上五壶醋，林中五只鹿，箱里五条裤。伐了山上树，搬下架上的醋，射死林中的鹿，取出箱中的裤。</li></ol><h4 id="鼻韵母练习"><a href="#鼻韵母练习" class="headerlink" title="鼻韵母练习"></a>鼻韵母练习</h4><ol><li>扁担长，板凳宽，扁担没有板凳宽，板凳没有扁担长，扁担想绑在板凳上，板凳不让扁担绑在板凳上，扁担偏偏绑在板凳上，到底是板凳宽还是扁担长。</li><li>一平盆面，烙一平盆饼，饼碰盆，盆碰饼。</li><li>山前有个严圆眼，山后有个严眼圆，二人山前来比眼，不知是严圆眼的眼圆，还是严眼圆比严圆眼的眼圆？</li></ol><h4 id="复韵母练习"><a href="#复韵母练习" class="headerlink" title="复韵母练习"></a>复韵母练习</h4><ol><li>出南门，走六步，见着六叔和六舅，叫声六叔和六舅，借我六斗六升好绿豆；过了秋，打了豆，还我六叔六舅六十六斗六升好绿豆。</li><li>哥挎瓜筐过宽沟，过沟筐漏瓜滚沟。隔沟挎筐瓜筐扣，瓜滚筐空哥怪沟。</li></ol><h4 id="唇音练习"><a href="#唇音练习" class="headerlink" title="唇音练习"></a>唇音练习</h4><ol><li>老方扛着黄幌子，老黄扛着方幌子。老方要拿老黄的方幌子，老黄要拿老方的黄幌子，末了儿方幌子碰破了黄幌子，黄幌子碰破了方幌子。</li></ol><h4 id="舌尖中音练习"><a href="#舌尖中音练习" class="headerlink" title="舌尖中音练习"></a>舌尖中音练习</h4><ol><li>你会炖炖冻豆腐，你来炖我的炖冻豆腐；你不会炖炖冻豆腐，别胡炖乱炖炖坏了我的炖冻豆腐。</li><li>老罗拉了一车梨，老李拉了一车栗。老罗人称大力罗，老李人称李大力。老罗拉梨做梨酒，老李拉栗去换梨。</li><li>有个面铺门朝南，门上挂着蓝布棉门帘，摘了蓝布棉门帘，面铺门朝南；挂上蓝布棉门帘，面铺还是门朝南。</li><li>大刀对单刀，单刀对大刀，大刀斗单刀，单刀夺大刀。</li></ol><h4 id="舌根音、舌面音练习"><a href="#舌根音、舌面音练习" class="headerlink" title="舌根音、舌面音练习"></a>舌根音、舌面音练习</h4><ol><li>一班有个黄贺，二班有个王克，黄贺、王克二人搞创作，黄贺搞木刻，王克写诗歌。黄贺帮助王克写诗歌，王克帮助黄贺搞木刻。由于二人搞协作，黄贺完成了木刻，王克写好了诗歌。<br>翘舌音、平舌音、练习</li><li>天上有个日头，地下有块石头，嘴里有个舌头，手上有五个手指头。不管是天上的热日头，地下的硬石头，嘴里的软舌头，手上的手指头，还是热日头，硬石头，软舌头，手指头，反正都是练舌头。</li><li>师部司令部指示：四团十连石连长带四十人在十日四时四十四分按时到达师部司令部，师长召开誓师大会。</li><li>早招租，晚招租，总找周邹郑曾朱。</li></ol>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OnJava8前言</title>
    <link href="/1-OnJava8Preface.html"/>
    <url>/1-OnJava8Preface.html</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本书基于Java 8的特性进行该语言的编程教学。</p></blockquote><p>我以前的那本Java书——《Java编程思想》（第4版），对于用Java 5编程仍然很有用，Android编程用的就是这个语言版本。然而随着Java 8的到来，这门语言发生了许多显著的变化，使得编写和阅读新版本Java代码的方式都与以往有了明显的不同。于是，花费两年时间编写一本新书也就在情理之中了。</p><p>本书的读者具备基础的编程经验即可。对于经验不足的编程入门者而言，可汗学院（Khan Academy）这类网络资源提供了不少介绍编程基础知识的课程，另外也可以尝试之前提及的“Thinking in C”免费多媒体课程。当你遇到问题时，相比数年前只能依靠纸质媒体的时代，如今通过YouTube、博客、Stack Overflow等网站就可以轻松地找到所需要的答案。此外，若有坚韧不拔的毅力，你完全可以把本书当作自己的第一本编程教材。此外，本书同样适用于那些希望拓宽自己知识面的专业程序员。</p><p>《Java编程思想》一书自面世至今，让我受益匪浅，尤其是与其相关的全球范围内的演讲让我收获很多。对此，我一直心存感激。而这本书真正的无价之处在于，它让许多人和公司之间产生了关联。</p><h2 id="本书目标"><a href="#本书目标" class="headerlink" title="本书目标"></a>本书目标</h2><p>本书每一章都会介绍一个或者一组互相关联的概念，同时这些概念不依赖于当前章节没有介绍的特性。因此，你可以结合当前获取的知识来充分理解上下文，然后再阅读下一章。</p><p>我个人对本书的目标如下。</p><ol><li>循序渐进地呈现相关知识点，以便你充分理解每一个理念，之后再继续前行。同时，谨慎地安排语言特性出现的顺序，以便你先学习一个特性，然后再接触与之相关的实际应用场景。然而我并不能保证百分之百可以做到这一点，当出现意外情况时，我也会提供一些简要的相关说明。</li><li>所使用的示例尽可能地浅显易懂。有时候我会因为这一条原则而放弃引入所谓“现实世界”的问题，然而我发现对于初学者而言，相比于因为示例解决了一个范围很大的问题而惊讶，当他们理解示例中所有细节的时候会觉得更有收获。对于这一点，也许有人会批判我只热衷于“简单示例”，但是为了产生更为明显的教育成效，我依然乐于接受目前的做法。</li><li>相较传授我所了解的语言知识，我更希望传授语言的重要之处是什么。我认为信息需要根据其重要程度进行分级，而事实是，有些细节对于95%的程序员而言是无关紧要的。这些细节只会让人们感到困惑，以及增加他们对于语言复杂度的认知。如果<strong>你的</strong>代码必须考虑这些细节，切记这些内容也会困扰那些阅读和维护代码的人。所以我提倡代码使用简单的实现方式。</li><li>为你打下坚实的编程语言基础，以便你之后学习难度更高的课程和图书时，可以充分理解自己所遇到的问题。</li></ol><h2 id="语言设计缺陷"><a href="#语言设计缺陷" class="headerlink" title="语言设计缺陷"></a>语言设计缺陷</h2><p>每一种语言都存在设计缺陷。屡屡让新手程序员感到不安和挫败的是，他们必须“周旋”于各种语言特性之中，不断猜测应该用什么、不应该用什么。承认错误总是让人感到不快，但是相比承认错误所带来的不适感，这种糟糕的新手体验要严重得多。令人尴尬的是，所有失败的语言/库设计一直存在于Java的发布版本里。</p><p>诺贝尔经济学奖得主Joseph Stiglitz有一句生活哲言十分应景，也叫作“承诺升级理论”（The Theory of Escalating Commitment）：</p><blockquote><p>持续犯错的代价由别人承担，而承认错误的代价由你自己来承担。</p></blockquote><p>如果你读过我以往的文章或著作，就会知道，当发现编程语言的设计缺陷时，我倾向于指出这些问题。Java发展到今天，已拥有了许多热心的拥护者，其中有些人甚至将Java视为自家“孩子”，而非一种语言工具。因为我编写了一些关于Java的著作，所以他们以为我也会像他们一样袒护Java。于是，当我发现了某个语言缺陷并进行批判时，经常会出现以下两种情况。</p><ol><li>起初会引起一阵类似于“我的孩子无论对错”的愤怒，之后会逐渐平复，变成只有零星反抗。到了最后（也许会经过许多年），该缺陷逐渐被大家广泛承认，从此被视为Java的历史遗留问题。</li><li>更为关键的是，新手程序员并没有经历过“想不通为什么会这样”的痛苦挣扎，尤其是发现了某个看起来不对劲儿的地方之后所产生的自我怀疑，在这种情况下人们会很自然地认为<strong>要么是自己做错了，要么就是自己还没有搞明白</strong>。更糟糕的是，有些教授该语言的人会直接引用一些错误的概念，而不是对问题进行更加深入的研究和分析。而如果能够理解语言的设计缺陷，即使是新手程序员也能够理解不对劲儿的地方是一个错误，从而绕过它继续前行。</li></ol><p>我认为，理解语言和库的设计缺陷是必要的，因为它们会影响程序员的生产力。有些公司和团队会刻意规避某些语言特性，因为虽然它们看起来很有趣，但可能会在你毫无准备之时突然卡住你的工作进程。此外，设计缺陷也会影响新语言的创建和采用。探索一门语言能做什么的过程十分有趣，然而设计缺陷能够告诉你该语言<strong>不能</strong>做什么。</p><p>多年以来，我真切地感受到Java语言的设计者不够关心用户。有些语言缺陷可谓是太过明显，根本没有经过深思熟虑，看起来像是设计者的思绪早已飞到了九霄云外，对自己的用户不管不顾。因此，Java语言在相当长的一段时间里饱受争议，也许这些有争议之处正是其诱惑所在。此外，这种对程序员看似不尊重的态度，也是我当初放弃Java选择其他语言，并且在相当长的一段时间内都不想回头的主要原因。</p><p>而当我重新回过头来审视Java的时候，Java 8给我的感觉是焕然一新，就好像是该语言的设计者对于语言和用户的态度发生了180度大转变。比如，许多被用户诟病已久，甚至被视为语言毒瘤的特性和库都得到了修正。新引入的特性也让人耳目一新，就好像是设计团队中新加入了几位极其关注程序员使用体验的设计者。这些特性最终被证明是有效的，从而使得Java语言更为出众，这明显好过在没有深入探究一个理念的本质时就急不可待地把它添加进来。此外，部分新特性十分优雅（至少可以说在考虑到Java局限性的情况下，已经尽可能地优雅了）。对此我只能猜测，可能有些人离开了Java语言设计团队，因而才发生了这些变化。</p><p>得益于语言设计者的良苦用心（其实我并没有料想到这一点），编写本书的过程相比以往要顺利得多。Java 8包含了许多基础和重要的改进，而由于Java的向后兼容性一直惨不忍睹，做出这些改进无疑需要花费相当多的精力。因此可以预料的是，将来也很难再见到如此重大的改进了（关于这一点，希望我是错的）。话虽如此，我依然要为那些把Java重新带入正确航道的人献上掌声。当终于能够用Java 8编写出某段代码时，我第一次下意识地喊出：“我爱死这个了！”</p><p>最后，本书的出版时机也非常不错，这是因为Java 8提供的一些重要特性会大大影响我们编写代码的方式，而到目前为止，Java 9似乎专注于改进语言的底层，其引入的一些重要的底层特性并不会影响本书中的代码。</p><h2 id="经过测试的示例"><a href="#经过测试的示例" class="headerlink" title="经过测试的示例"></a>经过测试的示例</h2><p>本书提供的示例所使用的是Java 8环境和Gradle编译工具。虽然我也使用新版本的Java测试过这些示例，但我依然推荐你使用该语言的长期稳定（LTS）版本：在我写这本书时，对应的是Java 8或者Java 11。此外，本书所有示例都可以从GitHub仓库免费获取。</p><p>每当构建一个应用程序时，如果没有一套内置测试流程来测试你的代码，就无法判断代码是否坚实可信。因此，我为本书创建了一套测试系统，用于展示和验证大多数示例的输出结果。具体而言，运行示例代码后的输出结果会生成一段注释，附加在代码的末尾处。有时候注释并不显示全部内容，而是只显示开头的几行，或者开头和末尾的几行。这种嵌入式的输出方式提升了代码可读性，降低了学习门槛，同时也提供了一种验证代码正确性的方式。</p><h2 id="普及程度"><a href="#普及程度" class="headerlink" title="普及程度"></a>普及程度</h2><p>Java的普及具有重要意义。我的意思是，如果你学会了Java，也许找工作会容易一些，而且市面上有大量的Java培训材料、课程以及其他学习资源等。另外，如果你开一家公司并且选择Java作为工作语言，招募Java程序员时也会容易一些。Java的这一点优势确实无可争辩。</p><p>话虽如此，目光短浅总归不是好事。如果你并不是真心喜爱Java，建议你还是远离它为好。我的意思是，如果学习Java只是为了找工作，无异于选择了一种不幸福的人生。而对于公司来说，如果你选择Java只是为了降低招聘难度，请务必三思而后行。根据你的实际需求，也许采用其他语言的话，你可以雇用更少的员工，但能达到更高的生产力（比如通过我的另一本书<em>Atomic Kotlin</em>学习Kotlin语言）。此外，使用一种更新也更激动人心的编程语言也许更容易吸引有志之士的加盟。</p><p>不过，如果你<strong>真的</strong>喜爱Java这门语言，那么欢迎你加入。同时，我希望本书可以丰富你的编程经验。</p><h2 id="关于Android程序员"><a href="#关于Android程序员" class="headerlink" title="关于Android程序员"></a>关于Android程序员</h2><p>Android编程使用的环境是Java 5，而我编写本书的原则是“尽可能使用纯粹的Java 8”，所以如果你学习Java的目的是为Android系统编写应用程序，那么推荐你学习《Java编程思想》（第4版）。此外，还有许多专门针对Android的编程资源可供学习。</p><p>顺便一提，对于Android编程而言，Kotlin语言是一种更新和更好的选择，同时它也是Android的官方编程语言。</p><h2 id="出版说明"><a href="#出版说明" class="headerlink" title="出版说明"></a>出版说明</h2><p>本书使用了自动化的构建过程，同样的自动化过程还有解压、编译以及测试所有示例代码。我使用Python 3编写了大量的应用程序来处理所有的自动化过程。</p><h3 id="封面设计"><a href="#封面设计" class="headerlink" title="封面设计"></a>封面设计</h3><p>本书的封面插图来自美国公共事业振兴署（Works Progress Administration，简称WPA，是1935—1943年美国大萧条时期所创建的一个大型公共事业项目，其目标是援助失业人口重新返回工作岗位）。此外，它也让我想起了《绿野仙踪》系列丛书的插图。我的设计师朋友Daniel Will-Harris和我都十分喜爱这张图片。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢Eric Evans（《领域驱动设计》一书的作者）针对本书书名提供了宝贵意见，也感谢所有在讨论组里帮助我确定书名的人们。</p><p>感谢James Ward，他使我得以为本书使用Gradle构建工具，感谢他一直以来提供的帮助以及跟我的友谊。感谢Ben Muschko对构建文件所做的优化，同时也要感谢Hans Dockter给Ben时间来做这件事。</p><p>感谢Jeremy Cerise与Bill Frasure参与本书的开发者活动，并提供了有价值的帮助。</p><p>感谢所有抽出宝贵时间莅临科罗拉多州克雷斯特德比特市，参加我所组织的会议、研讨活动、开发者活动以及其他活动的嘉宾们。你们虽深居幕后，但所做出的贡献不可或缺。</p><h2 id="献词"><a href="#献词" class="headerlink" title="献词"></a>献词</h2><p>谨献给我敬爱的父亲E. Wayne Eckel，他生于1924年4月1日，卒于2016年11月23日。</p>]]></content>
    
    
    <categories>
      
      <category>Books</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OnJava8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>摩尔庄园手游NPC喜好</title>
    <link href="/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%AD%E6%89%8B%E6%B8%B8NPC%E5%96%9C%E5%A5%BD.html"/>
    <url>/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%AD%E6%89%8B%E6%B8%B8NPC%E5%96%9C%E5%A5%BD.html</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"><strong>NPC</strong></th><th align="center"><strong>位置</strong></th><th><strong>喜好</strong></th><th><strong>厌恶</strong></th><th><strong>好友</strong></th></tr></thead><tbody><tr><td align="center">菩提</td><td align="center">神秘湖(阳光沙滩)码头</td><td>清炒毛毛豆、奇异果、星空鱼、香蕉</td><td>荔枝、狗鱼</td><td></td></tr><tr><td align="center">艾尔</td><td align="center">警署</td><td>鸡蛋、满天星、罗汉鱼、牛奶鱼群汤</td><td>大闸蟹、小龙虾</td><td></td></tr><tr><td align="center">艾米</td><td align="center">报社门口</td><td>锦鲤、月亮海螺、棉花糖、胡萝卜盖饭</td><td>水蜘蛛、奇异果</td><td></td></tr><tr><td align="center">杰西</td><td align="center">城堡喷泉广场</td><td>茄子、小丑鱼、小麦牛奶蛋粥、牛奶</td><td>水蛇、章鱼、葡萄</td><td></td></tr><tr><td align="center">彩虹</td><td align="center">宠物店</td><td>胡萝卜、浆果烧饼、小麦牛奶蛋粥、章鱼</td><td>利齿狗鱼、鲶鱼</td><td></td></tr><tr><td align="center">丝尔特</td><td align="center">服装店门口</td><td>苹果、羊毛、甲鱼南瓜盅、蒲兰花</td><td>大闸蟹、章鱼</td><td></td></tr><tr><td align="center">埃里克斯</td><td align="center">家具店门口</td><td>金鱼、铜矿石、红木、棉花糖豆浆</td><td>南瓜、西瓜</td><td></td></tr><tr><td align="center">梅森</td><td align="center">梅森小屋门口</td><td>南瓜、草莓、向日葵、葫芦炒茄子</td><td>鲶鱼、带鱼</td><td></td></tr><tr><td align="center">克劳</td><td align="center">爱心礼堂</td><td>牛奶鱼群汤、冰激凌鼠、百合花</td><td>水蜘蛛、水蛇</td><td></td></tr><tr><td align="center">尼克</td><td align="center">城堡餐厅门口</td><td>白菜、石榴炸冰虾、鲶鱼、河豚</td><td>百合花</td><td></td></tr><tr><td align="center">汤米</td><td align="center">摩尔拉雅山脚</td><td>水蜜桃、铜矿石、解暑冲饮、茄块狗鱼片</td><td>水煮大闸蟹 、章鱼</td><td></td></tr><tr><td align="center">弗礼德</td><td align="center">游戏小屋(白熊游戏屋)</td><td>葫芦、冰川虾、鲶鱼、香煎雪鱼</td><td>鲤鱼、玉米、香蕉</td><td></td></tr><tr><td align="center">花婶</td><td align="center">淘淘乐街</td><td>毛毛花、七色花、葡萄、椰汁水果捞</td><td>金鱼</td><td></td></tr><tr><td align="center">瑞琪</td><td align="center">前哨站</td><td>小丑鱼、抱抱熊、毛毛爆囧菇</td><td>怪怪鱼</td><td></td></tr><tr><td align="center">凯文</td><td align="center">摩尔拉雅山顶</td><td>小丑鱼、抱抱熊、葫芦烧茄子</td><td>水蛇、水蜘蛛、章鱼</td><td></td></tr><tr><td align="center">洛克</td><td align="center">摩尔城堡大门处</td><td>向日葵、星空鱼、浆果浓汤、椰子</td><td>毛毛豆、怪怪鱼、茄块狗鱼片、麻辣小龙虾</td><td></td></tr><tr><td align="center">琦琦</td><td align="center">派对广场</td><td>南瓜、初恋海星、麻辣小龙虾、水蜜桃</td><td>水蛇、水蜘蛛</td><td></td></tr><tr><td align="center">茜茜</td><td align="center">摩尔拉雅山腰</td><td>水蜘蛛、樱花蛇、麻辣小龙虾</td><td>带鱼、苹果</td><td></td></tr><tr><td align="center">尤尤</td><td align="center">阳光牧场</td><td>毛毛花、向日葵，玫瑰海星、奶油玉米浓汤</td><td>蒜头蛙、粑粑海肠、水蜘蛛</td><td></td></tr><tr><td align="center">贝琪</td><td align="center">摩尔拉雅山顶</td><td>玉米、绿鲤鱼、河童、花香金鱼</td><td>胡萝卜盖饭、胡萝卜、奇异果</td><td></td></tr></tbody></table><p><img src="/img/others/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%ADNPC.jpg" alt="摩尔庄园NPC"></p>]]></content>
    
    
    
    <tags>
      
      <tag>游戏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第七章 实现</title>
    <link href="/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AE%9E%E7%8E%B0.html"/>
    <url>/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AE%9E%E7%8E%B0.html</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-实现"><a href="#第七章-实现" class="headerlink" title="第七章 实现"></a>第七章 实现</h1><hr><h2 id="实现包括：编码和测试"><a href="#实现包括：编码和测试" class="headerlink" title="实现包括：编码和测试"></a>实现包括：编码和测试</h2><blockquote><p>编码：把软件设计结果翻译成程序。<br>测试：检测程序并改正错误的过程。</p></blockquote><hr><h2 id="白盒测试和黑盒测试的定义"><a href="#白盒测试和黑盒测试的定义" class="headerlink" title="白盒测试和黑盒测试的定义"></a>白盒测试和黑盒测试的定义</h2><h3 id="白盒测试（也称结构测试）"><a href="#白盒测试（也称结构测试）" class="headerlink" title="白盒测试（也称结构测试）"></a>白盒测试（也称结构测试）</h3><blockquote><p>如果知道软件内部工作过程，可以通过测试来检验软件内部动作是否按照规格说明书的规定正常进行，这种测试称为白盒测试。</p></blockquote><h3 id="黑盒测试（也称功能测试）"><a href="#黑盒测试（也称功能测试）" class="headerlink" title="黑盒测试（也称功能测试）"></a>黑盒测试（也称功能测试）</h3><blockquote><p>如果已经知道软件应该具有的功能，可以通过测试来检验是否每个功能都能正常使用，这种测试称黑盒测试。也称功能测试。</p></blockquote><hr><h2 id="软件测试的步骤"><a href="#软件测试的步骤" class="headerlink" title="软件测试的步骤"></a>软件测试的步骤</h2><h3 id="1-模块测试（测试编码和详细设计的错误）"><a href="#1-模块测试（测试编码和详细设计的错误）" class="headerlink" title="1. 模块测试（测试编码和详细设计的错误）"></a>1. 模块测试（测试编码和详细设计的错误）</h3><blockquote><p>模块测试又称单元测试，它把每个模块作为单独的实体来测试。</p></blockquote><h3 id="2-子系统测试（测试模块接口）"><a href="#2-子系统测试（测试模块接口）" class="headerlink" title="2. 子系统测试（测试模块接口）"></a>2. 子系统测试（测试模块接口）</h3><blockquote><p>子系统测试是把警告单元测试的模块放在一起形成一个子系统来测试。</p></blockquote><h3 id="3-系统测试"><a href="#3-系统测试" class="headerlink" title="3. 系统测试"></a>3. 系统测试</h3><blockquote><p>系统测试是把经过测试的子系统装配成一个完整的系统来测试。<br>子系统测试测试和系统测试，通常称为集成测试。</p></blockquote><h3 id="4-验收测试"><a href="#4-验收测试" class="headerlink" title="4. 验收测试"></a>4. 验收测试</h3><blockquote><p>验收测试把软件系统作为单一的实体进行测试（利用用户的实际数据测试）。</p></blockquote><h3 id="5-平行运行"><a href="#5-平行运行" class="headerlink" title="5.平行运行"></a>5.平行运行</h3><blockquote><p>平行运行是同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。</p></blockquote><hr><h2 id="单元测试-计算机测试（驱动程序和存根程序）"><a href="#单元测试-计算机测试（驱动程序和存根程序）" class="headerlink" title="单元测试-计算机测试（驱动程序和存根程序）"></a>单元测试-计算机测试（驱动程序和存根程序）</h2><blockquote><p>单元测试集中检测软件的设计的最小单元—模块。单元测试和编码属于软件工程的同一阶段。一般方法是：</p><ul><li>首先通过编译系统检查并改正程序中所有的语法错误；</li><li>然后用详细设计模块说明为指南，对重要的控制路径进行测试，以便发现模块内部的错误。</li><li>通常，单元测试使用白盒测试技术。</li></ul></blockquote><h3 id="测试重点"><a href="#测试重点" class="headerlink" title="测试重点"></a>测试重点</h3><ol><li>模块接口</li></ol><blockquote><p>应该对穿过模块接口的数据流进行检测，以保证正确的输入和输出。</p></blockquote><ol start="2"><li>局部数据结构</li></ol><blockquote><p>这是错误的主要来源，应该设计相应的测试用例，以便发现数据结构方面的错误。</p></blockquote><ol start="3"><li>重要的执行路径</li></ol><blockquote><p>由于不可能进行穷尽测试，因此选择测试路径是非常关键的。</p></blockquote><ol start="4"><li>出错处理通路和边界条件</li></ol><h3 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h3><h3 id="计算机测试"><a href="#计算机测试" class="headerlink" title="计算机测试"></a>计算机测试</h3><blockquote><p>由于软件模块不是一个独立的系统，不能独立运行，要依靠其他模块调用，或需要调用其他模块。因此，必须要为测试的单元开发驱动程序或存根程序。</p><p>1.驱动程序</p><blockquote><p>相当于一个“主程序”，用来把测试数据传送给被测试的模块，并打印有关结果。</p></blockquote><ol start="2"><li>存根程序</li></ol><blockquote><p>用来代替被测试模块所调用的模块，相当于“虚拟子程序”。</p></blockquote></blockquote><hr><h2 id="集成测试：非渐增测试和渐增式测试"><a href="#集成测试：非渐增测试和渐增式测试" class="headerlink" title="集成测试：非渐增测试和渐增式测试"></a>集成测试：非渐增测试和渐增式测试</h2><blockquote><p>集成测试是组装软件的系统化技术，它将经过单元测试的模块联系在一起进行测试。</p></blockquote><p>由模块组装成程序时有两种方法：</p><h3 id="1-非渐增式测试方法"><a href="#1-非渐增式测试方法" class="headerlink" title="1. 非渐增式测试方法"></a>1. 非渐增式测试方法</h3><blockquote><p>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序。</p></blockquote><h3 id="2-渐增式测试方法"><a href="#2-渐增式测试方法" class="headerlink" title="2. 渐增式测试方法"></a>2. 渐增式测试方法</h3><blockquote><p>每次增加一个待测试模块，把它同已经测试好的那些模块结合起来进行测试，反复进行直到完成所有模块测试的方法。<br>使用渐增式测试方法把模块结合到软件系统中去时，有自顶向下和自底向上两种集成方法。  </p></blockquote><hr><h2 id="确认测试：Alpha和Beta测试"><a href="#确认测试：Alpha和Beta测试" class="headerlink" title="确认测试：Alpha和Beta测试"></a>确认测试：Alpha和Beta测试</h2><h3 id="Alpha测试"><a href="#Alpha测试" class="headerlink" title="Alpha测试"></a>Alpha测试</h3><blockquote><p>用户在开发者的场所进行测试，并且在开发者的指导下进行，测试在受控环境中进行，开发者记录发现的错误和问题；</p></blockquote><h3 id="Beta测试"><a href="#Beta测试" class="headerlink" title="Beta测试"></a>Beta测试</h3><blockquote><p>用户在一个或多个客户场所进行测试，不受开发者控制，测试者记录发现的问题和错误，定期将问题报告发送给开发者。</p></blockquote><hr><h2 id="白盒测试技术"><a href="#白盒测试技术" class="headerlink" title="白盒测试技术"></a>白盒测试技术</h2><h3 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1. 语句覆盖"></a>1. 语句覆盖</h3><blockquote><p>设计的测试用例能使程序中每条语句至少执行一次。</p></blockquote><h3 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2. 判定覆盖"></a>2. 判定覆盖</h3><blockquote><p>判定覆盖是指：选取足够的测试用例，使得程序中每个判断的可能结果都至少执行一次，也就是说使程序的每个判断分支至少通过一次。</p></blockquote><h3 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3. 条件覆盖"></a>3. 条件覆盖</h3><blockquote><p>条件覆盖是指：选择足够的测试用例，使得程序中每个判定表达式的每个条件都取到各种可能的结果。</p></blockquote><blockquote><p>条件覆盖通常比判定覆盖强，但是条件覆盖不一定包含判定覆盖。</p></blockquote><h3 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定/条件覆盖"></a>4. 判定/条件覆盖</h3><blockquote><p>选取足够的测试用例使得同时满足判定覆盖和条件覆盖的要求。</p></blockquote><h3 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5. 条件组合覆盖"></a>5. 条件组合覆盖</h3><blockquote><p>选取足够的测试用例，使得每个判定表达式中条件的各种可能的组合都至少出现一次。</p></blockquote><p>如果从对程序路径的覆盖程度分析，可以提出下面一些逻辑覆盖标准：</p><h3 id="6-点覆盖"><a href="#6-点覆盖" class="headerlink" title="6. 点覆盖"></a>6. 点覆盖</h3><blockquote><p>选取足够多的测试用例，使得程序执行路径至少经过程序图中每个节点一次。</p></blockquote><h3 id="7-边覆盖"><a href="#7-边覆盖" class="headerlink" title="7.  边覆盖"></a>7.  边覆盖</h3><blockquote><p>边覆盖是指：选取足够多的测试用例，使得程序执行路径至少经过程序图中每条边一次。</p></blockquote><h3 id="8-路径覆盖"><a href="#8-路径覆盖" class="headerlink" title="8. 路径覆盖"></a>8. 路径覆盖</h3><blockquote><p>路径覆盖是指：选取足够多的测试用例，使得程序的每条可能路径都至少执行一次。</p></blockquote><hr><h2 id="黑盒测试：等价划分、边界值检测和错误推测"><a href="#黑盒测试：等价划分、边界值检测和错误推测" class="headerlink" title="黑盒测试：等价划分、边界值检测和错误推测"></a>黑盒测试：等价划分、边界值检测和错误推测</h2><hr><h2 id="调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）"><a href="#调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）" class="headerlink" title="调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）"></a>调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）</h2>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>软件工程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六章 详细设计</title>
    <link href="/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1.html"/>
    <url>/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1.html</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-详细设计"><a href="#第六章-详细设计" class="headerlink" title="第六章_详细设计"></a>第六章_详细设计</h1><hr><blockquote><p><strong>概要设计说明书</strong><br>该说明书是概要实际阶段的工作成果，它应说明功能分配、模块划分、程序的总体结构、输入输出以及接口设计、运行设计、数据结构设计和出错处理设计等，为详细设计提供基础。</p></blockquote><hr><h2 id="什么是结构化程序设计？经典、扩展和修正的控制结构；"><a href="#什么是结构化程序设计？经典、扩展和修正的控制结构；" class="headerlink" title="什么是结构化程序设计？经典、扩展和修正的控制结构；"></a>什么是结构化程序设计？经典、扩展和修正的控制结构；</h2><h3 id="经典定义"><a href="#经典定义" class="headerlink" title="经典定义"></a>经典定义</h3><blockquote><p>如果一个程序的代码块仅仅通过<strong>顺序、选择和循环</strong>这三种基本控制结构进行链接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。<br><img src="/img/soft_intro_c6/3%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="3种基本的控制结构"></p></blockquote><h3 id="更全面定义"><a href="#更全面定义" class="headerlink" title="更全面定义"></a>更全面定义</h3><blockquote><p>结构程序设计是尽可能少用 GOTO 语句的程序设计方法。最好仅在检测出错误时才使用 GOTO 语句，而且应该总是使用前向 GOTO 语句。</p></blockquote><blockquote><ul><li>为了实际使用方便起见，常常还允许使用 DO-UNTIL 和 DO-CASE 两种控制结构。<br><img src="/img/soft_intro_c6/%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="其他常用的控制结构"></li><li>有时需要立即从循环（甚至嵌套的循环）中转移出来，允许使用 LEAVE（或 BREAK）结构。LEAVE 或 BREAK 结构实质上是受限制的 GOTO 语句，用于转移到循环结构后面</li></ul></blockquote><h3 id="经典的结构程序设计"><a href="#经典的结构程序设计" class="headerlink" title="经典的结构程序设计"></a>经典的结构程序设计</h3><blockquote><p>只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这三种基本控制结构；</p></blockquote><h3 id="扩展的结构程序设计"><a href="#扩展的结构程序设计" class="headerlink" title="扩展的结构程序设计"></a>扩展的结构程序设计</h3><blockquote><p>如果除了上述3中基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构；</p></blockquote><h3 id="修正的结构程序设计"><a href="#修正的结构程序设计" class="headerlink" title="修正的结构程序设计"></a>修正的结构程序设计</h3><blockquote><p>再加上允许使用LEAVE（或BREAK）结构。</p></blockquote><hr><h2 id="人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；"><a href="#人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；" class="headerlink" title="人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；"></a>人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；</h2><blockquote><ul><li>人机界面设计是接口设计的重要组成部分。对于交互式系统来说，人机界面设计和数据设计、体系结构设计及过程设计一样重要。</li><li>人机界面的设计质量，直接影响用户对软件产品的评价，从而影响软件产品的竞争力和寿命，必须对人机界面设计给予足够重视。</li></ul></blockquote><h3 id="设计人机界面过程中会遇到的4个问题"><a href="#设计人机界面过程中会遇到的4个问题" class="headerlink" title="设计人机界面过程中会遇到的4个问题:"></a>设计人机界面过程中会遇到的4个问题:</h3><h4 id="1-系统响应时间"><a href="#1-系统响应时间" class="headerlink" title="1. 系统响应时间:"></a>1. 系统响应时间:</h4><blockquote><p>系统相应时间指从用户完成某个控制动作，到软件给出预期的相应之间的这段时间。系统响应时间有两个重要属性：长度和易变性。</p><ul><li><strong>长度：</strong> 如果系统响应时间过长，用户就会感到紧张</li><li><strong>易变性：</strong> 指系统响应时间相对于平均相应时间的偏差，即使系统响应时间较长，响应时间易变性低也有助于用户建立起稳定的工作节奏。</li></ul></blockquote><h4 id="2-用户帮助设施"><a href="#2-用户帮助设施" class="headerlink" title="2. 用户帮助设施"></a>2. 用户帮助设施</h4><blockquote><p>大多数现代软件都提供联机帮助设施，用户无须离开用户界面就能解决自己的问题。常见的帮助设施可分为集成的和附加的两类。</p><ul><li><strong>集成的帮助设施</strong> 设计在软件里面，它对用户工作内容是敏感的，用户可以从与刚刚完成的操作有关的主题中选择一个请求帮助。</li><li><strong>附加的帮助设施</strong> 是在系统建成后再添加到软件中的，它实际上是一种查询能力有限的联机用户手册。</li></ul><p>集成的帮助设施优于附加的帮助设施。</p></blockquote><h4 id="3-出错信息处理"><a href="#3-出错信息处理" class="headerlink" title="3. 出错信息处理"></a>3. 出错信息处理</h4><blockquote><p>出错信息和警告信息，是出现问题时交互式系统给出的“坏消息”。</p></blockquote><h4 id="4-命令交互"><a href="#4-命令交互" class="headerlink" title="4. 命令交互"></a>4. 命令交互</h4><blockquote><p>多数情况下，用户既可以从菜单中选择软件功能，也可以通过键盘命令序列调用软件功能。<br>在理想的情况下，所有应用软件都有一致的命令使用方法。</p></blockquote><hr><h2 id="过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树"><a href="#过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树" class="headerlink" title="过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树"></a>过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树</h2><blockquote><ul><li>定义：描述程序处理工程的工具</li><li>分类：图形、表格和语言</li><li>基本要求：不论是哪类工具，<strong>对它们的基本要求都是能提供对设计的无歧义的描述，</strong> 也就是应该指明控制流程、处理功能、数据组织以及其他方面的实现细节，从而在编码阶段能把对设计的描述直接翻译成程序代码。</li></ul></blockquote><h3 id="1-程序流程图"><a href="#1-程序流程图" class="headerlink" title="1. 程序流程图"></a>1. 程序流程图</h3><blockquote><ul><li>程序流程图又称为程序框图，它是历史最悠久、使用最广泛的描述过程设计的方法。</li><li>它的主要优点是对控制流程的描绘很直观，便于初学者掌握。</li><li>程序流程图历史悠久，至今仍在广泛使用着。</li></ul></blockquote><h4 id="程序流程图的符号"><a href="#程序流程图的符号" class="headerlink" title="程序流程图的符号"></a>程序流程图的符号</h4><blockquote><p><img src="/img/soft_intro_c6/%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%AC%A6%E5%8F%B7.png" alt="程序流程图符号"></p></blockquote><h4 id="程序流程图的主要缺点："><a href="#程序流程图的主要缺点：" class="headerlink" title="程序流程图的主要缺点："></a>程序流程图的主要缺点：</h4><blockquote><ul><li>程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。</li><li>程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。</li><li>程序流程图不易表示数据结构。</li></ul></blockquote><h3 id="2-盒图（N-S图）"><a href="#2-盒图（N-S图）" class="headerlink" title="2. 盒图（N-S图）"></a>2. 盒图（N-S图）</h3><h4 id="盒图的特点："><a href="#盒图的特点：" class="headerlink" title="盒图的特点："></a>盒图的特点：</h4><blockquote><ul><li>功能域明确。</li><li>不可能任意转移控制。</li><li>很容易确定局部和全称数据的作用域。</li><li>很容易表示嵌套关系，也可以表示模块的层次结构。</li></ul></blockquote><h4 id="盒图的基本符号"><a href="#盒图的基本符号" class="headerlink" title="盒图的基本符号:"></a>盒图的基本符号:</h4><blockquote><p><img src="/img/soft_intro_c6/%E7%9B%92%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7.png" alt="盒图的基本符号"><br>(a) 顺序；(b) IF_THEN_ELSE型分支；(c) CASE型多分支；(d) 循环；(e) 调用子程序 A</p></blockquote><h3 id="3-PAD图"><a href="#3-PAD图" class="headerlink" title="3. PAD图"></a>3. PAD图</h3><blockquote><ul><li>PAD是问题分析图(problem analysis diagram)的英文缩写，自1973年由日本日立公司发明以后，已得到一定程度的推广。</li><li>它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易。</li></ul></blockquote><h4 id="PAD图的基本符号："><a href="#PAD图的基本符号：" class="headerlink" title="PAD图的基本符号："></a>PAD图的基本符号：</h4><blockquote><p><img src="/img/soft_intro_c6/PAD%E5%9B%BE%E7%AC%A6%E5%8F%B7.png" alt="PAD图的基本符号"><br>(a)顺序（先执行P1后执行P2）；(b)选择（IF C THEN P1 ELSE P2）；(c)CASE型多分支(d)WHILE型循环（WHILE C DO P）；(e)UNTIL型循环（REPEAT P UNTIL C）;(f)语句标号；(g)定义</p></blockquote><h4 id="PAD图的主要优点："><a href="#PAD图的主要优点：" class="headerlink" title="PAD图的主要优点："></a>PAD图的主要优点：</h4><blockquote><ul><li>使用表示结构化控制结构的PAD符号设计出来的程序必然是结构化程序。</li><li>PAD图所描绘的程序结构十分清晰。</li><li>PAD图表现程序逻辑易读、易懂、易记。</li><li>容易将PAD图转换成高级语言源程序，这种转换可用软件工具自动完成。</li><li>既可表示程序逻辑，也可描绘数据结构。</li><li>PAD图的符号支持自顶向下、逐步求精方法的使用。</li></ul></blockquote><blockquote><p>使用PAD提供的定义功能来逐步求精的例子<br><img src="/img/soft_intro_c6/PAD_%E9%80%90%E6%AD%A5%E6%B1%82%E7%B2%BE.png" alt="使用PAD提供的定义功能逐步求精_例"></p></blockquote><h3 id="4-判定表"><a href="#4-判定表" class="headerlink" title="4. 判定表"></a>4. 判定表</h3><blockquote><ul><li>当算法中包含 <strong>多重嵌套的条件选择</strong> 时，用程序流程图、盒图、PAD图或后面即将介绍的过程设计语言（PDL）都不易清楚地描述。</li><li>判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。</li></ul></blockquote><h4 id="判定表组成（4部分）"><a href="#判定表组成（4部分）" class="headerlink" title="判定表组成（4部分）"></a>判定表组成（4部分）</h4><blockquote><ul><li>左上部列出所有条件；</li><li>左下部是所有可能做的动作；</li><li>右上部是表示各种条件组合的一个矩阵；</li><li>右下部是和每种条件组合相对应的动作。</li></ul><p><img src="/img/soft_intro_c6/%E5%88%A4%E5%AE%9A%E8%A1%A8%E7%BB%84%E6%88%90.png" alt="判定表组成"></p></blockquote><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><blockquote><p>能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p></blockquote><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><ul><li>判定表的含义不是一眼就能看出来的，初次接触这种工具的人理解它需要有一个简短的学习过程。</li><li>当数据元素的值多于两个时，判定表的简洁程度也将下降。</li></ul></blockquote><h3 id="5-判定树"><a href="#5-判定树" class="headerlink" title="5. 判定树"></a>5. 判定树</h3><blockquote><ul><li>判定树是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</li><li>多年来判定树一直受到人们的重视，是一种比较常用的系统分析和设计的工具。</li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c6/%E5%88%A4%E5%AE%9A%E6%A0%91%E4%BE%8B%E5%AD%90.png" alt="判定树例子"></p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><blockquote><p>形式简单，一眼就可以看出其含义，因此易于掌握和使用。</p></blockquote><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><ul><li>简洁性不如判定表，数据元素的同一个值往往要重复写多遍，而且越接近树的叶端重复次数越多。</li><li>画判定树时分枝的次序可能对最终画出的判定树的简洁程度有较大影响。</li></ul></blockquote><h3 id="6-过程设计语言"><a href="#6-过程设计语言" class="headerlink" title="6. 过程设计语言"></a>6. 过程设计语言</h3><hr><h2 id="过程设计语言（PDL）：伪码"><a href="#过程设计语言（PDL）：伪码" class="headerlink" title="过程设计语言（PDL）：伪码"></a>过程设计语言（PDL）：伪码</h2><blockquote><ul><li>过程设计语言(PDL)也称为伪码，它是用正文形式表示数据和处理过程的设计工具。</li><li>PDL具有严格的关键字外部语法，用于定义控制结构和数据结构；另一方面，PDL表示实际操作和条件的内部语法通常又是灵活自由的，可以适应各种工程项目的需要。</li><li>PDL是一种“混杂”语言，它使用一种语言的词汇，同时却使用另一种语言的语法。 </li></ul></blockquote><h3 id="伪代码的基本控制结构："><a href="#伪代码的基本控制结构：" class="headerlink" title="伪代码的基本控制结构："></a>伪代码的基本控制结构：</h3><blockquote><ul><li>简单陈述句结构：避免复合语句。</li><li>判定结构：IF_THEN_ELSE 或 CASE_OF 结构。</li><li>选择结构：WHILE_DO或REPEAT_UNTIL 结构</li></ul></blockquote><h3 id="PDL的特点："><a href="#PDL的特点：" class="headerlink" title="PDL的特点："></a>PDL的特点：</h3><blockquote><ol><li>关键字的固定用法，它提供了结构化控制结构、数据说明和模块化的特点。</li><li>自然语言的自由语言，它描绘处理特点。</li><li>数据说明的手段。应该既包括简单的数据结构，又包括复杂的数据结构。</li><li>模块定义和调用的技术，应该提供各种接口描述模式。</li></ol></blockquote><h3 id="PDL的优点："><a href="#PDL的优点：" class="headerlink" title="PDL的优点："></a>PDL的优点：</h3><blockquote><ul><li>可以作为注释直接插在源程序中间。有助于保持文档和程序的一致性，提高了文档的质量。</li><li>可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的书写和编辑工作。</li><li>已经有自动处理程序存在，并且可以自动由PDL生成代码。</li></ul></blockquote><h3 id="PDL的缺点："><a href="#PDL的缺点：" class="headerlink" title="PDL的缺点："></a>PDL的缺点：</h3><blockquote><p>不如图形工具直观，描述复杂的条件组合与动作间的对应关系时，不如判定表清晰简单。</p></blockquote><hr><h2 id="面向数据结构的设计方法-Jackson图，和步骤"><a href="#面向数据结构的设计方法-Jackson图，和步骤" class="headerlink" title="面向数据结构的设计方法-Jackson图，和步骤"></a>面向数据结构的设计方法-Jackson图，和步骤</h2><ul><li>数据结构既影响程序的结构又影响程序的处理过程<ul><li>重复出现的数据通常由具有循环控制结构的程序来处理</li><li>选择数据要用带有分支控制结构的程序来处理</li><li>层次的数据组织通常和使用这些数据的程序的层次结构十分相似。</li></ul></li><li>面向数据结构的设计方法的最终目标是得出对程序处理过程的描述。</li></ul><h3 id="Jackson图"><a href="#Jackson图" class="headerlink" title="Jackson图"></a>Jackson图</h3><h4 id="数据结构中数据元素彼此间的逻辑关系："><a href="#数据结构中数据元素彼此间的逻辑关系：" class="headerlink" title="数据结构中数据元素彼此间的逻辑关系："></a>数据结构中数据元素彼此间的逻辑关系：</h4><blockquote><ul><li><p>顺序结构，顺序结构的数据由一个或多个数据元素组成，每个元素按确定次序出现一次。<br><img src="/img/soft_intro_c6/Jackson%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84.png" alt="顺序结构"></p></li><li><p>选择结构，选择结构的数据包含两个或多个元素，每次使用这个数据时按一定条件从这些数据元素中选择一个。<br><img src="/img/soft_intro_c6/Jackson%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84.png" alt="选择结构"></p></li><li><p>重复结构，重复结构的数据，根据使用时的条件由一个数据元素出现零次或多次构成。<br><img src="/img/soft_intro_c6/Jackson%E9%87%8D%E5%A4%8D%E7%BB%93%E6%9E%84.png" alt="重复结构"></p></li></ul></blockquote><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><blockquote><ul><li>便于表示层次结构，而且是对结构进行自顶向下分解的有力工具；</li><li>形象直观可读性好；</li><li>技能表示数据结构也能表示程序结构。</li></ul></blockquote><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><p>表示选择或重复结构时，选择条件或循环结束条件不能直接在图上表示出来，影响了图的表达能力，也不易直接把图翻译成程序；<br>框间连线为斜线，不易在行式打印机上输出。</p></blockquote><h3 id="改进的Jackson图"><a href="#改进的Jackson图" class="headerlink" title="改进的Jackson图"></a>改进的Jackson图</h3><blockquote><p><img src="/img/soft_intro_c6/%E6%94%B9%E8%BF%9B%E7%9A%84Jackson%E5%9B%BE.png" alt="改进的Jackson图"><br>(a) 顺序结构，B、C、D中任一个都不能是选择出现或重复出现的数据元素（即不能是右上角有小圆圈或星号标记的元素；<br>(b) 选择结构，S 右面括号中的数字 i 是分支条件的编号；<br>(c) 可选结构，A 或者是元素 B 或者不出现（可选结构是选择结构的一种常见的特殊形式）；<br>(d) 重复结构，循环结束条件的编号为 i 。</p></blockquote><h3 id="Jackson程序设计方法由5个步骤组成："><a href="#Jackson程序设计方法由5个步骤组成：" class="headerlink" title="Jackson程序设计方法由5个步骤组成："></a>Jackson程序设计方法由5个步骤组成：</h3><ol><li><p>分析并确定输入数据和输出数据的逻辑结构，用 Jackson 图描绘数据结构。</p></li><li><p>找出输入数据结构和输出数据结构中有对应关系的数据单元。所谓有对应关系是指有直接的因果关系，在程序中可以同时处理的数据单元（对于重复出现的数据单元必须重复的次序和次序都相同才可能有对应关系）。</p></li><li><p>用下述规则从描绘数据结构的 Jackson 图导出描绘程序结构的 Jackson 图：</p><blockquote><ul><li>第一，为每对有对应关系的数据单元，按照它们在数据结构图中的层次在程序结构图的相应层次画一个处理框(层次不同时与图中层次低的那个对应)；</li><li>第二，根据输入数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框；</li><li>第三，根据输出数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。</li><li>改进的Jackson图规定在构成顺序结构的元素中不能有重复出现或选择出现的元素，因此可能需要增加中间层次的处理框。</li></ul></blockquote></li><li><p>列出所有操作和条件（包括分支条件和循环结束条件），并且把它们分配到程序结构图的适当位置。</p></li><li><p>用伪码表示程序。</p></li></ol><blockquote><table><thead><tr><th align="center">顺序结构</th><th align="left">选择结构</th><th align="left">循环结构</th></tr></thead><tbody><tr><td align="center">A seq</br>B</br>C</br>D</br>A end</td><td align="left">A select cond1</br>$\quad$B</br>A or cond2</br>$\quad$C</br>A or cond3</br>$\quad$D</br>A end</td><td align="left">A iter until(或while) cond</br>$\quad$B</br>A end$\quad$</td></tr></tbody></table></blockquote><h3 id="设计步骤如下："><a href="#设计步骤如下：" class="headerlink" title="设计步骤如下："></a>设计步骤如下：</h3><ol><li>用Jackson图描绘的输入输出结构。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="输入输出结构"></p></blockquote><ol start="2"><li>分析确定在输入数据结构和输出数据结构中有对应关系的数据单元。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83.png" alt="对应关系的数据单元"></p></blockquote><ol start="3"><li>从数据结构图导出程序结构图。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="从数据结构图导出程序结构图"></p></blockquote><ol start="4"><li>列出所有操作和条件，并且把它们分配到程序结构图的适当位置。</li></ol><blockquote><p><img src="/img/soft_intro_c6/%E6%93%8D%E4%BD%9C%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%88%86%E6%95%A3%E5%88%B0%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%9B%BE%E9%80%82%E5%BD%93%E7%9A%84%E4%BD%8D%E7%BD%AE.png"></p></blockquote><ol start="5"><li>用伪码表示程序处理程序。</li></ol><hr><h2 id="Jackson、层次图和层次方框图的区别"><a href="#Jackson、层次图和层次方框图的区别" class="headerlink" title="Jackson、层次图和层次方框图的区别"></a>Jackson、层次图和层次方框图的区别</h2><blockquote><table><thead><tr><th align="center"></th><th align="center">Jackson图</th><th align="center">层次图</th><th align="center">层次方框图</th></tr></thead><tbody><tr><td align="center">作用</td><td align="center">1. 描述数据结构</br>2. 描绘程序结构</td><td align="center">描绘软件结构</td><td align="center">描绘数据结构</td></tr><tr><td align="center">矩形框</td><td align="center">1. 数据结构</br>2. 几个语句</td><td align="center">模块</td><td align="center">数据元素</td></tr><tr><td align="center">连线</td><td align="center">组成关系</td><td align="center">调用关系</td><td align="center">组成关系</td></tr></tbody></table></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>软件工程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第五章_总体设计</title>
    <link href="/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1.html"/>
    <url>/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1.html</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-总体设计"><a href="#第五章-总体设计" class="headerlink" title="第五章_总体设计"></a>第五章_总体设计</h1><p>总体设计/概要设计基本目的：“系统如何实现”</p><ol><li>划分组成系统的物理元素</li><li>设计软件的结构，确定模块构成和之间的联系</li></ol><hr><h3 id="1-设计过程由两个主要阶段组成（9个步骤）"><a href="#1-设计过程由两个主要阶段组成（9个步骤）" class="headerlink" title="1. 设计过程由两个主要阶段组成（9个步骤）"></a>1. 设计过程由两个主要阶段组成（9个步骤）</h3><h4 id="系统设计阶段，确定系统的具体实现方案"><a href="#系统设计阶段，确定系统的具体实现方案" class="headerlink" title="系统设计阶段，确定系统的具体实现方案"></a>系统设计阶段，确定系统的具体实现方案</h4><ol><li><p>设想供选择的方案</p><blockquote><p>根据需求分析阶段得出的数据流图考虑各种可能的实现方案，力求从中选出最佳方案。</p></blockquote></li><li><p>选取合理的方案</p><blockquote><p>从前一步得到的一系列供选择的方案中选取若干个合理的方案。对每个合理的方案分析员都应该准备下列4份资料：</p><ol><li>系统流程图；</li><li>组成系统的物理元素清单；</li><li>成本/效益分析；</li><li>实现这个系统的进度计划。</li></ol></blockquote></li><li><p>推荐最佳方案</p><blockquote><p>分析员应该综合对比各种合理方案的利弊,推荐一个最佳的方案, 并且为推荐的方案制定详细地实现计划。</p></blockquote></li></ol><h4 id="结构设计阶段，确定软件结构"><a href="#结构设计阶段，确定软件结构" class="headerlink" title="结构设计阶段，确定软件结构"></a>结构设计阶段，确定软件结构</h4><ol start="4"><li><p>功能分解</p><blockquote><p>首先进行结构设计，然后进行过程设计。</p><ul><li>结构设计确定程序由哪些模块组成, 以及这些模块之间的关系；$\quad$过程设计 确定每个模块的处理过程。</li><li>结构设计是总体设计阶段的任务,$\quad$过程设计是详细设计阶段的任务。</li></ul></blockquote></li><li><p>设计软件的结构</p><blockquote><ul><li>通常程序中的一个模块完成一个适当的子功能。应该把模块组织成良好的层次系统。软件结构可以用层次图或结构图来描绘。</li><li>如果数据流图已经细化到适当的层次，则可以直接从数据流图映射出软件结构，这就是面向数据流的设计方法。</li></ul></blockquote></li><li><p>设计数据库</p><blockquote><p>对于需要使用数据库的那些应用系统，软件工程师应该在需求分析阶段所确定的系统数据需求的基础上，进一步设计数据库。</p></blockquote></li><li><p>制定测试计划</p><blockquote><p>在软件开发的早期阶段考虑测试问题，能促使软件设计人员在设计时注意提高软件的可测试性。</p></blockquote></li><li><p>书写文档</p><blockquote><p>应该用正式的稳定记录总体设计的结果，在这个阶段应该完成的文档通常有下述几种：</p><ol><li>系统说明；</li><li>用户手册；</li><li>测试计划；</li><li>详细的实现计划；</li><li>数据库设计结果；</li></ol></blockquote></li><li><p>审查和复审</p><blockquote><p>最后应该对总体设计的结果进行严格的技术审查和管理复审。</p></blockquote></li></ol><hr><h3 id="2-设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）"><a href="#2-设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）" class="headerlink" title="2. 设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）"></a>2. 设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）</h3><h4 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1. 模块化"></a>1. 模块化</h4><blockquote><ul><li>模块：由边界元素限定的相邻程序元素的序列，还有一个总体标识符代表</li><li>模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。</li></ul></blockquote><blockquote><p>为什么要模块化?</p><ul><li>使一个复杂的大型程序能被人的智力所管理,软件应该具备的唯一属性。</li><li>如果一个大型程序仅由一个模块组成，它将很难被人所理解。</li></ul></blockquote><blockquote><p>决定模块效率化的因素:</p><ol><li>模块的数量；</li><li>模块之间的接口；</li></ol></blockquote><blockquote><p><strong>评价一种设计方法定义模块能力的五条标准:</strong></p><ul><li>模块可分解性</li><li>模块可组装性</li><li>模块可理解性</li><li>模块连续性</li><li>模块保护性</li></ul></blockquote><blockquote><p><strong>模块化的作用:</strong></p><ul><li>采用模块化原理可以使软件结构清晰,不仅容易设计也容易阅读和理解。</li><li>模块化使软件容易测试和调试, 因而有助于提高软件的可靠性。</li><li>模块化能够提高软件的可修改性。</li><li>模块化也有助于软件开发工程的组织管理。</li></ul></blockquote><h4 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2. 抽象"></a>2. 抽象</h4><blockquote><ul><li><strong>抽象:</strong> 现实世界中一定事物、状态或过程之间总存在着某些相似的方面(共性)。把这些相似的方面集中和概括起来，暂时忽略它们之间的差异，这就是抽象。</li><li>抽象就是抽出事物本质特性而暂时不考虑细节。</li></ul></blockquote><blockquote><p><strong>一般抽象过程:</strong></p><ul><li>处理复杂系统的惟一有效的方法是用层次的方式构造和分析它。</li><li>一个复杂的动态系统首先可以用一些高级的抽象概念构造和理解，这些高级概念又可以用一些较低级的概念构造和理解，如此进行下去，直至最低层次的具体元素。</li><li>例：过程抽象、数据抽象</li></ul></blockquote><blockquote><p>软件工程抽象过程: 软件工程过程的每一步都是对软件解法的抽象层次的一次精化。</p><ul><li>在可行性研究阶段，软件作为系统的一个完整部件；</li><li>在需求分析期间，软件解法是使用在问题环境内熟悉的方式描述的；</li><li>当由总体设计向详细设计过渡时，抽象的程度也就随之减少了；</li><li>最后，当源程序写出来以后，也就达到了抽象的最低层。</li></ul></blockquote><h4 id="3-逐步求精"><a href="#3-逐步求精" class="headerlink" title="3. 逐步求精"></a>3. 逐步求精</h4><blockquote><p>为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。逐步求精是人类解决复杂问题时采用的基本方法，也是许多软件工程技术的基础。</p></blockquote><blockquote><p><strong>作用:</strong></p><ul><li>帮助软件工程师把精力集中在与当前开发阶段最相关的那些方面上，而忽略那些对整体解决方案来说虽然是必要的，然而目前还不需要考虑的细节。</li><li>确保每个问题都将被解决，而且每个问题都将在适当的时候被解决，但是，在任何时候一个人都不需要同时处理7个以上知识块。</li></ul></blockquote><h4 id="4-信息隐藏和局部化"><a href="#4-信息隐藏和局部化" class="headerlink" title="4. 信息隐藏和局部化"></a>4. 信息隐藏和局部化</h4><blockquote><ul><li><strong>信息隐藏:</strong> 应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。</li><li><strong>局部化:</strong> 局部化的概念和信息隐藏概念是密切相关的。所谓局部化是指把一些关系密切的软件元素物理地放得彼此靠近。显然，局部化有助于实现信息隐藏。</li></ul></blockquote><blockquote><p><strong>信息隐藏和局部化的作用:</strong></p><ul><li>“隐藏”意味着有效的模块化可以通过定义一组独立的模块而实现，这些独立的模块彼此间仅仅交换那些为了完成系统功能而必须交换的信息。</li><li>使用信息隐藏原理作为模块化系统设计的标准就会带来极大好处。因为绝大多数数据和过程对于软件的其他部分而言是隐藏的，在修改期间由于疏忽而引入的错误就很少可能传播到软件的其他部分。</li></ul></blockquote><h4 id="5-模块独立"><a href="#5-模块独立" class="headerlink" title="5. 模块独立"></a>5. 模块独立</h4><blockquote><p>模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果。<br>希望这样设计软件结构，使得每个模块完成一个相对独立的特定子功能，并且和其他模块之间的关系很简单。</p></blockquote><blockquote><ul><li>重要性:<ul><li>有效的模块化的软件比较容易开发出来。</li><li>独立的模块比较容易测试和维护。</li></ul></li></ul></blockquote><blockquote><ul><li><strong>模块独立程度的两个定性标准度量:</strong><ul><li><strong>耦合</strong>衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低，即每个模块和其他模块之间的关系要简单；</li><li><strong>内聚</strong>衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高，每个模块完成一个相对独立的子功能。</li></ul></li></ul></blockquote><h5 id="1-耦合"><a href="#1-耦合" class="headerlink" title="1. 耦合"></a>1. 耦合</h5><blockquote><ul><li>耦合:是对一个软件结构内不同模块之间互连程度的度量。</li><li>要求：在软件设计中应该追求尽可能松散耦合的系统。</li><li>可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解；</li><li>模块间联系简单，发生在一处的错误传播到整个系统的可能性很小；</li><li>模块间的耦合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性。</li></ul></blockquote><h6 id="耦合程度的度量"><a href="#耦合程度的度量" class="headerlink" title="耦合程度的度量"></a>耦合程度的度量</h6><blockquote><ol><li>非直接耦合/完全独立(no direct coupling)</li></ol><blockquote><p>如果两个模块中的每一个都能独立地工作而不需要另一个模块的存在，那么它们完全独立。在一个软件系统中不可能所有模块之间都没有任何连接。</p></blockquote><ol start="2"><li>数据耦合(data coupling)</li></ol><blockquote><p>如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。</p></blockquote><blockquote><p>评价:</p><ul><li>系统中至少必须存在这种耦合。一般说来，一个系统内可以只包含数据耦合。$\qquad$数据耦合是理想的目标。</li><li>维护更容易，对一个模块的修改不会是另一个模块产生退化错误。</li></ul></blockquote><ol start="3"><li>控制耦合(control coupling)</li></ol><blockquote><p>如果两个模块彼此间传递的信息中有控制信息，这种耦合成为控制耦合。</p></blockquote><blockquote><p><strong>评价:</strong></p><ul><li>控制耦合往往是多余的,把模块适当分解之后通常可以用数据耦合代替它。</li><li>被调用的模块需知道调用模块的内部结构和逻辑，降低了重用的可能性。</li></ul></blockquote><ol start="4"><li>特征耦合(stamp coupling)</li></ol><blockquote><p>当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。<br>评价：</p></blockquote><blockquote><p>被调用的模块可使用的数据多于它确实需要的数据，这将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。<br>无论何时把指针作为参数进行传递，都应该仔细检查该耦合。</p></blockquote><ol start="5"><li>公共环境耦合(common coupling)<blockquote><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等等。</p></blockquote></li></ol><blockquote><p>类型:<br><img src="/img/soft_intro_c5/%E5%85%AC%E5%85%B1%E7%8E%AF%E5%A2%83%E8%80%A6%E5%90%88.png" alt="公共环境耦合的两种类型"></p><ul><li>一个模块往公告环境送数据,另一个模块从公共环境取数据。数据耦合的一种形式，是比较松散的耦合。</li><li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li></ul></blockquote><ol start="6"><li>内容耦合(content coupling)</li></ol><blockquote><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合：</p><ul><li>一个模块访问另一个模块的内部数据；</li><li>一个模块不通过正常入口转到另一个模块的内部；</li><li>两个模块有一部分程序代码重叠；</li><li>一个模块有多个入口。</li></ul></blockquote></blockquote><blockquote><p>耦合是影响软件复杂程度的一个重要因素。</p></blockquote><blockquote><p>应该采取下述设计原则:</p><ul><li><strong>尽量使用数据耦合，</strong></li><li><strong>少用控制耦合和特征耦合，</strong></li><li><strong>限制公共环境耦合的范围，</strong></li><li><strong>完全不用内容耦合。</strong></li></ul></blockquote><h5 id="2-内聚"><a href="#2-内聚" class="headerlink" title="2. 内聚"></a>2. 内聚</h5><blockquote><ul><li>内聚: 标志一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。简单地说，理想内聚的模块只做一件事情。</li><li>要求:设计时应该力求做到高内聚，通常中等程度的内聚也是可以采用的，而且效果和高内聚相差不多；但是，低内聚不要使用。</li><li>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。</li></ul></blockquote><h6 id="内聚程度的度量"><a href="#内聚程度的度量" class="headerlink" title="内聚程度的度量"></a>内聚程度的度量</h6><ol><li>偶然内聚(coincidental cohesion)————低内聚</li></ol><blockquote><p>如果一个模块完成一组任务,  这些任务彼此间即使有关系, 关系也是很松散的, 就叫做偶然内聚。<br><img src="/img/soft_intro_c5/%E5%81%B6%E7%84%B6%E5%86%85%E8%81%9A.png" alt="偶然内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>模块内各元素之间没有实质性联系，很可能在一种应用场合需要修改这个模块，在另一种应用场合又不允许这种修改，从而陷入困境；</li><li>可理解性差，可维护性产生退化；</li><li>模块是不可重用的。</li></ul></blockquote><blockquote><p>解决方案:将模块分成更小的模块, 每个小模块执行一个操作。</p></blockquote><ol start="2"><li>逻辑内聚（logical cohesion）————低内聚</li></ol><blockquote><p>如果一个模块完成的任务在逻辑上属于相同或相似的一类，则称为逻辑内聚。<br><img src="/img/soft_intro_c5/%E9%80%BB%E8%BE%91%E5%86%85%E8%81%9A.png" alt="逻辑内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>接口难以理解, 造成整体上不易理解；</li><li>完成多个操作的代码互相纠缠在一起，即使局部功能的修改有时也会影响全局，导致严重的维护问题；</li><li>难以重用。</li></ul></blockquote><blockquote><p>解决方案: 模块分解。<br><img src="/img/soft_intro_c5/%E6%A8%A1%E5%9D%97%E5%88%86%E8%A7%A3.png" alt="模块分解示意"></p></blockquote><ol start="3"><li>时间内聚(temporal cohesion)————低内聚</li></ol><blockquote><p>如果一个模块包含的任务必须在同一段时间内执行，就叫时间内聚。<br><img src="/img/soft_intro_c5/%E6%97%B6%E9%97%B4%E5%86%85%E8%81%9A.png" alt="时间内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>时间关系在一定程度上反映了程序某些实质，所以时间内聚比逻辑内聚好一些。</li><li>模块内操作之间的关系很弱，与其他模块的操作却有很强的关联。</li><li>时间内聚的模块不太可能重用。</li></ul></blockquote><ol start="4"><li>过程内聚(procedural cohesion)</li></ol><blockquote><ul><li>如果一个模块内的处理元素是相关的，而且必须以特定次序执行，则称为过程内聚。</li><li>使用程序流程图作为工具设计软件时，常常通过研究流程图确定模块的划分，这样得到的往往是过程内聚的模块。</li></ul></blockquote><blockquote><p>评价:</p><ul><li>比时间内聚好，至少操作之间是过程关联的。</li><li>仍是弱连接，不太可能重用模块。</li></ul></blockquote><blockquote><p>解决方案：分割为单独的模块，每个模块执行一个操作</p></blockquote><ol start="5"><li>通信内聚（communicational cohesion）</li></ol><blockquote><p>如果模块中所有元素都使用同一个输入数据和(或)产生同一个输出数据，则称为通信内聚。即在同一个数据结构上操作。</p></blockquote><blockquote><p>评价：模块中各操作紧密相连，比过程内聚更好。不能重用。</p></blockquote><blockquote><p>解决方案：分成多个模块，每个模块执行一个操作。</p></blockquote><ol start="6"><li>顺序内聚(sequential cohesion)</li></ol><blockquote><p>如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。</p></blockquote><blockquote><p>评价：根据数据流图划分模块时，通常得到顺序内聚的模块，这种模块彼此间的连接往往比较简单。</p></blockquote><ol start="7"><li>功能内聚(functional cohesion)</li></ol><blockquote><p>如果模块内所有处理元素属于一个整体，完成一个单一的功能，则称为功能内聚。功能内聚是最高程度的内聚。</p></blockquote><blockquote><p>评价：</p><ul><li>模块可重用，应尽可能重用；</li><li>可隔离错误，维护更容易；</li><li>扩充产品功能时更容易。</li></ul></blockquote><h6 id="七种内聚的优劣评分结果"><a href="#七种内聚的优劣评分结果" class="headerlink" title="七种内聚的优劣评分结果"></a>七种内聚的优劣评分结果</h6><blockquote><table><thead><tr><th align="center"></th><th align="center">类型</th><th align="center">分数</th></tr></thead><tbody><tr><td align="center"><strong>高内聚</strong></td><td align="center"><strong>功能内聚</strong></td><td align="center"><strong>10分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>顺序内聚</strong></td><td align="center"><strong>9分</strong></td></tr><tr><td align="center"><strong>中内聚</strong></td><td align="center"><strong>通信内聚</strong></td><td align="center"><strong>7分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>过程内聚</strong></td><td align="center"><strong>5分</strong></td></tr><tr><td align="center"><strong>低内聚</strong></td><td align="center"><strong>时间内聚</strong></td><td align="center"><strong>3分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>逻辑内聚</strong></td><td align="center"><strong>1分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>偶然内聚</strong></td><td align="center"><strong>0分</strong></td></tr></tbody></table><p>设计时力争做到高内聚，并且能够辨认出低内聚的模块。</p></blockquote><hr><h3 id="3-启发准则"><a href="#3-启发准则" class="headerlink" title="3. 启发准则"></a>3. 启发准则</h3><h4 id="1-改进软件结构提高模块独立性"><a href="#1-改进软件结构提高模块独立性" class="headerlink" title="1. 改进软件结构提高模块独立性"></a>1. 改进软件结构提高模块独立性</h4><blockquote><p>通过模块分解或合并，降低耦合提高内聚。<br>两个方面：</p><blockquote><ul><li>模块功能完善化。 一个完整的模块包含：<ul><li>执行规定的功能的部分</li><li>出错处理的部分</li><li>返回一个”结束标志”</li></ul></li><li>消除重复功能, 改善软件结构。</li></ul></blockquote></blockquote><h4 id="2-模块规模应该适中"><a href="#2-模块规模应该适中" class="headerlink" title="2. 模块规模应该适中"></a>2. 模块规模应该适中</h4><blockquote><ul><li>经验表明，一个模块的规模不应过大，最好能写在一页纸内。通常规定50~100行语句，最多不超过500行。数字只能作为参考，根本问题是要保证模块的独立性。</li><li>过大的模块往往是由于分解不充分，但是进一步分解必须符合问题结构，一般说来，分解后不应该降低模块独立性。</li><li>过小的模块开销大于有效操作，而且模块数目过多将使系统接口复杂。</li></ul></blockquote><h4 id="3-深度、宽度、扇出和扇入都应适当"><a href="#3-深度、宽度、扇出和扇入都应适当" class="headerlink" title="3. 深度、宽度、扇出和扇入都应适当"></a>3. 深度、宽度、扇出和扇入都应适当</h4><blockquote><p><strong>深度：</strong> 软件结构中控制的层数，它往往能粗略地标志一个系统的大小和复杂程度。<br><strong>宽度：</strong> 软件结构内同一个层次上的模块总数的最大值。<br><strong>扇出：</strong> 一个模块直接控制（调用）的模块数目。<br><strong>扇入：</strong> 有多少个上级模块直接调用它。<br><img src="/img/soft_intro_c5/%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="软件结构"><br><img src="/img/soft_intro_c5/%E6%89%87%E5%87%BA%E6%89%87%E5%85%A5%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%E6%83%85%E5%86%B5.png" alt="不好的情况"></p></blockquote><h4 id="4-模块的作用域应该在控制域之内"><a href="#4-模块的作用域应该在控制域之内" class="headerlink" title="4. 模块的作用域应该在控制域之内"></a>4. 模块的作用域应该在控制域之内</h4><blockquote><ul><li><strong>模块的作用域：</strong> 定义为受该模块内一个判定影响的所有模块的集合。</li><li><strong>模块的控制域：</strong> 这个模块本身以及所有直接或间接从属于它的模块的集合。</li><li>在一个设计得很好的系统中，所有受判定影响的模块应该都从属于做出判定的那个模块，最好局限于做出判定的那个模块本身及它的直属下级模块。</li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E8%BF%9D%E5%8F%8D%E8%A7%84%E5%88%99%E7%9A%84%E6%83%85%E5%86%B5.png" alt="违反规则的情况"><br><strong>解决方案:</strong></p><ul><li>把模块 A 中的判定移到模块 M 中；</li><li>把模块 G 移到模块A下面，作为它的下级模块。</li></ul><p><img src="/img/soft_intro_c5/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="解决方案"></p></blockquote><h4 id="5-力争降低模块接口的复杂程度"><a href="#5-力争降低模块接口的复杂程度" class="headerlink" title="5. 力争降低模块接口的复杂程度"></a>5. 力争降低模块接口的复杂程度</h4><blockquote><p>模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。</p></blockquote><p><strong>例:解一元二次方程的函数</strong></p><ul><li><input disabled="" type="checkbox"> <strong>QUAD_ROOT(TBL, X)</strong><blockquote><ul><li>其中数组 TBL 传送方程的系数</li><li>数组 X 送回求得的根  </li></ul></blockquote></li><li><input checked="" disabled="" type="checkbox"> <strong>QUAD_ROOT(A, B, C, ROOT1, ROOT2)</strong></li></ul><h4 id="6-设计单入口单出口的模块"><a href="#6-设计单入口单出口的模块" class="headerlink" title="6. 设计单入口单出口的模块"></a>6. 设计单入口单出口的模块</h4><blockquote><p>警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。</p></blockquote><h4 id="7-模块功能应该可以预测"><a href="#7-模块功能应该可以预测" class="headerlink" title="7. 模块功能应该可以预测"></a>7. 模块功能应该可以预测</h4><blockquote><ul><li>模块的功能应该能够预测，但也要防止模块功能过分局限。</li><li>功能可预测：如果一个模块可以当做一个黑盒子，只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。</li></ul></blockquote><hr><h3 id="4-软件结构的图形工具：层次图（H图）、HIPO图、结构图"><a href="#4-软件结构的图形工具：层次图（H图）、HIPO图、结构图" class="headerlink" title="4. 软件结构的图形工具：层次图（H图）、HIPO图、结构图"></a>4. 软件结构的图形工具：层次图（H图）、HIPO图、结构图</h3><h4 id="1-层次图-H图"><a href="#1-层次图-H图" class="headerlink" title="1. 层次图(H图)"></a>1. 层次图(H图)</h4><blockquote><p>层次图用来描绘软件的层次结构。很适于在自顶向下设计软件的过程中使用。</p></blockquote><blockquote><p>层次图和层次方框图的区别：</p><table><thead><tr><th align="center"></th><th align="center">层次图</th><th align="center">层次方框图</th></tr></thead><tbody><tr><td align="center">作用</td><td align="center">描绘软件结构</td><td align="center">描绘数据结构</td></tr><tr><td align="center">矩形框</td><td align="center">模块</td><td align="center">数据元素</td></tr><tr><td align="center">连线</td><td align="center">调用关系</td><td align="center">组成关系</td></tr></tbody></table></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E6%AD%A3%E6%96%87%E5%8A%A0%E5%B7%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E5%9B%BE.png" alt="正文加工系统的层次图"></p></blockquote><h4 id="2-HIPO图"><a href="#2-HIPO图" class="headerlink" title="2. HIPO图"></a>2. HIPO图</h4><blockquote><ul><li>HIPO图是美国IBM公司发明的“层次图+输入/处理/输出图”的英文缩写。</li><li>为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。<br><img src="/img/soft_intro_c5/HIPO%E5%9B%BE.png" alt="HIPO图"><br>和H图中每个方框相对应，应该有一张IPO图描绘这个方框代表的模块的处理过程。模块在H图中的编号便于追踪了解这个模块在软件结构中的位置。</li></ul></blockquote><h4 id="3-结构图"><a href="#3-结构图" class="headerlink" title="3. 结构图"></a>3. 结构图</h4><blockquote><p><strong>基本符号:</strong></p><ul><li>方框代表一个模块；</li><li>方框之间的直线表示模块的调用关系；</li><li>尾部是空心圆箭头表示传递的是数据；</li><li>尾部是实心圆箭头表示传递的是控制信息。<br><img src="/img/soft_intro_c5/%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="结构图"></li></ul></blockquote><blockquote><p><strong>附加符号:</strong><br><img src="/img/soft_intro_c5/%E7%BB%93%E6%9E%84%E5%9B%BE%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7.png" alt="结构图附加符号"></p><ul><li>选择调用: 判定为真时调用 A，为假时调用 B。</li><li>模块 M 循环调用模块 A、B、C。</li></ul></blockquote><blockquote><p><strong>注意:</strong></p><ul><li>层次图和结构图并不严格表示模块的调用次序，多数人习惯从左到右画模块；</li><li>层次图和结构图并不指明合适调用下层模块；<br>层次图和结构图只表明一个模块调用哪些模块，没有表示模块内还有没有其他成分；<br>通常用层次图作为描绘软件结构的文档；<br>由层次图导出结构图的过程可以作为检查设计正确性和评价模块独立性的好方法。</li></ul></blockquote><hr><h3 id="5-面向数据流的设计方法：变换流和事务流"><a href="#5-面向数据流的设计方法：变换流和事务流" class="headerlink" title="5. 面向数据流的设计方法：变换流和事务流"></a>5. 面向数据流的设计方法：变换流和事务流</h3><h4 id="1-变换流"><a href="#1-变换流" class="headerlink" title="1. 变换流"></a>1. 变换流</h4><blockquote><p>信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。<br><img src="/img/soft_intro_c5/%E5%8F%98%E6%8D%A2%E6%B5%81.png" alt="变换流"></p></blockquote><h4 id="2-事务流"><a href="#2-事务流" class="headerlink" title="2. 事务流"></a>2. 事务流</h4><blockquote><p>数据沿输入通路到达一个处理T，T根据输入数据的类型在若干个动作序列中选出一个来执行。处理T称为事务中心，它完成下述任务：</p><ul><li>接收输入数据</li><li>分析每个事务以确定它的类型；</li><li>根据事务类型选取一条活动通路。<br><img src="/img/soft_intro_c5/%E4%BA%8B%E5%8A%A1%E6%B5%81.png" alt="事务流"></li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png" alt="设计过程"></p></blockquote><h4 id="3-变换分析"><a href="#3-变换分析" class="headerlink" title="3. 变换分析"></a>3. 变换分析</h4><blockquote><p>变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图按预先确定的模式映射成软件结构。</p></blockquote><blockquote><p><strong>设计步骤:</strong></p><ol><li>复查基本系统模型</li></ol><blockquote><ul><li>确保系统的输入数据和输出数据符合实际。</li></ul></blockquote><ol start="2"><li>复查并精化数据流图</li></ol><blockquote><ul><li>对需求分析阶段得出的数据流图认真复查，并且在必要时进行精化。</li><li>不仅要确保数据流图给出了目标系统的正确逻辑模型，而且应该使数据流图中每个处理都代表一个规模适中相对独立的子功能。</li></ul></blockquote><ol start="3"><li>确定数据流图具有变换特性还是事务特性</li></ol><blockquote><ul><li>一个系统中的所有信息流都可以认为是变换流，但是，当遇到有明显事务特性的信息流时，建议采用事务分析方法进行设计。确定数据流的全局特性和局部特性。</li></ul></blockquote><ol start="4"><li>确定输入流和输出流的边界，从而孤立出变换中心</li></ol><blockquote><ul><li>输入流和输出流的边界和对它们的解释有关,不同设计人员可能会在流内选取稍微不同的点作为边界的位置。</li></ul></blockquote><ol start="5"><li>完成“第一级分解”。</li></ol><blockquote><ul><li>位于软件结构最顶层的控制模块 $C_m$ 协调下述从属的控制功能：<ul><li>输入信息处理控制模块 $C_a$ ，管理对内部形式的数据的所有操作；</li><li>变换中心控制模块 $C_t$，管理对内部形式的数据的所有操作；</li><li>输出信息处理控制模块 $C_e$，协调输出信息的产生过程。</li></ul></li></ul><p><img src="/img/soft_intro_c5/%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%88%86%E8%A7%A3.png" alt="第一级分解"></p></blockquote><ol start="6"><li>完成“第二级分解”</li></ol><blockquote><ul><li>处理映射成软件结构中一个适当的模块。完成第二级分解的方法是：<ul><li>从变换中心的边界开始逆着输入通路向外移动，把输入通路中每个处理映射成软件结构中Ca控制下的一个低层模块；</li><li>然后沿输出通路向外移动，把输出通路中每个处理映射成直接或间接受模块Ce控制的一个低层模块；</li><li>最后把变换中心内的每个处理映射成受Ct控制的一个模块。</li></ul></li></ul><p><img src="/img/soft_intro_c5/%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E8%A7%A3.png" alt="第二级分解"><br><img src="/img/soft_intro_c5/%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E8%A7%A31.png" alt="第二级分解"></p></blockquote><ol start="7"><li>使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化</li></ol><blockquote><p>为了产生合理的分解，得到尽可能高的内聚、尽可能松散的耦合，为了得到一个易于实现、易于测试和易于维护的软件结构，应该对初步分割得到的模块进行再分解或合并。 </p></blockquote></blockquote><h4 id="4-事务分析"><a href="#4-事务分析" class="headerlink" title="4. 事务分析"></a>4. 事务分析</h4><blockquote><p>虽然在任何情况下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。</p></blockquote><blockquote><ul><li>事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同；</li><li>由事务流映射成的软件结构包括一个接收分支和一个发送分支；</li><li>映射出接收分支结构的方法和变换分析映射出输入结构的方法很相像，即从事务中心的边界开始，把沿着接收流通路的处理映射成模块；</li><li>发送分支的结构包含一个调度模块，它控制下层的所有活动模块；然后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构<br><img src="/img/soft_intro_c5/%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95.png" alt="事务分析的映射方法"></li></ul></blockquote><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结:"></a>5. 总结:</h4><blockquote><ul><li>一般说来，如果数据流不具有显著的事务特点，最好使用变换分析；反之，如果具有明显的事务中心，则应该采用事务分析技术。</li><li>机械地遵循变换分析或事务分析的映射规则，可能会得到一些不必要的控制模块，如果它们确实用处不大，那么可以而且应该把它们合并。</li><li>如果一个控制模块功能过分复杂，这应该分解为两个或多个控制模块，或者增加中间层次的控制模块。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>软件工程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三章 需求分析</title>
    <link href="/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.html"/>
    <url>/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90.html</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-需求分析"><a href="#第三章-需求分析" class="headerlink" title="第三章 需求分析"></a>第三章 需求分析</h1><hr><h4 id="需求分析的任务；获取需求的方法"><a href="#需求分析的任务；获取需求的方法" class="headerlink" title="需求分析的任务；获取需求的方法"></a>需求分析的任务；获取需求的方法</h4><h5 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h5><ul><li><p><strong>确定对系统的综合要求</strong></p><blockquote><ol><li><em>功能需求</em></li><li><em>性能需求</em></li><li><em>可靠性和可用性需求</em></li><li><em>出错处理需求</em></li><li><em>接口需求</em></li><li><em>约束</em></li><li><em>逆向需求</em></li><li><em>将来可能提出的要求</em></li></ol></blockquote></li><li><p><strong>分析系统的数据要求</strong></p><blockquote><ul><li>建立数据模型——ER图 </li><li>描绘数据结构——层次方框图和Warnier图  </li><li>数据结构规范化 </li></ul></blockquote></li><li><p><strong>导出系统的逻辑模型</strong></p><blockquote><p>综合上述两项分析的结果可以导出系统的详细的逻辑模型，通常用 <strong>数据流图</strong> 、<strong>实体-联系图</strong> 、<strong>状态转换图</strong> 、<strong>数据字典</strong> 和 <strong>主要的处理算法</strong> 描述这个逻辑模型。</p></blockquote></li><li><p><strong>修正系统开发计划</strong></p><blockquote><p>根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。 </p></blockquote></li></ul><h5 id="获取需求的方法"><a href="#获取需求的方法" class="headerlink" title="获取需求的方法"></a>获取需求的方法</h5><ul><li><p><strong>访谈</strong></p><blockquote><ol><li><em>正式访谈</em> : 系统分析员将提出一些事先准备好的具体问题。</li><li><em>非正式访谈</em> : 分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法。</li><li><em>调查表</em> : 经过仔细考虑写出的书面回答可能比被访者对问题的口头回答更准确。</li><li><em>情景分析技术</em> :<blockquote><p>对用户将来使用目标系统解决某个具体问题的方法和结果进行分析。<br><strong>情景分析技术的用处：</strong></p><ul><li>能在某种程度上演示目标系统的行为，从而便于用户理解，而且还可能进一步揭示出一些分析员目前还不知道的需求。</li><li>能保证用户在需求分析过程中始终扮演一个积极主动的角色。让用户起积极主动的作用对需求分析工作获得成功是至关重要的。</li></ul></blockquote></li></ol></blockquote></li><li><p><strong>面向数据流自顶向下求精</strong></p><blockquote><ol><li><em>分析追踪数据流图</em> : 需求分析的目标之一就是把数据流和数据存储定义到元素级，通常从数据流图的输出端着手分析。</li><li><em>用户复查</em> : <ul><li>必须请用户对上述分析过程中得出的结果仔细地复查。复查过程验证了已知的元素，补充了未知的元素，填补了文档中的空白。</li><li>随着分析过程的进展，经过问题和解答的反复循环，分析员越来越深入具体地定义了目标系统，最终得到对系统数据和功能要求的<del>满意</del>充足了解。<br><img src="/img/soft_intro_c3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B1%82%E7%B2%BE.png" alt="面向数据流自顶向下求精"></li></ul></li></ol></blockquote></li><li><p><strong>简易的应用规格说明技术</strong></p><blockquote><ul><li>简易的应用规格说明技术是一种面向团队的需求收集法。</li><li>这种方法提倡用户与开发者密切合作，共同标识问题，提出解决方案要素，商讨不同方案并指定基本需求。 </li></ul></blockquote><blockquote><p><strong>优点:</strong></p><ul><li>开发者与用户不分彼此，齐心协力，密切合作；</li><li>即时讨论并求精；</li><li>有能导出规格说明的具体步骤。 </li></ul></blockquote></li></ul><blockquote><p><strong>分析需求的典型过程如下:</strong></p><ol><li>初步访谈, 提出建议;</li><li>会前审查需求, 确定列表;</li><li>会上讨论列表, 创建组合列表;</li><li>分组制定小型规格说明;</li><li>制定确认标准, 起草需求规格说明书 </li></ol></blockquote><ul><li><p><strong>快速建立软件原型</strong></p><blockquote><ul><li>快速建立软件原型是最准确、最有效、最强大的需求分析技术。</li><li>快速原型就是快速建立起来的旨在演示目标系统主要功能的可运行的程序。</li><li>构建原型的要点是，它应该实现用户看得见的功能，省略目标系统的“隐含”功能。</li></ul></blockquote><blockquote><p><strong>特性:</strong></p><ul><li>“快速”。快速原型的目的是尽快向用户提供一个可在计算机上运行的目标系统的模型。因此，原型的某些缺陷是可以忽略的。</li><li>“容易修改”。如果原型的第一版不是用户所需要的，就必须根据用户的意见迅速地修改它，构建出原型的第二版，以更好地满足用户需求。如果修改耗时过多，势必延误软件开发时间。 </li></ul></blockquote></li></ul><blockquote><p><strong>通常使用的3种方法和工具：</strong></p><ol><li>第四代技术（4GL）</li><li>可重用的软件构建</li><li>形式化规格说明和原型环境</li></ol></blockquote><blockquote><p>第四代技术特点：<br>简单易学，用户界面良好，面向问题、非过程化程度高，用户只需告知系统做什么，而无需说明怎么做。用4GL编程使用的代码量较少，并可成数量级地提高软件生产率。</p></blockquote><blockquote><p>程序设计语言划代：<br>1GL是汇编语言；<br>2GL是高级程序设计语言，如FORTRAN，ALGOL，BASIC，LISP等；<br>3GL是增强性的高级程序设计语言，如PASCAL，ALGOL68，FORTRAN77等；<br>4GL是按计算机科学理论指导设计出来的语言，如ADA，MODULA－2，SMALLTALK－80，JAVA，VB，VC，VF等。 </p></blockquote><hr><h4 id="需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；"><a href="#需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；" class="headerlink" title="需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；"></a>需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；</h4><hr><h4 id="实体-联系图（E-R图）：三种信息、符号和应用"><a href="#实体-联系图（E-R图）：三种信息、符号和应用" class="headerlink" title="实体-联系图（E-R图）：三种信息、符号和应用"></a>实体-联系图（E-R图）：三种信息、符号和应用</h4><ul><li><p><strong>数据模型(E-R图):</strong> 描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形。</p></li><li><p><strong>三种相互关联的信息:</strong></p><ol><li><strong>数据对象</strong></li></ol><blockquote><ul><li>是对软件必须理解的复合信息的抽象。复合信息是指具有一系列不同性质或属性的事物，仅有单个值的事物不是数据对象。</li><li>数据对象可以是外部实体、事物、行为、事件、角色、单位、地点或结构等。数据对象彼此间是有关联的。</li></ul></blockquote><ol start="2"><li>数据对象的 <strong>属性</strong></li></ol><blockquote><ul><li><strong>属性</strong> 定义了数据对象的性质。必须把一个或多个属性定义为“标识符” 。</li><li>根据对问题的理解来确定特定数据对象的合适的属性。 </li></ul></blockquote><ol start="3"><li>数据对象彼此间相互连接的 <strong>关系</strong></li></ol><blockquote><ul><li><strong>联系:</strong> 数据对象彼此之间相互连接的方式称为联系，也称为关系。</li><li><strong>联系可分为以下3种类型：</strong><ol><li>一对一联系(1∶1)</li><li>一对多联系(1∶N)</li><li>多对多联系(M∶N)</li></ol></li><li><strong>联系也可能有属性。</strong></li></ul></blockquote></li><li><p><strong>E-R图的符号</strong></p><blockquote><p><img src="/img/soft_intro_c3/E-R%E5%9B%BE%E7%9A%84%E7%AC%A6%E5%8F%B7.png"></p></blockquote></li><li><p><strong>应用</strong></p></li><li><p><strong>优点</strong></p><blockquote><ul><li>比较接近人的习惯思维方式；</li><li>用简单的图形符号表达系统分析员对问题域的理解，用户也容易理解，可以作为用户与分析员之间有效的交流工具。 </li></ul></blockquote></li></ul><hr><h4 id="状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；"><a href="#状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；" class="headerlink" title="状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；"></a>状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；</h4><ul><li><p><strong>状态转换图:</strong> 通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。还指明了作为特定事件的结果系统将做哪些动作(例如，处理数据)。</p></li><li><p><strong>状态：</strong> 是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。</p><blockquote><p>状态主要有:</p><ul><li>初态(即初始状态), 只能有一个</li><li>终态(即最终状态)，可以有0至多个</li><li>中间状态</li></ul></blockquote><blockquote><p>状态图分类：</p><ul><li>表示系统循环运行过程，通常不关心循环是怎样启动的。</li><li>表示系统单程生命期，需要标明初始状态和最终状态。</li></ul></blockquote></li><li><p><strong>事件:</strong> 是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。简而言之，事件就是引起系统做动作或(和)转换状态的控制信息。 </p></li><li><p><strong>符号:</strong></p><blockquote><ul><li>初态:用实心圆表示；</li><li>终态:用一对同心圆(内圆为实心圆)表示；</li><li>中间状态: 用圆角矩形表示, 分成上、中、下3部分。<ul><li>上面部分—–为状态的名称；</li><li>中间部分—–为状态变量的名字和值；</li><li>下面部分—–是活动表（可选）。 </li></ul></li><li>带箭头的连线: 称为状态转换, 箭头指明了传播方向。</li></ul></blockquote></li><li><p><strong>活动表的语法格式</strong></p><blockquote><p><strong>语法格式: 事件名(参数表)/动作表达式</strong></p><ul><li>entry事件指定进入该状态的动作；</li><li>exit事件指定退出该状态的动作；</li><li>do事件则指定在该状态的动作。</li></ul><p>需要时可以为事件指定参数表。活动表中的动作表达式描述应做的具体动作。</p></blockquote></li><li><p><strong>事件表达式的语法格式</strong></p><blockquote><p>状态转换: 状态图中两个状态之间带箭头的连线，箭头指明了传播方向<br>状态变迁: 通常由事件触发, 在此情况下, 应在表示状态转换的箭头线上标出触发状态转换的事件表达式。如果未标明,则表示自动触发。</p></blockquote><blockquote><p>语法: <strong>事件说明[守卫条件] / 动作表达式</strong></p><ul><li>时间说明的语法为: 事件名(参数表)。</li><li>守卫条件是一个布尔表达式。如果同时使用时间说明和守卫条件，则当且仅当事件发生且布尔表达式为真时，状态转换才会发生。如果只有守卫条件没有事件说明，则只要守卫条件为真状态转换就发生。</li><li>动作表达式是一个过程表达式,当状态转换开始时执行该表达式<br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B01.png"><br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B021.png"><br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B022.png"></li></ul></blockquote></li></ul><hr><h4 id="其他图形工具：层次方框图、Warnier图、IPO图"><a href="#其他图形工具：层次方框图、Warnier图、IPO图" class="headerlink" title="其他图形工具：层次方框图、Warnier图、IPO图"></a>其他图形工具：层次方框图、Warnier图、IPO图</h4><ul><li><p><strong>层次方框图</strong></p><blockquote><p><strong>层次方框图:</strong> 用树形结构的一系列多层次的矩形框来描绘数据的层次结构。<br><img src="/img/soft_intro_c3/%E5%B1%82%E6%AC%A1%E6%96%B9%E6%A1%86%E5%9B%BE.png" alt="层次方框图"></p><ul><li>树形结构的顶层是一个单独的矩形框,它代表完整的数据结构；</li><li>下面的各层矩形框代表这个数据的子集；</li><li>最底层的各个框代表组成这个数据的实际数据元素(不能再分割的元素)。</li></ul></blockquote></li><li><p><strong>Warnier图</strong></p><blockquote><p><strong>Warnier图:</strong> 和层次方框图类似, Waarnier图也用树形结构描绘信息, 但是这种图形工具比层次方框图提供了更丰富的描绘手段。<br><img src="/img/soft_intro_c3/%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81%E7%9A%84Warnier%E5%9B%BE.png"><br><strong>特点:</strong> 用Warnier图可以表明信息的逻辑组织，也可以表示特定信息在某一类信息中是有条件地出现的。因为重复和条件约束是说明软件处理过程的基础，所以很容易把Warnier图转变成软件设计的工具。 </p></blockquote></li><li><p><strong>IPO图</strong></p><blockquote><p>IPO图: 是输入、处理、输出图的简称，它是美国IBM公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。<br>基本形式: 是在左边的框中列出有关的输入数据，在中间的框内列出主要的处理，在右边的框内列出产生的输出数据。在IPO图中还用类似向量符号的粗大箭头清楚地指出数据通信的情况。<br><img src="/img/soft_intro_c3/IPO%E5%9B%BE%E4%BE%8B%E5%AD%90.png" alt="IPO图例子"></p></blockquote><blockquote><p><strong>改进的IPO图:</strong> 这种图中包含某些附加的信息, 在软件设计过程中将比原始的IPO图更有用。<br><img src="/img/soft_intro_c3/IPO%E5%9B%BE_%E6%94%B9%E8%BF%9B.png" alt="改进的IPO图"><br>在需求分析阶段可以使用IPO图简略地描述系统的主要算法(即数据流图中各个处理的基本算法)。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>软件工程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 可行性研究</title>
    <link href="/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6.html"/>
    <url>/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6.html</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-可行性研究"><a href="#第二章-可行性研究" class="headerlink" title="第二章 可行性研究"></a>第二章 可行性研究</h1><hr><h4 id="可行性研究的内容"><a href="#可行性研究的内容" class="headerlink" title="可行性研究的内容"></a>可行性研究的内容</h4><p><strong>1. 技术可行性:</strong></p><blockquote><p>使用现有的技术能否实现这个系统？<br>是否有胜任开发该项目的熟练技术人员？<br>能否按期得到开发该项目所需的软件、硬件资源？</p></blockquote><p><strong>2. 经济可行性:</strong></p><blockquote><p>这个系统的经济效益能否超过它的开发成本？<br>需要对项目进行价格/利益分析，即“投入/产出”分析。<br>由于利益分析取决于软件系统的特点，因此在软件开发之前，很难对新系统产生的效益作出精确的定量描述，所以往往采用一些估算方法。</p></blockquote><p><strong>3. 操作可行性:</strong></p><blockquote><p>操作可行性评价系统运行后会引起的各方面变化，如：对组织机构管理模式、用户工作环境等产生的影响。</p></blockquote><p><strong>4. 社会可行性:</strong></p><blockquote><p>社会可行性主要讨论法律方面和使用方面的可行性。<br>例如，被开发软件的权利归属问题、软件所使用的技术是否会造成侵权等问题。</p></blockquote><hr><h4 id="可行性研究过程-7步骤"><a href="#可行性研究过程-7步骤" class="headerlink" title="可行性研究过程(7步骤)"></a>可行性研究过程(7步骤)</h4><ol><li>复查定义，确定系统规模和目标；<blockquote><p>确认目标问题（用户需要的是否等于我们认为用户需要的）</p></blockquote></li><li>研究目前正在使用的系统；<blockquote><p>确认成本，缺点，流程图，接口等</p></blockquote></li><li>导出新系统的高层逻辑模型（数据流图、数据字典）；<blockquote><p>输入输出，数据格式</p></blockquote></li><li>重新定义问题；</li></ol><blockquote><p>前 4 个步骤实质上构成一个循环</p></blockquote><ol start="5"><li>导出和评价供选择的解法（物理解决方案）；<blockquote><p>技术、操作、经济和市场上接受同时满足，给出供选择的方案。</p></blockquote></li><li>推荐行动方案；<blockquote><p>哪一种方案最好，为什么，给出定论和原因。</p></blockquote></li><li>草拟开发计划（粗略）；<blockquote><ul><li>任务分解，确定负责人</li><li>大致进度规划</li><li>财务预算</li><li>风险分析及对策</li></ul></blockquote></li><li>书写文档提交审查。 （作为下一个阶段工作的基础）</li></ol><p><strong>可行性报告，必须给出明确结论：</strong></p><ul><li>行或不行。</li><li>或者给出系统开始前需要首先具备哪些条件</li><li>或系统目标需要先行修改等。</li></ul><hr><h4 id="系统流程图概念，特点、符号和应用；"><a href="#系统流程图概念，特点、符号和应用；" class="headerlink" title="系统流程图概念，特点、符号和应用；"></a>系统流程图概念，特点、符号和应用；</h4><ul><li>概念和特点:<blockquote><p>系统流程图是概括的描述物理系统的传统工具。<br>系统流程图反映的是信息在系统各部分之间流动的情况；<br>系统流程图 $\neq$ 控制、处理信息（不同于程序流程图）</p></blockquote></li><li>符号:<br><img src="/img/soft_intro_c2/%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE_%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7.png" alt="基本符号"><br><img src="/img/soft_intro_c2/%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE_%E7%B3%BB%E7%BB%9F%E7%AC%A6%E5%8F%B7.png" alt="系统符号"></li><li>应用</li><li>分层:<blockquote><p>面对复杂的系统时,一个比较好的方法是分层次地描绘这个系统。首先用一张高层次的系统流程图描绘系统总体概貌,表明系统的关键功能。然后分别把每个关键功能扩展到适当的详细程度,画在单独的一页纸上。这种分层次的描绘方法便于阅读者按从抽象到具体的过程逐步深入地了解一个复杂的系统。</p></blockquote></li></ul><hr><h4 id="数据流图概念、要素、特点、符号和应用；"><a href="#数据流图概念、要素、特点、符号和应用；" class="headerlink" title="数据流图概念、要素、特点、符号和应用；"></a>数据流图概念、要素、特点、符号和应用；</h4><ul><li>定义:<blockquote><p>数据流图是系统逻辑功能的图形表示, 图中没有任何具体的物理部件。<br>数据流图描绘数据在软件系统内从输入移动到输出过程中所经受的变换。通常用数据流图建立软件结构的功能模型。</p></blockquote></li><li>要素及符号:<br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E6%BA%90%E7%82%B9or%E7%BB%88%E7%82%B9.png"><br><img src="/img/soft_intro_c2/DFD_%E5%A4%84%E7%90%86.png"><br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.png"><br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="基本符号"><br><img src="/img/soft_intro_c2/DFD_%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7.png" alt="附加符号"></li></ul><p><strong>注意:</strong></p><blockquote><ul><li>“处理”可表示：单个程序、一系列程序、程序的一个模块、人工处理过程等等；</li><li>“数据存储”可表示：一个文件、文件的一部分、数据库记录等等；</li><li>数据流图 <strong>忽略</strong> 出错处理、打开文件、关闭文件。</li></ul></blockquote><ul><li>特点:<blockquote><p>抽象性，概括性，层次性</p></blockquote></li><li>应用:<blockquote><p>见课本</p></blockquote></li></ul><p><strong>怎样画数据流图?</strong></p><blockquote><ol><li>提取数据流图的4种成分<ol><li><strong>考虑数据的源点和终点</strong></li><li><strong>考虑处理</strong></li><li><strong>考虑数据流和数据存储</strong></li></ol></li><li>画出基本系统模型并将其细化, 描绘系统的主要功能<br>   一旦把数据流程图中的四种成份都分离出来之后，就可着手绘制系统的数据流程图了。数据流程图的绘制也是采用自顶向下的方法，由粗到细，逐层细化，最后形成一套完整的拟建系统的数据流程图。 </li></ol></blockquote><p><strong>命名:</strong></p><blockquote><ol><li><strong>为数据流(或数据存储)命名</strong><ol><li>名字应该代表整个数据流(或数据存储)的内容；</li><li> 不要使用空洞的、缺乏具体含义的名字（如“数据”、“输入”）；</li><li>如果为某个数据流（或数据存储）起名字时遇到困难，则很可能是因为对数据流图的分解不恰当造成的，应该试试重新分解数据流图； </li></ol></li><li><strong>为处理命名</strong><ol><li>通常先为数据流命名，然后再为与之相关联的处理命名；</li><li>名字应该反映整个处理的功能；</li><li>应该尽量避免空洞笼统的动词做名字，如“处理”、“加工”；</li><li>通常用一个动词命名，如果必须用两个动词才能描述整个处理的功能，则可能要把这个处理分解成两个处理更恰当；</li><li>如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的情况，应考虑重新分解。</li></ol></li><li><strong>数据源点/终点并不需要在开发目标系统的过程中设计和实现,它并不属于数据流图的核心内容,只不过是目标系统的外围环境部分(可能是人员、计算机外部设备或传感器装置)。通常,为数据源点/终点命名时采用它们在问题域中习惯使用的名字(如“采购员”、“仓库管理员”等)。</strong></li></ol></blockquote><blockquote><p>作用:</p><ul><li>利用它作为交流信息的工具；</li><li>作为软件分析和设计的工具。</li></ul></blockquote><hr><h4 id="数据字典定义、包含内容："><a href="#数据字典定义、包含内容：" class="headerlink" title="数据字典定义、包含内容："></a>数据字典定义、包含内容：</h4><blockquote><p>关于数据的信息的集合，也就是对数据流图中包含元素的定义的集合。<br>与数据流图共同构成系统的 <strong>逻辑模型</strong></p><p>数据字典由下列四类元素的定义组成：</p><ul><li>数据流；</li><li>数据流分量（即数据元素）</li><li>数据存储；</li><li>处理。</li></ul></blockquote><h5 id="定义数据的方法"><a href="#定义数据的方法" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h5><ol><li><strong>数据元素字典</strong> 定义基本内容:<ul><li>数据元素编号、名称及其含义；</li><li>数据类型和长度；</li><li>合理取值；</li><li>其他内容，如它和其它数据的逻辑关系等。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据元素字典定义实例"></li></ul></li><li><strong>数据流字典</strong> 定义基本内容：<ul><li>数据流编号及名称；</li><li>数据流来源；</li><li>数据流去处；</li><li>数据流的组成； </li><li>流通量；</li><li>峰值。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据流字典定义实例"></li></ul></li><li><strong>数据存储</strong> 字典定义基本内容:<ul><li>数据存储编号及名称；</li><li>数据存储的组成；</li><li>其它要求。</li></ul></li><li><strong>数据处理</strong> 字典定义基本内容:<ul><li>数据处理编号及名称；</li><li>简单描述；</li><li>输入/输出；</li><li>功能描述；</li><li>有关数据存储。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据处理字典定义实例"></li></ul></li><li>数据元素组成数据的表示方法：<ul><li>顺序：即以确定次序连接两个或多个分量。</li><li>选择：即从两个或多个可能的元素中选取一个。</li><li>重复：即把指定的分量重复零次或多次。</li><li>可选：即一个分量是可有可无的(重复零次或一次)。</li></ul></li></ol><h5 id="数据字典的用途"><a href="#数据字典的用途" class="headerlink" title="数据字典的用途:"></a>数据字典的用途:</h5><ol><li>作为分析阶段的重要工具；</li><li>数据元素的控制信息非常有用；</li><li>有助于开发数据库。</li></ol><hr><h4 id="定义数据的方法-1"><a href="#定义数据的方法-1" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h4><p><img src="/img/soft_intro_c2/%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="定义数据的方法"></p><hr><h4 id="成本估算技术"><a href="#成本估算技术" class="headerlink" title="成本估算技术"></a>成本估算技术</h4><h5 id="1-代码行技术"><a href="#1-代码行技术" class="headerlink" title="1. 代码行技术"></a>1. 代码行技术</h5><blockquote><p>软件成本 = 每行代码的平均成本×估计的源代码总行数</p></blockquote><h5 id="2-任务分解技术"><a href="#2-任务分解技术" class="headerlink" title="2. 任务分解技术"></a>2. 任务分解技术</h5><blockquote><p>软件开发项目分解为若干个相对独立的任务，分别估计每个单独任务的成本；<br>单独任务成本 = 任务所需人力估计值×每人每月平均工资；<br>软件开发项目总成本估计 = 各个单独任务成本估计值之和。<br><img src="/img/soft_intro_c2/%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3%E6%8A%80%E6%9C%AF.png" alt="任务分解技术"></p></blockquote><h5 id="3-自动估计成本技术"><a href="#3-自动估计成本技术" class="headerlink" title="3. 自动估计成本技术"></a>3. 自动估计成本技术</h5><blockquote><p>采用自动估计成本的软件工具估计</p></blockquote><h5 id="成本-效应分析的方法"><a href="#成本-效应分析的方法" class="headerlink" title="成本/效应分析的方法"></a>成本/效应分析的方法</h5><p><strong>1. 货币的时间价值</strong></p><blockquote><p>假设年利率为i,如果现在存入P元钱，则n年以后可以得到的钱数为：<br>$$F = P(1+i)^n$$</p><p>反之，如果 <strong>n</strong> 年后能收入 <strong>F</strong> 元钱，那么这些钱现在的价值是：<br>$$P = F/(1+i)^n$$</p></blockquote><p><img src="/img/soft_intro_c2/%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90%E4%BE%8B01.png"><br><img src="/img/soft_intro_c2/%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90%E4%BE%8B02.png"><br><strong>2. 投资回收期</strong></p><blockquote><ul><li>第一、第二年回收：4225元</li><li>第三年回收投资要：(5000 - 4225)/1779 = 0.44 年</li><li>总的投资回收期 = 2.44 年</li></ul></blockquote><p><strong>3. 纯收入:</strong> 9011.94 - 5000 = 4011.94 (元)<br><strong>4. 投资回收率</strong><br>$$P = \frac{F_1}{(1+j)} + \frac{F_2}{(1+j)^2} +···+\frac{F_n}{(1+n)^n}$$</p><p>其中:</p><blockquote><p>P是现在的投资额；<br>Fi是第i年年底的效益（i=1,2,3,…,n）;<br>n是系统的使用寿命（一般假设n=5）；<br>j是投资回收率。</p></blockquote><p>上述修改系统的工程的投资回收率是41%-42%</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>软件工程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 软件工程概述</title>
    <link href="/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0.html"/>
    <url>/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0.html</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h1><ul><li><h4 id="软件包含几部分、软件本身特点"><a href="#软件包含几部分、软件本身特点" class="headerlink" title="软件包含几部分、软件本身特点"></a>软件包含几部分、软件本身特点</h4></li></ul><blockquote><table><thead><tr><th align="center">软件</th><th></th></tr></thead><tbody><tr><td align="center">程序(指令集)</td><td>可执行代码，由字符、数字等组成</td></tr><tr><td align="center">数据</td><td>输入输出数据</td></tr><tr><td align="center">相关文档</td><td>规格说明文档、设计文档、用户手册和其他管理文档</td></tr></tbody></table><p>特点:</p><ol><li>抽象：逻辑实体非物理实体（不直观）；</li><li>不存在磨损问题，可无限期使用；</li><li>可移植性；（零成本无限复制）；</li><li>复杂性，实现、维护等越来越复杂；</li><li>昂贵性，开发维护成本高；</li></ol></blockquote><ul><li><h4 id="软件危机概念，包含的两方面内容，提出的时间"><a href="#软件危机概念，包含的两方面内容，提出的时间" class="headerlink" title="软件危机概念，包含的两方面内容，提出的时间"></a>软件危机概念，包含的两方面内容，提出的时间</h4></li></ul><blockquote><p>软件危机的概念:计算机软件的开发和维护过程中遇到的一系列严重问题。两方面内容:</p><ol><li>如何开发软件，满足对软件日益增长的需求</li><li>如何维护数量不断膨胀的已有软件。</li></ol><p>提出的时间:<br>1968年，NATO北大西洋公约组织的计算机科学家召开了计算机国际会议，提出“软件危机”的概念，并提出了“软件工程”学科</p></blockquote><ul><li><h4 id="为消除软件危机，需要采取哪两方面措施？"><a href="#为消除软件危机，需要采取哪两方面措施？" class="headerlink" title="为消除软件危机，需要采取哪两方面措施？"></a>为消除软件危机，需要采取哪两方面措施？</h4></li></ul><blockquote><ol><li>对计算机软件有正确的认识，消除“软件就是程序”的错误认识。认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目，充分借鉴吸取已有经验。</li><li>应该推广使用在实践中总结出来的开发软件的成功技术和方法，并继续研究探索。</li><li>应该开发和使用更好的软件工具。<br>总之，为了解决软件危机，既要有<strong>技术</strong>措施(方法和工具)，又要有必要的组织<strong>管理</strong>措施</li></ol><p><strong>管理:</strong> 通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程。<br><strong>技术(软件工程方法学):</strong> 通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学(methodology)，也称为范型(paradigm)。</p></blockquote><ul><li><h4 id="软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点"><a href="#软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点" class="headerlink" title="软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点"></a>软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点</h4></li></ul><blockquote><ol><li><p>概念: 是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p></li><li><p>软件工程方法学:</p><ul><li><p>概念: 通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学(methodology)，也称为范型(paradigm)。</p></li><li><p>3要素:</p><ul><li>方法：是完成软件开发的各项任务的技术方法，回答“怎样做”的问题；</li><li>工具：是为运用方法而提供的自动的或半自动的软件工程支撑环境；如，CASE(Computer-Aided Software Engineering )工具</li><li>过程：需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</li></ul></li><li><p>传统方法学(生命周期方法学或结构化范型)——强调自顶向下:</p><ul><li>采用结构化技术来完成软件开发的各项任务；</li><li>划分为若干个阶段，然后顺序地完成每个阶段的任务；</li><li><strong>每个阶段的任务相对独立，而且比较简单，降低了整个软件开发工程的困难程度；</strong> 前一个阶段是后一个阶段的前提和基础，而后一阶段提出的解法更具体，细节更多；</li><li><strong>每个阶段结束前必须从技术和管理两方面对这个阶段的开发成果进行严格的检查，通过之后这个阶段才算结束；保证了质量，提高可维护性；</strong></li><li>当软件规模庞大，或者的需求模糊或随时间而变化时，传统方法学往往不成功；维护起来仍然很困难。</li></ul></li><li><p>面向对象方法学——强调主动地多次反复迭代</p><ul><li>面向对象方法: 把数据和行为看成同等重要，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。</li><li>面向对象方法学4个要点：<ul><li>对象(object)：融合了数据及在数据上的操作行为。</li><li>类(class)：类是对具有相同数据和相同操作的一组相似对象的定义。</li><li>继承：按照父类与子类的关系，把若干个相关类组成一个层次结构的系统。</li><li>消息：对象彼此间仅能通过发送消息互相联系。</li></ul></li><li>优点:<ol><li>面向对象方法学的尽量模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程。</li><li>面向对象方法学开发软件的过程，是一个主动地多次反复迭代的演化过程，保证了在各项开发活动之间的平滑过渡。</li><li>促进了软件重用。最终的软件产品由许多较小的、基本上独立的对象组成，每个对象相当于一个微型程序，而且大多数对象都与现实世界中的实体相对应，降低了复杂性，提高了可理解性，简化了开发和维护工作。</li></ol></li></ul></li></ul></li></ol></blockquote><ul><li><h4 id="软件生命周期（三个时期八个阶段）"><a href="#软件生命周期（三个时期八个阶段）" class="headerlink" title="软件生命周期（三个时期八个阶段）"></a>软件生命周期（三个时期八个阶段）</h4></li></ul><blockquote><p><img src="/img/soft_intro_c1/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="软件生命周期"></p><ol><li><p>问题定义:</p><blockquote><p><strong>任务: 问题是什么?</strong></p><ul><li>通过对客户的访问调查，系统分析员扼要地写出关于问题性质、工程目标和工程规模的书面报告。</li><li>经过讨论和必要的修改之后这份报告应该得到客户的确认。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 关于系统规模和目标的</p></blockquote></li><li><p>可行性研究:</p><blockquote><p><strong>任务: 有可行的解吗?</strong></p><ul><li>系统分析员需要进行一次大大压缩和简化了的系统分析和设计过程。</li><li>研究问题的范围，探索这个问题是否值得去解，是否有可行的解决办法。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>系统的高层逻辑模型（数据流图、成本效益分析）</li><li>可行性论证报告（立即进行/推迟进行/不能或不值得进行）</li></ul></blockquote></li><li><p>需求分析:</p><blockquote><p><strong>任务: 必须做什么</strong></p><ul><li>主要是确定目标系统必须具备哪些功能。</li><li>系统分析员必须和用户密切配合，充分交流信息，以得出经过用户确认的系统逻辑模型。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>系统的逻辑模型（数据流图、数据字典、简要的算法描述）</li><li>用规格说明书（Specification）准确地记录对目标系统的需求</li></ul></blockquote></li><li><p>总体设计:</p><blockquote><p><strong>任务: 如何提出已提出的问题</strong></p><ul><li>设计出实现目标系统的几种可能的方案（低、中、高成本）。</li><li>用适当的表达工具描述每种方案，分析优缺点，推荐一个最佳方案，制定出实现最佳方案的详细计划。设计程序的体系结构。</li></ul></blockquote><blockquote><p>**结果: **</p><ul><li>可能的解法(系统流程图、成本效益分析)</li><li>推荐的系统体系结构(层次图或结构图)</li></ul></blockquote></li><li><p>详细设计:</p><blockquote><p><strong>任务: 怎样具体实现该系统</strong></p><ul><li>详细地设计每个模块, 确定实现模块功能所需要的算法和数据结构</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>每个模块的算法和数据结构(程序流程图、PAD图、N-S图等)</li></ul></blockquote></li><li><p>编码和单元测试:</p><blockquote><p><strong>任务: 得到正确的程序模块</strong></p><ul><li>选取一种适当的高级程序设计语言(必要时用汇编语言)，把详细设计的结果翻译成用选定的语言书写的程序；</li><li>并且仔细测试编写出的每一个模块。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 代码和测试报告</p></blockquote></li><li><p>综合测试:</p><blockquote><p><strong>任务: 得到符合要求的软件</strong></p><ul><li>通过集成测试、验收测试、现场测试、平行运行等方法对目标系统进一步测试检验。</li><li>通过对软件测试结果的分析可以预测软件的可靠性；反之，根据对软件可靠性的要求，也可以决定测试和调试过程什么时候可以结束。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>测试计划、详细测试方案以及实际测试结果</li><li>完整一致的软件配置</li></ul></blockquote></li><li><p>软件维护:<br><img src="/img/soft_intro_c1/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4.png" alt="软件维护"></p><blockquote><p><strong>任务: 使系统持久地满足用户的需要</strong></p><ul><li>改正性维护,诊断和改正在使用过程中发现的软件错误；</li><li>适应性维护，修改软件以适应环境的变化；</li><li>完善性维护，根据用户的要求改进或扩充软件；</li><li>预防性维护，修改软件为将来的维护活动做准备。</li><li>每一项维护活动经历了一次压缩和简化了的软件定义和开发的全过程。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 完整准确的维护记录</p></blockquote></li></ol></blockquote><ul><li><h4 id="软件过程（几个模型）"><a href="#软件过程（几个模型）" class="headerlink" title="软件过程（几个模型）"></a>软件过程（几个模型）</h4></li></ul><blockquote><p><strong>1. 瀑布模型</strong> (文档驱动型)<br><img src="/img/soft_intro_c1/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="瀑布模型"></p><ul><li>瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落</li><li>特点:<blockquote><p><strong>1. 阶段间具有顺序性和依赖性</strong></p><ul><li>前一阶段的工作完成之后，才能开始后一阶段的工作；</li><li>前一阶段的输出文档就是后一阶段的输入文档。</li></ul><p><strong>2. 推迟实现的观点</strong></p><ul><li>对于规模较大的软件项目来说，往往编码开始得越早最终完成开发工作所需要的时间反而越长。</li></ul><p><strong>3. 质量保证的观点</strong></p><ul><li>每个阶段都必须完成规定的文档，是“文档驱动”的模型；</li><li>每个阶段结束前都要对所完成的文档进行评审，尽早发现问题，改正错误。</li></ul></blockquote></li><li><strong>优点:</strong><blockquote><ul><li>可强迫开发人员采用规范的方法；</li><li>严格地规定了每个阶段必须提交的文档；</li><li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li><strong>只能通过文档了解产品，不经过实践的需求是不切实际的。</strong></li></ul></blockquote></li><li><strong>适用于:</strong><blockquote><ul><li>需求是预知的；</li><li>软件实现方法是成熟的；</li><li>项目周期较短。</li></ul></blockquote></li></ul><p><strong>2. 快速原型模型</strong><br><img src="/img/soft_intro_c1/%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B.png" alt="快速原型模型"></p><ul><li>特点:<blockquote><ul><li>快速原型模型不带反馈环，软件产品的开发基本上是线性顺序进行的。</li><li>快速原型的本质是“快速”。应该尽可能快地建造出原型系统，以加速软件开发过程，节约成本。</li></ul></blockquote></li><li><strong>根据原型的不同作用,有三类原型模型</strong><blockquote><ul><li>探索型原型——用于开发的需求分析阶段</li><li>实验型原型——主要用于设计阶段</li><li>演化型原型——用于及早向用户提交一个原型系统</li></ul></blockquote></li><li><strong>快速原型模型的运用方式:</strong><blockquote><ul><li>抛弃策略——探索型和实验型采用此策略</li><li>附加策略——演化型快速原型采用此策略</li></ul></blockquote></li></ul><p><strong>3. 增量模型</strong><br><img src="/img/soft_intro_c1/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B.png" alt="增量模型"></p><ul><li><strong>优点:</strong><blockquote><ul><li>人员分配灵活，刚开始不用投入大量人力资源。</li><li>当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径。</li><li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。</li></ul></blockquote></li><li><strong>难点:</strong><blockquote><ul><li>软件体系结构必须是开放的。</li><li>模型本身是自相矛盾的。整体——独立构件。</li><li>不同的构件并行地构建有可能加快工程进度，但是冒无法集成到一起的风险。</li></ul></blockquote></li><li><strong>适用于:</strong><blockquote><ul><li>适用于需求经常改变的软件开发过程。</li><li>如果在项目既定的商业要求期限之前不可能找到足够的开发人员，在这种情况下，增量模型显得特别有用。<br><strong>4. 螺旋模型</strong> (风险驱动型)<br><img src="/img/soft_intro_c1/%E7%AE%80%E5%8C%96%E7%9A%84%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png" alt="简化的螺旋模型"></li></ul></blockquote></li><li><strong>优点:</strong><blockquote><ul><li>主要优势在于它是风险驱动的。</li><li>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标；</li><li>减少了过多测试或测试不足所带来的风险；</li><li>维护只是模型的另一个周期，维护和开发之间没有本质区别。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li>采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失。</li><li>过多的迭代次数会增加开发成本，延迟提交时间。</li></ul></blockquote></li></ul><p><img src="/img/soft_intro_c1/%E5%AE%8C%E6%95%B4%E7%9A%84%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png" alt="完整的螺旋模型"></p><ul><li><strong>适用于:</strong><blockquote><ul><li>特别适用于庞大、复杂并具有高风险的系统。</li><li>适用于内部开发的大规模软件项目。<br><strong>5. 喷泉模型</strong><br><img src="/img/soft_intro_c1/%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B.png" alt="喷泉模型"></li></ul></blockquote></li><li><strong>优点:</strong><blockquote><ul><li>该模型的各个阶段没有明显的界限，开发人员可以同步进行开发。</li><li>多次反复地增加或明确目标系统，而不是本质性的改动，降低错误的可能性。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li>由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，不利于项目的管理。</li><li>要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。</li></ul></blockquote></li><li><strong>适用于:</strong> 面向对象的软件开发过程。</li></ul></blockquote><h3 id="如有错误-请在博客页下方评论"><a href="#如有错误-请在博客页下方评论" class="headerlink" title="如有错误, 请在博客页下方评论"></a>如有错误, 请在<a href="https://ckxgzxa.github.io/2021/05/15/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/">博客页</a>下方评论</h3>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>软件工程导论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库系统概论第四章第7题</title>
    <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%AC7%E9%A2%98.html"/>
    <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%AC7%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>今有以下两个关系模式:<br>&ensp;&ensp;&ensp;&ensp;职工(职工号，姓名，年龄，职务，工资，部门号)<br>&ensp;&ensp;&ensp;&ensp;部门(部门号，名称，经理名，地址，电话号)<br>请用SQL的GRANT和REVOKE语句（加上视图机制）完成以下授权定义或存储控制功能:<br>(1)用户王明对两个表有SELECT权限。<br>(2)用户李勇对两个表有NSERT和DELETE权限。<br>(3)每个职工只对自己的记录有SELECT权限。<br>(4)用户刘星对职工表有SELECT权限，对工资字段具有更新权限。<br>(5)用户张新具有修改这两个表的结构的权限。<br>(6)用户周平具有对两个表的所有权限(读、插、改、删数据)，并具有给其他用户授权的权限。<br>(7)用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限，她不能查看每个人的工资。</p></blockquote><hr><h3 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h3><h5 id="建表"><a href="#建表" class="headerlink" title="建表:"></a>建表:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 部门 (<br>    部门号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    名称 <span class="hljs-type">CHAR</span>(<span class="hljs-number">16</span>),<br>    经理名 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    地址 <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>    电话号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 职工 (<br>    职工号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    姓名 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    年龄 <span class="hljs-type">SMALLINT</span>,<br>    职务 <span class="hljs-type">CHAR</span>(<span class="hljs-number">12</span>),<br>    工资 <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>),<br>    部门号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">FOREIGN</span> KEY ( 部门号 ) <span class="hljs-keyword">REFERENCES</span> 部门(部门号)<br>);<br></code></pre></td></tr></table></figure><h5 id="创建习题中涉及用户"><a href="#创建习题中涉及用户" class="headerlink" title="创建习题中涉及用户:"></a>创建习题中涉及用户:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 王明 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 李勇 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 刘星 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 张新 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 周平 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 杨兰 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="插入一些测试数据"><a href="#插入一些测试数据" class="headerlink" title="插入一些测试数据:"></a>插入一些测试数据:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM001&#x27;</span>,<span class="hljs-string">&#x27;部门一&#x27;</span>,<span class="hljs-string">&#x27;经理一&#x27;</span>,<span class="hljs-string">&#x27;地址一&#x27;</span>,<span class="hljs-string">&#x27;12345678901&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM002&#x27;</span>,<span class="hljs-string">&#x27;部门二&#x27;</span>,<span class="hljs-string">&#x27;经理二&#x27;</span>,<span class="hljs-string">&#x27;地址二&#x27;</span>,<span class="hljs-string">&#x27;12345678902&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM003&#x27;</span>,<span class="hljs-string">&#x27;部门三&#x27;</span>,<span class="hljs-string">&#x27;经理三&#x27;</span>,<span class="hljs-string">&#x27;地址三&#x27;</span>,<span class="hljs-string">&#x27;12345678903&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG001&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-number">31</span>,<span class="hljs-string">&#x27;职位一&#x27;</span>,<span class="hljs-number">11000</span>,<span class="hljs-string">&#x27;BM001&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG002&#x27;</span>,<span class="hljs-string">&#x27;李勇&#x27;</span>,<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;职位二&#x27;</span>,<span class="hljs-number">12000</span>,<span class="hljs-string">&#x27;BM002&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG003&#x27;</span>,<span class="hljs-string">&#x27;刘星&#x27;</span>,<span class="hljs-number">33</span>,<span class="hljs-string">&#x27;职位三&#x27;</span>,<span class="hljs-number">13000</span>,<span class="hljs-string">&#x27;BM003&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG004&#x27;</span>,<span class="hljs-string">&#x27;张新&#x27;</span>,<span class="hljs-number">34</span>,<span class="hljs-string">&#x27;职位四&#x27;</span>,<span class="hljs-number">14000</span>,<span class="hljs-string">&#x27;BM002&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG005&#x27;</span>,<span class="hljs-string">&#x27;周平&#x27;</span>,<span class="hljs-number">35</span>,<span class="hljs-string">&#x27;职位五&#x27;</span>,<span class="hljs-number">15000</span>,<span class="hljs-string">&#x27;BM003&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG006&#x27;</span>,<span class="hljs-string">&#x27;杨兰&#x27;</span>,<span class="hljs-number">36</span>,<span class="hljs-string">&#x27;职位六&#x27;</span>,<span class="hljs-number">16000</span>,<span class="hljs-string">&#x27;BM001&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="1-用户王明对两个表有SELECT权限"><a href="#1-用户王明对两个表有SELECT权限" class="headerlink" title="1. 用户王明对两个表有SELECT权限"></a>1. 用户王明对两个表有SELECT权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 王明;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 王明;<br></code></pre></td></tr></table></figure><h5 id="2-用户李勇对两个表有INSERT和DELETE权限"><a href="#2-用户李勇对两个表有INSERT和DELETE权限" class="headerlink" title="2. 用户李勇对两个表有INSERT和DELETE权限"></a>2. 用户李勇对两个表有INSERT和DELETE权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 李勇;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 李勇;<br></code></pre></td></tr></table></figure><h5 id="3-每个职工只对自己的记录有SELECT权利"><a href="#3-每个职工只对自己的记录有SELECT权利" class="headerlink" title="3. 每个职工只对自己的记录有SELECT权利"></a>3. 每个职工只对自己的记录有SELECT权利</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 职工视图 <br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> 职工 <br><span class="hljs-keyword">WHERE</span> concat(姓名,<span class="hljs-string">&#x27;@localhost&#x27;</span>) <span class="hljs-operator">=</span> <span class="hljs-keyword">USER</span>();<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> 职工视图<br><span class="hljs-keyword">TO</span> 王明,李勇,刘星, 张新,周平,杨兰;<br></code></pre></td></tr></table></figure><h5 id="4-用户刘星对职工表有SELECT权限-对工资字段有更新权限"><a href="#4-用户刘星对职工表有SELECT权限-对工资字段有更新权限" class="headerlink" title="4. 用户刘星对职工表有SELECT权限, 对工资字段有更新权限"></a>4. 用户刘星对职工表有SELECT权限, 对工资字段有更新权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">UPDATE</span>(工资)<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 刘星;<br></code></pre></td></tr></table></figure><h5 id="5-用户张新具有修改两个表结构权限"><a href="#5-用户张新具有修改两个表结构权限" class="headerlink" title="5. 用户张新具有修改两个表结构权限"></a>5. 用户张新具有修改两个表结构权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALTER</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 张新;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALTER</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 张新;<br></code></pre></td></tr></table></figure><h5 id="6-用户周平具有对两个表的所有权限-读、插、改、删数据-并具有给其他用户授权的权限"><a href="#6-用户周平具有对两个表的所有权限-读、插、改、删数据-并具有给其他用户授权的权限" class="headerlink" title="6. 用户周平具有对两个表的所有权限(读、插、改、删数据),并具有给其他用户授权的权限"></a>6. 用户周平具有对两个表的所有权限(读、插、改、删数据),并具有给其他用户授权的权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 周平<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 周平<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><h5 id="7-用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资"><a href="#7-用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资" class="headerlink" title="7. 用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资"></a>7. 用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 部门工资(名称,最高工资,最低工资,平均工资)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> `部门`.`名称`, <span class="hljs-built_in">MAX</span>(`工资`), <span class="hljs-built_in">MIN</span>(`工资`), <span class="hljs-built_in">AVG</span>(`工资`)<br><span class="hljs-keyword">FROM</span> `职工`, `部门`<br><span class="hljs-keyword">WHERE</span> `职工`.`部门号` <span class="hljs-operator">=</span> `部门`.`部门号`<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> `职工`.`部门号`;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> 部门工资<br><span class="hljs-keyword">TO</span> 杨兰;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>数据库系统概论</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
