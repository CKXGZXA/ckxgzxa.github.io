<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>百度高效研发实战训练营Step1 | 技术匝记簿</title><meta name="robots" content="noindex"><meta name="author" content="残魁斜罡"><meta name="copyright" content="残魁斜罡"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="百度高效研发实战训练营Step1百度工程能力实战训练营线上课程 1 设计方法与实践1.1 软件设计原则 软件设计的目的  软件设计是为了使软件在长期范围内能够容易的进行变化。我们从下面这三个点来理解这句话。   变化：软件不是一成不变的，无论是软件本身的需求、软件依赖的其他软件资源都是一直在发生变化的，唯一不变的就是变化。 容易：任何一个软件的变化都需要成本，要尽可能的降低变化的成本，使得软件可以">
<meta property="og:type" content="article">
<meta property="og:title" content="百度高效研发实战训练营Step1">
<meta property="og:url" content="https://www.ckxgzxa.top/bitTraingClub1.html">
<meta property="og:site_name" content="技术匝记簿">
<meta property="og:description" content="百度高效研发实战训练营Step1百度工程能力实战训练营线上课程 1 设计方法与实践1.1 软件设计原则 软件设计的目的  软件设计是为了使软件在长期范围内能够容易的进行变化。我们从下面这三个点来理解这句话。   变化：软件不是一成不变的，无论是软件本身的需求、软件依赖的其他软件资源都是一直在发生变化的，唯一不变的就是变化。 容易：任何一个软件的变化都需要成本，要尽可能的降低变化的成本，使得软件可以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060211788.png">
<meta property="article:published_time" content="2021-11-23T15:10:12.000Z">
<meta property="article:modified_time" content="2022-04-07T10:28:18.949Z">
<meta property="article:author" content="残魁斜罡">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060211788.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.ckxgzxa.top/bitTraingClub1.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 残魁斜罡","link":"链接: ","source":"来源: 技术匝记簿","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '百度高效研发实战训练营Step1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-07 18:28:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="技术匝记簿" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060211788.png')"><nav id="nav"><span id="blog-info"><a href="/" title="技术匝记簿"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">技术匝记簿</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">百度高效研发实战训练营Step1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-23T15:10:12.000Z" title="发表于 2021-11-23 23:10:12">2021-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-07T10:28:18.949Z" title="更新于 2022-04-07 18:28:18">2022-04-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%99%BE%E5%BA%A6%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/">百度高效研发实战训练营</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="百度高效研发实战训练营Step1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="百度高效研发实战训练营Step1"><a href="#百度高效研发实战训练营Step1" class="headerlink" title="百度高效研发实战训练营Step1"></a>百度高效研发实战训练营Step1</h1><p><a target="_blank" rel="noopener" href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p>
<h2 id="1-设计方法与实践"><a href="#1-设计方法与实践" class="headerlink" title="1 设计方法与实践"></a>1 设计方法与实践</h2><h3 id="1-1-软件设计原则"><a href="#1-1-软件设计原则" class="headerlink" title="1.1 软件设计原则"></a>1.1 软件设计原则</h3><ol>
<li><p>软件设计的目的</p>
<blockquote>
<p>软件设计是为了使软件在长期范围内能够容易的进行变化。我们从下面这三个点来理解这句话。</p>
<blockquote>
<ol>
<li>变化：<em>软件不是一成不变的</em>，无论是软件本身的需求、软件依赖的其他软件资源都是一直在发生变化的，唯一不变的就是变化。</li>
<li>容易：任何一个软件的变化都需要成本，要尽可能的降低变化的成本，使得软件可以很容易应对软件的变化。</li>
<li>长期：事实上需要长期进行维护的软件更应该做好软件设计，因为软件长期的变化非常多，难以提前作出预测，需要良好的软件设计来应对。</li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p>软件设计原则</p>
</li>
</ol>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111232319206.png"></p>
<blockquote>
<p>软件设计有着很多的原则，<em>最基本的原则是高内聚低耦合，它也是软件设计追求的最高目标</em>。 <em><strong>内聚</strong></em> 指的是一个软件内部间元素相关联的程度。</p>
<p><em><strong>高内聚</strong></em>追求的是紧密相关联的元素要放在一起。</p>
<p><em><strong>低耦合</strong></em>指的是单位之间尽可能少地关联，依赖。</p>
</blockquote>
<blockquote>
<p>在高内聚低耦合之上有很多其他的原则：如SOLID原则、简单设计、正交设计，在这之上还会有设计模式作为最高层的软件设计原则。</p>
</blockquote>
<h3 id="1-2-clean-code"><a href="#1-2-clean-code" class="headerlink" title="1.2 clean code"></a>1.2 clean code</h3><ol>
<li><p>clean code的概念</p>
<blockquote>
<p>clean code中文解释为<em>整洁代码</em>，是指写的代码能够在尽可能短的时间内被别人读懂，且代码看上去排版整洁、逻辑清晰、扩展性好。</p>
</blockquote>
</li>
<li><p>命名规则</p>
<blockquote>
<p>代码中命名需要遵循以下的几个规则：</p>
<blockquote>
<ol>
<li>表达它是什么，不要表达怎么做。</li>
<li>代码要做到自注释。</li>
<li>使用有意义的循环迭代变量。</li>
<li>避免缩写，尤其拼音缩写。</li>
<li>不要使用非约定俗成的缩写。</li>
<li>避免使用魔法数。</li>
<li>不要害怕长变量名。</li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p>注释</p>
<blockquote>
<p>注释对于代码来说是必不可少的。通常情况下，<em>好的注释包含：版权信息，设计意图，警示信息。</em></p>
<p>不好的注释则具有以下一个或几个特点：同义反复、隐晦关联关系、套用模板、提供历史修改记录以及注释掉的代码。</p>
</blockquote>
</li>
<li><p>函数</p>
<blockquote>
<p>在写函数时，应当注意，<em>每个函数只做一件事</em>，每个函数应是单一职责。</p>
<p>函数分为骨架函数和步骤函数。</p>
<ul>
<li><em>骨架函数</em> 是业务逻辑和算法是在高层次上的抽象描述。</li>
<li><em>步骤函数</em> 是业务逻辑和算法的一些实现细节，是被隐藏起来的。</li>
</ul>
</blockquote>
</li>
<li><p>编码细节</p>
<blockquote>
<p>在编码细节方面，需要遵循以下几点规则：</p>
<blockquote>
<ol>
<li>使用自然的比较顺序。</li>
<li>简化逻辑层次，避免多层嵌套。</li>
<li>在写三元表达式时不要出现复杂的逻辑和过长的条件。</li>
<li>需要控制变量的作用域，也就是缩小变量作用域的范围，越小越好。</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
<h3 id="1-3-单元测试"><a href="#1-3-单元测试" class="headerlink" title="1.3 单元测试"></a>1.3 单元测试</h3><ol>
<li><p>为什么进行单元测试</p>
<blockquote>
<p>测试是分为不同层次的：最底层是单元测试，中间是基于模块级、组件级的测试，再往上则是系统级别的测试。</p>
<p><em>越底层的测试，越能够快速地发现问题。</em>底层的测试集成性更好，能够安全的进行代码修改。上层的测试一般情况下获得反馈的速度比较慢，测试过程也比较笨重。</p>
<p>所以单元测试具有<em>更早发现问题，更容易集成，更安全地代码修改的优点</em>。</p>
</blockquote>
</li>
<li><p>写好单元测试的重要性</p>
<blockquote>
<p>写好单元很费时。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111232334866.webp"></p>
<p><em>好的单元测试能够降低产品开发的成本。</em> 然而单元测试写得不好的话，不但会增加产品开发的成本，而且还会增加单元测试成本。</p>
</blockquote>
</li>
<li><p>单元测试原则与模式</p>
<p><strong>第一个原则：Tests As Documentation</strong></p>
<p>将测试当成一个文档工作，也就是说我们需要把测试写得像文档一样简洁，通过一些描述，可以清晰地知道这个测试的作用。在之后对项目修改时，只需要查看单元测试即可。</p>
<p><strong>第二个原则：Fully Automated and Self-Checking</strong></p>
<p>单元测试都是可以进行自我检查、自我校验的，通过代码的编写，能够知道测试是否成功，不需要人为判定。</p>
<p><strong>第三个原则：Do No Harm，不可破坏性。</strong></p>
<p>部分开发人员在进行测试时，为了完成目的，会基于测试代码创立一些逻辑，这种做法是错误的。在写测试时不能单独为测试创建特别的逻辑，更不能破坏原有代码的逻辑。</p>
<p><strong>第四个原则：Keep tests as simple as possible，简洁性。</strong></p>
<p>单元测试虽然是用来保证代码的正确性，但单元测试也是一份代码，为了避免过多的测试代码相覆盖，要尽可能地把单元测试的代码写得简单，保证其不会出错。</p>
</li>
</ol>
<h3 id="1-4-重构"><a href="#1-4-重构" class="headerlink" title="1.4 重构"></a>1.4 重构</h3><pre><code>重构时需要遵循的规则如下:
</code></pre>
<blockquote>
<ol>
<li><strong>业务导向</strong></li>
</ol>
<p>重构一定是要解决实际的业务问题的，而不是为了重构去重构。</p>
<ol start="2">
<li><p><strong>小步快跑</strong></p>
<p> 通常重构是需要多人同时参与，重构过程中开发人员要随时对比主干与分支的情况。当某一个开发人员在分支上进行了大量改动并准备将其合并到主干时，有可能主干和分支的代码有很大的差异。所以进行重构时，要<em>将问题拆分成多个小的单元进行修改，并且每修改一个就进行一次分支合并</em>。这种小步快跑的模式可以随时同步主干上的代码，减少出错的可能。</p>
</li>
<li><p><strong>演进式设计</strong></p>
<p> 在进行代码重构之前，我们不可能知道重构的最终结果是什么。为了保证能够得到一个比较好的结果，我们采用演进式设计方法。在重构过程中<em>遵循包括高内聚低耦合、正交设计原则、SOLID原则等软件设计原则，不断地用小步快跑的方式去重构</em>，只有这样结果才能令人满意。</p>
</li>
<li><p><strong>正交设计原则</strong></p>
<p>分离关注点、消除重复、缩小依赖范围、向着稳定的方向依赖。</p>
</li>
</ol>
</blockquote>
<pre><code>在代码中，根据功能的不同，将其分为不同的变化方向。每个变化方向都是一个职责，我们把每一个不同的变化方向称作关注点，根据它的变化方向来进行相应的处理。
</code></pre>
<h3 id="1-5-配置化架构"><a href="#1-5-配置化架构" class="headerlink" title="1.5 配置化架构"></a>1.5 配置化架构</h3><ol>
<li><strong>配置化架构的定义：</strong></li>
</ol>
<p>以可配置的方式构建软件的方法。它是在领域建模的基础上，以配置表述业务，以配置组织架构元素，比如服务、组件、数据等，并对配置进行规范化、自动化的管理。</p>
<p>定义的原因：</p>
<blockquote>
<ol>
<li>通常情况下配置指的是对数据的抽象，需要架构上的描述；</li>
<li>架构上描述的配置指的是对架构元素的抽象，描述配置化不完整；</li>
<li>配置化包括对业务的抽象，尤其是逻辑；</li>
<li>配置化还包括对配置的管理以及分支。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>如何应用配置化架构</strong></li>
</ol>
<p>应用配置化架构包括三方面：从业务上改造，提高配置本身的开发效率，降低配置的维护成本。</p>
<blockquote>
<ol>
<li><strong>业务配置化改造</strong></li>
</ol>
<blockquote>
<ol>
<li>组件配置化</li>
</ol>
<p>组件配置化表达<em>是业务层面上非常重要的一环</em>，组件是一个独立升级发布的单元，这样的单元关联了很多配置，可将这些配置分为两类。一类是<em>组件内部的配置</em>，另二类是<em>描述组件与组件间关系的配置</em>。只有组件配置化是不够的，往往还需要构建DSL来帮助。</p>
<ol start="2">
<li>构建DSL：</li>
</ol>
<p>DSL是工程师针对不同的领域创建的语言。具有很强的针对性，在专业领域有时很长的代码只需要将其改为一行配置就足够了。</p>
</blockquote>
<ol start="2">
<li><strong>提高配置的开发效率</strong></li>
</ol>
<p>通过下面的持续发布的系统，能够很好地提高配置的开发效率。它只针对配置，可以独立的发布配置。在系统中：需要配置前端编辑逻辑，后端校验逻辑，当存储发生变更时，触发测试流水线，当测试流水线无异常后，才会借用部署的工具，将配置分发到线上去。</p>
<ol start="3">
<li><strong>降低配置的维护成本</strong></li>
</ol>
<p>通常来说，代码数量很大的项目，配置也会很多。这样的配置在维护起来需要花费大量的成本。所以在设计配置的时候，要满足以下这些规则：</p>
<blockquote>
<ol>
<li>让配置尽可能地在部署、数据版本、业务属性和架构描述这四个不同维度间参数能够共用。把部署的配置和策略的配置分离开来。</li>
<li>针对配置本身的语法，让配置支持合并.</li>
<li>减少冗余信。</li>
<li>消除信息重复。</li>
<li>使用配置的默认值。</li>
</ol>
</blockquote>
</blockquote>
<h2 id="2-高效研发流程脚本"><a href="#2-高效研发流程脚本" class="headerlink" title="2. 高效研发流程脚本"></a>2. 高效研发流程脚本</h2><h3 id="2-1-从产品目标到产品路线图"><a href="#2-1-从产品目标到产品路线图" class="headerlink" title="2.1 从产品目标到产品路线图"></a><strong>2.1 从产品目标到产品路线图</strong></h3><blockquote>
<p>满足用户诉求是产品的基础功能，在此之上还有一个更高的期望，即产品的目标。通常情况下产品目标与产品的收益、市场份额、流水有关。在制定具体产品目标时，需要考虑产品的商业模式以及产品所处的阶段。<em>好的产品目标是具体的、可衡量的、相对稳定的。</em></p>
<p>在进行产品目标阶段性地拆解时，需要考虑拆解的维度与方法。除了根据阶段性的时间维度进行拆分外，还可以根据产品的里程碑进行拆分。</p>
</blockquote>
<h3 id="2-2-从产品路线图到发布计划"><a href="#2-2-从产品路线图到发布计划" class="headerlink" title="2.2 从产品路线图到发布计划"></a>2.2 <strong>从产品路线图到发布计划</strong></h3><p>在了解如何制定产品发布计划之前，我们需要先了解一个工具：<em>用户故事地图</em>。用户故事地图实际上是一个完整的用户故事。它可以帮助我们增强团队协作、洞察真实需求、打磨优良产品。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242041157.png" alt="image-20211124204157089"></p>
<p>想要创建用户故事地图，首先要有用户故事地图的框架。它的核心是一条从左到右的时间线，然后从上到下按照归纳结构分为三个层级。这一条时间线上方的一级粒度的功能需求，在工作中，我们称之为Epic，也就是橙色卡片。这条时间线下方的第一行为二级粒度的功能需求，在工作中，称之为Feature，是黄色卡片。在二级粒度功能下，蓝色的卡片为三级粒度的需求，工作中，称之为Story，是蓝色卡片。</p>
<p>用户故事地图创建中五个重要的步骤：</p>
<blockquote>
<ol>
<li>一步一步写出你的故事</li>
<li>组织情节</li>
<li>探索替代故事</li>
<li>提取故事地图的主干</li>
<li>切分出能帮你达成特定目标的任务</li>
</ol>
</blockquote>
<p><strong>“训练智能机器人小A从起床到出门”</strong>的简单例子</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242043740.png" alt="image-20211124204337683"></p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242053569.png"></p>
<p><em>首先我们使用蓝色卡片</em> 按照步骤写出每个任务，每张卡片只写一个任务，任务以动词开头，如“睁眼”、“关闹钟”、“穿拖鞋”、“叠被子”等等。然后按照任务的发生顺序从左到右的组织卡片摆放。</p>
<p>接下来第二步，对所有的任务进行提取，得到概括性的行为，把这些<em>行为放到黄色卡片</em>上，也就是feature。如：“睁眼”、“关闹钟”这些行为可以归为“醒来”后要做的事情；“穿拖鞋”、“叠被子”这两个行为可以归为“起来”后要做的事情。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242055033.png"></p>
<p>接下来进入第三步：探索替代故事。细节、替代、变化和异常构成故事地图的主题。比如：时间充裕可以睡个回笼觉，楼上装修被提前吵醒等等可能发生的变化和异常。我们需要将这些任务补充进地图。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242057602.png"></p>
<p>然后进入第四步：将一系列类似的任务提取出来，形成更大的目标。在类似任务的上方，放一张<em>橙色的卡片,也就是之前提到的Epic,卡片贴上一个动词短语</em>，使其足以覆盖其下方所有任务卡片所要表达的意思。例如：“起床”可以概括“醒来”和“起来”；“如厕”可以概括“如厕”和“刷牙”。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242058456.png"></p>
<p>此时已经完成了较为完整的故事地图。然后进入第五步，切分出能达成特定目标的任务。先确定本次迭代需要完成的特性/目标，使用切分来识别和特定相关的所有任务和细节。</p>
<p>在“训练智能机器人小A从起床到出门”这个例子中，分为了三个版本。在第一个版本15分钟起床，回笼觉这张卡片明显是不需要放到其中的。在这些的story中选出满足15分钟起床的事务并将其放入都第一个版本中。至此我们也就完成了一个简单的用户故事地图的创建。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242002082.webp"></p>
<p>上面这张图片是实际工作中对用户故事地图的应用，可以看到在实际工作中完整的用户故事地图所包含的内容非常庞杂。</p>
<p>完成用户故事地图之后，就需要制订发布计划。在创建用户故事地图的第五步中，我们切分出了达成特定功能的任务目标，每一个发布计划都对应着一个版本。具体的步骤如下：</p>
<blockquote>
<ol>
<li>Big Story进行细化讨论</li>
<li>按照价值和重要程度进行版本规划</li>
<li>确定每个版本的期望达成目标</li>
<li>确定每个版本的内容</li>
<li>团队达成共识</li>
</ol>
</blockquote>
<p>通过以上步骤，就基本确定了用户故事地图的发布计划。</p>
<h3 id="2-3-从发布计划到迭代计划"><a href="#2-3-从发布计划到迭代计划" class="headerlink" title="2.3 从发布计划到迭代计划"></a>2.3 <strong>从发布计划到迭代计划</strong></h3><p>第三部分主要讲解 <em>集中发布式模式</em> 这一常用的模式，在集中发布式模式中<em>，一次发布包含多次迭代</em>；在迭代发布模式中，一次发布等于一次迭代。</p>
<p>很多大型项目都在使用这一模式，通常是每月发布一次，<em>一次发布包含四个迭代</em>，四个迭代之后，发布一次版本。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242101886.png"></p>
<p>从发布计划到迭代计划共包括四个内容。</p>
<ol>
<li><strong>用户故事拆分</strong></li>
</ol>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242101974.png"></p>
<pre><code>用户故事的拆分*对迭代速率有一定影响*。对用户故事的拆分要做到拆分出的故事尽量小，但是要适当，并不是越小越好。避免出现一个迭代内无法完成的故事。
</code></pre>
<ol start="2">
<li><strong>用户故事优先级</strong></li>
</ol>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242104291.webp"></p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242006342.webp"></p>
<pre><code>在完成用户故事拆分后，需要对用户故事的优先级进行排序。用户故事的排序其实是对需求的一个排序，优先级排序有许多方法，如高中低、数字排序、衣服尺码L、XL等方式。*优先级决定排入迭代的顺序。*

以一个两周的迭代时间为例，假设我们有这样一个需求，前面的数字是需求卡片的序号，后面的数字从100到45，这是项目优先级排序的一个方式。每一次迭代能做4个卡片时，我们就会*把优先级最高的卡片放入迭代池*。

而当第二次迭代时，需求发生了变化，出现了x和y两个新的需求，x和y有着较高的优先级，那么我们仍然将优先级最高的四个卡片放入迭代池中。

第三次迭代中又插入了新需求z，需求z也有较高的优先级，那么当我们进行迭代的时候，需求z就会顶替另一个需求被放入迭代池中。

通过以上的例子可以看到，在原本的迭代计划中，12张卡片会被按顺序放入迭代池中，而真实情况是插入了更高优先级的需求，替换了低优先级的需求，把低优先级的需求放入了下一次迭代中。这就是优先级排序对迭代计划的影响。
</code></pre>
<ol start="3">
<li><strong>用户故事估算</strong></li>
</ol>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242105269.png"></p>
<pre><code>在迭代之前，需要对用户故事进行估算，*用户故事估算实际上是对工作量的估算*。这个工作量体现的是团队均值能力。

通常在公司内有不同级别的员工，高级别的员工和低级别的员工完成同一任务所需的时间是不同的。所以在进行用户故事估算时就需要规避掉技能的差异，根据团队的均值能力来进行估算。
</code></pre>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242106613.png"></p>
<ol start="4">
<li><strong>迭代计划制定</strong></li>
</ol>
<p>当前面三步全部完成后，才能开始指定迭代计划。</p>
<p>将已拆分好的用户故事按照优先级依次放入迭代池中，对每个要进行迭代的用户故事进行估算，确定好迭代的时间期限。所以我们就制定出了迭代计划。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242107859.png"></p>
<p><em>推荐采用范围调整、需求置换</em>方式，即插入高优先级用户故事，顺延低优先级故事到下一次迭代。</p>
<h3 id="2-4-从迭代计划到迭代的落地执行"><a href="#2-4-从迭代计划到迭代的落地执行" class="headerlink" title="2.4 从迭代计划到迭代的落地执行"></a>2.4 <strong>从迭代计划到迭代的落地执行</strong></h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242108710.png" alt="迭代计划会、站会、需求评审会、迭代回顾会"></p>
<p>在整个过程中开发和测试以story的力度进行。<em>分析、开发与测试三个步骤并行。</em></p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111242110996.png" alt="卡片墙"></p>
<p>团队可以使用卡片墙标注完成的任务和未完成的任务以及遇到的bug等。通过这种方式，能够对执行情况有清晰的认知，对执行过程产生积极的影响。</p>
<h2 id="3-研发工具链介绍"><a href="#3-研发工具链介绍" class="headerlink" title="3 研发工具链介绍"></a>3 研发工具链介绍</h2><h3 id="3-1-项目管理工具-iCafe"><a href="#3-1-项目管理工具-iCafe" class="headerlink" title="3.1 项目管理工具: iCafe"></a>3.1 项目管理工具: iCafe</h3><h4 id="3-1-1-需求管理"><a href="#3-1-1-需求管理" class="headerlink" title="3.1.1 需求管理"></a>3.1.1 需求管理</h4><p><strong>需求管理是一个项目的基石。</strong>在互联网行业中，因为产品需求迭代快速这一特点，需求管理一直非常令人头疼。所以如何对需求进行更好的管理，更好的做出产品规划对互联网行业的项目来说是一个重要的问题。</p>
<blockquote>
<p>传统的需求管理方法有以下几种：</p>
<ol>
<li>直接将需求写在文档上面，</li>
<li>将需求制作成需求卡片，通过这样的方式让研发人员与需求人员保持信息的一致。</li>
<li>使用Excel进行需求管理和排序。</li>
</ol>
</blockquote>
<p>这三种方法都存在很多的缺点，如撰写文档耗时长、文档编写需求较多人力、文档维护成本高、文档使用过程中沟通不畅等等。文字因为其阅读特性，不方便对任务进行直观的展现。所以在很多项目开发过程中，经常会出现文档交给研发人员后，开发出的产品与文档设计不一致的问题。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111250059343.png"></p>
<p>互联网的需求管理需要具有<strong>需求完整性、沟通高效性、表达准确性，沟通便捷性</strong>等特点。</p>
<p>研究表明，不同的沟通方式产生的沟通效果各有不同。在所有的沟通方式中，文档沟通是最低效的沟通方式，而面对面使用白板沟通是最高效的沟通方式。结合多种高效沟通方式，就产生了用户故事地图这种新颖的需求管理、排序的方式。</p>
<p><strong>用户故事地图是敏捷项目管理中一种重要的管理方式。</strong></p>
<p>首先<strong>使用卡片在白板上将所有的需求列出来，</strong>这样有助于展现产品全貌，而且将需求转化为可视的卡片能更好的根据用户反馈对任务需求进行排序；</p>
<p>然后<strong>使用不同的颜色对卡片进行分层。</strong>蓝色卡片是第一层，黄色卡片是第二层，白色卡片是第三层。将颗粒度最小的需求放在白色卡片这一层，低颗粒度的需求更容易被研发人员接受。</p>
<p>最后通过横向的分组，把迭代计划每一期的每一版本的<strong>需求进行归类分组。</strong>这样有利于打通产品视图和研发计划视图。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292215228.png"></p>
<p>通过以上步骤可以得到一个较为完整的用户故事地图。</p>
<h4 id="3-1-2-迭代计划"><a href="#3-1-2-迭代计划" class="headerlink" title="3.1.2 迭代计划"></a>3.1.2 迭代计划</h4><p>在完成产品的版本规划后，研发团队需要制定相应的迭代计划。敏捷、快速、合理地迭代计划能够更高效地促进项目的迭代。</p>
<p>基于用户故事地图，可以在制定迭代计划的过程中中直接对需求进行<strong>上下拖拽修改优先级，左右拖拽更改计划。</strong>这样可以更清晰的展现迭代计划，使开发团队更好定位到的里程碑，完善整个迭代计划。</p>
<h4 id="3-1-3-进度追踪"><a href="#3-1-3-进度追踪" class="headerlink" title="3.1.3 进度追踪"></a>3.1.3 进度追踪</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111250103932.png"></p>
<p>进度跟踪的三大法宝：<strong>站会、卡片墙、燃尽图。</strong></p>
<p>站会同卡片墙相结合，在站会过程中可以直接通过电子看板共享项目进度和项目问题，提升站会沟通效率。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270116972.png"></p>
<p><strong>用户故事地图是一种非常高效需求管理方式，</strong>目前所有的研发团队都可以在效率云上不受物理条件限制的直接使用它进行需求管理和追踪。</p>
<h4 id="3-1-4-持续改进"><a href="#3-1-4-持续改进" class="headerlink" title="3.1.4 持续改进"></a>3.1.4 持续改进</h4><p>针对持续改进，有卡片状态时长散点图和卡片状态累积流图这两种工具。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270127171.png"></p>
<p><strong>卡片状态时长散点图</strong>能够精确展示团队工作速率，从需求提出到需求上线的单个周期时长和平均周期时长，精确的展示团队在每一个状态的工作速率及工作速率的变化。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270128848.png"></p>
<p><strong>卡片状态累积流图</strong>能够宏观展示项目各流程效率趋势，颜色的色块宽表示该流程积压的需求和任务比较多，色条变窄表明团队状态流动速率提高。</p>
<p>基于这两幅图工具，研发团队可以周期性地进行自检，对过去一段时间的工作进行自我审视，然后持续改进。</p>
<h3 id="3-2-代码管理工具-iCode"><a href="#3-2-代码管理工具-iCode" class="headerlink" title="3.2 代码管理工具:iCode"></a>3.2 代码管理工具:iCode</h3><h4 id="3-2-1-工作流"><a href="#3-2-1-工作流" class="headerlink" title="3.2.1 工作流"></a>3.2.1 工作流</h4><p>运转无序，开发混乱是困扰很多团队的一个问题，严重影响产品的交付。</p>
<p>典型的问题有：代码处理随意、bug重复发生、测试不完善、发布版本混乱等。</p>
<p>支持以下两种标准的工作流，用来保障团队有序协作。</p>
<h5 id="1-基于主干的工作流"><a href="#1-基于主干的工作流" class="headerlink" title="1.  基于主干的工作流"></a>1.  基于主干的工作流</h5><pre><code>在基于主干的工作流中，整个团队维护一条主干分支。为了保证主干分支的质量，需要配套严    格的准入机制，变更点在合入前需要经过机器、人工的双重评审，通过后才能合入主干。

需要发布的时候，会基于主干拉取发布分支，这个分支其实是主干特定点的快照，单纯用于发        布，如果发布问题过程中发现问题，回到主干修复Bug或进行功能增强，必要时再将主干提交拣        选到相应的发布分支上。

分支发布和主干并行不悖，不用担心开发中的功能被带到线上，发布完成后恢复到一条主干的        简明模式。
</code></pre>
<blockquote>
<p>基于主干的工作流<strong>优点</strong>有：</p>
<ol>
<li>主干质量高，随时可以发布。</li>
<li>模型简单，只有一条主干，节省分支合并的成本。</li>
</ol>
</blockquote>
<pre><code>缺点: 在开发高质量的工程项目时，团队需要建设完备的测试用例，在提交环节要求提交人保持原子提交，即功能和提交一一对应。
</code></pre>
<h5 id="2-基于分支的工作流"><a href="#2-基于分支的工作流" class="headerlink" title="2. 基于分支的工作流"></a>2. 基于分支的工作流</h5><p>在基于分支的工作流中，<strong>主干用于存储线上代码</strong>，需要变更时，基于主干最新代码开分支完成功能的开发、测试和发布；分支发布前，需要先同步主干的更新；上线之后，需要将分支合并回主干。</p>
<blockquote>
<p>基于分支的工作流的<strong>优点</strong>有：</p>
<ol>
<li>分支并行，独立开发，分支不会相互影响；</li>
<li>对团队而言，使用门槛低，分支贯穿一个独立功能开发、测试、发布的整个过程，给予团队充分的时间完善测试用例及完成人工测试；</li>
<li>容易上手，系统会引导开发人员完成新建分支、同步主干、合会主干等全部操作。</li>
</ol>
</blockquote>
<p>缺点：需要花费分支合并的成本、需要不断地同步主干，来发现分支的冲突风险点并提前解决。</p>
<h3 id="3-2-2-评审"><a href="#3-2-2-评审" class="headerlink" title="3.2.2 评审"></a>3.2.2 评审</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270327159.png"></p>
<p>评审是<strong>保证团队工程质量</strong>的一个重要的过程。如果不经过评审直接提交代码，可能会污染代码历史，增加后期维护成本，严重时可能还会产生代码质量问题。</p>
<p>在项目开发过程中，可能会出现本地运行正常的代码，在测试环境或者线上环境突然崩溃的情况。针对这样的问题，可以使用<strong>质量防护网</strong>。质量防护网包括代码扫描、持续集成、人工评审三个层次。</p>
<p><strong>代码扫描</strong>能够找出不符合代码规范的地方，在行间距中插入代码评论，同时出具一个风格报告，方便工程师对代码风格问题进行修改。</p>
<p><strong>持续集成</strong>会配置一个云端构建，通过云端构建，快速探测出代码初期Bug，帮助开发人员提早修复。</p>
<p>在前两步做好后，团队的资深成员就可以就架构、逻辑、设计等问题进行深入评审。</p>
<p>通过这三步，实现了机器、人工双重评审，层层递进，确保团队的工程质量。</p>
<h3 id="3-3-交付平台-iPipe"><a href="#3-3-交付平台-iPipe" class="headerlink" title="3.3 交付平台:iPipe"></a>3.3 交付平台:iPipe</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270329017.png"></p>
<h4 id="3-3-1-固化端到端的交付流程"><a href="#3-3-1-固化端到端的交付流程" class="headerlink" title="3.3.1 固化端到端的交付流程"></a>3.3.1 固化端到端的交付流程</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111270333279.png"></p>
<p>标准的软件交付的过程包括以下几点：</p>
<blockquote>
<ol>
<li>会有一个明确的发布版本的输入，</li>
<li>基于这个发布版本，会进行代码提交。</li>
<li>代码提交之后会进行编译、测试。其中测试环节可能包含模块级的测试和系统级的测试。</li>
<li>进行发布。发布上线的过程可能会分为预上线、生产灰度、生产全量几个环节。</li>
</ol>
</blockquote>
<p>为了使代码变更流程标准化，需要<strong>使用交付流水线的方式来落地</strong>。通过标准化交付过程从而达到可靠、可重复的作用。交付流水线是<strong>串行执行</strong>的，上一个阶段成功执行后，就会触发下一个阶段。执行阶段由任务组成，这些任务可以是穿行的也可是并行的。任务的执行状态决定阶段执行状态。</p>
<p><strong>iPipe这一工具目前包含了标准的交付流水线</strong>，用户可以在iPipe中看到流水线的构建情况。在使用交付流水线的过程中，如果当前阶段失败，后面的阶段就不会继续进行，这样可以节省资源并且快速的发现问题，及时修复问题。</p>
<h4 id="3-3-2-插件化现有工具和服务"><a href="#3-3-2-插件化现有工具和服务" class="headerlink" title="3.3.2 插件化现有工具和服务"></a>3.3.2 插件化现有工具和服务</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292215685.png"></p>
<p>在交付流水线中执行各种任务时需要依赖很多工具和服务，比如maven，docker、jenkins、git等工具和服务。</p>
<p>我们通过一套<strong>标准的插件化开发规范</strong>将这些工具和服务集成到了流水线中，用户在使用流水线的过程中就可以很方便的使用这些插件和服务。如果流水线中没有想使用的插件、服务或工具，可以根据效率云提供的插件规范，自行扩展以满足项目需求。</p>
<h4 id="3-3-3-数据度量驱动过程改进"><a href="#3-3-3-数据度量驱动过程改进" class="headerlink" title="3.3.3 数据度量驱动过程改进"></a>3.3.3 数据度量驱动过程改进</h4><p>通过交付流水线，可以快速获取项目所有的数据和信息，如：一个版本从代码提交到交付上线的周期或者一个项目各个阶段发现的缺陷数量等等。</p>
<p>用户可以通过调用API获取数据来进行数据的度量，从而推动交付过程的改进。在后续的发展中，平台会识别项目中关键的数据指标并且自动化的形成更加鲜明的数据报表。这样就可以持续的进行数据度量，给个人及团队提供一个维度丰富的平台。</p>
<h2 id="4-持续交付方法与实践"><a href="#4-持续交付方法与实践" class="headerlink" title="4 持续交付方法与实践"></a>4 持续交付方法与实践</h2><h3 id="4-1-为什么要做持续交付"><a href="#4-1-为什么要做持续交付" class="headerlink" title="4.1 为什么要做持续交付"></a>4.1 为什么要做持续交付</h3><h4 id="4-1-1-软件交付流程"><a href="#4-1-1-软件交付流程" class="headerlink" title="4.1.1 软件交付流程"></a>4.1.1 软件交付流程</h4><p>传统软件交付流程通常包括四个步骤：</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271338880.png"></p>
<ol>
<li>首先业务人员会诞生一个软件的想法；</li>
<li>然后开发人员将这个想法变为一个产品或者功能；</li>
<li>经过测试人员的测试之后提交给用户使用并产生收益；</li>
<li>最后运维人员参与产品或功能的后期运维。</li>
</ol>
<h4 id="4-1-2-传统软件交付的问题和困境"><a href="#4-1-2-传统软件交付的问题和困境" class="headerlink" title="4.1.2 传统软件交付的问题和困境"></a>4.1.2 传统软件交付的问题和困境</h4><p>通过分析以上流程，可以发现一些传统软件交付流程<strong>存在的问题</strong>。</p>
<ol>
<li><strong>业务人员产生的需求文档沟通效率较低</strong>，有时会产生需求文档描述不明确、需求文档变更频繁等问题。</li>
<li>随着开发进度的推进，测试人员的工作量会逐步增加，测试工作的比重会越来越大。而且由于测试方法和测试工具有限，自动化测试程度低，<strong>无法很好地把控软件质量</strong>。</li>
<li>真实项目中运维的排期经常会被挤占，又因为手工运维繁琐复杂，<strong>时间和技术上的双重压迫</strong>会导致运维质量难以保证。</li>
</ol>
<p>因为存在以上问题，所以传统的软件交付经常会出现开发团队花费大量成本开发出的功能或产品并不能满足客户需求这一双输的局面。由此可以总结出传统的软件交付存在<strong>两个层面的困境：</strong></p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271339450.png"></p>
<p>从<strong>表现层</strong>来看，传统软件交付存在进度不可控；流程不可靠；环境不稳定；协作不顺畅等困境。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271339695.png"></p>
<p>表现层的问题其实都是由<strong>底层问题</strong>引起的，从根源上来说，存在分支冗余导致合并困难；缺陷过多导致阻塞测试；开发环境、测试环境、部署环境不统一导致的未知错误；代码提交版本混乱无法回溯；等待上线周期过长；项目部署操作复杂经常失败；上线之后出现问题需要紧急回滚；架构设计不合理导致发生错误之后无法准确定位等困境。</p>
<h4 id="4-1-3-持续交付的流程与优势"><a href="#4-1-3-持续交付的流程与优势" class="headerlink" title="4.1.3 持续交付的流程与优势"></a>4.1.3 持续交付的流程与优势</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271340504.png"></p>
<p>经过对传统软件交付问题的分析和总结，持续交付应运而生，持续交付是一系列开发实践方法，用来确保让代码能够快速、安全的部署到生产环境中。持续交付是一个完全自动化的过程，当业务开发完成的时候，可以做到一键部署。持续交付提供了一套更为完善的解决传统软件开发流程的方案。</p>
<ol>
<li>在需求阶段，抛弃了传统的需求文档的方式，使用便于开发人员理解的用户故事。</li>
<li>在开发测试阶段，做到持续集成，让测试人员尽早进入项目开始测试。</li>
<li>在运维阶段，打通开发和运维之间的通路，保持开发环境和运维环境的统一。</li>
</ol>
<p><strong>持续交付具备以下几个优势：</strong></p>
<blockquote>
<ol>
<li>持续交付能够有效缩短提交代码到正式部署上线的时间，降低部署风险。</li>
<li>持续交付能够自动的、快速的提供反馈，及时发现和修复缺陷。</li>
<li>持续交付让软件在整个生命周期内都处于可部署的状态。</li>
<li>持续交付能够简化部署步骤，使软件版本更加清晰。</li>
<li>持续交付能够让交付过程成为一种可靠的、可预期的、可视化的过程。</li>
</ol>
</blockquote>
<h4 id="4-1-4-敏捷开发与Devops"><a href="#4-1-4-敏捷开发与Devops" class="headerlink" title="4.1.4 敏捷开发与Devops"></a>4.1.4 敏捷开发与Devops</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271341155.png"></p>
<p>持续交付依靠<strong>敏捷开发（Agile）</strong>和<strong>Devops</strong>两个组件的支撑可以更好地发挥作用。</p>
<p>敏捷开发（Agile）主要作用于需求阶段和研发阶段。</p>
<p>Devops主要作用于开发测试和运维部署阶段。</p>
<blockquote>
<p>了解Devops的相关知识。</p>
<blockquote>
<ol>
<li><p>Devops的趋势</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271341165.png"></p>
<p>根据最近的一项集体研究，DevOps的市场在2020年创造了约50亿美元的产值，预计到2022年，这个数字将达到约66亿美元。随着Devops的影响力不断扩大，目前DevOps已经成为软件工程的主流模式。</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><p>Devops效能</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271342341.png"></p>
<p>Devops的效能跟发布频率、部署时间、平均修复故障的时间点、部署变更的失败率四个因素紧密相关。通常在高效的团队内，发布频率会达到每天多次发布、部署时间和平均修复故障时间都小于一小时，部署变更的失败率也能维持在15%以下。</p>
</li>
</ol>
</blockquote>
</blockquote>
<h4 id="4-1-5-软件交付能力指标"><a href="#4-1-5-软件交付能力指标" class="headerlink" title="4.1.5 软件交付能力指标"></a>4.1.5 软件交付能力指标</h4><p>在评价互联网公司的软件交付能力的时候，通常会使用两个指标：</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271343658.png"></p>
<ol>
<li>仅涉及一行代码的改动需要花费多少时间才能部署上线，这也是<strong>核心指标</strong>。</li>
<li>开发团队是否在以一种可重复、可靠的方式在执行软件交付。</li>
</ol>
<p>目前，国外的主流互联网企业部署周期都以分钟为单位， Amazon、Google这些头部互联网企业单日的部署频率都在20000次以上。国内以百度、阿里、腾讯三大互联网巨头的数据来看，单日部署的频率也达到了单日8000次以上。高频率的部署代表着能够更快更好的响应客户的需求。</p>
<h3 id="4-2-如何做到高效的持续交付"><a href="#4-2-如何做到高效的持续交付" class="headerlink" title="4.2 如何做到高效的持续交付"></a>4.2 如何做到高效的持续交付</h3><h4 id="4-2-1-持续交付方法"><a href="#4-2-1-持续交付方法" class="headerlink" title="4.2.1 持续交付方法"></a>4.2.1 持续交付方法</h4><p>为了能更好的做到高效的持续交付。在此我们提供了一个<strong>三层叠加的持续交付方法</strong>。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271345629.png"></p>
<p>首先最上层，持续交付的<strong>总目标是价值交付</strong>，要为用户交付有价值的内容。</p>
<p>然后第二层包含了业务、流程、组织三个维度。</p>
<p>在业务这一维度，主要通过精益、用户故事地图、看板三种方式来减少业务部门与开发部门的沟通困难。</p>
<p>在流程这一维度，主要集中于创建一个供开发、测试、运维人员使用的可靠、可重复的流水线，将这种流水线应用于项目的流程中。</p>
<p>在组织这一维度，要求加强团队协作，提高项目质量和项目改进能力，并且引入了成熟度模型用于评估团队的能力层级。</p>
<p>如果没有技术能力的支撑，仅依靠方法和指导思想不足以做到高效持续交付。所以<strong>第三层也是最重要的底层是技术层</strong>。技术层包括了基础架构和应用架构。<strong>基础架构</strong>引入了容器集群管理、研发工具平台、持续交付工具链。<strong>应用框架</strong>引入了浮现式设计、微服务框架还有能够抽离出来的配置化架构。</p>
<h4 id="4-2-2-持续交付、持续集成、持续部署的关系"><a href="#4-2-2-持续交付、持续集成、持续部署的关系" class="headerlink" title="4.2.2 持续交付、持续集成、持续部署的关系"></a>4.2.2 持续交付、持续集成、持续部署的关系</h4><p>要进一步构建可靠可重复的流水线，首先就是要理清持续交付、持续集成和持续部署三者之间的关系。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271348755.png"></p>
<p>简单来说<strong>持续集成和持续部署是持续交付的基础，持续交付包括但不限于持续集成和持续部署。</strong></p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271350656.png"></p>
<p>持续集成是包含了代码的编译、近代检查、单元测试任务的集成，虽然持续集成也能构成一条流水线，但是这条流水线并不完整，而且集成并没有明确的目标。</p>
<p>近几年得益于虚拟机技术和容器技术的迅速发展，持续部署也逐渐变得简单高效，能够运用这些工具快速将项目部署到例如准入环境、预生产环境等等各种环境中。</p>
<h4 id="4-2-3-如何构建一个可靠可重复的流水线"><a href="#4-2-3-如何构建一个可靠可重复的流水线" class="headerlink" title="4.2.3 如何构建一个可靠可重复的流水线"></a>4.2.3 如何构建一个可靠可重复的流水线</h4><p>在理清持续交付的关系后，需要通过持续交付来构建一条可靠可重复的流水线，构建这条流水线的目的是为了让开发人员、测试人员、运维人员能更好的协作完成整个项目并上线到生产环境。</p>
<p>通过对比传统流水线和持续交付流水线，能更加清晰地展现出持续交付流水线的强大。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271351747.png"></p>
<p>在传统流水线中，首先代码提交要用过填写表单的形式进行版本申请，然后开发人员在离线环境上手工进行代码编译和单元测试，单元测试完成后需要撰写对应的测试报告文档并且向上提测，在系统测试环节需要测试人员手动构建和部署测试环境，完成测试之后再次撰写测试报告，并且申请上线，在通过上线审批之后，在线上生产环境需要再次手动构建环境以及进行生产环境的测试，最终完成整体的开发。</p>
<p>在持续交付流水线中，代码合入到主干之后会直接触发自动编译，自动编译完成之后会进行初步的自动化单元测试、模块测试和系统测试，在测试过程中持续交付可以自动构建和部署环境。完成系统测试之后会将问题抛出来，解决完成后再次提测，会自动化的再次进行系统测试，通过系统测试之后可以一键操作进行项目发布，并进行预上线，在完成预上线后，可以再次进行一键操作完成正式生产环境的上线。</p>
<p>通过两种流水线的对比，可以看出来，持续交付的流水线有显著的优势。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271352109.png"></p>
<p>实际生产中的产品级流水线，可以视为多个模块级流水线的组合，多个模块级流水线组合成为复杂的多线并发的产品级流水线，最终可以完成整个项目的持续交付。</p>
<h4 id="4-2-4-交付流水线落地工具"><a href="#4-2-4-交付流水线落地工具" class="headerlink" title="4.2.4 交付流水线落地工具"></a>4.2.4 交付流水线落地工具</h4><p>交付流水线的落地需要依靠<strong>落地方案</strong>和<strong>落地工具</strong>，目前常用的落地方案有GoCD，这是thoughtworks的一个产品。还有目前广泛应用的Jenkins和Spinnakeer。</p>
<img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271354818.png" style="zoom:50%;" />

<img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271354355.png" style="zoom:50%;" />

<p>常用的交付流水线落地工具有效率云平台中的iPipe工具，在这个工具中可以根据需求创建流水线，并且将相关内容全都关联到流水线中，这样可以让开发人员、测试人员和运维人员在这个工具中直观的看到产品的状态以及质量情况。</p>
<h3 id="4-3-持续部署"><a href="#4-3-持续部署" class="headerlink" title="4.3 持续部署"></a>4.3 持续部署</h3><p>对于持续交付整体来说，持续部署非常重要。</p>
<h4 id="4-3-1-持续部署方案"><a href="#4-3-1-持续部署方案" class="headerlink" title="4.3.1 持续部署方案"></a>4.3.1 持续部署方案</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292215446.png"></p>
<p>容器技术目前是部署中最流行的技术，常用的持续部署方案有Kubernetes+Docker和Matrix系统两种。容器技术一经推出就被广泛的接受和应用，主要原因是对比传统的虚拟机技术有以下几个<strong>优点</strong>：</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292215715.png"></p>
<ol>
<li>容器技术上手简单，轻量级架构，体积很小。</li>
<li>容器技术的集合性更好，能更容易对环境和软件进行打包复制和发布。</li>
</ol>
<p>容器技术的引入为软件的部署带来了前所未有的改进，不但<strong>解决了复制和部署麻烦</strong>的问题，还能<strong>更精准的将环境中的各种依赖进行完整的打包。</strong></p>
<h4 id="4-3-2-部署原则"><a href="#4-3-2-部署原则" class="headerlink" title="4.3.2 部署原则"></a>4.3.2 部署原则</h4><p><strong>在持续部署管理的时候，需要遵循一定的原则，内容包括以下几点：</strong></p>
<ol>
<li>部署包全部来自统一的存储库。</li>
<li>所有的环境使用相同的部署方式。</li>
<li>所有的环境使用相同的部署脚本。</li>
<li>部署流程编排阶梯式晋级，即在部署过程中需要设置多个检查点，一旦发生问题可以有序的进行回滚操作。</li>
<li>整体部署由运维人员执行。</li>
<li>仅通过流水线改变生产环境，防止配置漂移。</li>
<li>不可变服务器。部署方式采用蓝绿部署或金丝雀部署。</li>
</ol>
<h4 id="4-3-3-部署层次"><a href="#4-3-3-部署层次" class="headerlink" title="4.3.3 部署层次"></a>4.3.3 部署层次</h4><p>部署层次的设置对于部署管理来说也是非常重要的。首先要明确部署的目的并不是部署一个可工作的软件，而是<strong>部署一套可正常运行的环境</strong>。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271634406.png"></p>
<p><strong>完整的镜像部署包括三个环节：Build – Ship – Run。</strong></p>
<p>Build跟传统的编译类似，将软件编译形成RPM包或者Jar包。</p>
<p>Ship则是将所需的第三方依赖和第三方插件安装到环境中。</p>
<p>Run就是在不同的地方启动整套环境。</p>
<p>制作完成部署包之后，每次需要变更软件或者第三方依赖、插件升级的时候，不需要重新打包，直接更新部署包即可。</p>
<h4 id="4-3-4-不可变服务器"><a href="#4-3-4-不可变服务器" class="headerlink" title="4.3.4 不可变服务器"></a>4.3.4 不可变服务器</h4><p>在部署原则中提到的不可变服务器原则对于部署管理来说非常重要。不可变服务器<strong>是技术逐步演化的结果。</strong></p>
<p>在早期阶段，软件的部署是在物理机上进行的，每一台服务器的网络、存储、软件环境都是不同的，物理机的不稳定让环境重构变得异常困难。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271635334.png"></p>
<p>后来逐渐发展为虚拟机部署，在虚拟机上借助流程化的部署能较好的构建软件环境，但是第三方依赖库的重构不稳定为整体部署带来了困难。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111292216469.png"></p>
<p>现阶段使用容器部署不但继承和优化了虚拟机部署的优点，而且很好的解决了第三方依赖库的重构问题，容器部署就像一个集装箱，直接把所有需要的内容全部打包进行复制和部署。</p>
<h4 id="4-3-5-蓝绿部署和金丝雀部署"><a href="#4-3-5-蓝绿部署和金丝雀部署" class="headerlink" title="4.3.5 蓝绿部署和金丝雀部署"></a>4.3.5 蓝绿部署和金丝雀部署</h4><p>在部署原则中提到两大部署方式分别为蓝绿部署和金丝雀部署。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271635700.png"></p>
<p><strong>蓝绿部署</strong>是指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速的将用户环境切回旧版本，并对新版本进行修复和调整。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271636728.png"></p>
<p><strong>金丝雀部署</strong>是指当有新版本发布的时候，先让少量的用户使用新版本并且观察新版本是否存在问题，如果出现问题，就及时处理并重新发布，如果一切正常，就稳步的将新版本适配给所有的用户。</p>
<h4 id="4-3-6-服务描述"><a href="#4-3-6-服务描述" class="headerlink" title="4.3.6 服务描述"></a>4.3.6 服务描述</h4><p>服务描述要实现的目标是当软件部署到不同的环境中时，通过服务描述来<strong>规避环境配置的差异</strong>。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637518.png"></p>
<p>在服务描述中，通常会对不同的环境下所需的配置进行描述，例如所需要的CPU、内存、网络等。当实际部署的时候，如果出现环境差异，调度工具就可以按照服务描述的配置发放资源，使环境能够正常运行。</p>
<h4 id="4-3-7-流程控制"><a href="#4-3-7-流程控制" class="headerlink" title="4.3.7 流程控制"></a>4.3.7 流程控制</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637506.png"></p>
<p>在部署阶段，为了防止意外问题的发生，会在一些环节<strong>加入人工审核</strong>。例如在灰度发布工具中，就会先对线上机器进行分组部署，然后由人工去分组检查，如果没有问题，就进行下一组的部署，如果出现问题，人工就可以及时的进行回滚操作，避免问题扩大到更多地线上环境中。</p>
<h4 id="4-3-8-数据度量和分析"><a href="#4-3-8-数据度量和分析" class="headerlink" title="4.3.8 数据度量和分析"></a>4.3.8 数据度量和分析</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271637498.png"></p>
<p>在完成持续部署或持续交付之后，需要结合多个维度的数据对项目整体的<strong>研发效率和部署效率进行分析</strong>。例如通过交付时间周期的长短变化来反映流水线为团队带来的价值。再比如通过筛选和展示团队的相关数据，方便团队来进行决策。还有通过环比汇总数据来分析变化的趋势。系统也会通过数据的自动分析和异常报表监控一些关键指标，一旦关键数据出现问题，系统能够及时联系关键人员关注。</p>
<p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/BlogPictures/202111271640201.png"></p>
<p>通过以上的例子能够发现，<strong>持续交付与量化驱动改进是密不可分的</strong>，团队能够在度量中发现问题，在度量中看到进步。持续交付就是这样一个不断改进不断优化的过程，通过数据可以量化产出并且指引团队找到痛点并且进一步的深化改进。</p>
<!-- flag of hidden posts --></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.ckxgzxa.top">残魁斜罡</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.ckxgzxa.top/bitTraingClub1.html">https://www.ckxgzxa.top/bitTraingClub1.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.ckxgzxa.top" target="_blank">技术匝记簿</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060211788.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.png" alt="微信扫码"/></a><div class="post-qr-code-desc">微信扫码</div></li><li class="reward-item"><a href="https://qr.alipay.com/lpx08506gp8hbu7m1bih892" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="支付宝扫码"/></a><div class="post-qr-code-desc">支付宝扫码</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">残魁斜罡</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">68</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">20</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ckxgzxa"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ckxgzxa" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:ckxgzxa@ckxgzxa.top" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://t.me/ckxgzxa" target="_blank" title="Telegram"><i class="fab fa-telegram" style="color: #0088cc;"></i></a><a class="social-icon" href="https://twitter.com/ckxgzxabest" target="_blank" title="Twitter"><i class="fab fa-twitter" style="color: #1da1f2;"></i></a><a class="social-icon" href="https://www.instagram.com/ckxgzxa" target="_blank" title="Instagram"><i class="fab fa-instagram" style="color: #e1306c;"></i></a><a class="social-icon" href="https://weibo.com/u/5657042189" target="_blank" title="Weibo"><i class="fab fa-weibo" style="color: #e6162d;"></i></a><a class="social-icon" href="/img/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BA%8C%E7%BB%B4%E7%A0%81.jpg" target="_blank" title="Wechat"><i class="fab fa-brands fa-weixin" style="color: #7bb32e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">有朋自远方来，不亦乐乎!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%99%BE%E5%BA%A6%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5Step1"><span class="toc-number">1.</span> <span class="toc-text">百度高效研发实战训练营Step1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1 设计方法与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 软件设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-clean-code"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 clean code</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E9%87%8D%E6%9E%84"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 重构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%85%8D%E7%BD%AE%E5%8C%96%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 配置化架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E8%84%9A%E6%9C%AC"><span class="toc-number">1.2.</span> <span class="toc-text">2. 高效研发流程脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%8E%E4%BA%A7%E5%93%81%E7%9B%AE%E6%A0%87%E5%88%B0%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF%E5%9B%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 从产品目标到产品路线图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E4%BB%8E%E4%BA%A7%E5%93%81%E8%B7%AF%E7%BA%BF%E5%9B%BE%E5%88%B0%E5%8F%91%E5%B8%83%E8%AE%A1%E5%88%92"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 从产品路线图到发布计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E4%BB%8E%E5%8F%91%E5%B8%83%E8%AE%A1%E5%88%92%E5%88%B0%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 从发布计划到迭代计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BB%8E%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92%E5%88%B0%E8%BF%AD%E4%BB%A3%E7%9A%84%E8%90%BD%E5%9C%B0%E6%89%A7%E8%A1%8C"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 从迭代计划到迭代的落地执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A0%94%E5%8F%91%E5%B7%A5%E5%85%B7%E9%93%BE%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.</span> <span class="toc-text">3 研发工具链介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-iCafe"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 项目管理工具: iCafe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E9%9C%80%E6%B1%82%E7%AE%A1%E7%90%86"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">3.1.1 需求管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E8%BF%AD%E4%BB%A3%E8%AE%A1%E5%88%92"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">3.1.2 迭代计划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E8%BF%9B%E5%BA%A6%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">3.1.3 进度追踪</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E6%8C%81%E7%BB%AD%E6%94%B9%E8%BF%9B"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">3.1.4 持续改进</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-iCode"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 代码管理工具:iCode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">3.2.1 工作流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E4%B8%BB%E5%B9%B2%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">1.  基于主干的工作流</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E5%88%86%E6%94%AF%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">2. 基于分支的工作流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E8%AF%84%E5%AE%A1"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.2.2 评审</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BA%A4%E4%BB%98%E5%B9%B3%E5%8F%B0-iPipe"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.3 交付平台:iPipe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%9B%BA%E5%8C%96%E7%AB%AF%E5%88%B0%E7%AB%AF%E7%9A%84%E4%BA%A4%E4%BB%98%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">3.3.1 固化端到端的交付流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E6%8F%92%E4%BB%B6%E5%8C%96%E7%8E%B0%E6%9C%89%E5%B7%A5%E5%85%B7%E5%92%8C%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">3.3.2 插件化现有工具和服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E6%95%B0%E6%8D%AE%E5%BA%A6%E9%87%8F%E9%A9%B1%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%94%B9%E8%BF%9B"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">3.3.3 数据度量驱动过程改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.4.</span> <span class="toc-text">4 持续交付方法与实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 为什么要做持续交付</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-%E8%BD%AF%E4%BB%B6%E4%BA%A4%E4%BB%98%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">4.1.1 软件交付流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-%E4%BC%A0%E7%BB%9F%E8%BD%AF%E4%BB%B6%E4%BA%A4%E4%BB%98%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E5%9B%B0%E5%A2%83"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">4.1.2 传统软件交付的问题和困境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E7%9A%84%E6%B5%81%E7%A8%8B%E4%B8%8E%E4%BC%98%E5%8A%BF"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">4.1.3 持续交付的流程与优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E4%B8%8EDevops"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">4.1.4 敏捷开发与Devops</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-%E8%BD%AF%E4%BB%B6%E4%BA%A4%E4%BB%98%E8%83%BD%E5%8A%9B%E6%8C%87%E6%A0%87"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">4.1.5 软件交付能力指标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%AB%98%E6%95%88%E7%9A%84%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 如何做到高效的持续交付</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">4.2.1 持续交付方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E6%8C%81%E7%BB%AD%E4%BA%A4%E4%BB%98%E3%80%81%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E3%80%81%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">4.2.2 持续交付、持续集成、持续部署的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%9D%A0%E5%8F%AF%E9%87%8D%E5%A4%8D%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">4.2.3 如何构建一个可靠可重复的流水线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E4%BA%A4%E4%BB%98%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%90%BD%E5%9C%B0%E5%B7%A5%E5%85%B7"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4.2.4 交付流水线落地工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 持续部署</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-1-%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">4.3.1 持续部署方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-%E9%83%A8%E7%BD%B2%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">4.3.2 部署原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-3-%E9%83%A8%E7%BD%B2%E5%B1%82%E6%AC%A1"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">4.3.3 部署层次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-4-%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4.3.4 不可变服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-5-%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2%E5%92%8C%E9%87%91%E4%B8%9D%E9%9B%80%E9%83%A8%E7%BD%B2"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">4.3.5 蓝绿部署和金丝雀部署</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-%E6%9C%8D%E5%8A%A1%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">4.3.6 服务描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-7-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">4.3.7 流程控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-8-%E6%95%B0%E6%8D%AE%E5%BA%A6%E9%87%8F%E5%92%8C%E5%88%86%E6%9E%90"><span class="toc-number">1.4.3.8.</span> <span class="toc-text">4.3.8 数据度量和分析</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/OracleDB02.html" title="2. Oracle学习笔记-Oracle的体系结构"><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060210380.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2. Oracle学习笔记-Oracle的体系结构"/></a><div class="content"><a class="title" href="/OracleDB02.html" title="2. Oracle学习笔记-Oracle的体系结构">2. Oracle学习笔记-Oracle的体系结构</a><time datetime="2023-12-04T15:04:25.000Z" title="发表于 2023-12-04 23:04:25">2023-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/OracleDB01.html" title="1.Oracle学习笔记-Oracle 19c概述"><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060212846.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1.Oracle学习笔记-Oracle 19c概述"/></a><div class="content"><a class="title" href="/OracleDB01.html" title="1.Oracle学习笔记-Oracle 19c概述">1.Oracle学习笔记-Oracle 19c概述</a><time datetime="2023-12-02T19:41:37.000Z" title="发表于 2023-12-03 03:41:37">2023-12-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/road2docker04.html" title="04.Docker Compose"><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060211788.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="04.Docker Compose"/></a><div class="content"><a class="title" href="/road2docker04.html" title="04.Docker Compose">04.Docker Compose</a><time datetime="2023-08-13T05:37:38.000Z" title="发表于 2023-08-13 13:37:38">2023-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/road2docker03.html" title="03.Dockerfile"><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060210380.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="03.Dockerfile"/></a><div class="content"><a class="title" href="/road2docker03.html" title="03.Dockerfile">03.Dockerfile</a><time datetime="2023-08-12T16:06:58.000Z" title="发表于 2023-08-13 00:06:58">2023-08-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/road2docker02.html" title="02.Docker 镜像"><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312060213891.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="02.Docker 镜像"/></a><div class="content"><a class="title" href="/road2docker02.html" title="02.Docker 镜像">02.Docker 镜像</a><time datetime="2023-08-12T14:01:23.000Z" title="发表于 2023-08-12 22:01:23">2023-08-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 残魁斜罡</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><a href="http://beian.miit.gov.cn/" target="_blank">湘ICP备2021018734号</a><span class="footer-separator">|</span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43052102000188" target="_blank"><img src="/img/police_beian.png" alt="备案图标"/><span>湘公网安备 43052102000188号</span></a></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const loadUtterances = () => {
    let ele = document.createElement('script')
    ele.id = 'utterances_comment'
    ele.src = 'https://utteranc.es/client.js'
    ele.setAttribute('repo', 'CKXGZXA/GitPageComments')
    ele.setAttribute('issue-term', 'pathname')
    const nowTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'photon-dark' : 'github-light'
    ele.setAttribute('theme', nowTheme)
    ele.crossOrigin = 'anonymous'
    ele.async = true
    document.getElementById('utterances-wrap').appendChild(ele)
  }

  const utterancesTheme = theme => {
    const iframe = document.querySelector('.utterances-frame')
    if (iframe) {
      const theme = theme === 'dark' ? 'photon-dark' : 'github-light'
      const message = {
        type: 'set-theme',
        theme: theme
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es');
    }
  }

  btf.addGlobalFn('themeChange', utterancesTheme, 'utterances')

  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>