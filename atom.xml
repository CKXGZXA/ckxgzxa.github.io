<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术匝记簿</title>
  
  
  <link href="https://www.ckxgzxa.top/atom.xml" rel="self"/>
  
  <link href="https://www.ckxgzxa.top/"/>
  <updated>2023-12-07T19:38:01.960Z</updated>
  <id>https://www.ckxgzxa.top/</id>
  
  <author>
    <name>残魁斜罡</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3. Oracle学习笔记-SQL语言基础</title>
    <link href="https://www.ckxgzxa.top/OracleDB03.html"/>
    <id>https://www.ckxgzxa.top/OracleDB03.html</id>
    <published>2023-12-05T12:29:33.000Z</published>
    <updated>2023-12-07T19:38:01.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL语言基础"><a href="#SQL语言基础" class="headerlink" title="SQL语言基础"></a>SQL语言基础</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRSQL语言基础--&gt;SQL概述SQL语言基础--&gt;用户模式SQL语言基础--&gt;数据定义SQL语言基础--&gt;数据查询SQL语言基础--&gt;数据更新SQL语言基础--&gt;空值的处理  </pre></div><h3 id="1-SQL-概述"><a href="#1-SQL-概述" class="headerlink" title="1 SQL 概述"></a>1 <code>SQL</code> 概述</h3><p><strong><code>SQL</code></strong>（Structured Query Language）: 结构化查询语言, 是关系数据库的标准语言</p><p>SQL是一个通用的、功能极强的关系数据库语言</p><h4 id="1-1-SQL-的特点"><a href="#1-1-SQL-的特点" class="headerlink" title="1.1 SQL 的特点"></a>1.1 SQL 的特点</h4><h5 id="1-1-1-综合统一"><a href="#1-1-1-综合统一" class="headerlink" title="1.1.1 综合统一"></a>1.1.1 综合统一</h5><ul><li>集数据定义语言（DDL），数据操纵语言（DML），数据控制语言（DCL）功能于一体。</li><li>可以独立完成数据库生命周期中的全部活动：<ul><li>定义和修改、删除关系模式，定义和删除视图，插入数据，建立数据库;</li><li>对数据库中的数据进行查询和更新;</li><li>数据库重构和维护</li><li>数据库安全性、完整性控制，以及事务控制</li><li>嵌入式SQL和动态SQL定义</li></ul></li><li>用户数据库投入运行后，可根据需要随时逐步修改模式，不影响数据库的运行。</li><li>数据操作符统一</li></ul><h5 id="1-1-2-高度非过程化"><a href="#1-1-2-高度非过程化" class="headerlink" title="1.1.2 高度非过程化"></a>1.1.2 高度非过程化</h5><p>非关系数据模型的数据操纵语言“面向过程”，必须指定存取路径。<br><code>SQL</code>只要提出“<u>做什么</u>”，无须了解存取路径。<br>存取路径的选择以及SQL的操作过程由系统 <em>自动</em> 完成。</p><h5 id="1-1-3-面向集合的操作方式"><a href="#1-1-3-面向集合的操作方式" class="headerlink" title="1.1.3 面向集合的操作方式"></a>1.1.3 面向集合的操作方式</h5><p>非关系数据模型采用面向记录的操作方式，操作对象是一条记录；<br>SQL采用集合操作方式操作对象、查找结果可以是元组的集合，一次插入、删除、更新操作的对象可以是元组的集合</p><h5 id="1-1-4-以同一种语法结构提供多种使用方式"><a href="#1-1-4-以同一种语法结构提供多种使用方式" class="headerlink" title="1.1.4 以同一种语法结构提供多种使用方式"></a>1.1.4 以同一种语法结构提供多种使用方式</h5><p>SQL是 <strong>独立</strong> 的语言，能够独立地用于联机交互的使用方式；<br>SQL又是<strong>嵌入式</strong>语言SQL，能够嵌入到高级语言（例如C，C++，Java）程序中，供程序员设计程序时使用</p><h5 id="1-1-5-语言简介，易学易用"><a href="#1-1-5-语言简介，易学易用" class="headerlink" title="1.1.5 语言简介，易学易用"></a>1.1.5 语言简介，易学易用</h5><p>SQL功能极强，完成核心功能只用了9个动词。</p><div class="table-container"><table><thead><tr><th style="text-align:center">SQL功能</th><th>动词</th></tr></thead><tbody><tr><td style="text-align:center">数据查询</td><td><strong>SELECT</strong></td></tr><tr><td style="text-align:center">数据定义</td><td><strong>CREATE</strong>, <strong>DROP</strong>, <strong>ALTER</strong></td></tr><tr><td style="text-align:center">数据操作</td><td><strong>INSERT</strong>, <strong>UPDATE</strong>, <strong>DELETE</strong></td></tr><tr><td style="text-align:center">数据控制</td><td><strong>GRANT</strong>, <strong>REVOKE</strong></td></tr></tbody></table></div><h3 id="1-2-SQL-的基本概念"><a href="#1-2-SQL-的基本概念" class="headerlink" title="1.2 SQL 的基本概念"></a>1.2 <code>SQL</code> 的基本概念</h3><p><code>SQL</code> 支持关系数据库三级模式结构</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312052052739.png" alt=""></p><h4 id="1-2-1-基本表"><a href="#1-2-1-基本表" class="headerlink" title="1.2.1 基本表"></a>1.2.1 基本表</h4><ul><li>本身独立存在的表</li><li>SQL中一个关系就对应一个基本表</li><li>一个（或多个）基本表对应一个存储文件</li><li>一个表可以带若干索引</li></ul><h4 id="1-2-2-存储文件"><a href="#1-2-2-存储文件" class="headerlink" title="1.2.2 存储文件"></a>1.2.2 存储文件</h4><ul><li>逻辑结构组成了关系数据库的内模式</li><li>物理结构对用户是隐蔽的</li></ul><h4 id="1-2-3-视图"><a href="#1-2-3-视图" class="headerlink" title="1.2.3 视图"></a>1.2.3 视图</h4><ul><li>从一个或几个基本表导出的表</li><li>数据库中只存放视图的定义而不存放视图对应的数据</li><li>视图是一个虚表</li><li>用户可以在视图上再定义视图</li></ul><h3 id="2-用户模式"><a href="#2-用户模式" class="headerlink" title="2 用户模式"></a>2 用户模式</h3><ol><li><p>在oracle数据库中，数据对象是以模式为单位进行组织和管理的。模式是指一系列的逻辑数据结构或对象的集合。</p></li><li><p>模式与用户名相对应，一个模式只能对应<strong>一个</strong>用户，并且该模式名称与用户的名称相同，在一般的情况下，用户所创建的数据库对象都存储在同名的模式下。</p><p>在同一模式中数据对象的名称必须唯一。不同模式中的数据对象可以相同。</p><blockquote><p>例如：用户user1在数据库中创建test表对象，则test表放在user1模式中。用户user2创建test表对象，则放在user2模式中。</p></blockquote></li><li><p>在默认的情况下，用户引用对象是引用<strong>同名</strong>模式中的对象，如想要引用其他模式中的对象，则必须在引用对象的前面加上对象所属模式</p><blockquote><p>例如：用户 user1下有test表，用户user2下有test表，默认情况下用户user1访问test表，直接<code>select * from test</code>，但是如要访问user2下的test 则 <code>select * from user2.test</code>;</p></blockquote></li></ol><h3 id="3-数据定义"><a href="#3-数据定义" class="headerlink" title="3 数据定义"></a>3 数据定义</h3><h4 id="3-1-定义基本表"><a href="#3-1-定义基本表" class="headerlink" title="3.1 定义基本表"></a>3.1 定义基本表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[ <span class="operator">&lt;</span>列级完整性约束条件<span class="operator">&gt;</span> ]</span><br><span class="line">[,<span class="operator">&lt;</span>列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span>[ <span class="operator">&lt;</span>列级完整性约束条件<span class="operator">&gt;</span>]] …</span><br><span class="line">[,<span class="operator">&lt;</span>表级完整性约束条件<span class="operator">&gt;</span>] );</span><br></pre></td></tr></table></figure><p><strong>&lt;表名&gt;</strong>：所要定义的基本表的名字<br><strong>&lt;列名&gt;</strong>：组成该表的各个属性（列）<br><strong>&lt;列级完整性约束条件&gt;</strong>：涉及相应属性列的完整性约束条件<br><strong>&lt;表级完整性约束条件&gt;</strong>：涉及一个或多个属性列的完整性约束条件<br>如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可<br>以定义在表级。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建立“学生”表Student。学号是主码，姓名取值唯一。</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(</span><br><span class="line">sno <span class="type">char</span>(<span class="number">9</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">sname <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">ssex <span class="type">char</span>(<span class="number">2</span>),</span><br><span class="line">sage <span class="type">SMALLINT</span>,</span><br><span class="line">sdept <span class="type">char</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 建立一个“课程”表Course</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> course(</span><br><span class="line">cno <span class="type">char</span>(<span class="number">4</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">cname <span class="type">char</span>(<span class="number">40</span>),</span><br><span class="line">cpno <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">ccredit <span class="type">SMALLINT</span>,</span><br><span class="line"><span class="keyword">FOREIGN</span> key(cpno) <span class="keyword">REFERENCES</span> course(cno)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 建立一个学生选课表SC</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sc(</span><br><span class="line">sno <span class="type">char</span>(<span class="number">9</span>),</span><br><span class="line">cno <span class="type">char</span>(<span class="number">4</span>),</span><br><span class="line">grade <span class="type">SMALLINT</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(sno,cno),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (sno) <span class="keyword">REFERENCES</span> student(sno),</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (cno) <span class="keyword">REFERENCES</span> course(cno)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="3-2-Oracle中的数据类型"><a href="#3-2-Oracle中的数据类型" class="headerlink" title="3.2 Oracle中的数据类型"></a>3.2 Oracle中的数据类型</h4><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>CHAR(n), CHARACTER(N)</strong></td><td>长度为n的定长字符串</td></tr><tr><td style="text-align:center"><strong>VARCHAR(n)</strong>, <strong>CHARACTERVARYING(n)</strong></td><td>最大长度为n的变长字符串</td></tr><tr><td style="text-align:center"><strong>CLOB</strong></td><td>字符串大对象</td></tr><tr><td style="text-align:center"><strong>BLOB</strong></td><td>二进制大对象</td></tr><tr><td style="text-align:center"><strong>INT</strong>, <strong>INTEGER</strong></td><td>长整数(4字节)</td></tr><tr><td style="text-align:center"><strong>SMALLINT</strong></td><td>短整数(2字节)</td></tr><tr><td style="text-align:center"><strong>BIGINT</strong></td><td>大整数（8字节)</td></tr><tr><td style="text-align:center"><strong>NUMERIC(p, d)</strong></td><td>定点数，由p位数字(不包括符号、小数点)组成,小数后面有d位数字</td></tr><tr><td style="text-align:center"><strong>DECIMAL(p, d)</strong>, <strong>DEC(p, d)</strong></td><td>同NUMERIC</td></tr><tr><td style="text-align:center"><strong>REAL</strong></td><td>取决于机器精度的单精度浮点数</td></tr><tr><td style="text-align:center"><strong>DOUBLE PRECISION</strong></td><td>取决于机器精度的双精度浮点数</td></tr><tr><td style="text-align:center"><strong>FLOAT(n)</strong></td><td>可选精度的浮点数,精度至少为n位数字</td></tr><tr><td style="text-align:center"><strong>BOOLEAN</strong></td><td>逻辑布尔量</td></tr><tr><td style="text-align:center"><strong>DATE</strong></td><td>日期，包含年、月、日，格式为YYYY-MM-DD</td></tr><tr><td style="text-align:center"><strong>TIME</strong></td><td>时间，包含一日的时、分、秒，格式为HH:MM:SS</td></tr><tr><td style="text-align:center"><strong>TIMESTAMP</strong></td><td>时间戳类型</td></tr><tr><td style="text-align:center"><strong>INTERVAL</strong></td><td>时间间隔类型</td></tr></tbody></table></div><h4 id="3-3-修改基本表"><a href="#3-3-修改基本表" class="headerlink" title="3.3 修改基本表"></a>3.3 修改基本表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">ADD</span>[<span class="keyword">COLUMN</span>] <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> [ 完整性约束 ] ]</span><br><span class="line">[ <span class="keyword">ADD</span> <span class="operator">&lt;</span>表级完整性约束<span class="operator">&gt;</span>]</span><br><span class="line">[ <span class="keyword">DROP</span> [ <span class="keyword">COLUMN</span> ] <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [CASCADE<span class="operator">|</span> RESTRICT] ]</span><br><span class="line">[ <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>[ RESTRICT <span class="operator">|</span> CASCADE ] ]</span><br><span class="line">[<span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> ] ;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 向Student表增加“入学时间”列，其数据类型为日期型</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> s_entrance <span class="type">DATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student modify sage <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 增加课程名称必须取唯一值的约束条件。</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> course <span class="keyword">ADD</span> <span class="keyword">unique</span>(cname)</span><br></pre></td></tr></table></figure><h3 id="4-数据查询"><a href="#4-数据查询" class="headerlink" title="4 数据查询"></a>4 数据查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>] <span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>目标列表达式<span class="operator">&gt;</span>] …</span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> ]…<span class="operator">|</span>(<span class="keyword">SELECT</span> 语句) [<span class="keyword">AS</span>]<span class="operator">&lt;</span>别名<span class="operator">&gt;</span></span><br><span class="line">[ <span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;</span> [ <span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ] ]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;</span> [ <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></table></figure><p><code>SELECT</code>子句：指定要显示的属性列.<br><code>FROM</code>子句：指定查询对象（基本表或视图）.<br><code>WHERE</code>子句：指定查询条件.<br><code>GROUP BY</code>子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中作用聚集函数.<br><code>HAVING</code>短语：只有满足指定条件的组才予以输出.<br><code>ORDER BY</code>子句：对查询结果表按指定列值的升序或降序排序.</p><h4 id="4-1-单表查询"><a href="#4-1-单表查询" class="headerlink" title="4.1 单表查询"></a>4.1 单表查询</h4><h5 id="4-1-1-选择表中的若干列"><a href="#4-1-1-选择表中的若干列" class="headerlink" title="4.1.1 选择表中的若干列"></a>4.1.1 选择表中的若干列</h5><ul><li><p>查询指定列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询全体学生的学号与姓名。</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,sname <span class="keyword">FROM</span> student</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询全体学生的姓名、学号、所在系。</span></span><br><span class="line"><span class="keyword">SELECT</span> sname,sno,sdept <span class="keyword">FROM</span> STUDENT </span><br></pre></td></tr></table></figure></li><li><p>查询全部列</p><p>选出所有属性列：在<code>SELECT</code>关键字后面列出所有列名 <em>或</em> 将<code>&lt;目标列表达式&gt;</code>指定为 <code>*</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询全体学生的详细记录</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,sname,ssex,sage,sdept <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure></li><li><p>查询经过计算的值, 同时可以使用列别名更改输出列名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查全体学生的姓名及其出生年份。</span></span><br><span class="line"><span class="keyword">SELECT</span> sname,<span class="number">2023</span><span class="operator">-</span>sage <span class="keyword">FROM</span> student</span><br><span class="line"><span class="comment">-- 查询全体学生的姓名、出生年份和所在的院系，要求用小写字母表示系名。</span></span><br><span class="line"><span class="keyword">SELECT</span> sname 姓名,<span class="number">2023</span><span class="operator">-</span>sage <span class="keyword">as</span> 出生年份,<span class="built_in">LOWER</span>(sdept) <span class="keyword">as</span> 所在院系 <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure></li></ul><h5 id="4-1-2-选择表中的若干元组"><a href="#4-1-2-选择表中的若干元组" class="headerlink" title="4.1.2 选择表中的若干元组"></a>4.1.2 选择表中的若干元组</h5><ul><li><p>消除取值重复的行，如果没有指定DISTINCT关键词，则缺省为ALL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询选修了课程的学生学号。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sno <span class="keyword">FROM</span> sc</span><br></pre></td></tr></table></figure></li><li><p>查询满足条件的元组</p><p>常用的查询条件如下表</p><p>| 查询条件           | 谓词                                                         |<br>| ————————— | —————————————————————————————— |<br>| 比较               | <code>=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>, <code>&lt;&gt;</code>, <code>!&gt;</code>, <code>!&lt;</code>; <code>NOT</code>+上述运算符 |<br>| 确定范围           | <code>BETWEEN AND</code>, <code>NOT BETWEEN AND</code>                             |<br>| 确定集合           | <code>IN</code>, <code>NOT IN</code>                                               |<br>| 字符匹配           | <code>LIKE</code>, <code>NOT LIKE</code>                                           |<br>| 空值               | <code>IS NULL</code>, <code>IS NOT NULL</code>                                     |<br>| 多重条件(逻辑运算) | <code>AND</code>, <code>OR</code>, <code>NOT</code>                                           |</p><ol><li><p>比较大小</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询计算机科学系全体学生的名单。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="comment">-- 查询所有年龄在20岁以下的学生姓名及其年龄。</span></span><br><span class="line"><span class="keyword">SELECT</span> sname,sage <span class="keyword">FROM</span>  student <span class="keyword">WHERE</span> sage<span class="operator">&lt;</span><span class="number">20</span></span><br><span class="line"><span class="comment">-- 查询考试成绩有不及格的学生的学号。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>  sno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> grade<span class="operator">&gt;=</span><span class="number">60</span></span><br></pre></td></tr></table></figure></li><li><p>确定范围</p><p><strong>谓词</strong>: <code>BETWEEN … AND …</code> 和 <code>NOT BETWEEN … AND …</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄在20~23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄</span></span><br><span class="line"><span class="keyword">SELECT</span> sname,sdept,sage <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sage<span class="operator">&gt;=</span><span class="number">20</span> <span class="keyword">AND</span> sage<span class="operator">&lt;=</span><span class="number">23</span></span><br><span class="line"><span class="keyword">SELECT</span> sname,sdept,sage <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sage <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span></span><br><span class="line"><span class="comment">-- 查询年龄不在20~23岁之间的学生姓名、系别和年龄</span></span><br><span class="line"><span class="keyword">SELECT</span> sname,sdept,sage <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sage <span class="keyword">not</span> <span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">23</span></span><br><span class="line"><span class="keyword">SELECT</span> sname,sdept,sage <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sage<span class="operator">&lt;</span><span class="number">20</span> <span class="keyword">OR</span> sage<span class="operator">&gt;</span><span class="number">23</span></span><br></pre></td></tr></table></figure></li><li><p>确定集合</p><p><strong>谓词</strong> :  IN &lt;值表&gt;, NOT IN &lt;值表&gt;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">OR</span> sdept<span class="operator">=</span><span class="string">&#x27;MA&#x27;</span> <span class="keyword">OR</span> sdept <span class="operator">=</span> <span class="string">&#x27;IS&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="keyword">IN</span> (<span class="string">&#x27;CS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br><span class="line"><span class="comment">-- 查询既不是计算机科学系、数学系，也不是信息系的学生的姓名和性别。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">!=</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span>  sdept<span class="operator">!=</span><span class="string">&#x27;MA&#x27;</span> <span class="keyword">AND</span> sdept <span class="operator">!=</span> <span class="string">&#x27;IS&#x27;</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="string">&#x27;CS&#x27;</span>,<span class="string">&#x27;MA&#x27;</span>,<span class="string">&#x27;IS&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>字符匹配</p><p><strong>谓词</strong> : <code>[NOT] LIKE ‘&lt;匹配串&gt;’ [ESCAPE ‘ &lt;换码字符&gt;’]</code></p><blockquote><p>&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符<code>%</code>和<code>_</code> ;<br><code>%</code> （百分号） 代表任意长度（长度可以为0）的字符串<br>例如a%b表示以a开头，以b结尾的任意长度的字符串<br><code>_</code> （下横线） 代表任意单个字符。<br>例如a_b表示以a开头，以b结尾的长度为3的任意字符串</p></blockquote><ul><li><p>匹配串为固定字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询学号为201215121的学生的详细情况。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sno <span class="keyword">LIKE</span> <span class="string">&#x27;201215121&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>匹配串为含通配符的字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有姓刘学生的姓名、学号和性别。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sname <span class="keyword">LIKE</span> <span class="string">&#x27;刘_&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>使用换码字符可以将通配符转义为普通字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询DB_Design课程的课程号和学分。</span></span><br><span class="line"><span class="keyword">SELECT</span> Cno，Ccredit <span class="keyword">FROM</span> Course</span><br><span class="line"><span class="keyword">WHERE</span> Cname <span class="keyword">LIKE</span> <span class="string">&#x27;DB\_Design&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\ &#x27;</span> ;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>涉及空值的查询</p><p><strong>谓词</strong> : <code>IS NULL</code> 或 <code>IS NOT NULL</code></p><p>“<code>IS</code>” 不能用 “<code>=</code>” 代替</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 某些学生选修课程后没有参加考试，所以有选课记录，但没有考试成绩。</span></span><br><span class="line"><span class="comment">-- 查询缺少成绩的学生的学号和相应的课程号。</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,cno <span class="keyword">FROM</span> sc</span><br><span class="line"><span class="keyword">WHERE</span> grade <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="comment">-- 查所有有成绩的学生学号和课程号。</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,cno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> grade <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></li><li><p>多重条件查询</p><p>逻辑运算符：使用<code>`AND</code> 和 <code>OR</code> 来连接多个查询条件<br><code>AND</code> 的优先级高于 <code>OR</code>, 还可以用括号改变优先级</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询计算机系年龄在20岁以下的学生姓名。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT <span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span> sage<span class="operator">&lt;</span><span class="number">20</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h5 id="4-1-3-ORDER-BY-子句"><a href="#4-1-3-ORDER-BY-子句" class="headerlink" title="4.1.3 ORDER BY 子句"></a>4.1.3 <code>ORDER BY</code> 子句</h5><p>可以按<strong>一个</strong>或<strong>多个</strong>属性列排序;<br>升序：<code>ASC</code>; 降序：<code>DESC</code> ; <strong>缺省值</strong>为升序;<br>对于空值，排序时显示的次序由具体系统实现来决定</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- [例3.39]查询选修了3号课程的学生的学号及其成绩，查询结果按分数降序排列。</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,grade <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> cno<span class="operator">=</span><span class="string">&#x27;3&#x27;</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> grade <span class="keyword">DESC</span></span><br><span class="line"><span class="comment">-- [例3.40]查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> STUDENT <span class="keyword">ORDER</span> <span class="keyword">BY</span> sdept,sage <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><h5 id="4-1-4-聚集函数"><a href="#4-1-4-聚集函数" class="headerlink" title="4.1.4 聚集函数"></a>4.1.4 聚集函数</h5><table>  <thead>    <tr>      <th style="text-align: center;">函数</th>      <th style="text-align: center;">作用</th>    </tr>  </thead>  <tbody>    <tr>      <td>COUNT(*)</td>      <td>统计元组个数</td>    </tr>    <tr>      <td>COUNT([DISTINCT|ALL] &lt;列名&gt;)</td>      <td>统计一列中值的个数</td>    </tr>    <tr>      <td>SUM([DISTINCT|ALL] &lt;列名&gt;)</td>      <td>计算一列值的总和（此列必须为数值型）</td>    </tr>    <tr>      <td>AVG([DISTINCT|ALL] &lt;列名&gt;)</td>      <td>计算一列值的平均值（此列必须为数值型）</td>    </tr>    <tr>      <td>MAX([DISTINCT|ALL] &lt;列名&gt;)<br/>MIN([DISTINCT|ALL] &lt;列名&gt;)</td>      <td>求一列中的最大值和最小值</td>    </tr>  </tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询学生总人数。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student</span><br><span class="line"><span class="comment">-- 查询选修了课程的学生人数。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> sno) <span class="keyword">FROM</span> sc</span><br><span class="line"><span class="comment">-- 计算3号课程的学生平均成绩。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(grade) <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cno<span class="operator">=</span><span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="comment">-- 查询选修3号课程的学生最高分数。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">max</span>(grade) <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cno<span class="operator">=</span><span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="comment">-- 查询学生201215125选修课程的总学分数。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">sum</span>(course.CCREDIT)  <span class="keyword">FROM</span> sc,COURSE </span><br><span class="line"><span class="keyword">WHERE</span> sc.cno<span class="operator">=</span>course.cno <span class="keyword">AND</span> sc.sno<span class="operator">=</span><span class="string">&#x27;201215125&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="4-1-5-GROUP-BY-子句"><a href="#4-1-5-GROUP-BY-子句" class="headerlink" title="4.1.5 GROUP BY 子句"></a>4.1.5 <code>GROUP BY</code> 子句</h5><p>细化聚集函数的作用对象</p><ul><li>如果未对查询结果分组，聚集函数将作用于整个查询结果</li><li>对查询结果分组后，聚集函数将分别作用于每个组</li><li>按指定的一列或多列值分组，值相等的为一组</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求各个课程号及相应的选课人数。</span></span><br><span class="line"><span class="keyword">SELECT</span> cno,<span class="built_in">count</span>(sno) <span class="keyword">FROM</span> sc <span class="keyword">group</span> <span class="keyword">BY</span> cno</span><br><span class="line"><span class="comment">-- 查询选修了2门以上课程的学生学号。</span></span><br><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> sc  <span class="keyword">group</span> <span class="keyword">BY</span> sno <span class="keyword">HAVING</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;=</span><span class="number">2</span></span><br><span class="line"><span class="comment">-- 查询平均成绩大于等于90分的学生学号和平均成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> sno,<span class="built_in">avg</span>(grade) <span class="keyword">FROM</span> sc <span class="keyword">GROUP</span> <span class="keyword">BY</span> sno <span class="keyword">HAVING</span> <span class="built_in">avg</span>(grade)<span class="operator">&gt;=</span><span class="number">90</span></span><br></pre></td></tr></table></figure><blockquote><p><code>HAVING</code>短语与<code>WHERE</code>子句的区别：<strong>作用对象</strong>不同<br><code>WHERE</code>子句作用于<strong>基表</strong>或<strong>视图</strong>，从中选择满足条件的元组<br><code>HAVING</code>短语作用于<strong>组</strong>，从中选择满足条件的<strong>组</strong>。</p></blockquote><h4 id="4-2-连接查询"><a href="#4-2-连接查询" class="headerlink" title="4.2 连接查询"></a>4.2 连接查询</h4><p>连接查询：同时涉及两个以上的表的查询，<br>连接条件或连接谓词：用来连接两个表的条件，一般格式: <code>[&lt;表名1&gt;.]&lt;列名1&gt; &lt;比较运算符&gt; [&lt;表名2&gt;.]&lt;列名2&gt;[&lt;表名1&gt;.]&lt;列名1&gt; BETWEEN [&lt;表名2&gt;.]&lt;列名2&gt; AND [&lt;表名2&gt;.]&lt;列名3&gt;</code> ;<br>连接字段：连接谓词中的列名称;</p><p>连接条件中的各连接字段类型必须是可比的，但名字不必相同; </p><h5 id="4-2-1-等值连接查询"><a href="#4-2-1-等值连接查询" class="headerlink" title="4.2.1 等值连接查询"></a>4.2.1 等值连接查询</h5><p>等值连接：连接运算符为<code>=</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每个学生及其选修课程的情况</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.sno,stu.sname,stu.ssex,sc.cno,sc.grade <span class="keyword">FROM</span> student stu, sc <span class="keyword">WHERE</span> stu.sno <span class="operator">=</span> sc.sno;</span><br></pre></td></tr></table></figure><blockquote><p><strong>连接操作</strong>的执行过程</p><ol><li><strong>嵌套循环法</strong>（NESTED-LOOP）<br>首先在表1中找到第一个元组，然后从头开始扫描表2，逐一查找满足连接件的元组，找到后就将表1<br>中的第一个元组与该元组拼接起来，形成结果表中一个元组。<br>表2全部查找完后，再找表1中第二个元组，然后再从头开始扫描表2，逐一查找满足连接条件的元组，<br>找到后就将表1中的第二个元组与该元组拼接起来，形成结果表中一个元组。<br>重复上述操作，直到表1中的全部元组都处理完毕</li><li><strong>索引连接</strong>（INDEX-JOIN）<br>对表2按连接字段建立索引<br>对表1中的每个元组，依次根据其连接字段值查询表2的索引，从中找到满足条件的元组，找到后就<br>将表1中的第一个元组与该元组拼接起来，形成结果表中一个元组</li></ol></blockquote><h5 id="4-2-2-自然连接"><a href="#4-2-2-自然连接" class="headerlink" title="4.2.2 自然连接"></a>4.2.2 自然连接</h5><p>一条SQL语句可以同时完成选择和连接查询，这时<code>WHERE</code>子句是由连接谓词和选择谓词组成的复合条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询选修3号课程且成绩在90分以上的所有学生的学号和姓名。</span></span><br><span class="line"><span class="keyword">SELECT</span> stu.sno, stu.sname <span class="keyword">FROM</span> student stu, sc <span class="keyword">WHERE</span> stu.sno <span class="operator">=</span> sc.sno <span class="keyword">AND</span> cno <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">AND</span> sc.grade <span class="operator">&gt;</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure><p>执行过程:</p><ul><li>先从SC中挑选出Cno=’2’并且Grade&gt;90的元组形成一个中间关系</li><li>再和Student中满足连接条件的元组进行连接得到最终的结果关系</li></ul><h5 id="4-2-3-自身连接"><a href="#4-2-3-自身连接" class="headerlink" title="4.2.3 自身连接"></a>4.2.3 自身连接</h5><p>一个表与其自己进行连接, 需要给表起别名以示区别;<br>由于所有属性名都是同名属性，因此必须使用别名前缀.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每一门课的间接先修课（即先修课的先修课）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> c2.<span class="operator">*</span> <span class="keyword">FROM</span> course c1, course c2 <span class="keyword">WHERE</span> c1.cpno <span class="operator">=</span> c2.cno;</span><br></pre></td></tr></table></figure><h5 id="4-2-4-外连接"><a href="#4-2-4-外连接" class="headerlink" title="4.2.4 外连接"></a>4.2.4 外连接</h5><p>外连接与普通连接的区别</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312080124970.png" alt=""></p><ul><li>普通连接操作只输出满足连接条件的元组</li><li>外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出</li><li>左外连接<br>列出左边关系中所有的元组</li><li>右外连接<br>列出右边关系中所有的元组</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每个学生及其选修课程的情况</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno <span class="operator">=</span> sc.sno;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno <span class="operator">=</span> sc.sno;</span><br><span class="line"><span class="comment">-- 改用内连接</span></span><br><span class="line"><span class="keyword">SELECT</span> s.sno, s.sname, s.ssex,sc.cno, sc.grade <span class="keyword">FROM</span> student s <span class="keyword">INNER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> s.sno <span class="operator">=</span> sc.sno;</span><br></pre></td></tr></table></figure><h5 id="4-2-5-多表连接"><a href="#4-2-5-多表连接" class="headerlink" title="4.2.5 多表连接"></a>4.2.5 多表连接</h5><p>两个以上的表进行连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每个学生的学号、姓名、选修的课程名及成绩</span></span><br><span class="line"><span class="keyword">SELECT</span> s.sno, sname, cname, grade <span class="keyword">FROM</span> student s, sc, course c <span class="keyword">WHERE</span> s.sno<span class="operator">=</span>sc.sno <span class="keyword">AND</span> sc.cno<span class="operator">=</span>c.cno;</span><br><span class="line"><span class="comment">-- 使用join改造</span></span><br><span class="line"><span class="keyword">SELECT</span> s.sno, sname, cname, grade <span class="keyword">FROM</span> student s <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> s.sno<span class="operator">=</span>sc.sno <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> sc.cno<span class="operator">=</span>c.cno;</span><br></pre></td></tr></table></figure><h4 id="4-3-嵌套查询"><a href="#4-3-嵌套查询" class="headerlink" title="4.3 嵌套查询"></a>4.3 嵌套查询</h4><p>一个<code>SELECT-FROM-WHERE</code>语句称为一个查询块,<br>将一个查询块嵌套在另一个查询块的<code>WHERE</code>子句或<code>HAVING</code>短语的条件中的查询称为嵌套查询.</p><ul><li>上层的查询块称为外层查询或父查询</li><li>下层查询块称为内层查询或子查询</li><li>SQL语言允许多层嵌套查询, 即一个子查询中还可以嵌套其他子查询</li><li>子查询的限制<br>不能使用ORDER BY子句</li></ul><blockquote><p>嵌套查询求解方法</p><p><strong>不相关子查询</strong>：</p><p>子查询的查询条件不依赖于父查询：<br>由里向外 逐层处理。即每个子查询在上一级查询处理之前求解，子查询的结果用于建立其父查询的<br>查找条件。</p><p><strong>相关子查询</strong>：子查询的查询条件依赖于父查询</p><ul><li>首先取外层查询中表的第一个元组，根据它与内层查询相关的属性值处理内层查询，若WHERE<br>子句返回值为真，则取此元组放入结果表</li><li>然后再取外层表的下一个元组</li><li>重复这一过程，直至外层表全部检查完为止</li></ul></blockquote><h5 id="4-3-1-带有IN谓词的子查询"><a href="#4-3-1-带有IN谓词的子查询" class="headerlink" title="4.3.1 带有IN谓词的子查询"></a>4.3.1 带有<code>IN</code>谓词的子查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与“刘晨灿”在同一个系学习的学生。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sdept <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sname<span class="operator">=</span><span class="string">&#x27;刘晨灿&#x27;</span>);</span><br><span class="line"><span class="comment">-- JOIN 可以替代子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student s1 <span class="keyword">JOIN</span> student s2 <span class="keyword">ON</span> s1.sdept <span class="operator">=</span> s2.sdept <span class="keyword">AND</span> s2.sname<span class="operator">=</span><span class="string">&#x27;刘晨灿&#x27;</span>;</span><br><span class="line"><span class="comment">-- 用自身连接查询代替</span></span><br><span class="line"><span class="keyword">SELECT</span> s1.<span class="operator">*</span> <span class="keyword">FROM</span> student s1, student s2 <span class="keyword">WHERE</span> s1.sdept<span class="operator">=</span>s2.sdept <span class="keyword">AND</span> s2.sname<span class="operator">=</span><span class="string">&#x27;刘晨灿&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询选修了课程名为“信息系统” 的学生学号和姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> sno, sname <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> cno <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> cname<span class="operator">=</span><span class="string">&#x27;信息系统&#x27;</span></span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 用连接查询改造</span></span><br><span class="line"><span class="keyword">SELECT</span> s.sno, s.sname <span class="keyword">FROM</span> student s, sc, course c <span class="keyword">WHERE</span> s.sno <span class="operator">=</span> sc.sno <span class="keyword">AND</span> sc.cno<span class="operator">=</span>c.cno <span class="keyword">AND</span> c.cname<span class="operator">=</span><span class="string">&#x27;信息系统&#x27;</span>;</span><br><span class="line"><span class="comment">-- 用join</span></span><br><span class="line"><span class="keyword">SELECT</span> s.sno, s.sname <span class="keyword">FROM</span> student s <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> s.sno <span class="operator">=</span> sc.sno <span class="keyword">JOIN</span> course c <span class="keyword">ON</span> sc.cno<span class="operator">=</span>c.cno <span class="keyword">AND</span> c.cname<span class="operator">=</span><span class="string">&#x27;信息系统&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-带有比较运算符的子查询"><a href="#4-3-2-带有比较运算符的子查询" class="headerlink" title="4.3.2 带有比较运算符的子查询"></a>4.3.2 带有比较运算符的子查询</h5><p>当能确切知道内层查询返回单值时，可用比较运算符（&gt;，&lt;，=，&gt;=，&lt;=，!=或&lt; &gt;）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于一个学生只可能在一个系学习，则可以用 = 代替IN， 尽量不使用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">=</span> (<span class="keyword">SELECT</span> sdept <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sname<span class="operator">=</span><span class="string">&#x27;刘晨灿&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 找出每个学生超过他选修课程平均成绩的课程号。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc x <span class="keyword">WHERE</span> grade <span class="operator">&gt;=</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(grade) <span class="keyword">FROM</span> sc y <span class="keyword">WHERE</span> y.sno<span class="operator">=</span>x.sno</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="4-3-3-带有ANY（SOME）或ALL谓词的子查询"><a href="#4-3-3-带有ANY（SOME）或ALL谓词的子查询" class="headerlink" title="4.3.3 带有ANY（SOME）或ALL谓词的子查询"></a>4.3.3 带有<code>ANY（SOME）</code>或<code>ALL</code>谓词的子查询</h5><p>使用ANY或ALL谓词时必须同时使用比较运算, 语义为：</p><blockquote><p><code>ANY</code> 大于子查询结果中的某个值<br><code>ALL</code> 大于子查询结果中的所有值<br><code>&lt; ANY</code> 小于子查询结果中的某个值<br><code>&lt; ALL</code> 小于子查询结果中的所有值<br><code>= ANY</code> 大于等于子查询结果中的某个值<br><code>= ALL</code> 大于等于子查询结果中的所有值</p><p><code>&lt;= ANY</code> 小于等于子查询结果中的某个值<br><code>&lt;= ALL</code> 小于等于子查询结果中的所有值<br><code>= ANY</code> 等于子查询结果中的某个值（通常没有实际意义）<br><code>= ALL</code> 等于子查询结果中的所有值（通常没有实际意义）<br><code>!=（或&lt;&gt;）</code> ANY 不等于子查询结果中的某个值<br><code>!=（或&lt;&gt;）</code> ALL 不等于子查询结果中的任何一个值</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, sage</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span> sage <span class="operator">&lt;</span> <span class="keyword">ANY</span> (</span><br><span class="line"><span class="keyword">SELECT</span> sage <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 用聚集函数实现</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, sage</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span> sage <span class="operator">&lt;</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(sage) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询非计算机科学系中比计算机科学系所有学生年龄小的学生姓名和年龄</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, sage</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span> sage <span class="operator">&lt;</span> <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span> sage <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 用聚集函数来实现</span></span><br><span class="line"><span class="keyword">SELECT</span> sname, sage</span><br><span class="line"><span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">&lt;&gt;</span> <span class="string">&#x27;CS&#x27;</span> <span class="keyword">AND</span> sage <span class="operator">&lt;</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(sage) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="4-3-4-带有EXISTS谓词的子查询"><a href="#4-3-4-带有EXISTS谓词的子查询" class="headerlink" title="4.3.4 带有EXISTS谓词的子查询"></a>4.3.4 带有<code>EXISTS</code>谓词的子查询</h5><ul><li>带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。<br>若内层查询结果非空，则外层的WHERE子句返回真值<br>若内层查询结果为空，则外层的WHERE子句返回假值</li><li>由EXISTS引出的子查询，其目标列表达式通常都用 <code>*</code> ，因为带EXISTS的子查询只返回真值或假<br>值，给出列名无实际意义。</li><li><code>NOT EXISTS</code>谓词<br>若内层查询结果非空，则外层的WHERE子句返回假值<br>若内层查询结果为空，则外层的WHERE子句返回真值</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询所有选修了1号课程的学生姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> sname <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> student.sno<span class="operator">=</span>sc.sno <span class="keyword">AND</span> cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询与“刘晨灿”在同一个系学习的学生。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student s1 <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> sdept <span class="keyword">FROM</span> student s2 <span class="keyword">WHERE</span> s1.sdept<span class="operator">=</span>s2.sdept <span class="keyword">AND</span> sname<span class="operator">=</span><span class="string">&#x27;刘晨灿&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询选修了全部课程的学生姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> sname <span class="keyword">FROM</span> student </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> course <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> sno<span class="operator">=</span>student.sno <span class="keyword">AND</span> cno<span class="operator">=</span>course.cno</span><br><span class="line">)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-4-集合查询"><a href="#4-4-集合查询" class="headerlink" title="4.4 集合查询"></a>4.4 集合查询</h4><p>集合操作的种类</p><ul><li>并操作 <code>UNION</code></li><li>交操作 <code>INTERSECT</code></li><li>差操作 <code>EXCEPT</code></li></ul><p>参加集合操作的各查询结果的列数必须相同;对应项的数据类型也必须相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- UNION：将多个查询结果合并起来时，系统自动去掉重复元组</span></span><br><span class="line"><span class="comment">-- UNION ALL：将多个查询结果合并起来时，保留重复元组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询计算机科学系的学生及年龄不大于19岁的学生, 多个查询查同一张表union</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept <span class="operator">=</span> <span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sage <span class="operator">&lt;=</span> <span class="number">19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询选修了课程1或者选修了课程2的学生。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询计算机科学系的学生与年龄不大于19岁的学生的交集。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> cdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sage <span class="operator">&lt;=</span> <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询既选修了课程1又选修了课程2的学生。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cno<span class="operator">=</span><span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询计算机科学系的学生与年龄不大于19岁的学生的差集。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span></span><br><span class="line">MINUS</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sage<span class="operator">&lt;=</span><span class="number">19</span>;</span><br></pre></td></tr></table></figure><h4 id="4-5-基于派生表的查询"><a href="#4-5-基于派生表的查询" class="headerlink" title="4.5 基于派生表的查询"></a>4.5 基于派生表的查询</h4><p>子查询不仅可以出现在<code>WHERE</code>子句中，还可以出现在<code>FROM</code>子句中，这时子查询生成的临时派生表（Derived Table）成为主查询的查询对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出每个学生超过他选修课程平均成绩的课程号。</span></span><br><span class="line"><span class="keyword">SELECT</span> sc.sno, sc.cno <span class="keyword">FROM</span> sc,</span><br><span class="line"> (<span class="keyword">SELECT</span> sno, <span class="built_in">AVG</span>(grade) <span class="keyword">AS</span> avggrade <span class="keyword">FROM</span> sc <span class="keyword">GROUP</span> <span class="keyword">BY</span> sno) savg</span><br><span class="line"><span class="keyword">WHERE</span> sc.sno <span class="operator">=</span> savg.sno <span class="keyword">AND</span> sc.grade <span class="operator">&gt;=</span> savg.avggrade;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询所有选修了1号课程的学生姓名</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> student.sname <span class="keyword">FROM</span> student, (<span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> cno <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>) sc1</span><br><span class="line"><span class="keyword">WHERE</span> student.sno <span class="operator">=</span> sc1.sno;</span><br></pre></td></tr></table></figure><p>如果子查询中没有聚集函数，派生表可以不指定属性列，子查询SELECT子句后面的列名为其缺省属<br>性。</p><h3 id="5-数据更新"><a href="#5-数据更新" class="headerlink" title="5 数据更新"></a>5 数据更新</h3><h4 id="5-1-插入数据"><a href="#5-1-插入数据" class="headerlink" title="5.1 插入数据"></a>5.1 插入数据</h4><h5 id="5-1-1-插入元组"><a href="#5-1-1-插入元组" class="headerlink" title="5.1.1 插入元组"></a>5.1.1 插入元组</h5><p>语句格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>属性列<span class="number">2</span> <span class="operator">&gt;</span>…)]</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="operator">&lt;</span>常量<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>常量<span class="number">2</span><span class="operator">&gt;</span>]… );</span><br></pre></td></tr></table></figure><p>功能： 将新元组插入指定表中</p><p><code>INTO</code>子句</p><ul><li>指定要插入数据的表名及属性列</li><li>属性列的顺序可与表定义中的顺序不一致</li><li>没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致</li><li>指定部分属性列：插入的元组在其余属性列上取空值</li></ul><p><code>VALUES</code>子句<br>提供的值必须与INTO子句匹配</p><ul><li>值的个数</li><li>值的类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将一个新学生元组（学号：201215128;姓名：陈冬;性别：男;所在系：IS;年龄：18岁）插入到Student表中。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student(sno, sname, ssex, sage, sdept) <span class="keyword">VALUES</span>(<span class="string">&#x27;201215128&#x27;</span>,<span class="string">&#x27;陈东&#x27;</span>,<span class="string">&#x27;m&#x27;</span>，<span class="number">18</span>, <span class="string">&#x27;IS&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> student <span class="keyword">VALUES</span>(<span class="string">&#x27;201215129&#x27;</span>,<span class="string">&#x27;陈东梅&#x27;</span>,<span class="string">&#x27;m&#x27;</span>，<span class="number">18</span>, <span class="string">&#x27;IS&#x27;</span>，<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入一条选课记录(&#x27;201215128&#x27;, &#x27;1&#x27;)</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sc(cno, sno) <span class="keyword">VALUES</span>(<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;201215128&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sc <span class="keyword">VALUES</span>(<span class="string">&#x27;201215128&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><h5 id="5-1-2-插入子查询结果"><a href="#5-1-2-插入子查询结果" class="headerlink" title="5.1.2 插入子查询结果"></a>5.1.2 插入子查询结果</h5><p>语句格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> [(<span class="operator">&lt;</span>属性列<span class="number">1</span><span class="operator">&gt;</span> [,<span class="operator">&lt;</span>属性列<span class="number">2</span><span class="operator">&gt;</span>… )]</span><br><span class="line">子查询;</span><br></pre></td></tr></table></figure><p><code>INTO</code>子句<br>插入子查询结果;<br><code>SELECT</code>子句目标列<strong>值的个数</strong>以及<strong>值的类型</strong>必须与<code>INTO</code>子句匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept_age(sdept <span class="type">CHAR</span>(<span class="number">25</span>), ave_age <span class="type">SMALLINT</span>);</span><br><span class="line"><span class="comment">-- 插入子查询结果</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept_age(sdept, ave_age)</span><br><span class="line"><span class="keyword">SELECT</span> sdept, <span class="built_in">AVG</span>(sage) <span class="keyword">FROM</span> student <span class="keyword">GROUP</span> <span class="keyword">BY</span> sdept;</span><br></pre></td></tr></table></figure><h4 id="5-2-修改数据"><a href="#5-2-修改数据" class="headerlink" title="5.2 修改数据"></a>5.2 修改数据</h4><p>语句格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>列名<span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="operator">&gt;</span>]…</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><p>功能: </p><ul><li>修改指定表中满足WHERE子句条件的元组</li><li><code>SET</code>子句给出&lt;表达式&gt;的值用于取代相应的属性列</li><li>如果省略<code>WHERE</code>子句，表示要修改表中的所有元组</li></ul><h5 id="5-2-1-修改某一个元组的值"><a href="#5-2-1-修改某一个元组的值" class="headerlink" title="5.2.1 修改某一个元组的值"></a>5.2.1 修改某一个元组的值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将学生201215121的年龄改为22岁</span></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> sage <span class="operator">=</span> <span class="number">22</span> <span class="keyword">WHERE</span> sno <span class="operator">=</span> <span class="string">&#x27;201215121&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="5-2-2-修改多个元组的值"><a href="#5-2-2-修改多个元组的值" class="headerlink" title="5.2.2 修改多个元组的值"></a>5.2.2 修改多个元组的值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将所有学生的年龄增加一岁</span></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> sage <span class="operator">=</span> sage <span class="operator">+</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h5 id="5-2-3-带子查询的修改语句"><a href="#5-2-3-带子查询的修改语句" class="headerlink" title="5.2.3 带子查询的修改语句"></a>5.2.3 带子查询的修改语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将计算机科学系全体学生的成绩置零</span></span><br><span class="line"><span class="keyword">UPDATE</span> sc <span class="keyword">SET</span> grade<span class="operator">=</span><span class="number">0</span> <span class="keyword">WHERE</span> sno <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="5-3-删除数据"><a href="#5-3-删除数据" class="headerlink" title="5.3 删除数据"></a>5.3 删除数据</h4><p>语句格式:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件<span class="operator">&gt;</span>];</span><br></pre></td></tr></table></figure><p>功能：删除指定表中满足WHERE子句条件的元组<br><code>WHERE</code>子句</p><ul><li>指定要删除的元组</li><li>缺省表示要删除表中的全部元组，表的定义仍在字典中</li></ul><h5 id="5-3-1-删除某一个元组的值"><a href="#5-3-1-删除某一个元组的值" class="headerlink" title="5.3.1 删除某一个元组的值"></a>5.3.1 删除某一个元组的值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除学号为201215128的学生记录。</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sno<span class="operator">=</span><span class="string">&#x27;201215128&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="5-3-2-删除多个元组的值"><a href="#5-3-2-删除多个元组的值" class="headerlink" title="5.3.2 删除多个元组的值"></a>5.3.2 删除多个元组的值</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除所有的学生选课记录。</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> sc;</span><br></pre></td></tr></table></figure><h5 id="5-3-3-带子查询的删除语句"><a href="#5-3-3-带子查询的删除语句" class="headerlink" title="5.3.3 带子查询的删除语句"></a>5.3.3 带子查询的删除语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--  删除计算机科学系所有学生的选课记录。</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> sno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sdept<span class="operator">=</span><span class="string">&#x27;CS&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="6-空值的处理"><a href="#6-空值的处理" class="headerlink" title="6 空值的处理"></a>6 空值的处理</h3><p>空值就是“不知道”或“不存在”或“无意义”的值。<br>一般有以下几种情况：</p><ul><li>该属性应该有一个值，但<strong>目前不知道</strong>它的具体值</li><li>该属性不应该有值</li><li>由于某种原因不便于填写</li></ul><h4 id="6-1-空值的产生"><a href="#6-1-空值的产生" class="headerlink" title="6.1 空值的产生"></a>6.1 空值的产生</h4><p>空值是一个很特殊的值，含有不确定性。对关系运算带来特殊的问题，需要做特殊的处理。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 向SC表中插入一个元组，学生号是”201215125”，课程号是”1”，成绩为空。</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> sc(sno, cno, grade) <span class="keyword">VALUES</span>(<span class="string">&#x27;201215125&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将Student表中学生号为”201215138”的学生所属的系改为空值</span></span><br><span class="line"><span class="keyword">UPDATE</span> student <span class="keyword">SET</span> sdept<span class="operator">=</span><span class="keyword">null</span> <span class="keyword">WHERE</span> sno<span class="operator">=</span><span class="string">&#x27;201215138&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="6-2-空值的判断"><a href="#6-2-空值的判断" class="headerlink" title="6.2 空值的判断"></a>6.2 空值的判断</h4><p>判断一个属性的值是否为空值，用IS NULL或IS NOT NULL来表示。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从Student表中找出漏填了数据的学生信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> sname <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> ssex <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> sage <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">OR</span> sdept <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><h4 id="6-3-空值的约束条件"><a href="#6-3-空值的约束条件" class="headerlink" title="6.3 空值的约束条件"></a>6.3 空值的约束条件</h4><p>属性定义（或者域定义）中</p><ul><li>有<code>NOT NULL</code>约束条件的不能取空值</li><li>加了<code>UNIQUE</code>限制的属性不能取空值</li><li>码属性不能取空值</li></ul><h4 id="6-4-空值的算术运算、比较运算和逻辑运算"><a href="#6-4-空值的算术运算、比较运算和逻辑运算" class="headerlink" title="6.4 空值的算术运算、比较运算和逻辑运算"></a>6.4 空值的算术运算、比较运算和逻辑运算</h4><ul><li><p>空值与另一个值（包括另一个空值）的算术运算的结果为空值</p></li><li><p>空值与另一个值（包括另一个空值）的比较运算的结果为UNKNOWN。</p></li><li><p>有UNKNOWN后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑</p><table>  <thead>    <tr>      <th><strong>x</strong></th>      <th><strong>y</strong></th>      <th><strong>x AND y</strong></th>      <th><strong>x OR y</strong></th>      <th><strong>NOT x</strong></th>    </tr>  </thead>  <tbody>    <tr>      <td>T</td>      <td>T</td>      <td>T</td>      <td>T</td>      <td>F</td>    </tr>    <tr>      <td>T</td>      <td>U</td>      <td>U</td>      <td>T</td>      <td>F</td>    </tr>    <tr>      <td>T</td>      <td>F</td>      <td>F</td>      <td>T</td>      <td>F</td>    </tr>    <tr>      <td>U</td>      <td>T</td>      <td>U</td>      <td>T</td>      <td>U</td>    </tr>    <tr>      <td>U</td>      <td>U</td>      <td>U</td>      <td>U</td>      <td>U</td>    </tr>    <tr>      <td>T</td>      <td>F</td>      <td>F</td>      <td>U</td>      <td>U</td>    </tr>    <tr>      <td>F</td>      <td>T</td>      <td>F</td>      <td>T</td>      <td>T</td>    </tr>    <tr>      <td>F</td>      <td>U</td>      <td>F</td>      <td>U</td>      <td>T</td>    </tr>    <tr>      <td>F</td>      <td>F</td>      <td>F</td>      <td>F</td>      <td>T</td>    </tr>  </tbody></table><p><em>T表示TRUE, F表示FALSE, U表示UNKOWN</em></p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出选修1号课程的不及格的学生。</span></span><br><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> grade <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">AND</span> cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="comment">-- 查询结果不包括缺考的Grade值为null的学生</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 选出选修1号课程的不及格的学生以及缺考的学生。</span></span><br><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> grade <span class="operator">&lt;</span> <span class="number">60</span> <span class="keyword">AND</span> cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> grade <span class="keyword">IS</span> <span class="keyword">NULL</span> <span class="keyword">AND</span> cno<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="7-SQL小结"><a href="#7-SQL小结" class="headerlink" title="7 SQL小结"></a>7 SQL小结</h3><p>SQL可以分为<strong>数据定义</strong>、<strong>数据查询</strong>、<strong>数据更新</strong>、<strong>数据控制</strong>四大部分;<br>SQL是关系数据库语言的<strong>工业标准</strong>。大部分数据库管理系统产品都能支持SQL92, 但是许多数据库系统只支持SQL99、SQL2008和SQL2011的部分特征，至今尚没有一个数据库系统能够完全支持SQL99以上的标准。</p><h3 id="8-Oracle-常用函数"><a href="#8-Oracle-常用函数" class="headerlink" title="8 Oracle 常用函数"></a>8 Oracle 常用函数</h3><ul><li><p>字符类函数<code>CHR()</code>实现整型转字符。<code>dual</code>是Oracle系统内部提供的用于实现临时数据计算的特殊<br>表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CHR(<span class="number">90</span>), CHR(<span class="number">72</span>) <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure></li><li><p>字符串连接函数<code>CONCAT(s1,s2)</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;hello &#x27;</span>, <span class="string">&#x27;world&#x27;</span>) information <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure></li><li><p>数字类函数cell()返回指定小数的整数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ceil</span>(<span class="number">5.6</span>) <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure></li><li><p>日期和时间类函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sysdate <span class="keyword">AS</span> 系统日期 <span class="keyword">FROM</span> dual;</span><br><span class="line"><span class="keyword">SELECT</span> ADD_MONTHS(SYSDATE, <span class="number">2</span>) <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL语言基础&quot;&gt;&lt;a href=&quot;#SQL语言基础&quot; class=&quot;headerlink&quot; title=&quot;SQL语言基础&quot;&gt;&lt;/a&gt;SQL语言基础&lt;/h2&gt;&lt;div class=&quot;mermaid-wrap&quot;&gt;&lt;pre class=&quot;mermaid-src&quot; hi</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://www.ckxgzxa.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>2. Oracle学习笔记-Oracle的体系结构</title>
    <link href="https://www.ckxgzxa.top/OracleDB02.html"/>
    <id>https://www.ckxgzxa.top/OracleDB02.html</id>
    <published>2023-12-04T15:04:25.000Z</published>
    <updated>2023-12-05T19:45:52.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-Oracle的体系结构概述"><a href="#2-Oracle的体系结构概述" class="headerlink" title="2. Oracle的体系结构概述"></a>2. Oracle的体系结构概述</h2><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph LRA[Oracle的体系结构]--&gt;体系结构概述A--&gt;逻辑存储结构A--&gt;物理存储结构A--&gt;服务器结构A--&gt;数据字典  </pre></div><h3 id="2-1-Oracle体系结构图"><a href="#2-1-Oracle体系结构图" class="headerlink" title="2.1 Oracle体系结构图"></a>2.1 Oracle体系结构图</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042309443.png" alt=""></p><h3 id="2-2-用户进程和服务器进程的关系"><a href="#2-2-用户进程和服务器进程的关系" class="headerlink" title="2.2 用户进程和服务器进程的关系"></a>2.2 用户进程和服务器进程的关系</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042312481.png" alt=""></p><h3 id="2-3-存储结构分类"><a href="#2-3-存储结构分类" class="headerlink" title="2.3 存储结构分类"></a>2.3 存储结构分类</h3><h4 id="2-3-1-逻辑存储结构"><a href="#2-3-1-逻辑存储结构" class="headerlink" title="2.3.1 逻辑存储结构"></a>2.3.1 <strong>逻辑存储结构</strong></h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042313556.png" alt=""></p><h5 id="数据块"><a href="#数据块" class="headerlink" title="数据块"></a>数据块</h5><ul><li><p>数据块是Oracle逻辑存储结构中的最小的逻辑单位</p></li><li><p>一个数据库对应一个或者多个物理块, 大小由参数 <code>DB_BLOCK_SIZE</code> 决定</p></li><li><p>数据块的结构包括块头和存储区的两个部分</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042318973.png" alt=""></p></li></ul><h5 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h5><ul><li>数据区是由连续的数据块结合而成的</li><li>数据区是Oracle存储分配的最小单位</li></ul><h5 id="段"><a href="#段" class="headerlink" title="段"></a>段</h5><ul><li>数据段：存储表中所有数据</li><li>索引段：存储表上最佳查询的所有索引数据</li><li>临时段：存储表排序操作期间建立的临时表的数据</li><li>回滚段：存储修改之前的位置和值</li></ul><h5 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h5><ul><li>表空间是数据库的最大逻辑划分区域</li><li>一个表空间由一个或多个数据文件组成，一个数据文件只属于一个表空间</li><li>表空间的大小是它所对应的数据文件大小的总和</li><li>默认创建的表空间<ul><li>系统表空间</li><li>辅助表空间</li><li>撤销表空间</li><li>用户表空间</li></ul></li></ul><h4 id="2-3-2-物理存储结构"><a href="#2-3-2-物理存储结构" class="headerlink" title="2.3.2 物理存储结构"></a>2.3.2 物理存储结构</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042321953.png" alt=""></p><p>物理结构包含三种数据文件</p><h5 id="控制文件"><a href="#控制文件" class="headerlink" title="控制文件"></a><strong>控制文件</strong></h5><ul><li>是数据库中最小的文件同时也是数据库中最<strong>重要</strong>的文件</li></ul><h5 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a>数据文件</h5><p>数据文件的种类</p><ul><li>系统数据文件（<code>SYSTEM01.DBF</code> 和 <code>SYSAUX01.DBF</code> ）</li><li>回滚数据文件（<code>UNDOTBS01.DBF</code>）</li><li>用户数据文件（<code>USERS01.DBF</code>）</li><li>临时数据文件（<code>TEMP01.DBF</code>）</li></ul><h5 id="重做日志文件"><a href="#重做日志文件" class="headerlink" title="重做日志文件"></a>重做日志文件</h5><p>日志文件 <code>.LOG</code></p><ul><li>重做日志文件：记录所有的数据变化、提供恢复机制</li><li>归档日志文件：重做日志文件的历史备份，有归档模式和非归档模式之分</li></ul><h5 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h5><ul><li>服务器参数文件 （<code>orcl.ora</code>）</li><li>密码文件 (<code>PWDorcl.ora</code>)</li><li>警告文件 (<code>alert_orcl.log</code>)</li><li>跟踪文件</li></ul><h3 id="2-4-Oracle-服务器结构"><a href="#2-4-Oracle-服务器结构" class="headerlink" title="2.4 Oracle 服务器结构"></a>2.4 Oracle 服务器结构</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042332911.png" alt=""></p><p>Oracle服务器主要由以下部分组成：</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042334793.png" alt=""></p><h4 id="2-4-1-系统全局区SGA"><a href="#2-4-1-系统全局区SGA" class="headerlink" title="2.4.1 系统全局区SGA"></a>2.4.1 系统全局区SGA</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042333302.png" alt=""></p><ul><li><p>高速数据缓冲区</p><p>作用：用来存放Oracle系统最近访问过的数据块<br>经常或最近被访问的数据块会被放置到高速数据缓冲区的前端，不经常被访问的数据块会被放置到高速数据缓冲区的后端</p></li><li><p>共享池</p><p>作用：存储最近执行过的SQL语句和最近使用过的数据定义<br>共享池包含：库高速缓冲区 和 字典高速缓冲区</p></li></ul><h4 id="2-4-2-程序全局区（PGA）"><a href="#2-4-2-程序全局区（PGA）" class="headerlink" title="2.4.2 程序全局区（PGA）"></a>2.4.2 程序全局区（PGA）</h4><p>程序全局区PGA又称作用户进程全局区, 可以把代码、全局变量和数据结构都存储在其中, 每个Oracle服务器进程只拥有自己的那部分PGA资源<br>程序全局区由两部分组成：私有SQL区 和 会话区</p><h4 id="2-4-3-前台进程"><a href="#2-4-3-前台进程" class="headerlink" title="2.4.3 前台进程"></a>2.4.3 前台进程</h4><ul><li>用户进程: 使用SQL Plus连接成功后生成。包含两个重要概念：连接和会话</li><li>服务器进程：处理用户会话过程中的SQL语句和SQL Plus命令</li></ul><h4 id="2-4-4-后台进程"><a href="#2-4-4-后台进程" class="headerlink" title="2.4.4 后台进程"></a>2.4.4 后台进程</h4><ul><li>数据写入进程</li><li>检查点进程</li><li>日志写入进程</li><li>归档进程</li></ul><h4 id="2-4-4-实例"><a href="#2-4-4-实例" class="headerlink" title="2.4.4 实例"></a>2.4.4 实例</h4><h4 id="2-4-5-数据库"><a href="#2-4-5-数据库" class="headerlink" title="2.4.5 数据库"></a>2.4.5 数据库</h4><h3 id="2-5-数据字典"><a href="#2-5-数据字典" class="headerlink" title="2.5 数据字典"></a>2.5 数据字典</h3><p>数据字典是Oracle存储数据库内部信息的地方，描述了数据库内部的运行和管理情况。<br>Oracle数据字典的名称由前缀和后缀组成，使用下划线“_”连接</p><ul><li>dba_: 包含数据库实例的所有对象信息。_</li><li>v$_：当前实例的动态视图，包含系统管理和系统优化等使用的视图。</li><li>user_：记录用户的对象信息。</li><li>gv_：分布式环境下所有实例的动态视图，包含系统管理和系统优化使用的视图</li><li>all_：记录用户的对象信息及被授权访问的对象信息。</li></ul><h4 id="2-5-1-基本的数据字典"><a href="#2-5-1-基本的数据字典" class="headerlink" title="2.5.1 基本的数据字典"></a>2.5.1 基本的数据字典</h4><div class="table-container"><table><thead><tr><th>字典名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>DBA_TABLES</strong></td><td>所有表的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_COLUMNS</strong></td><td>所有表的列信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_VIEWS</strong></td><td>所有视图的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_COMMENTS</strong></td><td>所有表的注释信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_COL_COMMENTS</strong></td><td>所有列的注释信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_INDEXES</strong></td><td>所有索引的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_IND_COLUMNS</strong></td><td>所有索引列的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_CONSTRAINTS</strong></td><td>所有约束的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_CONS_COLUMNS</strong></td><td>所有约束列的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_PRIVS</strong></td><td>所有表的权限信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_PRIVS_RECD</strong></td><td>所有表的详细权限信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_COLUMNS_STATISTICS</strong></td><td>所有表的列统计信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_MODIFICATIONS</strong></td><td>所有表的最后修改时间信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_PARTITIONS</strong></td><td>所有表的分区信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_SUBPARTITIONS</strong></td><td>所有表的子分区信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TRIGGERS</strong></td><td>所有触发器的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_PROCEDURES</strong></td><td>所有存储过程和函数的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_ARGUMENTS</strong></td><td>所有存储过程和函数参数的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_ERRORS</strong></td><td>所有存储过程、函数和包中的错误信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_STATISTICS</strong></td><td>所有表的统计信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_TAB_PENDING_STATS</strong></td><td>所有表的等待统计信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_SCHEDULER_JOBS</strong></td><td>所有调度任务的信息，包括所有者（用户）</td></tr><tr><td><strong>DBA_SCHEDULER_JOB_RUN_DETAILS</strong></td><td>所有调度任务运行详情信息，包括所有者（用户）</td></tr></tbody></table></div><h4 id="2-5-2-常用动态性能视图"><a href="#2-5-2-常用动态性能视图" class="headerlink" title="2.5.2 常用动态性能视图"></a>2.5.2 常用动态性能视图</h4><div class="table-container"><table><thead><tr><th>视图名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>V$SESSION</strong></td><td>提供有关当前会话的信息，如会话 ID、用户名、状态等</td></tr><tr><td><strong>V$SQL</strong></td><td>包含所有当前正在执行的 SQL 语句的信息</td></tr><tr><td><strong>V$SQLAREA</strong></td><td>包含有关 SQL 语句执行计划和性能的信息</td></tr><tr><td><strong>V$SESSION_EVENT</strong></td><td>提供与会话相关的等待事件信息</td></tr><tr><td><strong>V$SYSTEM_EVENT</strong></td><td>提供与系统相关的等待事件信息</td></tr><tr><td><strong>V$SQL_PLAN</strong></td><td>提供 SQL 语句执行计划的信息</td></tr><tr><td><strong>V$SQL_PLAN_STATISTICS</strong></td><td>提供 SQL 语句执行计划的统计信息</td></tr><tr><td><strong>V$INSTANCE</strong></td><td>提供有关数据库实例的信息，如实例名称、状态等</td></tr><tr><td><strong>V$WAITSTAT</strong></td><td>提供有关等待事件统计信息的汇总</td></tr><tr><td><strong>V$LOCK</strong></td><td>提供有关数据库锁的信息</td></tr><tr><td><strong>V$TRANSACTION</strong></td><td>提供有关数据库事务的信息</td></tr><tr><td><strong>V$ROLLSTAT</strong></td><td>提供有关回滚段的信息</td></tr><tr><td><strong>V$SYSSTAT</strong></td><td>提供有关系统级统计信息</td></tr><tr><td><strong>V$SESSION_LONGOPS</strong></td><td>提供有关长时间运行的操作的信息</td></tr><tr><td><strong>V$RESOURCE_LIMIT</strong></td><td>提供有关资源限制和使用情况的信息</td></tr><tr><td><strong>V$DATABASE</strong></td><td>提供有关数据库的全局信息，如数据库名称、状态等</td></tr><tr><td><strong>V$PARAMETER</strong></td><td>提供有关初始化参数的信息</td></tr><tr><td><strong>V$INSTANCE_PARAMETER</strong></td><td>提供有关实例初始化参数的信息</td></tr><tr><td><strong>V$SQLSTATS</strong></td><td>提供 SQL 语句的统计信息，包括执行次数、等待时间等</td></tr></tbody></table></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;2-Oracle的体系结构概述&quot;&gt;&lt;a href=&quot;#2-Oracle的体系结构概述&quot; class=&quot;headerlink&quot; title=&quot;2. Oracle的体系结构概述&quot;&gt;&lt;/a&gt;2. Oracle的体系结构概述&lt;/h2&gt;&lt;div class=&quot;mermaid</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://www.ckxgzxa.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>1.Oracle学习笔记-Oracle 19c概述</title>
    <link href="https://www.ckxgzxa.top/OracleDB01.html"/>
    <id>https://www.ckxgzxa.top/OracleDB01.html</id>
    <published>2023-12-02T19:41:37.000Z</published>
    <updated>2023-12-05T18:54:58.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Oracle-19c概述"><a href="#Oracle-19c概述" class="headerlink" title="Oracle 19c概述"></a>Oracle 19c概述</h2><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312050128954.png" alt=""></p><h3 id="1-Oracle-的发展史"><a href="#1-Oracle-的发展史" class="headerlink" title="1 Oracle 的发展史"></a>1 Oracle 的发展史</h3><p>Oracle是甲骨文公司的一款关系数据库管理系统，也是目前较流行的关系数据管理系统，在数据库领域中一直处于领先地位。该系统具有可移植性好、使用方便、功能强等特点。<br>Oracle数据库自发布至今，也经历了一个从不稳定到稳定，从功能简单至强大的过程。Oracle的每一次版本变迁，都具有里程碑意义。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312030413956.png" alt="Oracle的版本发展"></p><blockquote><ul><li>小型: Access</li><li>中型: SQL server、MySQL、TiDB</li><li>大型: Oracle、DB2、SyBase</li></ul></blockquote><p>Oracle 的特点:</p><ul><li>可用性强</li><li>可扩展性强</li><li>数据安全性强</li><li>稳定性强</li></ul><h3 id="2-关系数据库"><a href="#2-关系数据库" class="headerlink" title="2  关系数据库"></a>2  关系数据库</h3><h4 id="2-1-数据库的特点"><a href="#2-1-数据库的特点" class="headerlink" title="2.1 数据库的特点:"></a>2.1 数据库的<strong>特点</strong>:</h4><p>永久存储、有组织、可共享</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312030430601.png" alt=""></p><h4 id="2-2-数据库的地位"><a href="#2-2-数据库的地位" class="headerlink" title="2.2 数据库的地位:"></a>2.2 数据库的<strong>地位</strong>:</h4><p>数据库技术产生于六十年代末，是数据管理的有效技术，是计算机科学的重要分支。<br>数据库技术是信息系统的核心和基础，它的出现极大地促进了计算机应用向各行各业的渗透。数据库已经成为每个人生活中不可缺少的部分。</p><h4 id="2-3-数据库的4个基本概念"><a href="#2-3-数据库的4个基本概念" class="headerlink" title="2.3 数据库的4个基本概念"></a>2.3 数据库的4个基本概念</h4><h5 id="2-3-1-数据-Data"><a href="#2-3-1-数据-Data" class="headerlink" title="2.3.1 数据 (Data)"></a>2.3.1 数据 (Data)</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312030438789.gif" alt=""></p><p>数据（Data）是数据库中存储的基本对象<br>数据的定义：描述事物的符号记录<br>数据的种类：数字、文字、图形、图像、音频、视频、学生的档案记录等</p><blockquote><p>数据的含义称为数据的语义，数据与其语义是不可分的。例如  93是一个数据<br>语义1：学生某门课的成绩<br>语义2：某人的体重<br>语义3：计算机系2013级学生人数</p><p>语义3：……</p><p>学生档案中的学生记录<br>（李明，男，199505，江苏南京市，计算机系，2013）<br>语义：学生姓名、性别、出生年月、出生地、所在院系、入学时间<br>解释：李明是个大学生，1995年5月出生，江苏南京市人，  2013年考入计算机系</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312030440805.png" alt=""></p></blockquote><h5 id="2-3-2-数据库-Database"><a href="#2-3-2-数据库-Database" class="headerlink" title="2.3.2 数据库 (Database)"></a>2.3.2 数据库 (Database)</h5><ul><li>数据库的定义<br>数据库（Database，简称DB）是长期储存在计算机内、有组织的、可共享的大量数据的集合。</li><li>数据库的基本特征<ol><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ol></li></ul><h5 id="2-3-3-数据库管理系统-DBMS-DataBase-Management-System"><a href="#2-3-3-数据库管理系统-DBMS-DataBase-Management-System" class="headerlink" title="2.3.3 数据库管理系统 (DBMS, DataBase Management System)"></a>2.3.3 数据库管理系统 (DBMS, DataBase Management System)</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312030450943.png" alt=""></p><ul><li><p>什么是数据库管理系统</p><ul><li>位于用户与操作系统之间的一层数据管理软件</li><li>是基础软件, 是一个大型复杂的软件系统</li></ul></li><li><p>数据库管理系统的用途</p><p>科学地组织和存储数据、高效地获取和维护数据</p></li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312031343623.png" alt="数据库在计算机系统中的位置"></p><p>数据库管理系统的主要功能</p><ul><li><p>数据定义功能</p><p>提供数据定义语言（DDL）定义数据库中的数据对象</p></li><li><p>数据组织、存储和管理</p><ul><li>分类组织、存储和管理各种数据</li><li>确定组织数据的文件结构和存取方式</li><li>实现数据之间的联系</li><li>提供多种存取方法提高存取效率</li></ul></li><li><p>数据操纵功能</p><p>提供数据操纵语言（DML）实现对数据库的基本操作 （查询、插入、删除和修改）</p></li><li><p>数据库的事务管理和运行管理</p><ul><li>数据库在建立数据库在建立、运行和维护时由数据库管理系统统一管理和控制</li><li>保证数据的安全性、完整性、多用户对数据的并发使用</li><li>发生故障后的系统恢复</li></ul></li><li><p>数据库的建立和维护功能</p><ul><li>数据库的初始数据的装载和转换</li><li>数据库转储、恢复功能</li><li>数据库的重组织</li><li>性能监视、分析等</li></ul></li><li>其它功能<br>数据库管理系统与网络中其它软件系统的通信数据库管理系统系统之间的数据转换<br>异构数据库之间的互访和互操作</li></ul><h5 id="2-3-4-数据库系统-DBS"><a href="#2-3-4-数据库系统-DBS" class="headerlink" title="2.3.4 数据库系统 (DBS)"></a>2.3.4 数据库系统 (DBS)</h5><h6 id="2-3-4-1-数据库系统的构成"><a href="#2-3-4-1-数据库系统的构成" class="headerlink" title="2.3.4.1 数据库系统的构成"></a>2.3.4.1 数据库系统的构成</h6><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312031616935.png" alt=""></p><ul><li>数据库</li><li>数据库管理系统（及其应用开发工具）</li><li>应用程序</li><li>数据库管理员</li></ul><h6 id="2-3-4-2-数据管理技术的产生和发展"><a href="#2-3-4-2-数据管理技术的产生和发展" class="headerlink" title="2.3.4.2 数据管理技术的产生和发展"></a>2.3.4.2 数据管理技术的产生和发展</h6><ul><li><p>什么是数据管理</p><p>对数据进行分类、组织、编码、存储、检索和维护， 是数据管理的中心问题</p></li><li><p>数据管理技术的发展过程</p><p>人工管理阶段（20世纪50年代中期以前）</p><p>文件系统阶段（20世纪50年代末~60年代中期）</p><p>数据库系统阶段（20世纪60年代末~现在）</p></li><li><p>数据管理技术的发展动力</p><p>应用需求的推动</p><p>计算机硬件的发展</p><p>计算机软件的发展</p></li></ul><h6 id="2-3-4-3-数据库系统的特点"><a href="#2-3-4-3-数据库系统的特点" class="headerlink" title="2.3.4.3 数据库系统的特点"></a>2.3.4.3 数据库系统的特点</h6><div class="table-container"><table><thead><tr><th style="text-align:left">学号</th><th>姓名</th><th>性别</th><th>年龄</th><th>专业</th></tr></thead><tbody><tr><td style="text-align:left">2019015200</td><td>刘源</td><td>男</td><td>21</td><td>软件工程</td></tr><tr><td style="text-align:left">2019015401</td><td>马超</td><td>男</td><td>22</td><td>石油工程</td></tr><tr><td style="text-align:left">2020015621</td><td>李湘芸</td><td>女</td><td>20</td><td>储运</td></tr><tr><td style="text-align:left">…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">奖励</th></tr></thead><tbody><tr><td style="text-align:center">2020学年校级奖学金， 2021学年国家奖学金</td></tr><tr><td style="text-align:center">2021校级优秀学生</td></tr></tbody></table></div><ul><li><p>数据结构化</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312031646575.png" alt=""></p><ul><li>数据的整体结构化是数据库的主要特征之一</li><li><p>整体结构化</p><p>不再仅仅针对某一个应用，而是面向全组织<br>不仅数据内部结构化，整体是结构化的，数据之间具有联系<br>数据记录可以变长<br>数据的最小存取单位是数据项</p></li></ul></li><li><p>数据的共享性高，冗余度低且易扩充</p><ul><li>数据面向整个系统，可以被多个用户、多个应用共享使用。</li><li>数据共享的好处<br>减少数据冗余，节约存储空间<br>避免数据之间的不相容性与不一致性<br>使系统易于扩充</li></ul></li><li><p>数据独立性高</p><ul><li>物理独立性<br>指用户的应用程序与数据库中数据的物理存储是相互独立的。当数据的物理存储改变了，应用程序不用改变。</li><li>逻辑独立性<br>指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，应用程序不用改变。</li><li><p>数据独立性</p><p>由数据库管理系统的二级映像功能来保证。</p></li></ul></li><li><p>数据由数据库管理系统统一管理和控制</p><ol><li>数据的安全性（Security）保护<br>保护数据以防止不合法的使用造成的数据的泄密和破坏。</li><li>数据的完整性（Integrity）检查<br>保证数据的正确性、有效性和相容性。</li><li>并发（Concurrency）控制<br>对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</li><li>数据库恢复（Recovery）<br>将数据库从错误状态恢复到某一已知的正确状态。</li></ol></li></ul><h4 id="2-4-数据库概念小结"><a href="#2-4-数据库概念小结" class="headerlink" title="2.4 数据库概念小结"></a>2.4 数据库概念小结</h4><ol><li>数据库是长期存储在计算机内有组织的大量的共享的数据集合。</li><li>可以供各种用户共享，具有最小冗余度和较高的数据独立性。</li><li>数据库管理系统在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性、安<br>全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</li></ol><h3 id="3-数据模型"><a href="#3-数据模型" class="headerlink" title="3  数据模型"></a>3  数据模型</h3><ul><li>数据模型是对现实世界数据特征的抽象。</li><li>通俗地讲数据模型就是现实世界的模拟。</li><li><p>数据模型应满足三方面要求：</p><ol><li>能比较真实地模拟现实世界</li><li>容易为人所理解</li><li>便于在计算机上实现</li></ol></li><li>数据模型是数据库系统的核心和基础</li></ul><h4 id="3-1-两类数据模型"><a href="#3-1-两类数据模型" class="headerlink" title="3.1  两类数据模型"></a>3.1  两类数据模型</h4><p>数据模型分为两类（两个不同的层次）</p><ol><li><strong>概念模型</strong> 也称信息模型，它是按用户的观点来对数据和信息建模，用于数据库设计。</li><li><strong>逻辑模型</strong>和<strong>物理模型</strong><br>逻辑模型主要包括网状模型、层次模型、关系模型、面向对象数据模型、对象关系数据模型、<br>半结构化数据模型等。按计算机系统的观点对数据建模，用于DBMS实现。<br>物理模型是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁<br>带上的存储方式和存取方法。</li></ol><p>客观对象的抽象过程——两步抽象</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312031957495.png" alt=""></p><ul><li><p>现实世界中的客观对象抽象为概念模型；</p><p>将现实世界抽象为信息世界</p></li><li>把概念模型转换为某一数据库管理系统支持的数据模型。<br>将信息世界转换为机器世界</li></ul><p><strong>概念模型</strong></p><ul><li><p>概念模型的用途</p><p>概念模型用于信息世界的建模<br>是现实世界到机器世界的一个中间层次<br>是数据库设计的有力工具<br>数据库设计人员和用户之间进行交流的语言</p></li><li><p>对概念模型</p><p>较强的语义表达能力<br>简单、清晰、易于用户理解</p></li></ul><h4 id="3-2-信息世界中的基本概念"><a href="#3-2-信息世界中的基本概念" class="headerlink" title="3.2 信息世界中的基本概念"></a>3.2 信息世界中的基本概念</h4><h5 id="3-2-1-基本概念"><a href="#3-2-1-基本概念" class="headerlink" title="3.2.1 基本概念"></a>3.2.1 基本概念</h5><ol><li>实体（Entity）<br>客观存在并可相互区别的事物称为实体。可以是具体的人、事、物或抽象的概念。</li><li>属性（Attribute）<br>实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。</li><li>码（Key）<br>唯一标识实体的属性集称为码。</li><li>实体型（Entity Type）<br>用实体名及其属性名集合来抽象和刻画同类实体称为实体型。</li><li>实体集（Entity Set）<br>同一类型实体的集合称为实体集。</li><li>联系（Relationship）<br>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。<br>实体内部的联系通常是指组成实体的各属性之间的联系；<br>实体之间的联系通常是指不同实体集之间的联系；<br>实体之间的联系有一对一、一对多和多对多等多种类型。</li></ol><h5 id="3-2-2-实体-联系方法"><a href="#3-2-2-实体-联系方法" class="headerlink" title="3.2.2 实体-联系方法"></a>3.2.2 实体-联系方法</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312032222537.png" alt=""></p><p>用E-R图来描述现实世界的概念模型，E-R方法（Entity-Relationship Approach）也称为E-R模型</p><ul><li><p>数据操作</p><p>对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则</p><ul><li><p>数据操作的类型</p><p>查询和更新（包括插入、删除、修改）</p></li><li>数据模型对操作的定义<br>操作的确切含义、操作符号、操作规则（如优先级）、实现操作的语言</li><li>数据操作是对系统动态特性的描述</li></ul></li><li><p>数据的完整性约束条件</p><p>一组完整性规则的集合<br>完整性规则：给定的数据模型中数据及其联系所具有的制约和依存规则，用以限定符合数据模型的数据库状态以及状态的变化，以保证数据的正确、有效和相容</p><p>数据模型对完整性约束条件的定义</p><ul><li>反映和规定必须遵守的基本的通用的完整性约束条件。</li><li>提供定义完整性约束条件的机制，以反映具体应用所涉及的数据必须遵守的特定的语义约束条件。</li></ul></li></ul><h4 id="3-3-常用的数据模型"><a href="#3-3-常用的数据模型" class="headerlink" title="3.3 常用的数据模型"></a>3.3 常用的数据模型</h4><h5 id="3-3-1-层次模型（Hierarchical-Model）"><a href="#3-3-1-层次模型（Hierarchical-Model）" class="headerlink" title="3.3.1 层次模型（Hierarchical Model）"></a>3.3.1 层次模型（Hierarchical Model）</h5><ul><li>层次模型是数据库系统中最早出现的数据模型, 层次数据库系统的典型代表是IBM公司的IMS（Information Management System）数据库管理系统, 层次模型用树形结构来表示各类实体以及实体间的联系</li><li><p>满足下面两个条件的基本层次联系的集合为层次模型</p><ol><li>有且只有一个结点没有双亲结点，这个结点称为根结点</li><li>根以外的其它结点有且只有一个双亲结点</li></ol></li><li><p>根结点，双亲结点，兄弟结点，叶结点</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312032307300.png" alt=""></p></li><li><p>层次模型的特点</p><ul><li>结点的双亲是唯一的</li><li>只能直接处理一对多的实体联系</li><li>每个记录类型可以定义一个排序字段，也称为码字段</li><li>任何记录值只有按其路径查看时，才能显出它的全部意义</li><li>没有一个子女记录值能够脱离双亲记录值而独立存在</li></ul></li><li><p>层次模型的完整性约束条件</p><p>无相应的双亲结点值就不能插入子女结点值</p><p>如果删除双亲结点值，则相应的子女结点值也被同时删除</p><p>更新操作时，应更新所有相应记录，以保证数据的一致性</p></li><li><p>层次模型的优越点</p><ul><li><p>优点</p><p>层次模型的数据结构比较简单清晰<br>查询效率高，性能优于关系模型，不低于网状模型<br>层次数据模型提供了良好的完整性支持</p></li><li><p>缺点</p><p>结点之间的多对多联系表示不自然<br>对插入和删除操作的限制多，应用程序的编写比较复杂<br>查询子女结点必须通过双亲结点<br>层次命令趋于程序化</p></li></ul></li></ul><h5 id="3-3-2-网状模型（Network-Model）"><a href="#3-3-2-网状模型（Network-Model）" class="headerlink" title="3.3.2 网状模型（Network Model）"></a>3.3.2 网状模型（Network Model）</h5><p>网状数据库系统采用网状模型作为数据的组织方式<br>满足下面两个条件的基本层次联系的集合：</p><ol><li>允许一个以上的结点无双亲；</li><li>一个结点可以有多于一个的双亲。</li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312032317640.png" alt=""></p><blockquote><p>例如：一个学生可以选修若干门课程，某一课程可以被多个学生选修，学生与课程之间是多对多联<br>系<br>引进一个学生选课的联结记录，由3个数据项组成<br>学号、课程号、成绩——表示某个学生选修某一门课程及其成绩</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312032318373.png" alt=""></p></blockquote><ul><li><p>优点</p><p>能够更为直接地描述现实世界，如一个结点可以有多个双亲</p><p>具有良好的性能，存取效率较高</p></li><li><p>缺点</p><p>结构比较复杂，而且随着应用环境的扩大，数据库的结构就变得越来越复杂，不利于最终用户掌握<br>DDL、DML语言复杂，用户不容易使用<br>记录之间联系是通过存取路径实现的，用户必须了解系统结构的细节</p></li></ul><h5 id="3-3-3-关系模型（Relational-Model-）"><a href="#3-3-3-关系模型（Relational-Model-）" class="headerlink" title="3.3.3 关系模型（Relational Model)）"></a>3.3.3 关系模型（Relational Model)）</h5><p>关系数据库系统采用关系模型作为数据的组织方式</p><p>1970年美国IBM公司San Jose研究室的研究员E.F.Codd首次提出了数据库系统的关系模型</p><p>计算机厂商新推出的数据库管理系统几乎都支持关系模型</p><blockquote><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312032322817.png" alt=""></p><ul><li>关系（Relation）<br>一个关系对应通常说的一张表</li><li>元组（Tuple）<br>表中的一行即为一个元组</li><li>属性（Attribute）<br>表中的一列即为一个属性，给每一个属性起一个名称即属性名</li><li>主码（Key）<br>也称码键。表中的某个属性组，它可以唯一确定一个元组</li><li>域（Domain）<br>是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。</li><li>分量<br>元组中的一个属性值。</li><li>关系模式：对关系的描述<br>关系名（属性1，属性2，…，属性n）<br>学生（学号，姓名，年龄，性别，系名，年级）</li></ul></blockquote><p>关系必须是规范化的，满足一定的规范条件<br>最基本的规范条件：关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表<br>下图中工资和扣除是可分的数据项 ,不符合关系模型要求</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312032324597.png" alt=""></p><ul><li><p>术语对比</p><p>|  关系术语  |      一般表格的术语      |<br>| :————: | :———————————: |<br>|   关系名   |           表名           |<br>|  关系模式  |     表头(表格的描述)     |<br>|    关系    |      (一张) 二维表      |<br>|    元组    |         记录或行         |<br>|    属性    |            列            |<br>|   属性名   |           列名           |<br>|   属性值   |           列值           |<br>|    分量    |   一条记录中的一个列值   |<br>| 非规范关系 | 表中有表(大表中嵌有小表) |</p></li><li><p>关系模型的操纵与完整性约束</p><p>数据操作是集合操作，操作对象和操作结果都是关系</p><ul><li>查询</li><li>插入</li><li>删除</li><li>更新</li></ul><p>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</p><p>关系的完整性约束条件</p><ul><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ul></li><li><p>优点</p><ul><li>建立在严格的数学概念的基础上</li><li>概念单一<br>实体和各类联系都用关系来表示<br>对数据的检索结果也是关系</li><li>关系模型的存取路径对用户透明<br>具有更高的数据独立性，更好的安全保密性<br>简化了程序员的工作和数据库开发建立的工作</li></ul></li><li>缺点<br>存取路径对用户透明，查询效率往往不如格式化数据模型<br>为提高性能，必须对用户的查询请求进行优化，增加了开发数据库管理系统的难度</li></ul><h5 id="3-3-4-面向对象数据模型（Object-Oriented-Data-Model）"><a href="#3-3-4-面向对象数据模型（Object-Oriented-Data-Model）" class="headerlink" title="3.3.4 面向对象数据模型（Object Oriented Data Model）"></a>3.3.4 面向对象数据模型（Object Oriented Data Model）</h5><h5 id="3-3-5-对象关系数据模型（Object-Relational-Data-Model）"><a href="#3-3-5-对象关系数据模型（Object-Relational-Data-Model）" class="headerlink" title="3.3.5 对象关系数据模型（Object Relational Data Model）"></a>3.3.5 对象关系数据模型（Object Relational Data Model）</h5><h5 id="3-3-6-半结构化数据模型（Semistruture-Data-Model）"><a href="#3-3-6-半结构化数据模型（Semistruture-Data-Model）" class="headerlink" title="3.3.6 半结构化数据模型（Semistruture Data Model）"></a>3.3.6 半结构化数据模型（Semistruture Data Model）</h5><h3 id="4-Oracle的安装"><a href="#4-Oracle的安装" class="headerlink" title="4 Oracle的安装"></a>4 Oracle的安装</h3><ol><li><p>访问 <a href="https://www.oracle.com/cn/">Oracle 中国官网</a> <a href="https://www.oracle.com/cn/">https://www.oracle.com/cn/</a></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312040010182.png" alt=""></p></li><li><p>点击菜单栏上产品—&gt;硬件和软件—&gt;Oracle Database</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312040011578.png" alt=""></p></li><li><p>进入之后点击 <code>下载Oracle Database 19c</code>, 随后根据待安装系统架构选择适合的进行下载即可, 比如我这次想在下载之前需要登录Oracle账号即可, 当然Oracle还提供了Docker中的安装方式, 请自行学习.</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312040014470.png" alt=""></p></li><li>下载解压之后运行 <code>Setup.exe</code> 文件</li><li><p>安装过程</p><ul><li><p>选择创建并配置单实例数据库， 点击下一步</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042133262.png" alt=""></p></li><li><p>选择桌面类系统安装，供我们自己学习，生产环境安装到Linux服务器上一般选择服务器， 随后点击下一步</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042133648.png" alt=""></p></li><li><p>指定Oracle主目录用户</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042134017.png" alt=""></p></li><li><p>选择好Oracle目录并设置好口令点击下一步， 密码不强需要二次确认</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042134946.png" alt=""></p></li><li><p>随后直接下一步等待安装完成</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202312042134090.png" alt=""></p></li></ul></li></ol><h3 id="5-Oracle的卸载"><a href="#5-Oracle的卸载" class="headerlink" title="5 Oracle的卸载"></a>5 Oracle的卸载</h3><p>Oracle的卸载非常简单，只需要在服务中将Oracle开头的相关服务全部停止，再删除如下注册表项目即可：</p><blockquote><p>要删除的注册表项：</p><p><code>HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE</code></p><p><code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\</code> 下的Oracle相关项</p><p>要重装Oracle 数据库， 建议重启计算机</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Oracle-19c概述&quot;&gt;&lt;a href=&quot;#Oracle-19c概述&quot; class=&quot;headerlink&quot; title=&quot;Oracle 19c概述&quot;&gt;&lt;/a&gt;Oracle 19c概述&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://zxastaticpag</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://www.ckxgzxa.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>04.Docker Compose</title>
    <link href="https://www.ckxgzxa.top/road2docker04.html"/>
    <id>https://www.ckxgzxa.top/road2docker04.html</id>
    <published>2023-08-13T05:37:38.000Z</published>
    <updated>2023-12-05T18:20:35.537Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="1-docker-compose-安装"><a href="#1-docker-compose-安装" class="headerlink" title="1. docker-compose 安装"></a>1. <code>docker-compose</code> 安装</h2><p>Linux 上我们可以从 Github 上下载它的二进制包来使用，最新发行的版本地址：<a href="https://github.com/docker/compose/releases。">https://github.com/docker/compose/releases。</a></p><p>运行以下命令以下载 Docker Compose 的当前稳定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">&quot;https://github.com/docker/compose/releases/download/版本号/docker-compose-<span class="subst">$(uname -s)</span>-<span class="subst">$(uname -m)</span>&quot;</span> -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>添加执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>创建软链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>测试是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker compose version </span><br><span class="line">Docker Compose version v2.12.2</span><br></pre></td></tr></table></figure><p>也可以使用 <code>pip</code> 安装docker-compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install docker-compose</span><br></pre></td></tr></table></figure><h2 id="2-compose文件的结构和版本"><a href="#2-compose文件的结构和版本" class="headerlink" title="2.compose文件的结构和版本"></a>2.compose文件的结构和版本</h2><ul><li><p><strong>基本语法结构</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 容器</span></span><br><span class="line">  <span class="attr">servicename:</span> <span class="comment"># 服务名字，可为内部bridge网络的 DNS name</span></span><br><span class="line">    <span class="attr">image:</span> <span class="comment"># 镜像的名字</span></span><br><span class="line">    <span class="attr">command:</span> <span class="comment"># 可选，如果设置，则会覆盖默认镜像里的 CMD命令</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="comment"># 可选，相当于 docker run里的 --env</span></span><br><span class="line">    <span class="attr">volumes:</span> <span class="comment"># 可选，相当于docker run里的 -v</span></span><br><span class="line">    <span class="attr">networks:</span> <span class="comment"># 可选，相当于 docker run里的 --network</span></span><br><span class="line">    <span class="attr">ports:</span> <span class="comment"># 可选，相当于 docker run里的 -p</span></span><br><span class="line">  <span class="attr">servicename2:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment"># 可选，相当于 docker volume create</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment"># 可选，相当于 docker network create</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-Compose&quot;&gt;&lt;a href=&quot;#Docker-Compose&quot; class=&quot;headerlink&quot; title=&quot;Docker Compose&quot;&gt;&lt;/a&gt;Docker Compose&lt;/h1&gt;&lt;h2 id=&quot;1-docker-compose-</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="cloud" scheme="https://www.ckxgzxa.top/categories/cloud/"/>
    
    
    <category term="Docker" scheme="https://www.ckxgzxa.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>03.Dockerfile</title>
    <link href="https://www.ckxgzxa.top/road2docker03.html"/>
    <id>https://www.ckxgzxa.top/road2docker03.html</id>
    <published>2023-08-12T16:06:58.000Z</published>
    <updated>2023-12-05T18:20:32.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><h2 id="1-基础镜像的选择"><a href="#1-基础镜像的选择" class="headerlink" title="1. 基础镜像的选择"></a>1. 基础镜像的选择</h2><p>基本原则:</p><ul><li>官方镜像优于非官方的镜像，如果没有官方镜像，则尽量选择Dockerfile开源的</li><li>固定版本tag而不是每次都使用latest</li><li>尽量选择体积小的镜像</li></ul><h2 id="2-通过RUN执行指令"><a href="#2-通过RUN执行指令" class="headerlink" title="2.通过RUN执行指令"></a>2.通过<code>RUN</code>执行指令</h2><p><code>RUN</code> 主要用于在Image里执行指令, 比如安装软件, 下载文件等. 使用 <code>\</code> 拼接命令防止不必要的分层</p><h2 id="3-文件复制和目录操作"><a href="#3-文件复制和目录操作" class="headerlink" title="3.文件复制和目录操作"></a>3.文件复制和目录操作</h2><p>使用<code>COPY</code> 和 <code>ADD</code> 命令</p><ul><li><p>复制普通文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>.<span class="number">5</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> hello.py /app/hello.py</span></span><br></pre></td></tr></table></figure></li><li><p>复制压缩文件</p><p>使用 <code>ADD</code>  时如果复制的是一个gzip等压缩文件时，ADD会帮助我们自动去解压缩文件。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.9</span>.<span class="number">5</span>-alpine3.<span class="number">13</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hello.tar.gz /app/</span></span><br></pre></td></tr></table></figure></li><li><p>命令的选择</p><p>在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>.</p></li><li><p><code>WORKDIR</code></p><p><code>WORKDIR</code> 指令为 Dockerfile 中紧随其后的 <code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>COPY</code> 和 <code>ADD</code> 指令设置工作目录。如果指定的工作目录不存在，即使在后续的 Dockerfile 指令中没有使用，它也会被创建。</p></li></ul><h2 id="4-构建参数和环境变量-ARG-vs-ENV"><a href="#4-构建参数和环境变量-ARG-vs-ENV" class="headerlink" title="4.构建参数和环境变量(ARG vs ENV)"></a>4.构建参数和环境变量(ARG vs ENV)</h2><p>当在 Docker 中构建镜像时，我们经常需要考虑如何传递配置信息和变量到镜像内部。</p><h3 id="构建参数（ARG）"><a href="#构建参数（ARG）" class="headerlink" title="构建参数（ARG）"></a>构建参数（ARG）</h3><p>构建参数（<code>ARG</code>）是在构建镜像时传递给构建过程的变量。它们可以用于在构建过程中进行条件判断、选择不同的分支或在构建过程中传递信息。以下是使用 <code>ARG</code> 的示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用构建参数定义变量</span></span><br><span class="line"><span class="keyword">ARG</span> APP_VERSION</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在构建过程中使用构建参数</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Building app version: <span class="variable">$APP_VERSION</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>在构建过程中，可以通过 <code>--build-arg</code> 选项来传递构建参数的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-arg APP_VERSION=1.0 -t myapp .</span><br></pre></td></tr></table></figure><h3 id="环境变量（ENV）"><a href="#环境变量（ENV）" class="headerlink" title="环境变量（ENV）"></a>环境变量（ENV）</h3><p>环境变量（<code>ENV</code>）是在容器内运行时使用的变量。它们可以用于在容器内部设置配置、传递信息或指定行为。以下是使用 <code>ENV</code> 的示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> DB_HOST=localhost</span><br><span class="line"><span class="keyword">ENV</span> DB_PORT=<span class="number">5432</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器内使用环境变量</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Connecting to database at <span class="variable">$DB_HOST</span>:<span class="variable">$DB_PORT</span>&quot;</span></span></span><br></pre></td></tr></table></figure><p>使用 <code>-e</code> 选项可以在运行容器时设置环境变量的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -e DB_HOST=mydbhost -e DB_PORT=5432 myapp</span><br></pre></td></tr></table></figure><h3 id="ARG-vs-ENV：选择哪种方式？"><a href="#ARG-vs-ENV：选择哪种方式？" class="headerlink" title="ARG vs ENV：选择哪种方式？"></a>ARG vs ENV：选择哪种方式？</h3><p>在选择使用 <code>ARG</code> 还是 <code>ENV</code> 时，需要考虑以下几点：</p><ul><li><code>ARG</code> 用于构建时，<code>ENV</code> 用于运行时。如果您希望在构建过程中传递变量值，使用 <code>ARG</code>。如果需要在容器运行时设置配置或环境，使用 <code>ENV</code>。</li><li><code>ARG</code> 值只在构建过程中可用，不会在容器内保留。<code>ENV</code> 值将在容器内持续存在。</li><li><code>ENV</code> 更适合在容器内部设置常驻环境变量，如配置信息、路径等。</li></ul><p>综合考虑，根据需要选择适当的方式来管理构建参数和环境变量，以实现更有效的 Docker 镜像管理。</p><h2 id="5-CMD-容器启动命令"><a href="#5-CMD-容器启动命令" class="headerlink" title="5.CMD 容器启动命令"></a>5.<code>CMD</code> 容器启动命令</h2><p>在 Docker 中，<code>CMD</code> 是用于定义容器启动时默认执行的命令或应用程序。这个命令会在容器启动时自动执行，如果在 <code>docker run</code> 命令中没有指定要运行的特定命令。</p><p>以下是关于 <code>CMD</code> 的一些重要信息：</p><ul><li><code>CMD</code> 可以在 Dockerfile 中使用，用于指定在容器启动时要运行的默认命令。这个命令可以是应用程序，也可以是一条脚本。</li><li>如果在 Dockerfile 中有多个 <code>CMD</code> 指令，只有最后一个会生效。</li><li><code>CMD</code> 指令的格式可以是列表形式，也可以是字符串形式。列表形式使用 JSON 数组格式（例如 <code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code>），字符串形式则使用标准 shell 命令（例如 <code>CMD executable param1 param2</code>）。</li><li>如果在 <code>docker run</code> 命令中指定了要运行的命令，它将覆盖 <code>CMD</code> 中定义的默认命令。</li><li><code>CMD</code> 中指定的命令不会在容器内创建新的进程，而是替代了容器的默认进程。<strong>这意味着当指定的命令运行结束时，容器也会自动终止。</strong></li></ul><h2 id="6-ENTRYPOINT-容器启动命令"><a href="#6-ENTRYPOINT-容器启动命令" class="headerlink" title="6.ENTRYPOINT 容器启动命令"></a>6.<code>ENTRYPOINT</code> 容器启动命令</h2><p>在 Docker 中，<code>ENTRYPOINT</code> 用于定义容器启动时要执行的主要命令或应用程序。与 <code>CMD</code> 不同，<code>ENTRYPOINT</code> 定义的命令在容器启动时始终执行，无论是否在 <code>docker run</code> 命令中指定了其他命令。</p><p>以下是关于 <code>ENTRYPOINT</code> 的一些重要信息：</p><ul><li><code>ENTRYPOINT</code> 可以在 Dockerfile 中使用，用于指定容器启动时要运行的主要命令。这个命令可以是应用程序，也可以是一条脚本。</li><li>如果在 <code>docker run</code> 命令中指定了要运行的命令，它将被视为 <code>ENTRYPOINT</code> 中命令的参数，而不会覆盖 <code>ENTRYPOINT</code> 定义的默认命令。</li><li>如果需要在容器启动时传递参数，可以将这些参数放在 <code>ENTRYPOINT</code> 后面。例如：<code>ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</code>。</li><li><code>CMD</code> 指令可以与 <code>ENTRYPOINT</code> 一起使用，提供默认的参数。这样可以在运行容器时覆盖 <code>CMD</code> 提供的默认参数，但不会影响 <code>ENTRYPOINT</code> 的命令。</li><li>与 <code>CMD</code> 类似，<code>ENTRYPOINT</code> 中指定的命令也不会在容器内创建新的进程，而是替代了容器的默认进程。这意味着当指定的命令运行结束时，容器也会自动终止。</li></ul><h2 id="7-Shell格式和Exec格式"><a href="#7-Shell格式和Exec格式" class="headerlink" title="7.Shell格式和Exec格式"></a>7.Shell格式和Exec格式</h2><p>在 Docker 的 <code>CMD</code> 和 <code>ENTRYPOINT</code> 指令中，有两种常见的格式：Shell 格式和 Exec 格式。</p><h3 id="Shell-格式"><a href="#Shell-格式" class="headerlink" title="Shell 格式"></a>Shell 格式</h3><p>在 Shell 格式中，<code>CMD</code> 或 <code>ENTRYPOINT</code> 的命令会被解释为在一个 shell 中执行。这意味着你可以使用 shell 的特性，比如通配符和变量替换。</p><p>例如，以下是一个使用 Shell 格式的示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$USER</span>!&quot;</span></span></span><br></pre></td></tr></table></figure><p>在这个示例中，<code>$USER</code> 是一个 shell 变量，将会在容器启动时被替换成实际的用户名。</p><h3 id="Exec-格式"><a href="#Exec-格式" class="headerlink" title="Exec 格式"></a>Exec 格式</h3><p>在 Exec 格式中，<code>CMD</code> 或 <code>ENTRYPOINT</code> 的命令会被直接执行，不会被解释成 shell 命令。这意味着没有 shell 特性可用，也没有变量替换。</p><p>例如，以下是一个使用 Exec 格式的示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;echo&quot;</span>, <span class="string">&quot;Hello, World!&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>在这个示例中，命令 <code>[&quot;echo&quot;, &quot;Hello, World!&quot;]</code> 会被直接执行，不会进行任何 shell 解释或变量替换。</p><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><p>选择使用哪种格式取决于你的需求。如果需要使用 shell 的特性或变量替换，那么可以使用 Shell 格式。但是，Shell 格式可能会引入一些潜在的问题，比如需要处理 shell 的转义和安全性问题。</p><p>Exec 格式通常更安全，因为它避免了 shell 的解释和可能的漏洞。它也更适合于不依赖于 shell 特性的命令。</p><p>总之，根据实际情况选择合适的格式，以满足容器的需求。</p><p>当你想要在 <code>CMD</code> 中使用带有 Shell 变量的命令，你可以使用 Shell 格式，如下所示：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$USER</span>!&quot;</span></span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>$USER</code> 是一个 shell 变量，将会在容器启动时被替换成实际的用户名。然而，如果你想在 Exec 格式中使用变量，你需要使用 Shell 的执行命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo Hello, <span class="variable">$USER</span>!&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了 <code>/bin/sh</code> 作为执行的 shell，然后使用 <code>-c</code> 选项传递要执行的命令。这样，<code>$USER</code> 变量会在 shell 中被解释和替换。</p><p>请注意，虽然这个例子使用了 Exec 格式，但是它还是在容器内部启动了一个 shell 进程，然后执行了命令。这可能会引入一些不必要的额外开销，因此在选择 Shell 格式和 Exec 格式时，需要根据实际需求进行权衡。</p><h2 id="8-合理使用缓存"><a href="#8-合理使用缓存" class="headerlink" title="8.合理使用缓存"></a>8.合理使用缓存</h2><p>在编写 Dockerfile 时，合理使用缓存是优化构建过程和减少镜像构建时间的重要技巧之一。</p><p>Docker 在构建镜像时会使用缓存，以便重复使用之前的构建步骤。</p><p>以下是一些合理使用缓存的技巧：</p><h3 id="1-优先复用不变的步骤"><a href="#1-优先复用不变的步骤" class="headerlink" title="1. 优先复用不变的步骤"></a>1. 优先复用不变的步骤</h3><p>将不太可能发生变化的步骤放在 Dockerfile 的前面，以便在构建过程中复用缓存。比如，安装基础依赖、复制代码等步骤通常不会频繁变化。</p><h3 id="2-分阶段构建"><a href="#2-分阶段构建" class="headerlink" title="2. 分阶段构建"></a>2. 分阶段构建</h3><p>将 Dockerfile 分成多个阶段（<code>FROM</code>），每个阶段执行特定的任务。这样可以确保只有在前面阶段的内容发生变化时才会重新构建。不变的阶段的缓存会被复用。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阶段一：构建应用</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">14</span> AS builder</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> package*.json ./</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm install</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> npm build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 阶段二：运行应用</span></span><br><span class="line"><span class="keyword">FROM</span> nginx:alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=builder /app/dist /usr/share/nginx/html</span></span><br></pre></td></tr></table></figure><h3 id="3-使用-no-cache"><a href="#3-使用-no-cache" class="headerlink" title="3. 使用 --no-cache"></a>3. 使用 <code>--no-cache</code></h3><p>有时，为了确保获取最新的依赖或代码，你可以在构建时禁用缓存，以防止旧的缓存内容被使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --no-cache -t myapp .</span><br></pre></td></tr></table></figure><h3 id="4-按需精确刷新缓存"><a href="#4-按需精确刷新缓存" class="headerlink" title="4. 按需精确刷新缓存"></a>4. 按需精确刷新缓存</h3><p>如果你只想刷新特定步骤的缓存，可以在 Dockerfile 中做一些改变，例如修改一个文件的时间戳，以触发后续步骤的重新构建。</p><h3 id="5-使用-dockerignore-文件"><a href="#5-使用-dockerignore-文件" class="headerlink" title="5. 使用 .dockerignore 文件"></a>5. 使用 <code>.dockerignore</code> 文件</h3><p><code>.dockerignore</code> 文件可以用来指定哪些文件不需要被包含在构建上下文中，从而减少构建上下文的大小，提高构建速度。</p><h3 id="6-小心使用-COPY-和-ADD"><a href="#6-小心使用-COPY-和-ADD" class="headerlink" title="6. 小心使用 COPY 和 ADD"></a>6. 小心使用 <code>COPY</code> 和 <code>ADD</code></h3><p><code>COPY</code> 和 <code>ADD</code> 步骤会影响缓存的使用。如果源文件没有变化，那么缓存会被重用。但是如果源文件发生了变化，所有后续步骤都将无法复用缓存。所以，在使用 <code>COPY</code> 和 <code>ADD</code> 时要注意只复制必要的文件。</p><p>总之，合理使用缓存可以显著提高 Docker 镜像的构建效率。通过优化 Dockerfile 的结构和使用缓存技巧，你可以减少构建时间，提高开发效率。</p><h2 id="9-镜像的多阶段构建"><a href="#9-镜像的多阶段构建" class="headerlink" title="9.镜像的多阶段构建"></a>9.镜像的多阶段构建</h2><p>Dockerfile 的多阶段构建是一种强大的技巧，可以在构建镜像时实现更高效的资源利用和减小镜像大小。它适用于需要在构建过程中生成多个临时文件、编译代码或处理多个步骤的场景。以下是关于镜像的多阶段构建的一些技巧：</p><h3 id="1-减小镜像大小"><a href="#1-减小镜像大小" class="headerlink" title="1. 减小镜像大小"></a>1. 减小镜像大小</h3><p>多阶段构建允许你在不同的构建阶段中创建临时镜像，最终仅将需要的文件和结果复制到最终的镜像中。这样可以避免将构建时产生的临时文件和不必要的依赖包含在最终镜像中，从而减小镜像的大小。</p><h3 id="2-分隔构建过程"><a href="#2-分隔构建过程" class="headerlink" title="2. 分隔构建过程"></a>2. 分隔构建过程</h3><p>将不同的构建步骤放在不同的构建阶段中，使得每个阶段专注于一个特定的任务。这有助于保持 Dockerfile 的可读性和维护性，同时也能更好地控制每个步骤的缓存和重新构建。</p><h3 id="3-使用不同的基础镜像"><a href="#3-使用不同的基础镜像" class="headerlink" title="3. 使用不同的基础镜像"></a>3. 使用不同的基础镜像</h3><p>不同的构建阶段可以使用不同的基础镜像，以适应不同的需求。例如，一个阶段可以使用包含编译工具的基础镜像，而另一个阶段可以使用更轻量的生产环境基础镜像。</p><h3 id="4-使用-COPY-from-复制文件"><a href="#4-使用-COPY-from-复制文件" class="headerlink" title="4. 使用 COPY --from 复制文件"></a>4. 使用 <code>COPY --from</code> 复制文件</h3><p>通过使用 <code>COPY --from</code> 语法，你可以从一个构建阶段复制文件到另一个构建阶段，而不必将整个临时镜像中的文件都复制到最终镜像中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DockerfileCopy code# 第一个阶段：编译</span><br><span class="line">FROM golang:1.16 AS builder</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line">RUN go build -o myapp</span><br><span class="line"></span><br><span class="line"># 第二个阶段：最终镜像</span><br><span class="line">FROM alpine:latest</span><br><span class="line">COPY --from=builder /app/myapp /usr/bin/</span><br><span class="line">CMD [&quot;myapp&quot;]</span><br></pre></td></tr></table></figure><p>在上面的示例中，最终镜像只包含了编译后的可执行文件，而不包含编译工具和源代码。</p><h3 id="5-清理不必要的文件"><a href="#5-清理不必要的文件" class="headerlink" title="5. 清理不必要的文件"></a>5. 清理不必要的文件</h3><p>在每个构建阶段的结束时，可以使用 <code>RUN</code> 命令来清理不再需要的临时文件、缓存和依赖项，以进一步减小镜像的大小。</p><p>总之，多阶段构建是一个优秀的技巧，可以创建更小、更高效的 Docker 镜像。通过在不同的阶段处理不同的任务，你可以将构建过程分割为更小的部分，并在最终镜像中仅包含必要的内容。这对于开发、测试和部署都有很大的好处。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h1&gt;&lt;h2 id=&quot;1-基础镜像的选择&quot;&gt;&lt;a href=&quot;#1-基础镜像的选择&quot; c</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="cloud" scheme="https://www.ckxgzxa.top/categories/cloud/"/>
    
    
    <category term="Docker" scheme="https://www.ckxgzxa.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>02.Docker 镜像</title>
    <link href="https://www.ckxgzxa.top/road2docker02.html"/>
    <id>https://www.ckxgzxa.top/road2docker02.html</id>
    <published>2023-08-12T14:01:23.000Z</published>
    <updated>2023-12-05T18:20:29.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h1><h2 id="1-镜像的获取方式"><a href="#1-镜像的获取方式" class="headerlink" title="1. 镜像的获取方式"></a>1. 镜像的获取方式</h2><ul><li>从 <code>registry</code> 拉取(online)<ul><li>public</li><li>private</li></ul></li><li>从 <code>Dockerfile</code> 构建(online)</li><li>从 <code>file</code> 文件导入(offline)</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202308122209696.png" alt=""></p><h2 id="2-镜像基本操作"><a href="#2-镜像基本操作" class="headerlink" title="2. 镜像基本操作"></a>2. 镜像基本操作</h2><ul><li><p>镜像拉取</p><p>从 <code>registry</code> 下载一个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image pull NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure></li><li><p>查看镜像列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br></pre></td></tr></table></figure></li><li><p>显示一个或多个镜像详细信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image inspect IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure></li><li><p>删除镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">rm</span> [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p><code>-f</code>, 强制删除</p></li><li><p>导出镜像文件</p><p>将一个或多个镜像保存到一个tar归档文件中（默认流式传输到标准输出）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image save [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure><p><code>--output</code> , <code>-o</code>写入文件, 而不是标准输出</p></li><li><p>导入镜像文件</p><p>从一个tar归档文件或标准输入加载一个镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image load [OPTIONS]</span><br></pre></td></tr></table></figure><p>—input , -i 从tar归档文件中读取，而不是从标准输入读取</p></li><li><p>创建新的镜像</p><p>从容器的更改创建新的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure><p><code>--author</code>, <code>-a</code>  作者</p><p> <code>--change</code> , <code>-c</code>   将 Dockerfile 指令应用于创建的镜像</p><p><code>--message</code> , <code>-m</code>  提交消息</p><p><code>--pause</code> , <code>-p</code>  默认为true, 在提交过程中暂停容器</p><p>从Dockerfile构建镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure><p>| 名称，简写                | 默认值 | 描述                                         |<br>| ————————————- | ——— | —————————————————————— |<br>| <code>--add-host</code>              |        | 添加自定义主机到IP映射（主机:IP）            |<br>| <code>--build-arg</code>             |        | 设置构建时的变量                             |<br>| <code>--cache-from</code>            |        | 要视为缓存源的镜像                           |<br>| <code>--cgroup-parent</code>         |        | 容器的可选父cgroup                           |<br>| <code>--compress</code>              |        | 使用gzip压缩构建上下文                       |<br>| <code>--cpu-period</code>            |        | 限制CPU CFS（完全公平调度程序）周期          |<br>| <code>--cpu-quota</code>             |        | 限制CPU CFS（完全公平调度程序）配额          |<br>| <code>--cpu-shares</code>，<code>-c</code>      |        | CPU份额（相对权重）                          |<br>| <code>--cpuset-cpus</code>           |        | 允许执行的CPU（0-3，0,1）                    |<br>| <code>--cpuset-mems</code>           |        | 允许执行的内存节点（0-3，0,1）               |<br>| <code>--disable-content-trust</code> | <code>true</code> | 跳过镜像验证                                 |<br>| <code>--file</code>，<code>-f</code>            |        | Dockerfile的名称（默认为路径/Dockerfile）    |<br>| <code>--force-rm</code>              |        | 始终删除中间容器                             |<br>| <code>--iidfile</code>               |        | 将镜像ID写入文件                             |<br>| <code>--isolation</code>             |        | 容器隔离技术                                 |<br>| <code>--label</code>                 |        | 为镜像设置元数据                             |<br>| <code>--memory</code>，<code>-m</code>          |        | 内存限制                                     |<br>| <code>--memory-swap</code>           |        | 交换限制等于内存加交换：-1表示启用无限交换   |<br>| <code>--network</code>               |        | 设置构建期间RUN指令的网络模式                |<br>| <code>--no-cache</code>              |        | 构建镜像时不使用缓存                         |<br>| <code>--platform</code>              |        | 如果服务器支持多平台，则设置平台             |<br>| <code>--pull</code>                  |        | 始终尝试拉取更新版本的镜像                   |<br>| <code>--quiet</code>，<code>-q</code>           |        | 抑制构建输出，并在成功时打印镜像ID           |<br>| <code>--rm</code>                    | <code>true</code> | 在成功构建后删除中间容器                     |<br>| <code>--security-opt</code>          |        | 安全选项                                     |<br>| <code>--shm-size</code>              |        | /dev/shm的大小                               |<br>| <code>--squash</code>                |        | 实验性（守护程序）将新构建的层压缩为单个新层 |<br>| <code>--tag</code>，<code>-t</code>             |        | 名称和（可选）标签，格式为name:tag           |<br>| <code>--target</code>                |        | 设置要构建的目标构建阶段                     |<br>| <code>--ulimit</code>                |        | Ulimit选项                                   |</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-镜像&quot;&gt;&lt;a href=&quot;#Docker-镜像&quot; class=&quot;headerlink&quot; title=&quot;Docker 镜像&quot;&gt;&lt;/a&gt;Docker 镜像&lt;/h1&gt;&lt;h2 id=&quot;1-镜像的获取方式&quot;&gt;&lt;a href=&quot;#1-镜像的获取方式&quot; class</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="cloud" scheme="https://www.ckxgzxa.top/categories/cloud/"/>
    
    
    <category term="Docker" scheme="https://www.ckxgzxa.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>01.Docker的安装</title>
    <link href="https://www.ckxgzxa.top/road2docker01.html"/>
    <id>https://www.ckxgzxa.top/road2docker01.html</id>
    <published>2022-11-14T14:56:24.000Z</published>
    <updated>2023-12-05T18:20:24.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h1><ul><li><p>更新库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt apt-get update</span><br><span class="line">sudo apt-get install ca-certificates curl gnupg </span><br></pre></td></tr></table></figure></li><li><p>添加Docker <code>GPG</code> 官方密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg</span><br><span class="line">sudo <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure></li><li><p>设置Docker 源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=&quot;</span>$(dpkg --print-architecture)<span class="string">&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  &quot;</span>$(. /etc/os-release &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)<span class="string">&quot; stable&quot;</span> | \</span><br><span class="line">  sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure></li><li>使用 <code>sudo  apt-get update</code>更新库索引</li><li><p>安装Docker</p><ul><li><p>最新版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure></li><li><p>特定版本</p><ol><li><p>首先使用 <code>apt-cache madison docker-ce | awk &#39;&#123; print $3 &#125;&#39;</code>命令查看Docker版本列表</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202308121827429.png" alt=""></p></li><li><p>选择特定版本并安装:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VERSION_STRING=5:23.0.3-1~ubuntu.20.04~focal</span><br><span class="line">sudo apt-get install docker-ce=<span class="variable">$VERSION_STRING</span> docker-ce-cli=<span class="variable">$VERSION_STRING</span> containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure></li></ol></li></ul></li><li><p>验证Docker被成功安装, 运行实例容器 <code>sudo docker run hello-world</code>, 可见以下输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">&quot;hello-world&quot;</span> image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker的安装&quot;&gt;&lt;a href=&quot;#Docker的安装&quot; class=&quot;headerlink&quot; title=&quot;Docker的安装&quot;&gt;&lt;/a&gt;Docker的安装&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;更新库&lt;/p&gt;
&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="cloud" scheme="https://www.ckxgzxa.top/categories/cloud/"/>
    
    
    <category term="Docker" scheme="https://www.ckxgzxa.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习14-常见任务</title>
    <link href="https://www.ckxgzxa.top/road2go14.html"/>
    <id>https://www.ckxgzxa.top/road2go14.html</id>
    <published>2022-11-11T16:47:36.000Z</published>
    <updated>2022-11-11T18:32:18.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习14-常见任务"><a href="#Go语言学习14-常见任务" class="headerlink" title="Go语言学习14-常见任务"></a>Go语言学习14-常见任务</h2><h3 id="内置的-JSON-解析"><a href="#内置的-JSON-解析" class="headerlink" title="内置的 JSON 解析"></a>内置的 JSON 解析</h3><p>利用反射实现, 通过 FieldTag 来标识对应的 json 值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> JobInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">    Skills []<span class="type">string</span> <span class="string">`json:&quot;skills&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    BasicInfo BasicInfo <span class="string">`json:&quot;basic_info&quot;`</span></span><br><span class="line">    JobInfo   JobInfo   <span class="string">`json:&quot;job_info&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// embedded_json_test.go</span></span><br><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">`&#123;</span></span><br><span class="line"><span class="string">&quot;basic_info&quot;:&#123;</span></span><br><span class="line"><span class="string">&quot;name&quot;:&quot;Mike&quot;,</span></span><br><span class="line"><span class="string">&quot;age&quot;:30</span></span><br><span class="line"><span class="string">&#125;,</span></span><br><span class="line"><span class="string">&quot;job_info&quot;:&#123;</span></span><br><span class="line"><span class="string">&quot;skills&quot;: [&quot;Java&quot;, &quot;Go&quot;, &quot;C&quot;]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestEmbeddedJson</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">e := <span class="built_in">new</span>(Employee)</span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(jsonStr), e)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">t.Error(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(*e)</span><br><span class="line"><span class="keyword">if</span> v, err := json.Marshal(e); err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="type">string</span>(v))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Error(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="更快的-JSON-解析"><a href="#更快的-JSON-解析" class="headerlink" title="更快的 JSON 解析"></a>更快的 JSON 解析</h3><p>EasyJSON 采用代码生成而非反射</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211120143847.png" alt=""></p><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/mailru/easyjson/...</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">easyjson -all &lt;结构定义&gt;.go</span><br></pre></td></tr></table></figure><h3 id="HTTP-Server"><a href="#HTTP-Server" class="headerlink" title="HTTP Server"></a>HTTP Server</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">fmt.Fprintf(w, <span class="string">&quot;Hello World!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/time/&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">t := time.Now()</span><br><span class="line">timeStr := fmt.Sprintf(<span class="string">&quot;&#123;\&quot;time\&quot;: \&quot;%s\&quot;&#125;&quot;</span>, t)</span><br><span class="line">w.Write([]<span class="type">byte</span>(timeStr))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h4><ul><li><p>URL 分为两种，末尾是 / ：表示一个子树，后面可以跟其他子路径； 末尾不 是 /，表示一个叶子，固定的路径</p><p>以/ 结尾的 URL 可以匹配它的任何子路径，比如 /images 会匹配 /images/cute-cat.jpg</p></li><li><p>它采用最长匹配原则，如果有多个匹配，一定采用匹配路径最长的那个进行处</p><p>理</p></li><li><p>如果没有找到任何匹配项，会返回 404 错误</p></li></ul><h4 id="Default-Router"><a href="#Default-Router" class="headerlink" title="Default Router"></a>Default Router</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sh serverHandler)</span></span> ServeHTTP(rw ResponseWriter, req *Request) &#123;</span><br><span class="line">handler := sh.srv.Handler</span><br><span class="line"><span class="keyword">if</span> handler == <span class="literal">nil</span> &#123;</span><br><span class="line">handler = DefaultServeMux</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> req.RequestURI == <span class="string">&quot;*&quot;</span> &amp;&amp; req.Method == <span class="string">&quot;OPTIONS&quot;</span> &#123;</span><br><span class="line">handler = globalOptionsHandler&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">handler.ServeHTTP(rw, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建Restful服务"><a href="#构建Restful服务" class="headerlink" title="构建Restful服务"></a>构建Restful服务</h4><h5 id="更好的Router"><a href="#更好的Router" class="headerlink" title="更好的Router"></a>更好的Router</h5><p><a href="https://github.com/julienschmidt/httprouter">https://github.com/julienschmidt/httprouter</a></p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Hello</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;  </span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;hello, %s!\n&quot;</span>, ps.ByName(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    router := httprouter.New()  router.GET(<span class="string">&quot;/&quot;</span>, Index)</span><br><span class="line">    router.GET(<span class="string">&quot;/hello/:name&quot;</span>, Hello)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, router))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="面向资源的架构-Resource-Oriented-Architecture"><a href="#面向资源的架构-Resource-Oriented-Architecture" class="headerlink" title="面向资源的架构(Resource Oriented Architecture)"></a>面向资源的架构(Resource Oriented Architecture)</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211120215896.png" alt=""></p><p>In software engineering, a <strong>resource</strong>-<strong>oriented</strong> <strong>architecture</strong> (ROA) is a style of software <strong>architecture</strong> and programming paradigm for supportive designing and developing software in the form of Internetworking of <strong>resources</strong> with “RESTful” interfaces.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">ID   <span class="type">string</span> <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> employeeDB <span class="keyword">map</span>[<span class="type">string</span>]*Employee</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">employeeDB = <span class="keyword">map</span>[<span class="type">string</span>]*Employee&#123;&#125;</span><br><span class="line">employeeDB[<span class="string">&quot;Mike&quot;</span>] = &amp;Employee&#123;</span><br><span class="line">ID:   <span class="string">&quot;e-1&quot;</span>,</span><br><span class="line">Name: <span class="string">&quot;Mike&quot;</span>,</span><br><span class="line">Age:  <span class="number">35</span>,</span><br><span class="line">&#125;</span><br><span class="line">employeeDB[<span class="string">&quot;Rose&quot;</span>] = &amp;Employee&#123;</span><br><span class="line">ID:   <span class="string">&quot;e-2&quot;</span>,</span><br><span class="line">Name: <span class="string">&quot;Rose&quot;</span>,</span><br><span class="line">Age:  <span class="number">45</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Index</span><span class="params">(w http.ResponseWriter, r *http.Request, _ httprouter.Params)</span></span> &#123;</span><br><span class="line">fmt.Fprint(w, <span class="string">&quot;Welcome!\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetEmployeeByName</span><span class="params">(w http.ResponseWriter, r *http.Request, ps httprouter.Params)</span></span> &#123;</span><br><span class="line">qName := ps.ByName(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">ok       <span class="type">bool</span></span><br><span class="line">info     *Employee</span><br><span class="line">infoJson []<span class="type">byte</span></span><br><span class="line">err      <span class="type">error</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> info, ok = employeeDB[qName]; !ok &#123;</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;&#123;\&quot;error\&quot;:\&quot;Not Found\&quot;&#125;&quot;</span>))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> infoJson, err = json.Marshal(info); err != <span class="literal">nil</span> &#123;</span><br><span class="line">w.Write([]<span class="type">byte</span>(fmt.Sprintf(<span class="string">&quot;&#123;\&quot;error\&quot;:,\&quot;%s\&quot;&#125;&quot;</span>, err)))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">w.Write(infoJson)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">router := httprouter.New()</span><br><span class="line">router.GET(<span class="string">&quot;/&quot;</span>, Index)</span><br><span class="line">router.GET(<span class="string">&quot;/employees/:name&quot;</span>, GetEmployeeByName)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;localhost:8080&quot;</span>, router))</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习14-常见任务&quot;&gt;&lt;a href=&quot;#Go语言学习14-常见任务&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习14-常见任务&quot;&gt;&lt;/a&gt;Go语言学习14-常见任务&lt;/h2&gt;&lt;h3 id=&quot;内置的-JSON-解析&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习13-常见软件架构的实现</title>
    <link href="https://www.ckxgzxa.top/road2go13.html"/>
    <id>https://www.ckxgzxa.top/road2go13.html</id>
    <published>2022-11-11T10:45:41.000Z</published>
    <updated>2022-11-11T17:17:04.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习13-常见软件架构的实现"><a href="#Go语言学习13-常见软件架构的实现" class="headerlink" title="Go语言学习13-常见软件架构的实现"></a>Go语言学习13-常见软件架构的实现</h2><h3 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h3><p>An <font color="blue">architectural pattern</font> is a general, <strong>reusable solution</strong> to a commonly occurring problem in <font color="blue">software architectural</font> within a given context. ——wikipedia</p><h3 id="Pipe-Filter-架构"><a href="#Pipe-Filter-架构" class="headerlink" title="Pipe-Filter 架构"></a>Pipe-Filter 架构</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211111857702.png" alt=""></p><h4 id="Pipe-Filter-模式"><a href="#Pipe-Filter-模式" class="headerlink" title="Pipe-Filter 模式"></a>Pipe-Filter 模式</h4><ul><li><p>非常适合于数据处理及数据分析系统</p></li><li><p>Filter 封装数据处理的功能</p></li><li><p>松耦合: Filter只跟数据(格式) 耦合</p></li><li><p>Pipe用于连接 Filter 传递数据或者在异步处理过程中缓冲数据流</p><p>进程内同步调用时, pipe 演变为数据在方法调用间传递</p></li></ul><h4 id="Filter和组合模式"><a href="#Filter和组合模式" class="headerlink" title="Filter和组合模式"></a>Filter和组合模式</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211111911415.png" alt=""></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211111911920.png" alt=""></p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211111924672.png" style="zoom:25%;" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// filter.go</span></span><br><span class="line"><span class="comment">// Package pipefilter is to define the interfaces</span></span><br><span class="line"><span class="comment">// and the structures for pipe-filter style implementation</span></span><br><span class="line"><span class="keyword">package</span> pipefilter</span><br><span class="line"></span><br><span class="line"><span class="comment">// Request is the input of the filter</span></span><br><span class="line"><span class="keyword">type</span> Request <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Response is the output of the filter</span></span><br><span class="line"><span class="keyword">type</span> Response <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Filter interface is the definition of the data processing components</span></span><br><span class="line"><span class="comment">// Pipe-Filter structure</span></span><br><span class="line"><span class="keyword">type</span> Filter <span class="keyword">interface</span> &#123;</span><br><span class="line">Process(data Request) (Response, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// split_filter.go</span></span><br><span class="line"><span class="keyword">package</span> pipefilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SplitFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SplitFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">delimiter <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSplitFilter</span><span class="params">(delimiter <span class="type">string</span>)</span></span> *SplitFilter &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;SplitFilter&#123;delimiter&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SplitFilter)</span></span> Process(data Request) (Response, <span class="type">error</span>) &#123;</span><br><span class="line">str, ok := data.(<span class="type">string</span>) <span class="comment">// 检查数据格式/类型, 是否可以处理</span></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, SplitFilterWrongFormatError</span><br><span class="line">&#125;</span><br><span class="line">parts := strings.Split(str, sf.delimiter)</span><br><span class="line"><span class="keyword">return</span> parts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// to_int_filter.go</span></span><br><span class="line"><span class="keyword">package</span> pipefilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ToIntFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []string&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ToIntFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToIntFilter</span><span class="params">()</span></span> *ToIntFilter &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ToIntFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tif *ToIntFilter)</span></span> Process(data Request) (Response, <span class="type">error</span>) &#123;</span><br><span class="line">parts, ok := data.([]<span class="type">string</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, ToIntFilterWrongFormatError</span><br><span class="line">&#125;</span><br><span class="line">ret := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, part := <span class="keyword">range</span> parts &#123;</span><br><span class="line">s, err := strconv.Atoi(part)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">ret = <span class="built_in">append</span>(ret, s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sum_filter.go</span></span><br><span class="line"><span class="keyword">package</span> pipefilter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;errors&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> SumFilterWrongFormatError = errors.New(<span class="string">&quot;input data should be []int&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SumFilter <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSumFilter</span><span class="params">()</span></span> *SumFilter &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;SumFilter&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sf *SumFilter)</span></span> Process(data Request) (Response, <span class="type">error</span>) &#123;</span><br><span class="line">elems, ok := data.([]<span class="type">int</span>)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, SumFilterWrongFormatError</span><br><span class="line">&#125;</span><br><span class="line">ret := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, elem := <span class="keyword">range</span> elems &#123;</span><br><span class="line">ret += elem</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// straight_pipeline.go</span></span><br><span class="line"><span class="keyword">package</span> pipefilter</span><br><span class="line"></span><br><span class="line"><span class="comment">// StraightPipeline is composed of the filters, and the filters are piled as a straight line.</span></span><br><span class="line"><span class="keyword">type</span> StraightPipeline <span class="keyword">struct</span> &#123;</span><br><span class="line">Name    <span class="type">string</span></span><br><span class="line">Filters *[]Filter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStraightPipeline create a new StraightPipelineWithWallTime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStraightPipeline</span><span class="params">(name <span class="type">string</span>, filters ...Filter)</span></span> *StraightPipeline &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;StraightPipeline&#123;</span><br><span class="line">Name:    name,</span><br><span class="line">Filters: &amp;filters,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process is to process the coming data by the pipeline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *StraightPipeline)</span></span> Process(data Request) (Response, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> ret <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">for</span> _, filter := <span class="keyword">range</span> *f.Filters &#123;</span><br><span class="line">ret, err = filter.Process(data)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ret, err</span><br><span class="line">&#125;</span><br><span class="line">data = ret</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Micro-Kernel架构"><a href="#Micro-Kernel架构" class="headerlink" title="Micro Kernel架构"></a>Micro Kernel架构</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211120114863.png" alt=""></p><ul><li>特点<ul><li>易于扩展</li><li>错误隔离</li><li>保持架构一致性</li></ul></li><li>要点<ul><li>内核包含公共流程或通用逻辑</li><li>将可变或可扩展部分规划为扩展点</li><li>抽象扩展点行为, 定义接口</li><li>利用插件进行扩展</li></ul></li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211120116741.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> microkernel</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Waiting = <span class="literal">iota</span></span><br><span class="line">Running</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> WrongStateError = errors.New(<span class="string">&quot;can not take the operation in the current state&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CollectorsError <span class="keyword">struct</span> &#123;</span><br><span class="line">CollectorsErrors []<span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ce CollectorsError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">var</span> strs []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> _, err := <span class="keyword">range</span> ce.CollectorsErrors &#123;</span><br><span class="line">strs = <span class="built_in">append</span>(strs, err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strings.Join(strs, <span class="string">&quot;;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Event <span class="keyword">struct</span> &#123;</span><br><span class="line">Source  <span class="type">string</span></span><br><span class="line">Content <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EventReceiver <span class="keyword">interface</span> &#123;</span><br><span class="line">OnEvent(evt Event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Collector <span class="keyword">interface</span> &#123;</span><br><span class="line">Init(evtReceiver EventReceiver) <span class="type">error</span></span><br><span class="line">Start(agtCtx context.Context) <span class="type">error</span></span><br><span class="line">Stop() <span class="type">error</span></span><br><span class="line">Destroy() <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Agent <span class="keyword">struct</span> &#123;</span><br><span class="line">collectors <span class="keyword">map</span>[<span class="type">string</span>]Collector</span><br><span class="line">evtBuf     <span class="keyword">chan</span> Event</span><br><span class="line">cancel     context.CancelFunc</span><br><span class="line">ctx        context.Context</span><br><span class="line">state      <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> EventProcessGroutine() &#123;</span><br><span class="line"><span class="keyword">var</span> evtSeg [<span class="number">10</span>]Event</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> evtSeg[i] = &lt;-agt.evtBuf:</span><br><span class="line"><span class="keyword">case</span> &lt;-agt.ctx.Done():</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(evtSeg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAgent</span><span class="params">(sizeEvtBuf <span class="type">int</span>)</span></span> *Agent &#123;</span><br><span class="line">agt := Agent&#123;</span><br><span class="line">collectors: <span class="keyword">map</span>[<span class="type">string</span>]Collector&#123;&#125;,</span><br><span class="line">evtBuf:     <span class="built_in">make</span>(<span class="keyword">chan</span> Event, sizeEvtBuf),</span><br><span class="line">state:      Waiting,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;agt</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> RegisterCollector(name <span class="type">string</span>, collector Collector) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line"><span class="keyword">return</span> WrongStateError</span><br><span class="line">&#125;</span><br><span class="line">agt.collectors[name] = collector</span><br><span class="line"><span class="keyword">return</span> collector.Init(agt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> startCollectors() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">var</span> errs CollectorsError</span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>, collector Collector, ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">err = collector.Start(ctx)</span><br><span class="line">mutex.Lock()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs.CollectorsErrors = <span class="built_in">append</span>(errs.CollectorsErrors,</span><br><span class="line">errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;(name, collector, agt.ctx)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorsErrors) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> stopCollectors() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">var</span> errs CollectorsError</span><br><span class="line"><span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line"><span class="keyword">if</span> err = collector.Stop(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs.CollectorsErrors = <span class="built_in">append</span>(errs.CollectorsErrors,</span><br><span class="line">errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorsErrors) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> destroyCollectors() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">var</span> errs CollectorsError</span><br><span class="line"><span class="keyword">for</span> name, collector := <span class="keyword">range</span> agt.collectors &#123;</span><br><span class="line"><span class="keyword">if</span> err = collector.Destroy(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">errs.CollectorsErrors = <span class="built_in">append</span>(errs.CollectorsErrors,</span><br><span class="line">errors.New(name+<span class="string">&quot;:&quot;</span>+err.Error()))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(errs.CollectorsErrors) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> errs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> Start() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line"><span class="keyword">return</span> WrongStateError</span><br><span class="line">&#125;</span><br><span class="line">agt.state = Running</span><br><span class="line">agt.ctx, agt.cancel = context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> agt.EventProcessGroutine()</span><br><span class="line"><span class="keyword">return</span> agt.startCollectors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> Stop() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> agt.state != Running &#123;</span><br><span class="line"><span class="keyword">return</span> WrongStateError</span><br><span class="line">&#125;</span><br><span class="line">agt.state = Waiting</span><br><span class="line">agt.cancel()</span><br><span class="line"><span class="keyword">return</span> agt.stopCollectors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> Destroy() <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> agt.state != Waiting &#123;</span><br><span class="line"><span class="keyword">return</span> WrongStateError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> agt.destroyCollectors()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(agt *Agent)</span></span> OnEvent(evt Event) &#123;</span><br><span class="line">agt.evtBuf &lt;- evt</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习13-常见软件架构的实现&quot;&gt;&lt;a href=&quot;#Go语言学习13-常见软件架构的实现&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习13-常见软件架构的实现&quot;&gt;&lt;/a&gt;Go语言学习13-常见软件架构的实现&lt;/h2&gt;&lt;h3 id=&quot;架</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习12-反射和Unsafe</title>
    <link href="https://www.ckxgzxa.top/road2go12.html"/>
    <id>https://www.ckxgzxa.top/road2go12.html</id>
    <published>2022-11-11T05:55:01.000Z</published>
    <updated>2022-11-11T10:46:26.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习12-反射和Unsafe"><a href="#Go语言学习12-反射和Unsafe" class="headerlink" title="Go语言学习12-反射和Unsafe"></a>Go语言学习12-反射和Unsafe</h2><h3 id="reflect-TypeOf-vs-reflect-ValueOf"><a href="#reflect-TypeOf-vs-reflect-ValueOf" class="headerlink" title="reflect.TypeOf vs. reflect.ValueOf"></a>reflect.TypeOf vs. reflect.ValueOf</h3><ul><li>reflect.TypeOf 返回类型 (reflect.Type)</li><li>reflect.ValueOf 返回类型 (reflect.Value)</li><li>可以从 reflect.Value 获得类型</li><li>通过 kind 来判断类型</li></ul><h3 id="判断类型——Kind"><a href="#判断类型——Kind" class="headerlink" title="判断类型——Kind()"></a>判断类型——Kind()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckType</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(v)</span><br><span class="line"><span class="keyword">switch</span> t.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Float32, reflect.Float64:</span><br><span class="line">fmt.Println(<span class="string">&quot;Float&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> reflect.Int, reflect.Int32, reflect.Int64:</span><br><span class="line">fmt.Println(<span class="string">&quot;Integer&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Unknown&quot;</span>, t)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用反射编写灵活的代码"><a href="#利用反射编写灵活的代码" class="headerlink" title="利用反射编写灵活的代码"></a>利用反射编写灵活的代码</h3><h4 id="按名字访问结构的成员"><a href="#按名字访问结构的成员" class="headerlink" title="按名字访问结构的成员"></a>按名字访问结构的成员</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.ValueOf(*e).FieldByName(<span class="string">&quot;Name&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="按名字访问结构的方法"><a href="#按名字访问结构的方法" class="headerlink" title="按名字访问结构的方法"></a>按名字访问结构的方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.ValueOf(e).MethodByName(<span class="string">&quot;UpdateAge&quot;</span>).Call([]reflect.Value&#123;reflect.ValueOf(<span class="number">1</span>)&#125;)</span><br></pre></td></tr></table></figure><h3 id="Struct-Tag"><a href="#Struct-Tag" class="headerlink" title="Struct Tag"></a>Struct Tag</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BasicInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">Age  <span class="type">int</span> <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="访问-StructTag"><a href="#访问-StructTag" class="headerlink" title="访问 StructTag"></a>访问 StructTag</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> nameField, ok := reflect.TypeOf(*e).FieldByName(<span class="string">&quot;Name&quot;</span>); !ok &#123;</span><br><span class="line">t.Error(<span class="string">&quot;Failed to get &#x27;Name&#x27; field.&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Log(<span class="string">&quot;Tag:format&quot;</span>, nameField.Tag.Get(<span class="string">&quot;format&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Reflect.Type 和 Reflect.Value 都有 FieldByName ⽅方法，注意他们的区别</p></blockquote><h3 id="万能程序"><a href="#万能程序" class="headerlink" title="万能程序"></a>万能程序</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FillBySettings</span><span class="params">(st <span class="keyword">interface</span>&#123;&#125;, settings <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// func(v value) Elem() Value</span></span><br><span class="line"><span class="comment">// elem returns the value that the interface v contains or that the pointer v points to.</span></span><br><span class="line"><span class="comment">// It panics if v&#x27;s Kind is not Interface or Ptr</span></span><br><span class="line"><span class="comment">// It returns the zero Value if v is nil.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reflect.TypeOf(st).Kind() != reflect.Ptr &#123;</span><br><span class="line"><span class="comment">// Elem() 获取指针指向的值</span></span><br><span class="line"><span class="keyword">if</span> reflect.TypeOf(st).Elem().Kind() != reflect.Struct &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;the first param should be a pointer to the struct type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> settings == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;settings is nil&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">field reflect.StructField</span><br><span class="line">ok    <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> settings &#123;</span><br><span class="line"><span class="keyword">if</span> field, ok = (reflect.ValueOf(st)).Elem().Type().FieldByName(k); !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> field.Type == reflect.TypeOf(v) &#123;</span><br><span class="line">vstr := reflect.ValueOf(st)</span><br><span class="line">vstr = vstr.Elem()</span><br><span class="line">vstr.FieldByName(k).Set(reflect.ValueOf(v))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射的特点"><a href="#反射的特点" class="headerlink" title="反射的特点"></a>反射的特点</h3><ul><li>提高了程序的灵活性</li><li>降低了程序的可读性</li><li>降低了程序的性能</li></ul><h3 id="“不安全”-编程"><a href="#“不安全”-编程" class="headerlink" title="“不安全” 编程"></a>“不安全” 编程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUnsafe</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">f := *(*<span class="type">float64</span>)(unsafe.Pointer(&amp;i))</span><br><span class="line">t.Log(unsafe.Pointer(&amp;i))</span><br><span class="line">t.Log(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The cases is suitable for unsafe</span></span><br><span class="line"><span class="keyword">type</span> MyInt <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合理的类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestConvert</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b := *(*[]MyInt)(unsafe.Pointer(&amp;a))</span><br><span class="line">t.Log(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原子类型操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAtomic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> shareBufPtr unsafe.Pointer</span><br><span class="line">writeDataFn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">data = <span class="built_in">append</span>(data, i)</span><br><span class="line">&#125;</span><br><span class="line">atomic.StorePointer(&amp;shareBufPtr, unsafe.Pointer(&amp;data))</span><br><span class="line">&#125;</span><br><span class="line">readDataFn := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := atomic.LoadPointer(&amp;shareBufPtr)</span><br><span class="line">fmt.Println(data, *(*[]<span class="type">int</span>)(data))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">writeDataFn()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">writeDataFn()</span><br><span class="line">time.Sleep(time.Microsecond * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">readDataFn()</span><br><span class="line">time.Sleep(time.Microsecond * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习12-反射和Unsafe&quot;&gt;&lt;a href=&quot;#Go语言学习12-反射和Unsafe&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习12-反射和Unsafe&quot;&gt;&lt;/a&gt;Go语言学习12-反射和Unsafe&lt;/h2&gt;&lt;h3 id=&quot;r</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习11-测试</title>
    <link href="https://www.ckxgzxa.top/road2go11.html"/>
    <id>https://www.ckxgzxa.top/road2go11.html</id>
    <published>2022-11-10T19:47:58.000Z</published>
    <updated>2022-11-11T05:54:39.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习11-测试"><a href="#Go语言学习11-测试" class="headerlink" title="Go语言学习11-测试"></a>Go语言学习11-测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functions.go</span></span><br><span class="line"><span class="keyword">package</span> testing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(op <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> op * op</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functions_test.go</span></span><br><span class="line"><span class="keyword">package</span> testing</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/stretchr/testify/assert&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSquare</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">inputs := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">expected := [...]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inputs); i++ &#123;</span><br><span class="line">ret := square(inputs[i])</span><br><span class="line">assert.Equal(t, expected[i], ret)</span><br><span class="line"><span class="comment">//if ret != expected[i] &#123;</span></span><br><span class="line"><span class="comment">//t.Errorf(&quot;input is %d, the expcted is %d, the actual %d&quot;,</span></span><br><span class="line"><span class="comment">//inputs[i], expected[i], ret)</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestErrorInCode</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">t.Error(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFailInCode</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Start&quot;</span>)</span><br><span class="line">t.Fatal(<span class="string">&quot;Error&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;End&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内置单元测试框架"><a href="#内置单元测试框架" class="headerlink" title="内置单元测试框架"></a>内置单元测试框架</h4><ul><li>Fail, Error: 该测试失败, 该测试继续, 其他测试继续执行</li><li><p>FailNow, Fatal: 该测试失败, 该测试中止, 其他测试继续执行</p></li><li><p>代码覆盖率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -cover</span><br></pre></td></tr></table></figure></li><li><p>断言<a href="https://github.com/stretchr/testify">https://github.com/stretchr/testify</a></p></li></ul><h3 id="Benchmark"><a href="#Benchmark" class="headerlink" title="Benchmark"></a>Benchmark</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcatStringByAdd</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="comment">// 与性能测试无关的代码</span></span><br><span class="line">b.ResetTimer()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">&#125;</span><br><span class="line">b.StopTimer()</span><br><span class="line">    <span class="comment">// 与性能测试无关的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="benchmark命令"><a href="#benchmark命令" class="headerlink" title="benchmark命令"></a>benchmark命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -bench=. -benchmem</span><br></pre></td></tr></table></figure><p>-bench=\&lt;相关benchmark测试></p><p>Windows下使用<code>go test</code>命令行时, <code>-bench=.</code> 应写为 <code>-bench=&quot;.&quot;</code></p><h3 id="Behavior-Driven-Development"><a href="#Behavior-Driven-Development" class="headerlink" title="Behavior Driven Development"></a>Behavior Driven Development</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110432503.png" alt="让业务领域的专家参与开发"></p><p><em>“I believe that the hardest part of software projects, the most common source of project failure, is <strong>communication</strong> with the customers and users of that software. By providing a clear yet precise language to deal with domains, a DSL can help improve this communication.” – Martin Fowler.</em></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110434362.png" alt="用业务领域的语言来描述"></p><h4 id="BDD-in-Go"><a href="#BDD-in-Go" class="headerlink" title="BDD in Go"></a>BDD in Go</h4><h5 id="项目网站"><a href="#项目网站" class="headerlink" title="项目网站"></a>项目网站</h5><p><a href="https://github.com/smartystreets/goconvey">https://github.com/smartystreets/goconvey</a></p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/smartystreets/goconvey/convey</span><br></pre></td></tr></table></figure><h5 id="启动-web-ui"><a href="#启动-web-ui" class="headerlink" title="启动 web ui"></a>启动 web ui</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$GOPATH</span>/bin/goconvey</span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSpec</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="comment">// Only pass t into top-level Convey calls</span></span><br><span class="line">Convey(<span class="string">&quot;Given 2 even numbers&quot;</span>, t, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := <span class="number">2</span></span><br><span class="line">b := <span class="number">4</span></span><br><span class="line"></span><br><span class="line">Convey(<span class="string">&quot;When add the two numbers&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := a + b</span><br><span class="line"></span><br><span class="line">Convey(<span class="string">&quot;Then the result is still even&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">So(c%<span class="number">2</span>, ShouldEqual, <span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习11-测试&quot;&gt;&lt;a href=&quot;#Go语言学习11-测试&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习11-测试&quot;&gt;&lt;/a&gt;Go语言学习11-测试&lt;/h2&gt;&lt;h3 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习10-sync.Pool对象缓存</title>
    <link href="https://www.ckxgzxa.top/road2go10.html"/>
    <id>https://www.ckxgzxa.top/road2go10.html</id>
    <published>2022-11-10T19:08:16.000Z</published>
    <updated>2022-11-10T19:48:38.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习10-sync-Pool对象缓存"><a href="#Go语言学习10-sync-Pool对象缓存" class="headerlink" title="Go语言学习10-sync.Pool对象缓存"></a>Go语言学习10-sync.Pool对象缓存</h2><h3 id="sync-Pool-对象获取"><a href="#sync-Pool-对象获取" class="headerlink" title="sync.Pool 对象获取"></a><code>sync.Pool</code> 对象获取</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110340058.png" alt=""></p><ul><li>尝试从私有对象获取</li><li>私有对象不存在, 尝试从当前 Processor 的共享池获取</li><li>如果当前 Processor 共享池也是空的, name就尝试去其他 Processor 的共享池获取</li><li>如果所有子池都是空的, 最后就用用户指定的 New 函数产生一个新的对象返回</li></ul><h3 id="sync-Pool-对象的放回"><a href="#sync-Pool-对象的放回" class="headerlink" title="sync.Pool 对象的放回"></a><code>sync.Pool</code> 对象的放回</h3><ul><li>如果私有对象不存在则保存为私有对象</li><li>如果私有对象存在, 放入当前 Processor 子池的共享池中</li></ul><h3 id="使用-sync-Pool"><a href="#使用-sync-Pool" class="headerlink" title="使用 sync.Pool"></a>使用 <code>sync.Pool</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool := &amp;sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arry := pool.Get().(<span class="type">int</span>)</span><br><span class="line">...</span><br><span class="line">pool.Put(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h3 id="sync-Pool-对象的生命周期"><a href="#sync-Pool-对象的生命周期" class="headerlink" title="sync.Pool 对象的生命周期"></a><code>sync.Pool</code> 对象的生命周期</h3><ul><li>GC 会清除 sync.pool 缓存的对象</li><li>对象的缓存有效期为下一次 GC 之前</li></ul><h3 id="sync-Pool-总结"><a href="#sync-Pool-总结" class="headerlink" title="sync.Pool  总结"></a><code>sync.Pool</code>  总结</h3><ul><li>适合于通过复用, 降低复杂对象的创建 和 GC 代价</li><li>协程安全, <font color="red">会有锁的开销</font></li><li><font color="red">声明周期受 GC 影响, 不适合于做连接池等, 需自己管理声明周期的资源的池化</font></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习10-sync-Pool对象缓存&quot;&gt;&lt;a href=&quot;#Go语言学习10-sync-Pool对象缓存&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习10-sync.Pool对象缓存&quot;&gt;&lt;/a&gt;Go语言学习10-sync.Pool对象</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习09-典型并发任务</title>
    <link href="https://www.ckxgzxa.top/road2go09.html"/>
    <id>https://www.ckxgzxa.top/road2go09.html</id>
    <published>2022-11-10T17:28:05.000Z</published>
    <updated>2022-11-10T19:08:05.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习09-典型并发任务"><a href="#Go语言学习09-典型并发任务" class="headerlink" title="Go语言学习09-典型并发任务"></a>Go语言学习09-典型并发任务</h2><h3 id="单例模式-懒汉式-线程安全"><a href="#单例模式-懒汉式-线程安全" class="headerlink" title="单例模式(懒汉式, 线程安全)"></a>单例模式(懒汉式, 线程安全)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Singleton <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> singleInstance *Singleton</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetSingletonObj</span><span class="params">()</span></span> *Singleton &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Create Obj&quot;</span>)</span><br><span class="line">singleInstance = <span class="built_in">new</span>(Singleton)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> singleInstance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetSingletonObj</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">obj := GetSingletonObj()</span><br><span class="line">fmt.Println(unsafe.Pointer(obj))</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景01-仅需任意任务完成"><a href="#场景01-仅需任意任务完成" class="headerlink" title="场景01: 仅需任意任务完成"></a>场景01: 仅需任意任务完成</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runTask</span><span class="params">(id <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;The result is from %d&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FirstResponse</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">numOfRunner := <span class="number">10</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, numOfRunner)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numOfRunner; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ret := runTask(i)</span><br><span class="line">ch &lt;- ret</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &lt;-ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFirstResponse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">&quot;Before:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">t.Log(FirstResponse())</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">t.Log(<span class="string">&quot;After:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="场景02-等待所有任务完成"><a href="#场景02-等待所有任务完成" class="headerlink" title="场景02: 等待所有任务完成"></a>场景02: 等待所有任务完成</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runTask</span><span class="params">(id <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;The result is from %d&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AllResponse</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">numOfRunner := <span class="number">10</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, numOfRunner)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numOfRunner; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">ret := runTask(i)</span><br><span class="line">ch &lt;- ret</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">finalRet := <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; numOfRunner; j++ &#123;</span><br><span class="line">finalRet += &lt;-ch + <span class="string">&quot;\n&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> finalRet</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestFirstResponse</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">t.Log(<span class="string">&quot;Before:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">t.Log(AllResponse())</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">t.Log(<span class="string">&quot;After:&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现池化"><a href="#实现池化" class="headerlink" title="实现池化"></a>实现池化</h3><h4 id="使用-buffered-channel-实现对象池"><a href="#使用-buffered-channel-实现对象池" class="headerlink" title="使用 buffered channel 实现对象池"></a>使用 buffered channel 实现对象池</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReusableObj <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ObjPool <span class="keyword">struct</span> &#123;</span><br><span class="line">bufChan <span class="keyword">chan</span> *ReusableObj <span class="comment">// 用于缓冲可重用对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewObjPool</span><span class="params">(numOfObj <span class="type">int</span>)</span></span> *ObjPool &#123;</span><br><span class="line">objPool := ObjPool&#123;&#125;</span><br><span class="line">objPool.bufChan = <span class="built_in">make</span>(<span class="keyword">chan</span> *ReusableObj, numOfObj)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numOfObj; i++ &#123;</span><br><span class="line">objPool.bufChan &lt;- &amp;ReusableObj&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;objPool</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ObjPool)</span></span> GetObj(timeout time.Duration) (*ReusableObj, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ret := &lt;-p.bufChan:</span><br><span class="line"><span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(timeout): <span class="comment">// 超时控制</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;time out&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ObjPool)</span></span> ReleaseObj(obj *ReusableObj) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> p.bufChan &lt;- obj:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> errors.New(<span class="string">&quot;overflow&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习09-典型并发任务&quot;&gt;&lt;a href=&quot;#Go语言学习09-典型并发任务&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习09-典型并发任务&quot;&gt;&lt;/a&gt;Go语言学习09-典型并发任务&lt;/h2&gt;&lt;h3 id=&quot;单例模式-懒汉式-线程安全</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习08-并发编程</title>
    <link href="https://www.ckxgzxa.top/road2go08.html"/>
    <id>https://www.ckxgzxa.top/road2go08.html</id>
    <published>2022-11-10T05:08:07.000Z</published>
    <updated>2022-11-10T19:04:02.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习08-并发编程"><a href="#Go语言学习08-并发编程" class="headerlink" title="Go语言学习08-并发编程"></a>Go语言学习08-并发编程</h2><h3 id="Thread-vs-Groutine"><a href="#Thread-vs-Groutine" class="headerlink" title="Thread vs. Groutine"></a>Thread vs. Groutine</h3><ol><li><p>创建时默认的stack的大小</p><ul><li>JDK5 以后 Java Thread stack 默认为 1M</li><li>Groutine 的 Stack 初始化大小为 2K</li></ul></li><li><p>和 KSE (Kernel Space Entity) 的对应关系</p><ul><li>Java Thread 是 1:1 </li><li>Groutine 是 M:N</li></ul><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211101405748.png" alt=""></p></li></ol><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110251760.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGroutine</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="共享内存并发机制"><a href="#共享内存并发机制" class="headerlink" title="共享内存并发机制"></a>共享内存并发机制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounterThreadSafe</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mut sync.Mutex</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mut.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">mut.Lock()</span><br><span class="line">counter++</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCounterWaitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> mut sync.Mutex</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">counter := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mut.Unlock()</span><br><span class="line">&#125;()</span><br><span class="line">mut.Lock()</span><br><span class="line">counter++</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">t.Logf(<span class="string">&quot;counter = %d&quot;</span>, counter)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSP并发机制"><a href="#CSP并发机制" class="headerlink" title="CSP并发机制"></a>CSP并发机制</h3><h4 id="CSP-vs-Actor"><a href="#CSP-vs-Actor" class="headerlink" title="CSP vs. Actor"></a>CSP vs. Actor</h4><ul><li><p>和Actor的直接通讯不不同，CSP模式则是通过Channel进行通讯的，更松耦合⼀些</p></li><li><p>Go中channel是有容量限制并且独立于处理Groutine，而如Erlang，Actor模式中的mailbox容量是无限的，接收进程也总是被动地处理消息。</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110302506.png" alt=""></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110302716.png" alt=""></p><h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110302717.png" alt=""></p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211110302668.png" alt=""></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">service</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Done&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">otherTask</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;working on something else&quot;</span>)</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">100</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;Task is done.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestService</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">fmt.Println(service())</span><br><span class="line">otherTask()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AsyncService</span><span class="params">()</span></span> <span class="keyword">chan</span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">//retCh := make(chan string)</span></span><br><span class="line">retCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ret := service()</span><br><span class="line">fmt.Println(<span class="string">&quot;returned result.&quot;</span>)</span><br><span class="line">retCh &lt;- ret</span><br><span class="line">fmt.Println(<span class="string">&quot;service exited.&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> retCh</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestAsynService</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">retCh := AsyncService()</span><br><span class="line">otherTask()</span><br><span class="line">fmt.Println(&lt;-retCh)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多路选择和超时控制"><a href="#多路选择和超时控制" class="headerlink" title="多路选择和超时控制"></a>多路选择和超时控制</h3><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><font color="blue">多渠道的选择</font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> ret := &lt;-retCh1:</span><br><span class="line">    t.Logf(<span class="string">&quot;result %s&quot;</span>, ret)</span><br><span class="line">    <span class="keyword">case</span> ret := &lt;-retCh2:</span><br><span class="line">    t.Logf(<span class="string">&quot;result %s&quot;</span>, ret)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    t.Error(<span class="string">&quot;No one returned&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="blue">超时控制</font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> ret := &lt;-retCh:</span><br><span class="line">t.Logf(<span class="string">&quot;result %s&quot;</span>, ret)</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">t.Error(<span class="string">&quot;time out&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel的关闭和广播"><a href="#channel的关闭和广播" class="headerlink" title="channel的关闭和广播"></a>channel的关闭和广播</h3><h4 id="channel的关闭"><a href="#channel的关闭" class="headerlink" title="channel的关闭"></a>channel的关闭</h4><ul><li>向 关闭的channel发送数据, 会导致 panic</li><li><code>v, ok &lt;-ch</code>; ok 为bool值, true 表示正常接受, false 表示通道关闭</li><li>所有的 channel 接收者都会在channel关闭时, 立刻从阻塞等待中返回且上述ok值为false. 这个广播机制常被利用, 进行向多个订阅者同时发送信号. 如: 退出信号</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataProducer</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"><span class="comment">//ch &lt;- 11</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dataReceiver</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">11</span>; i++ &#123;</span><br><span class="line"><span class="comment">//data := &lt;-ch</span></span><br><span class="line"><span class="comment">//fmt.Println(data)</span></span><br><span class="line"><span class="keyword">if</span> data, ok := &lt;-ch; ok &#123;</span><br><span class="line">fmt.Println(data)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCloseChannel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">dataProducer(ch, &amp;wg)</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line">dataReceiver(ch, &amp;wg)</span><br><span class="line"><span class="comment">//wg.Add(1)</span></span><br><span class="line"><span class="comment">//dataReceiver(ch, &amp;wg)</span></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="context处理复杂场景任务的取消"><a href="#context处理复杂场景任务的取消" class="headerlink" title="context处理复杂场景任务的取消"></a>context处理复杂场景任务的取消</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isCancelled</span><span class="params">(cancelChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-cancelChan:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancel_1</span><span class="params">(cancelChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">cancelChan &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cancel_2</span><span class="params">(cancelChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="built_in">close</span>(cancelChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCancel</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">cancelChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>, cancelCh <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> isCancelled(cancelCh) &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(i, <span class="string">&quot;Cancelled&quot;</span>)</span><br><span class="line">&#125;(i, cancelChan)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cancel_1(cancelChan)</span></span><br><span class="line">cancel_2(cancelChan)</span><br><span class="line">time.Sleep(time.Second * <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Context与关联任务取消"><a href="#Context与关联任务取消" class="headerlink" title="Context与关联任务取消"></a>Context与关联任务取消</h4><ul><li>根Context: 通过 context.Background() 创建</li><li>子Context: context.WithCancel(parentContext) 创建<ul><li>ctx, cancel := context.WithCancel(context.Background())</li></ul></li><li>当前Context 被取消时, 基于他的子 context 都会被取消</li><li>接收取消通知 <code>&lt;-ctx.Done()</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习08-并发编程&quot;&gt;&lt;a href=&quot;#Go语言学习08-并发编程&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习08-并发编程&quot;&gt;&lt;/a&gt;Go语言学习08-并发编程&lt;/h2&gt;&lt;h3 id=&quot;Thread-vs-Groutine&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习07-包和依赖管理</title>
    <link href="https://www.ckxgzxa.top/road2go07.html"/>
    <id>https://www.ckxgzxa.top/road2go07.html</id>
    <published>2022-11-09T14:42:43.000Z</published>
    <updated>2022-11-10T18:50:40.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习07-包和依赖管理"><a href="#Go语言学习07-包和依赖管理" class="headerlink" title="Go语言学习07-包和依赖管理"></a>Go语言学习07-包和依赖管理</h2><h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><ol><li><p><strong>基本复用模块单元</strong></p><p>以首字母大写来表明可被包外代码访问</p></li><li><p><strong>代码的 package 可以和所在的目录不一致</strong></p></li><li><p><strong>同一目录里的 Go 代码的 package 要保持一致</strong></p></li></ol><hr><ol><li><p>通过 <code>go get</code> 来获取远程依赖</p><p><code>go get -u</code> 强制从网络更新远程依赖</p></li><li><p>注意代码在 GitHub 上的组织形式, 以适应 <code>go get</code></p><p>直接以代码路径开始, 不要有 src</p></li></ol><h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h3><ul><li>在 main 被执行前, 所有依赖的 package 的 init 方法都会被执行</li><li>不同包的 init 函数按照包导入的依赖关系决定执行顺序</li><li>每个包可以有多个init函数</li><li>包的每个源文件也可以有多个init函数, 这点比较特殊</li></ul><h3 id="Go-未解决的依赖问题"><a href="#Go-未解决的依赖问题" class="headerlink" title="Go 未解决的依赖问题"></a>Go 未解决的依赖问题</h3><ol><li>统一环境下, 不同项目使用同一包的不同版本</li><li>无法管理对包的特定版本的依赖</li></ol><h3 id="vendor-路径"><a href="#vendor-路径" class="headerlink" title="vendor 路径"></a>vendor 路径</h3><p>随着Go 1.5 release 版本的发布, vendor目录被添加到除了<strong>GOPATH</strong> 和<strong>GOROOT</strong>之外的依赖目录查找的解决方案。在Go 1.6之前，你需要手动的设置环境变量</p><p><strong>查找依赖包路径的解决方案如下:</strong></p><ol><li>当前包下的 vendor 目录</li><li>向上级目录查找, 知道找到 src 下的 vendor 目录</li><li>在 GOPATH 下面查找依赖包</li><li>在 GOROOT 目录下查找</li></ol><h3 id="常用的依赖管理工具"><a href="#常用的依赖管理工具" class="headerlink" title="常用的依赖管理工具"></a>常用的依赖管理工具</h3><p>godep <a href="https://github.com/tools/godep">https://github.com/tools/godep</a></p><p>glide <a href="https://github.com/Masterminds/glide">https://github.com/Masterminds/glide</a></p><p>dep <a href="https://github.com/golang/dep">https://github.com/golang/dep</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习07-包和依赖管理&quot;&gt;&lt;a href=&quot;#Go语言学习07-包和依赖管理&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习07-包和依赖管理&quot;&gt;&lt;/a&gt;Go语言学习07-包和依赖管理&lt;/h2&gt;&lt;h3 id=&quot;package&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习06-错误处理</title>
    <link href="https://www.ckxgzxa.top/road2go06.html"/>
    <id>https://www.ckxgzxa.top/road2go06.html</id>
    <published>2022-11-09T13:45:38.000Z</published>
    <updated>2022-11-10T18:48:45.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习06-错误处理"><a href="#Go语言学习06-错误处理" class="headerlink" title="Go语言学习06-错误处理"></a>Go语言学习06-错误处理</h2><h3 id="Go的错误机制"><a href="#Go的错误机制" class="headerlink" title="Go的错误机制"></a>Go的错误机制</h3><font color="blue">与其他主要编程语言的差异</font><ol><li><p>没有异常机制</p></li><li><p><code>error</code>类型实现了error接口</p></li><li><p>可以通过 errors.New 来快速创建错误实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errors.New(<span class="string">&quot;n must be in range [0, 10]&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><font color="blue">定义不同的错误变量, 以便于判断错误类型</font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LessThanTwoError = errors.New(<span class="string">&quot;n should be not less than 2&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> LargeThanHundredError = errors.New(<span class="string">&quot;n should be not larger than 100&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFibonacci</span><span class="params">(n <span class="type">int</span>)</span></span> ([]<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, LessThanTwoError</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &gt; <span class="number">100</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, LargeThanHundredError</span><br><span class="line">&#125;</span><br><span class="line">fibList := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span>; i &lt; n; i++ &#123;</span><br><span class="line">fibList = <span class="built_in">append</span>(fibList, fibList[i<span class="number">-2</span>]+fibList[i<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fibList, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetFibonacci</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> v, err := GetFibonacci(<span class="number">-10</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == LessThanTwoError &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;It is less.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">t.Error(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Log(v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="blue"><strong>及早失败, 避免嵌套!</strong></font><h3 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h3><ul><li>panic 用于不可恢复的错误</li><li>panic 退出前会执行 defer 指定的内容</li></ul><h4 id="panic-vs-os-Exit"><a href="#panic-vs-os-Exit" class="headerlink" title="panic vs. os.Exit"></a>panic vs. os.Exit</h4><ul><li>os.Exit 退出时不会调用 defer 指定的函数</li><li>os.Exit 退出时不输出当前调用栈信息</li></ul><h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最常见的&quot;错误恢复&quot;</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        Log.Error(<span class="string">&quot;recovered panic&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>缺陷:</p><ul><li>形成僵尸服务进程, 导致 health check 失效</li><li>“Let it Crash!” 往往是我们恢复不确定性错误的最好方法</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习06-错误处理&quot;&gt;&lt;a href=&quot;#Go语言学习06-错误处理&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习06-错误处理&quot;&gt;&lt;/a&gt;Go语言学习06-错误处理&lt;/h2&gt;&lt;h3 id=&quot;Go的错误机制&quot;&gt;&lt;a href=&quot;#Go</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习05-面向对象编程</title>
    <link href="https://www.ckxgzxa.top/road2go05.html"/>
    <id>https://www.ckxgzxa.top/road2go05.html</id>
    <published>2022-11-08T19:34:34.000Z</published>
    <updated>2022-11-10T18:47:19.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习05-面向对象编程"><a href="#Go语言学习05-面向对象编程" class="headerlink" title="Go语言学习05-面向对象编程"></a>Go语言学习05-面向对象编程</h2><p>Go语言官方对于Go 语言是否为面向对象编程的描述<a href="https://golang.org/doc/faq">https://golang.org/doc/faq</a>：</p><blockquote><font color="blue"><strong>Is Go an object-oriented language?</strong></font><p><font color="red">Yes and no.</font> Although Go has types and methods and allows an object-oriented style of programming, there is <strong>no type hierarchy. The concept of “interface” in Go provides a different approach that we believe is wasy to use and in some ways more general.</strong></p><p>Also, the lack of a type hierarchy makes “objects” in Go fell much more lightweight than in language such as C++ or Java.</p></blockquote><h3 id="封装数据和行为"><a href="#封装数据和行为" class="headerlink" title="封装数据和行为"></a>封装数据和行为</h3><h4 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="type">string</span></span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实例创建及初始化"><a href="#实例创建及初始化" class="headerlink" title="实例创建及初始化"></a>实例创建及初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">e := Employee&#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">20</span>&#125;</span><br><span class="line">e1 := Employee&#123;Name: <span class="string">&quot;Mike&quot;</span>, Age:<span class="number">30</span>&#125;</span><br><span class="line">e2 := <span class="built_in">new</span>(Employee)<span class="comment">// 注意这里返回的引用/指针, 相当于 e:=&amp;EmployeeP&#123;&#125;</span></span><br><span class="line">e2.Id = <span class="string">&quot;2&quot;</span><span class="comment">// 与其他编程语言的差异: 通过实例的指针访问成员不需要-&gt;</span></span><br><span class="line">e2.Age = <span class="number">22</span></span><br><span class="line">e2.Name = <span class="string">&quot;Rose&quot;</span></span><br></pre></td></tr></table></figure><h4 id="行为-方法-定义"><a href="#行为-方法-定义" class="headerlink" title="行为 (方法) 定义"></a>行为 (方法) 定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种定义方式在实例对应方法被调用时, 实例的成员会进行值复制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e Employee)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ID:%s-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常情况下为了避免内存拷贝我们使用第二种定义方式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ID:%s-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口与依赖"><a href="#接口与依赖" class="headerlink" title="接口与依赖"></a>接口与依赖</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">class A</span><br><span class="line">class AImpl</span><br><span class="line">class AClient</span><br><span class="line">&lt;&lt;interface&gt;&gt; A</span><br><span class="line">AImpl ..|&gt; A</span><br><span class="line">AClient ..&gt; A</span><br><span class="line">AClient ..&gt; AImpl</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Programmer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Programmer</span> &#123;</span><br><span class="line">    String <span class="title function_">WriteCodes</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GoProgrammer.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GoProgrammer</span> <span class="keyword">implements</span> <span class="title class_">Programmer</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">WriteCodes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;fmt.Println(\&quot;Hello World!\&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Programmer</span> <span class="variable">prog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GoProgrammer</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">codes</span> <span class="operator">=</span> prog.WriteCodes();</span><br><span class="line">        System.out.printlv(codes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Duck-Type式接口实现"><a href="#Duck-Type式接口实现" class="headerlink" title="Duck Type式接口实现"></a>Duck Type式接口实现</h3><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Programmer <span class="keyword">interface</span> &#123;</span><br><span class="line">    WriteHelloWorld() Code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GoProgrammer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *GoProgrammer)</span></span> WriteHelloWorld() Code &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;fmt.Printlv(\&quot;Hello World!\&quot;)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Go-接口"><a href="#Go-接口" class="headerlink" title="Go 接口"></a>Go 接口</h3><font color="blue">与其他主要编程语言的差异</font><ol><li>接口为非入侵性, 实现不依赖于接口定义</li><li>所以接口的定义可以包含在接口使用者包内</li></ol><h3 id="接口变量"><a href="#接口变量" class="headerlink" title="接口变量"></a>接口变量</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211091513954.png" alt=""></p><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><ol><li><code>type IntConvertionFn func(n int) int</code></li><li><code>type Mypoint int</code></li></ol><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211091856135.png" alt=""></p><h3 id="空接口与断言"><a href="#空接口与断言" class="headerlink" title="空接口与断言"></a>空接口与断言</h3><ol><li><p>空接口可以表示任何类型</p></li><li><p>通过断言来将空接口转换为指定类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := p.(<span class="type">int</span>)   <span class="comment">//ok = true 时为转换成功</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="Go-接口最佳实践"><a href="#Go-接口最佳实践" class="headerlink" title="Go 接口最佳实践"></a>Go 接口最佳实践</h3><ul><li><p>倾向于使用小的接口定义, 很多接口只包含一个方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">    Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>较大的接口定义, 可以由多个小接口定义组合而成</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">    Reader</span><br><span class="line">    Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只依赖于必要功能的最小接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StoreData</span><span class="params">(reader Reader)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习05-面向对象编程&quot;&gt;&lt;a href=&quot;#Go语言学习05-面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习05-面向对象编程&quot;&gt;&lt;/a&gt;Go语言学习05-面向对象编程&lt;/h2&gt;&lt;p&gt;Go语言官方对于Go 语言是否为面向</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习04-函数</title>
    <link href="https://www.ckxgzxa.top/road2go04.html"/>
    <id>https://www.ckxgzxa.top/road2go04.html</id>
    <published>2022-11-08T19:13:52.000Z</published>
    <updated>2023-11-19T12:27:35.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习04-函数"><a href="#Go语言学习04-函数" class="headerlink" title="Go语言学习04-函数"></a>Go语言学习04-函数</h2><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p><code>&lt;font color=&quot;Blue&quot;&gt;</code>与其他主要编程语言的差异<code>&lt;/font&gt;</code></p><ol><li>可以有多个返回值</li><li>所有参数都是值传递: slice, map, channel 会有传引用的错觉</li><li>函数可以作为变量的值</li><li>函数可以作为参数和返回值</li></ol><blockquote><p>学习函数式编程</p><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202311192020666.png" alt=""></p></blockquote><h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(ops ...<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    s := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, op := <span class="keyword">range</span> ops &#123;</span><br><span class="line">        s += op</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="defer-函数"><a href="#defer-函数" class="headerlink" title="defer 函数"></a>defer 函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestDefer</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        t.Log(<span class="string">&quot;Clear resources&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    t.Log(<span class="string">&quot;Started&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;Fatal error&quot;</span>) <span class="comment">// defer仍会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习04-函数&quot;&gt;&lt;a href=&quot;#Go语言学习04-函数&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习04-函数&quot;&gt;&lt;/a&gt;Go语言学习04-函数&lt;/h2&gt;&lt;h3 id=&quot;函数是一等公民&quot;&gt;&lt;a href=&quot;#函数是一等公民&quot; c</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习03-字符串</title>
    <link href="https://www.ckxgzxa.top/road2go03.html"/>
    <id>https://www.ckxgzxa.top/road2go03.html</id>
    <published>2022-11-08T13:14:58.000Z</published>
    <updated>2022-11-10T18:43:54.900Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习03-字符串"><a href="#Go语言学习03-字符串" class="headerlink" title="Go语言学习03-字符串"></a>Go语言学习03-字符串</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><font color="Blue">与其他主要编程语言的差异</font><ol><li>string 是数据类型, 不是引用或指针类型</li><li>string 是只读的 byte slice, len 函数可以返回它所包含的byte数</li><li>string 的byte数组可以存放任何数据</li></ol><h3 id="Unicode-UTF8"><a href="#Unicode-UTF8" class="headerlink" title="Unicode UTF8"></a>Unicode UTF8</h3><ol><li>Unicode 是一种字符集(code point)</li><li>UTF8 是 unicode 的存储实现(转换为字节序列的规则)</li></ol><h3 id="编码与存储"><a href="#编码与存储" class="headerlink" title="编码与存储"></a>编码与存储</h3><div class="table-container"><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">“中”</th></tr></thead><tbody><tr><td style="text-align:center">Unicode</td><td style="text-align:center">0x4E2D</td></tr><tr><td style="text-align:center">UTF-8</td><td style="text-align:center">0xE4B8AD</td></tr><tr><td style="text-align:center">string/[]byte</td><td style="text-align:center">[0xE4, 0xB8, 0xAD]</td></tr></tbody></table></div><h3 id="常用字符串函数"><a href="#常用字符串函数" class="headerlink" title="常用字符串函数"></a>常用字符串函数</h3><ol><li>strings包(<a href="https://golang.org/pkg/strings">https://golang.org/pkg/strings</a>)</li><li>strconv包(<a href="https://golang.org/pkg/strconv">https://golang.org/pkg/strconv</a>)</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习03-字符串&quot;&gt;&lt;a href=&quot;#Go语言学习03-字符串&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习03-字符串&quot;&gt;&lt;/a&gt;Go语言学习03-字符串&lt;/h2&gt;&lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言学习02-常用集合</title>
    <link href="https://www.ckxgzxa.top/road2go02.html"/>
    <id>https://www.ckxgzxa.top/road2go02.html</id>
    <published>2022-11-08T03:18:24.000Z</published>
    <updated>2022-11-10T18:42:36.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Go语言学习02-常用集合"><a href="#Go语言学习02-常用集合" class="headerlink" title="Go语言学习02-常用集合"></a>Go语言学习02-常用集合</h2><h3 id="条件与循环"><a href="#条件与循环" class="headerlink" title="条件与循环"></a>条件与循环</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><font color="Blue">与其他主要编程语言的差异</font><p>Go语言仅支持循环关键字 <code>for</code></p><p> <code>for j := 7; j &lt;= 9; j++</code></p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><font color="green">while条件循环 </font><font color="green">while (n < 5) </font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n &lt; <span class="number">5</span> &#123;</span><br><span class="line">    n++</span><br><span class="line">    fmt.Println(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="green">无限循环 </font><font color="green">while (true) </font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> n &lt; <span class="number">5</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if条件"><a href="#if条件" class="headerlink" title="if条件"></a>if条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition &#123;</span><br><span class="line">    <span class="comment">// code to be executed if condition is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code to be executed if condition is false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition<span class="number">-1</span> &#123;</span><br><span class="line">    <span class="comment">// code to be executed if condition-1 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition<span class="number">-2</span> &#123;</span><br><span class="line">    <span class="comment">// code to be executed if condition-2 is true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// code to be executed if both condition1 and condition2 are false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="blue">与其他主要编程语言的差异</font><ol><li><p>condition 表达式结果必须为布尔值</p></li><li><p>支持变量赋值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">var</span> declaration; condition &#123;</span><br><span class="line">    <span class="comment">// code to be executed if conditon is true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="switch条件"><a href="#switch条件" class="headerlink" title="switch条件"></a>switch条件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> os := runtime.GOOS; os &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;darwin&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;OS X.&quot;</span>)</span><br><span class="line"><span class="comment">// break</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;linux&quot;</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;Linux.&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// freebsd, openbsd,</span></span><br><span class="line"><span class="comment">// plan9, windows...</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s.&quot;</span>, os)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span> &lt;= Num &amp;&amp; Num &lt;= <span class="number">3</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;0-3&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span> &lt;= Num &amp;&amp; Num &lt;= <span class="number">6</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;4-6&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span> &gt;= Num &amp;&amp; Num &lt;= <span class="number">9</span>:</span><br><span class="line">fmt.Printf(<span class="string">&quot;7-9&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><font color="blue">与其他主要编程语言的差异</font><ol><li>条件表达式不限制为常量或者整数;</li><li>单个case中, 可以出现多个结果选项, 使用逗号分隔;</li><li>与C语言等规则相反, Go语言不需要用break来明确退出一个case;</li><li>可以不设定 switch 之后的条件表达式, 在此种情况下, 整个switch结构与多个if…else…的逻辑作用等同</li></ol><h3 id="数组与切片"><a href="#数组与切片" class="headerlink" title="数组与切片"></a>数组与切片</h3><h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">3</span>]<span class="type">int</span> <span class="comment">//声明并初始化为默认零值</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">b := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;<span class="comment">// 声明同时初始化</span></span><br><span class="line">c := [<span class="number">2</span>][<span class="number">2</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;&#125;<span class="comment">// 多位数组初始化</span></span><br></pre></td></tr></table></figure><font color="Blue">与其他主要编程语言的差异</font><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestTravelArray</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    a := [...]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;<span class="comment">// 不指定元素个数</span></span><br><span class="line">    <span class="keyword">for</span> idx<span class="comment">/*索引*/</span>, elem<span class="comment">/*元素*/</span> := <span class="keyword">range</span> a &#123;</span><br><span class="line">        fmt.Println(idx, elem)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组截取"><a href="#数组截取" class="headerlink" title="数组截取"></a>数组截取</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a[开始索引(包含)，结束索引(不包含)]</span><br><span class="line"></span><br><span class="line">a := [...]<span class="type">int</span>&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">5</span>&#125;</span><br><span class="line">a[<span class="number">1</span>:<span class="number">2</span>] <span class="comment">//2</span></span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//2,3</span></span><br><span class="line">a[<span class="number">1</span>:<span class="built_in">len</span>(a)] <span class="comment">//2,3,4,5</span></span><br><span class="line">a[<span class="number">1</span>:] <span class="comment">//2,3,4,5</span></span><br><span class="line">a[:<span class="number">3</span>] <span class="comment">//1,2,3</span></span><br></pre></td></tr></table></figure><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><h5 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211080205152.png" alt=""></p><h5 id="切片声明"><a href="#切片声明" class="headerlink" title="切片声明"></a>切片声明</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s0 []<span class="type">int</span></span><br><span class="line">s0 = <span class="built_in">append</span>(s0，<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">s1 := []<span class="type">int</span>&#123;<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>，<span class="number">2</span>，<span class="number">4</span>)</span><br><span class="line">   <span class="comment">/* []type, len, cap</span></span><br><span class="line"><span class="comment">   其中len个元素会被初始化为默认零值, 未初始化元素不可以访问</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure><h5 id="切片共享存储结构"><a href="#切片共享存储结构" class="headerlink" title="切片共享存储结构"></a>切片共享存储结构</h5><p><img src="https://zxastaticpages.oss-cn-beijing.aliyuncs.com/blogpictures/202211080216477.png" alt=""></p><h4 id="数组-vs-切片"><a href="#数组-vs-切片" class="headerlink" title="数组 vs. 切片"></a>数组 vs. 切片</h4><ol><li>数组容量不可伸缩</li><li>相同维数, 相同长度的数组可以进行比较, 每一个元素都相同, 这两个数组会被认为相同</li></ol><h3 id="Map声明、元素访问及遍历"><a href="#Map声明、元素访问及遍历" class="headerlink" title="Map声明、元素访问及遍历"></a>Map声明、元素访问及遍历</h3><h4 id="Map声明"><a href="#Map声明" class="headerlink" title="Map声明"></a>Map声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>:<span class="number">1</span>, <span class="string">&quot;two&quot;</span>:<span class="number">2</span>, <span class="string">&quot;three&quot;</span>:<span class="number">3</span>&#125;</span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">m1[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="number">10</span> <span class="comment">/*Initial Capacity*/</span>)</span><br></pre></td></tr></table></figure><h4 id="Map元素的访问"><a href="#Map元素的访问" class="headerlink" title="Map元素的访问"></a>Map元素的访问</h4><font color="Blue">与其他主要编程语言的差异</font><p>在访问的Key不存在时, 仍会返回零值, 不能通过返回nil来判断元素是否存在</p><h4 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;one&quot;</span>:<span class="number">1</span>, <span class="string">&quot;two&quot;</span>:<span class="number">2</span>, <span class="string">&quot;three&quot;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">    t.Log(k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Set"><a href="#实现Set" class="headerlink" title="实现Set"></a>实现Set</h3><p><strong>Go 的内置集合中没有 Set 实现, 可以map[type]bool</strong></p><ol><li><p><strong>元素的唯一性</strong></p></li><li><p><strong>基本操作</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestMapForSet</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mySet := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">mySet[<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">n := <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> mySet[n] &#123;</span><br><span class="line">t.Logf(<span class="string">&quot;%d is existing&quot;</span>, n)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Logf(<span class="string">&quot;%d is not existing&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">mySet[<span class="number">3</span>] = <span class="literal">true</span></span><br><span class="line">t.Log(<span class="built_in">len</span>(mySet))</span><br><span class="line"><span class="built_in">delete</span>(mySet, <span class="number">1</span>)</span><br><span class="line">n = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> mySet[n] &#123;</span><br><span class="line">t.Logf(<span class="string">&quot;%d is existing&quot;</span>, n)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">t.Logf(<span class="string">&quot;%d is not existing&quot;</span>, n)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>添加元素</li><li>判断元素是否存在</li><li>删除元素</li><li>元素个数</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Go语言学习02-常用集合&quot;&gt;&lt;a href=&quot;#Go语言学习02-常用集合&quot; class=&quot;headerlink&quot; title=&quot;Go语言学习02-常用集合&quot;&gt;&lt;/a&gt;Go语言学习02-常用集合&lt;/h2&gt;&lt;h3 id=&quot;条件与循环&quot;&gt;&lt;a href=&quot;#条件与循</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Go" scheme="https://www.ckxgzxa.top/tags/Go/"/>
    
  </entry>
  
</feed>
