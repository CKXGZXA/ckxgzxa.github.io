<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>残魁斜罡的空间</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-19T10:58:54.861Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>残魁斜罡</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一些绕口令</title>
    <link href="http://example.com/2021/09/19/%E4%B8%80%E4%BA%9B%E7%BB%95%E5%8F%A3%E4%BB%A4/"/>
    <id>http://example.com/2021/09/19/%E4%B8%80%E4%BA%9B%E7%BB%95%E5%8F%A3%E4%BB%A4/</id>
    <published>2021-09-19T10:49:35.000Z</published>
    <updated>2021-09-19T10:58:54.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些绕口令"><a href="#一些绕口令" class="headerlink" title="一些绕口令"></a>一些绕口令</h1><ol><li><p>==八了百了标了兵了奔了北了坡，炮了兵了并了排了北了边了跑， 炮了兵了怕了把了标了兵了碰，标了兵了怕了碰了炮了兵了炮。（双唇及舌）==</p></li><li><p>==巴老爷有八十八棵芭蕉树，来了八十八个把式要在巴老爷八十八棵芭蕉树下住。巴老爷拔了八十八棵芭蕉树，不让八十八个把式在八十八棵芭蕉树下住。八十八个把式烧了八十八棵芭蕉树，巴老爷在八十八棵树边哭。（锻炼唇力）==</p></li><li><p>==门口吊刀，刀倒吊着。……（反复说，锻炼舌的顶力）==</p></li><li><p>==山前有个催粗腿，山后有个催腿粗，俩人山前来比腿，不知是催粗腿比催腿粗的腿粗，还是催腿粗比催粗腿的腿粗。==</p></li><li><p>==粉红墙上画凤凰，凤凰画在粉红墙。红凤凰、粉凤凰，红粉凤凰花凤凰。==</p></li></ol><h3 id="主持人播音员专业八级绕口令考试试卷"><a href="#主持人播音员专业八级绕口令考试试卷" class="headerlink" title="主持人播音员专业八级绕口令考试试卷"></a>主持人播音员专业八级绕口令考试试卷</h3><h4 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h4><p>老龙恼怒闹老农，老农恼怒闹老龙。农怒龙恼农更怒，龙恼农怒龙怕农。</p><h4 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h4><p>牛郎恋刘娘，刘娘念牛郞，牛郎年年念刘娘，刘娘牛年恋牛郎，郎念娘来娘恋娘</p><h4 id="第三题："><a href="#第三题：" class="headerlink" title="第三题："></a>第三题：</h4><p>七巷一个漆匠，西巷一个锡匠。七巷漆匠用了西巷锡匠的锡，西巷锡匠拿了七巷漆匠的漆，七巷漆匠气西巷锡匠用了漆，西巷锡匠讥七巷漆匠拿了锡。</p><h4 id="第四题："><a href="#第四题：" class="headerlink" title="第四题："></a>第四题：</h4><p>初级 大声说20遍(红凤凰)<br>中级 大声说20遍(粉红凤凰)<br>高级 大声说10遍(红凤凰，黄凤凰，粉红凤凰花凤凰)</p><hr><p>丝瓜藤上绕满绳，<br>瓜藤绕着绳架伸。<br>绳长藤伸瓜儿长，<br>绳粗藤壮瓜儿沉。</p><p>风吹银铃叮铃铃<br>小琳琳，爱银铃，<br>琳琳用劲摇银铃，<br>银铃的铃声真好听。<br>风吹银铃叮铃铃，<br>小琳以为铃失灵，<br>银铃笑琳琳真是不机灵！</p><p>蓝教练是女教练，吕教练是男教练<br>蓝教练不是男教练，吕教练不是男教练<br>蓝南是男篮主力，吕楠是女篮主力。吕教练在男篮训练蓝南，蓝教练在女篮训练吕楠。</p><p>小盈林，爱银铃，<br>盈林用劲摇银铃，<br>银铃声音真动听。<br>风吹银铃叮铃铃，<br>盈林心中喜盈盈，<br>笑声尽情赛银玲。</p><hr><ol><li>初入江湖：化肥会挥发</li><li>小有名气：黑化肥发灰，灰化肥发黑</li><li>名动一方：黑化肥发灰会挥发；灰化肥挥发会发黑</li><li>天下闻名：黑化肥挥发发灰会花飞；灰化肥挥发发黑会飞花</li><li>一代宗师：黑灰化肥会挥发发灰黑讳为花飞；灰黑化肥会挥发发黑灰为讳飞花</li><li>超凡入圣：黑灰化肥灰会挥发发灰黑讳为黑灰花会飞；灰黑化肥会会挥发发黑灰为讳飞花化为灰</li><li>天外飞仙：黑化黑灰化肥灰会挥发发灰黑讳为黑灰花会回飞；灰化灰黑化肥会会挥发发黑灰为讳飞花回化为灰</li></ol><h3 id="绕口令"><a href="#绕口令" class="headerlink" title="绕口令"></a>绕口令</h3><h4 id="单韵母练习"><a href="#单韵母练习" class="headerlink" title="单韵母练习"></a>单韵母练习</h4><ol><li>坡上立着一只鹅，坡下就是一条河。宽宽的河，肥肥的鹅，鹅要过河，河要渡鹅，不知是鹅过河，还是河渡鹅？</li><li>山上五棵树，架上五壶醋，林中五只鹿，箱里五条裤。伐了山上树，搬下架上的醋，射死林中的鹿，取出箱中的裤。</li></ol><h4 id="鼻韵母练习"><a href="#鼻韵母练习" class="headerlink" title="鼻韵母练习"></a>鼻韵母练习</h4><ol><li>扁担长，板凳宽，扁担没有板凳宽，板凳没有扁担长，扁担想绑在板凳上，板凳不让扁担绑在板凳上，扁担偏偏绑在板凳上，到底是板凳宽还是扁担长。</li><li>一平盆面，烙一平盆饼，饼碰盆，盆碰饼。</li><li>山前有个严圆眼，山后有个严眼圆，二人山前来比眼，不知是严圆眼的眼圆，还是严眼圆比严圆眼的眼圆？</li></ol><h4 id="复韵母练习"><a href="#复韵母练习" class="headerlink" title="复韵母练习"></a>复韵母练习</h4><ol><li>出南门，走六步，见着六叔和六舅，叫声六叔和六舅，借我六斗六升好绿豆；过了秋，打了豆，还我六叔六舅六十六斗六升好绿豆。</li><li>哥挎瓜筐过宽沟，过沟筐漏瓜滚沟。隔沟挎筐瓜筐扣，瓜滚筐空哥怪沟。</li></ol><h4 id="唇音练习"><a href="#唇音练习" class="headerlink" title="唇音练习"></a>唇音练习</h4><ol><li>老方扛着黄幌子，老黄扛着方幌子。老方要拿老黄的方幌子，老黄要拿老方的黄幌子，末了儿方幌子碰破了黄幌子，黄幌子碰破了方幌子。</li></ol><h4 id="舌尖中音练习"><a href="#舌尖中音练习" class="headerlink" title="舌尖中音练习"></a>舌尖中音练习</h4><ol><li>你会炖炖冻豆腐，你来炖我的炖冻豆腐；你不会炖炖冻豆腐，别胡炖乱炖炖坏了我的炖冻豆腐。</li><li>老罗拉了一车梨，老李拉了一车栗。老罗人称大力罗，老李人称李大力。老罗拉梨做梨酒，老李拉栗去换梨。</li><li>有个面铺门朝南，门上挂着蓝布棉门帘，摘了蓝布棉门帘，面铺门朝南；挂上蓝布棉门帘，面铺还是门朝南。</li><li>大刀对单刀，单刀对大刀，大刀斗单刀，单刀夺大刀。</li></ol><h4 id="舌根音、舌面音练习"><a href="#舌根音、舌面音练习" class="headerlink" title="舌根音、舌面音练习"></a>舌根音、舌面音练习</h4><ol><li>一班有个黄贺，二班有个王克，黄贺、王克二人搞创作，黄贺搞木刻，王克写诗歌。黄贺帮助王克写诗歌，王克帮助黄贺搞木刻。由于二人搞协作，黄贺完成了木刻，王克写好了诗歌。<br>翘舌音、平舌音、练习</li><li>天上有个日头，地下有块石头，嘴里有个舌头，手上有五个手指头。不管是天上的热日头，地下的硬石头，嘴里的软舌头，手上的手指头，还是热日头，硬石头，软舌头，手指头，反正都是练舌头。</li><li>师部司令部指示：四团十连石连长带四十人在十日四时四十四分按时到达师部司令部，师长召开誓师大会。</li><li>早招租，晚招租，总找周邹郑曾朱。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些绕口令&quot;&gt;&lt;a href=&quot;#一些绕口令&quot; class=&quot;headerlink&quot; title=&quot;一些绕口令&quot;&gt;&lt;/a&gt;一些绕口令&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;==八了百了标了兵了奔了北了坡，炮了兵了并了排了北了边了跑， 炮了兵了怕了把了标了兵了碰，标了兵了</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>1.OnJava8前言</title>
    <link href="http://example.com/2021/09/15/1-OnJava8%E5%89%8D%E8%A8%80/"/>
    <id>http://example.com/2021/09/15/1-OnJava8%E5%89%8D%E8%A8%80/</id>
    <published>2021-09-15T13:44:40.000Z</published>
    <updated>2021-09-15T14:47:39.175Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本书基于Java 8的特性进行该语言的编程教学。</p></blockquote><p>我以前的那本Java书——《Java编程思想》（第4版），对于用Java 5编程仍然很有用，Android编程用的就是这个语言版本。然而随着Java 8的到来，这门语言发生了许多显著的变化，使得编写和阅读新版本Java代码的方式都与以往有了明显的不同。于是，花费两年时间编写一本新书也就在情理之中了。</p><p>本书的读者具备基础的编程经验即可。对于经验不足的编程入门者而言，可汗学院（Khan Academy）这类网络资源提供了不少介绍编程基础知识的课程，另外也可以尝试之前提及的“Thinking in C”免费多媒体课程。当你遇到问题时，相比数年前只能依靠纸质媒体的时代，如今通过YouTube、博客、Stack Overflow等网站就可以轻松地找到所需要的答案。此外，若有坚韧不拔的毅力，你完全可以把本书当作自己的第一本编程教材。此外，本书同样适用于那些希望拓宽自己知识面的专业程序员。</p><p>《Java编程思想》一书自面世至今，让我受益匪浅，尤其是与其相关的全球范围内的演讲让我收获很多。对此，我一直心存感激。而这本书真正的无价之处在于，它让许多人和公司之间产生了关联。</p><h2 id="本书目标"><a href="#本书目标" class="headerlink" title="本书目标"></a>本书目标</h2><p>本书每一章都会介绍一个或者一组互相关联的概念，同时这些概念不依赖于当前章节没有介绍的特性。因此，你可以结合当前获取的知识来充分理解上下文，然后再阅读下一章。</p><p>我个人对本书的目标如下。</p><ol><li>循序渐进地呈现相关知识点，以便你充分理解每一个理念，之后再继续前行。同时，谨慎地安排语言特性出现的顺序，以便你先学习一个特性，然后再接触与之相关的实际应用场景。然而我并不能保证百分之百可以做到这一点，当出现意外情况时，我也会提供一些简要的相关说明。</li><li>所使用的示例尽可能地浅显易懂。有时候我会因为这一条原则而放弃引入所谓“现实世界”的问题，然而我发现对于初学者而言，相比于因为示例解决了一个范围很大的问题而惊讶，当他们理解示例中所有细节的时候会觉得更有收获。对于这一点，也许有人会批判我只热衷于“简单示例”，但是为了产生更为明显的教育成效，我依然乐于接受目前的做法。</li><li>相较传授我所了解的语言知识，我更希望传授语言的重要之处是什么。我认为信息需要根据其重要程度进行分级，而事实是，有些细节对于95%的程序员而言是无关紧要的。这些细节只会让人们感到困惑，以及增加他们对于语言复杂度的认知。如果<strong>你的</strong>代码必须考虑这些细节，切记这些内容也会困扰那些阅读和维护代码的人。所以我提倡代码使用简单的实现方式。</li><li>为你打下坚实的编程语言基础，以便你之后学习难度更高的课程和图书时，可以充分理解自己所遇到的问题。</li></ol><h2 id="语言设计缺陷"><a href="#语言设计缺陷" class="headerlink" title="语言设计缺陷"></a>语言设计缺陷</h2><p>每一种语言都存在设计缺陷。屡屡让新手程序员感到不安和挫败的是，他们必须“周旋”于各种语言特性之中，不断猜测应该用什么、不应该用什么。承认错误总是让人感到不快，但是相比承认错误所带来的不适感，这种糟糕的新手体验要严重得多。令人尴尬的是，所有失败的语言/库设计一直存在于Java的发布版本里。</p><p>诺贝尔经济学奖得主Joseph Stiglitz有一句生活哲言十分应景，也叫作“承诺升级理论”（The Theory of Escalating Commitment）：</p><blockquote><p>持续犯错的代价由别人承担，而承认错误的代价由你自己来承担。</p></blockquote><p>如果你读过我以往的文章或著作，就会知道，当发现编程语言的设计缺陷时，我倾向于指出这些问题。Java发展到今天，已拥有了许多热心的拥护者，其中有些人甚至将Java视为自家“孩子”，而非一种语言工具。因为我编写了一些关于Java的著作，所以他们以为我也会像他们一样袒护Java。于是，当我发现了某个语言缺陷并进行批判时，经常会出现以下两种情况。</p><ol><li>起初会引起一阵类似于“我的孩子无论对错”的愤怒，之后会逐渐平复，变成只有零星反抗。到了最后（也许会经过许多年），该缺陷逐渐被大家广泛承认，从此被视为Java的历史遗留问题。</li><li>更为关键的是，新手程序员并没有经历过“想不通为什么会这样”的痛苦挣扎，尤其是发现了某个看起来不对劲儿的地方之后所产生的自我怀疑，在这种情况下人们会很自然地认为<strong>要么是自己做错了，要么就是自己还没有搞明白</strong>。更糟糕的是，有些教授该语言的人会直接引用一些错误的概念，而不是对问题进行更加深入的研究和分析。而如果能够理解语言的设计缺陷，即使是新手程序员也能够理解不对劲儿的地方是一个错误，从而绕过它继续前行。</li></ol><p>我认为，理解语言和库的设计缺陷是必要的，因为它们会影响程序员的生产力。有些公司和团队会刻意规避某些语言特性，因为虽然它们看起来很有趣，但可能会在你毫无准备之时突然卡住你的工作进程。此外，设计缺陷也会影响新语言的创建和采用。探索一门语言能做什么的过程十分有趣，然而设计缺陷能够告诉你该语言<strong>不能</strong>做什么。</p><p>多年以来，我真切地感受到Java语言的设计者不够关心用户。有些语言缺陷可谓是太过明显，根本没有经过深思熟虑，看起来像是设计者的思绪早已飞到了九霄云外，对自己的用户不管不顾。因此，Java语言在相当长的一段时间里饱受争议，也许这些有争议之处正是其诱惑所在。此外，这种对程序员看似不尊重的态度，也是我当初放弃Java选择其他语言，并且在相当长的一段时间内都不想回头的主要原因。</p><p>而当我重新回过头来审视Java的时候，Java 8给我的感觉是焕然一新，就好像是该语言的设计者对于语言和用户的态度发生了180度大转变。比如，许多被用户诟病已久，甚至被视为语言毒瘤的特性和库都得到了修正。新引入的特性也让人耳目一新，就好像是设计团队中新加入了几位极其关注程序员使用体验的设计者。这些特性最终被证明是有效的，从而使得Java语言更为出众，这明显好过在没有深入探究一个理念的本质时就急不可待地把它添加进来。此外，部分新特性十分优雅（至少可以说在考虑到Java局限性的情况下，已经尽可能地优雅了）。对此我只能猜测，可能有些人离开了Java语言设计团队，因而才发生了这些变化。</p><p>得益于语言设计者的良苦用心（其实我并没有料想到这一点），编写本书的过程相比以往要顺利得多。Java 8包含了许多基础和重要的改进，而由于Java的向后兼容性一直惨不忍睹，做出这些改进无疑需要花费相当多的精力。因此可以预料的是，将来也很难再见到如此重大的改进了（关于这一点，希望我是错的）。话虽如此，我依然要为那些把Java重新带入正确航道的人献上掌声。当终于能够用Java 8编写出某段代码时，我第一次下意识地喊出：“我爱死这个了！”</p><p>最后，本书的出版时机也非常不错，这是因为Java 8提供的一些重要特性会大大影响我们编写代码的方式，而到目前为止，Java 9似乎专注于改进语言的底层，其引入的一些重要的底层特性并不会影响本书中的代码。</p><h2 id="经过测试的示例"><a href="#经过测试的示例" class="headerlink" title="经过测试的示例"></a>经过测试的示例</h2><p>本书提供的示例所使用的是Java 8环境和Gradle编译工具。虽然我也使用新版本的Java测试过这些示例，但我依然推荐你使用该语言的长期稳定（LTS）版本：在我写这本书时，对应的是Java 8或者Java 11。此外，本书所有示例都可以从GitHub仓库免费获取。</p><p>每当构建一个应用程序时，如果没有一套内置测试流程来测试你的代码，就无法判断代码是否坚实可信。因此，我为本书创建了一套测试系统，用于展示和验证大多数示例的输出结果。具体而言，运行示例代码后的输出结果会生成一段注释，附加在代码的末尾处。有时候注释并不显示全部内容，而是只显示开头的几行，或者开头和末尾的几行。这种嵌入式的输出方式提升了代码可读性，降低了学习门槛，同时也提供了一种验证代码正确性的方式。</p><h2 id="普及程度"><a href="#普及程度" class="headerlink" title="普及程度"></a>普及程度</h2><p>Java的普及具有重要意义。我的意思是，如果你学会了Java，也许找工作会容易一些，而且市面上有大量的Java培训材料、课程以及其他学习资源等。另外，如果你开一家公司并且选择Java作为工作语言，招募Java程序员时也会容易一些。Java的这一点优势确实无可争辩。</p><p>话虽如此，目光短浅总归不是好事。如果你并不是真心喜爱Java，建议你还是远离它为好。我的意思是，如果学习Java只是为了找工作，无异于选择了一种不幸福的人生。而对于公司来说，如果你选择Java只是为了降低招聘难度，请务必三思而后行。根据你的实际需求，也许采用其他语言的话，你可以雇用更少的员工，但能达到更高的生产力（比如通过我的另一本书<em>Atomic Kotlin</em>学习Kotlin语言）。此外，使用一种更新也更激动人心的编程语言也许更容易吸引有志之士的加盟。</p><p>不过，如果你<strong>真的</strong>喜爱Java这门语言，那么欢迎你加入。同时，我希望本书可以丰富你的编程经验。</p><h2 id="关于Android程序员"><a href="#关于Android程序员" class="headerlink" title="关于Android程序员"></a>关于Android程序员</h2><p>Android编程使用的环境是Java 5，而我编写本书的原则是“尽可能使用纯粹的Java 8”，所以如果你学习Java的目的是为Android系统编写应用程序，那么推荐你学习《Java编程思想》（第4版）。此外，还有许多专门针对Android的编程资源可供学习。</p><p>顺便一提，对于Android编程而言，Kotlin语言是一种更新和更好的选择，同时它也是Android的官方编程语言。</p><h2 id="出版说明"><a href="#出版说明" class="headerlink" title="出版说明"></a>出版说明</h2><p>本书使用了自动化的构建过程，同样的自动化过程还有解压、编译以及测试所有示例代码。我使用Python 3编写了大量的应用程序来处理所有的自动化过程。</p><h3 id="封面设计"><a href="#封面设计" class="headerlink" title="封面设计"></a>封面设计</h3><p>本书的封面插图来自美国公共事业振兴署（Works Progress Administration，简称WPA，是1935—1943年美国大萧条时期所创建的一个大型公共事业项目，其目标是援助失业人口重新返回工作岗位）。此外，它也让我想起了《绿野仙踪》系列丛书的插图。我的设计师朋友Daniel Will-Harris和我都十分喜爱这张图片。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢Eric Evans（《领域驱动设计》一书的作者）针对本书书名提供了宝贵意见，也感谢所有在讨论组里帮助我确定书名的人们。</p><p>感谢James Ward，他使我得以为本书使用Gradle构建工具，感谢他一直以来提供的帮助以及跟我的友谊。感谢Ben Muschko对构建文件所做的优化，同时也要感谢Hans Dockter给Ben时间来做这件事。</p><p>感谢Jeremy Cerise与Bill Frasure参与本书的开发者活动，并提供了有价值的帮助。</p><p>感谢所有抽出宝贵时间莅临科罗拉多州克雷斯特德比特市，参加我所组织的会议、研讨活动、开发者活动以及其他活动的嘉宾们。你们虽深居幕后，但所做出的贡献不可或缺。</p><h2 id="献词"><a href="#献词" class="headerlink" title="献词"></a>献词</h2><p>谨献给我敬爱的父亲E. Wayne Eckel，他生于1924年4月1日，卒于2016年11月23日。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本书基于Java 8的特性进行该语言的编程教学。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我以前的那本Java书</summary>
      
    
    
    
    <category term="Books" scheme="http://example.com/categories/Books/"/>
    
    
    <category term="OnJava8" scheme="http://example.com/tags/OnJava8/"/>
    
  </entry>
  
  <entry>
    <title>摩尔庄园手游NPC喜好</title>
    <link href="http://example.com/2021/06/19/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%AD%E6%89%8B%E6%B8%B8NPC%E5%96%9C%E5%A5%BD/"/>
    <id>http://example.com/2021/06/19/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%AD%E6%89%8B%E6%B8%B8NPC%E5%96%9C%E5%A5%BD/</id>
    <published>2021-06-19T15:42:01.000Z</published>
    <updated>2021-09-19T10:51:05.142Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"><strong>NPC</strong></th><th align="center"><strong>位置</strong></th><th><strong>喜好</strong></th><th><strong>厌恶</strong></th><th><strong>好友</strong></th></tr></thead><tbody><tr><td align="center">菩提</td><td align="center">神秘湖(阳光沙滩)码头</td><td>清炒毛毛豆、奇异果、星空鱼、香蕉</td><td>荔枝、狗鱼</td><td></td></tr><tr><td align="center">艾尔</td><td align="center">警署</td><td>鸡蛋、满天星、罗汉鱼、牛奶鱼群汤</td><td>大闸蟹、小龙虾</td><td></td></tr><tr><td align="center">艾米</td><td align="center">报社门口</td><td>锦鲤、月亮海螺、棉花糖、胡萝卜盖饭</td><td>水蜘蛛、奇异果</td><td></td></tr><tr><td align="center">杰西</td><td align="center">城堡喷泉广场</td><td>茄子、小丑鱼、小麦牛奶蛋粥、牛奶</td><td>水蛇、章鱼、葡萄</td><td></td></tr><tr><td align="center">彩虹</td><td align="center">宠物店</td><td>胡萝卜、浆果烧饼、小麦牛奶蛋粥、章鱼</td><td>利齿狗鱼、鲶鱼</td><td></td></tr><tr><td align="center">丝尔特</td><td align="center">服装店门口</td><td>苹果、羊毛、甲鱼南瓜盅、蒲兰花</td><td>大闸蟹、章鱼</td><td></td></tr><tr><td align="center">埃里克斯</td><td align="center">家具店门口</td><td>金鱼、铜矿石、红木、棉花糖豆浆</td><td>南瓜、西瓜</td><td></td></tr><tr><td align="center">梅森</td><td align="center">梅森小屋门口</td><td>南瓜、草莓、向日葵、葫芦炒茄子</td><td>鲶鱼、带鱼</td><td></td></tr><tr><td align="center">克劳</td><td align="center">爱心礼堂</td><td>牛奶鱼群汤、冰激凌鼠、百合花</td><td>水蜘蛛、水蛇</td><td></td></tr><tr><td align="center">尼克</td><td align="center">城堡餐厅门口</td><td>白菜、石榴炸冰虾、鲶鱼、河豚</td><td>百合花</td><td></td></tr><tr><td align="center">汤米</td><td align="center">摩尔拉雅山脚</td><td>水蜜桃、铜矿石、解暑冲饮、茄块狗鱼片</td><td>水煮大闸蟹 、章鱼</td><td></td></tr><tr><td align="center">弗礼德</td><td align="center">游戏小屋(白熊游戏屋)</td><td>葫芦、冰川虾、鲶鱼、香煎雪鱼</td><td>鲤鱼、玉米、香蕉</td><td></td></tr><tr><td align="center">花婶</td><td align="center">淘淘乐街</td><td>毛毛花、七色花、葡萄、椰汁水果捞</td><td>金鱼</td><td></td></tr><tr><td align="center">瑞琪</td><td align="center">前哨站</td><td>小丑鱼、抱抱熊、毛毛爆囧菇</td><td>怪怪鱼</td><td></td></tr><tr><td align="center">凯文</td><td align="center">摩尔拉雅山顶</td><td>小丑鱼、抱抱熊、葫芦烧茄子</td><td>水蛇、水蜘蛛、章鱼</td><td></td></tr><tr><td align="center">洛克</td><td align="center">摩尔城堡大门处</td><td>向日葵、星空鱼、浆果浓汤、椰子</td><td>毛毛豆、怪怪鱼、茄块狗鱼片、麻辣小龙虾</td><td></td></tr><tr><td align="center">琦琦</td><td align="center">派对广场</td><td>南瓜、初恋海星、麻辣小龙虾、水蜜桃</td><td>水蛇、水蜘蛛</td><td></td></tr><tr><td align="center">茜茜</td><td align="center">摩尔拉雅山腰</td><td>水蜘蛛、樱花蛇、麻辣小龙虾</td><td>带鱼、苹果</td><td></td></tr><tr><td align="center">尤尤</td><td align="center">阳光牧场</td><td>毛毛花、向日葵，玫瑰海星、奶油玉米浓汤</td><td>蒜头蛙、粑粑海肠、水蜘蛛</td><td></td></tr><tr><td align="center">贝琪</td><td align="center">摩尔拉雅山顶</td><td>玉米、绿鲤鱼、河童、花香金鱼</td><td>胡萝卜盖饭、胡萝卜、奇异果</td><td></td></tr></tbody></table><p><img src="/img/others/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%ADNPC.jpg" alt="摩尔庄园NPC"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;NPC&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;位置&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;喜好&lt;/strong&gt;&lt;/th&gt;
&lt;</summary>
      
    
    
    
    
    <category term="游戏" scheme="http://example.com/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>第七章 实现</title>
    <link href="http://example.com/2021/05/22/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/05/22/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-21T16:44:15.000Z</published>
    <updated>2021-05-23T12:24:10.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-实现"><a href="#第七章-实现" class="headerlink" title="第七章 实现"></a>第七章 实现</h1><hr><h2 id="实现包括：编码和测试"><a href="#实现包括：编码和测试" class="headerlink" title="实现包括：编码和测试"></a>实现包括：编码和测试</h2><blockquote><p>编码：把软件设计结果翻译成程序。<br>测试：检测程序并改正错误的过程。</p></blockquote><hr><h2 id="白盒测试和黑盒测试的定义"><a href="#白盒测试和黑盒测试的定义" class="headerlink" title="白盒测试和黑盒测试的定义"></a>白盒测试和黑盒测试的定义</h2><h3 id="白盒测试（也称结构测试）"><a href="#白盒测试（也称结构测试）" class="headerlink" title="白盒测试（也称结构测试）"></a>白盒测试（也称结构测试）</h3><blockquote><p>如果知道软件内部工作过程，可以通过测试来检验软件内部动作是否按照规格说明书的规定正常进行，这种测试称为白盒测试。</p></blockquote><h3 id="黑盒测试（也称功能测试）"><a href="#黑盒测试（也称功能测试）" class="headerlink" title="黑盒测试（也称功能测试）"></a>黑盒测试（也称功能测试）</h3><blockquote><p>如果已经知道软件应该具有的功能，可以通过测试来检验是否每个功能都能正常使用，这种测试称黑盒测试。也称功能测试。</p></blockquote><hr><h2 id="软件测试的步骤"><a href="#软件测试的步骤" class="headerlink" title="软件测试的步骤"></a>软件测试的步骤</h2><h3 id="1-模块测试（测试编码和详细设计的错误）"><a href="#1-模块测试（测试编码和详细设计的错误）" class="headerlink" title="1. 模块测试（测试编码和详细设计的错误）"></a>1. 模块测试（测试编码和详细设计的错误）</h3><blockquote><p>模块测试又称单元测试，它把每个模块作为单独的实体来测试。</p></blockquote><h3 id="2-子系统测试（测试模块接口）"><a href="#2-子系统测试（测试模块接口）" class="headerlink" title="2. 子系统测试（测试模块接口）"></a>2. 子系统测试（测试模块接口）</h3><blockquote><p>子系统测试是把警告单元测试的模块放在一起形成一个子系统来测试。</p></blockquote><h3 id="3-系统测试"><a href="#3-系统测试" class="headerlink" title="3. 系统测试"></a>3. 系统测试</h3><blockquote><p>系统测试是把经过测试的子系统装配成一个完整的系统来测试。<br>子系统测试测试和系统测试，通常称为集成测试。</p></blockquote><h3 id="4-验收测试"><a href="#4-验收测试" class="headerlink" title="4. 验收测试"></a>4. 验收测试</h3><blockquote><p>验收测试把软件系统作为单一的实体进行测试（利用用户的实际数据测试）。</p></blockquote><h3 id="5-平行运行"><a href="#5-平行运行" class="headerlink" title="5.平行运行"></a>5.平行运行</h3><blockquote><p>平行运行是同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。</p></blockquote><hr><h2 id="单元测试-计算机测试（驱动程序和存根程序）"><a href="#单元测试-计算机测试（驱动程序和存根程序）" class="headerlink" title="单元测试-计算机测试（驱动程序和存根程序）"></a>单元测试-计算机测试（驱动程序和存根程序）</h2><blockquote><p>单元测试集中检测软件的设计的最小单元—模块。单元测试和编码属于软件工程的同一阶段。一般方法是：</p><ul><li>首先通过编译系统检查并改正程序中所有的语法错误；</li><li>然后用详细设计模块说明为指南，对重要的控制路径进行测试，以便发现模块内部的错误。</li><li>通常，单元测试使用白盒测试技术。</li></ul></blockquote><h3 id="测试重点"><a href="#测试重点" class="headerlink" title="测试重点"></a>测试重点</h3><ol><li>模块接口</li></ol><blockquote><p>应该对穿过模块接口的数据流进行检测，以保证正确的输入和输出。</p></blockquote><ol start="2"><li>局部数据结构</li></ol><blockquote><p>这是错误的主要来源，应该设计相应的测试用例，以便发现数据结构方面的错误。</p></blockquote><ol start="3"><li>重要的执行路径</li></ol><blockquote><p>由于不可能进行穷尽测试，因此选择测试路径是非常关键的。</p></blockquote><ol start="4"><li>出错处理通路和边界条件</li></ol><h3 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h3><h3 id="计算机测试"><a href="#计算机测试" class="headerlink" title="计算机测试"></a>计算机测试</h3><blockquote><p>由于软件模块不是一个独立的系统，不能独立运行，要依靠其他模块调用，或需要调用其他模块。因此，必须要为测试的单元开发驱动程序或存根程序。</p><p>1.驱动程序</p><blockquote><p>相当于一个“主程序”，用来把测试数据传送给被测试的模块，并打印有关结果。</p></blockquote><ol start="2"><li>存根程序</li></ol><blockquote><p>用来代替被测试模块所调用的模块，相当于“虚拟子程序”。</p></blockquote></blockquote><hr><h2 id="集成测试：非渐增测试和渐增式测试"><a href="#集成测试：非渐增测试和渐增式测试" class="headerlink" title="集成测试：非渐增测试和渐增式测试"></a>集成测试：非渐增测试和渐增式测试</h2><blockquote><p>集成测试是组装软件的系统化技术，它将经过单元测试的模块联系在一起进行测试。</p></blockquote><p>由模块组装成程序时有两种方法：</p><h3 id="1-非渐增式测试方法"><a href="#1-非渐增式测试方法" class="headerlink" title="1. 非渐增式测试方法"></a>1. 非渐增式测试方法</h3><blockquote><p>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序。</p></blockquote><h3 id="2-渐增式测试方法"><a href="#2-渐增式测试方法" class="headerlink" title="2. 渐增式测试方法"></a>2. 渐增式测试方法</h3><blockquote><p>每次增加一个待测试模块，把它同已经测试好的那些模块结合起来进行测试，反复进行直到完成所有模块测试的方法。<br>使用渐增式测试方法把模块结合到软件系统中去时，有自顶向下和自底向上两种集成方法。  </p></blockquote><hr><h2 id="确认测试：Alpha和Beta测试"><a href="#确认测试：Alpha和Beta测试" class="headerlink" title="确认测试：Alpha和Beta测试"></a>确认测试：Alpha和Beta测试</h2><h3 id="Alpha测试"><a href="#Alpha测试" class="headerlink" title="Alpha测试"></a>Alpha测试</h3><blockquote><p>用户在开发者的场所进行测试，并且在开发者的指导下进行，测试在受控环境中进行，开发者记录发现的错误和问题；</p></blockquote><h3 id="Beta测试"><a href="#Beta测试" class="headerlink" title="Beta测试"></a>Beta测试</h3><blockquote><p>用户在一个或多个客户场所进行测试，不受开发者控制，测试者记录发现的问题和错误，定期将问题报告发送给开发者。</p></blockquote><hr><h2 id="白盒测试技术"><a href="#白盒测试技术" class="headerlink" title="白盒测试技术"></a>白盒测试技术</h2><h3 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1. 语句覆盖"></a>1. 语句覆盖</h3><blockquote><p>设计的测试用例能使程序中每条语句至少执行一次。</p></blockquote><h3 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2. 判定覆盖"></a>2. 判定覆盖</h3><blockquote><p>判定覆盖是指：选取足够的测试用例，使得程序中每个判断的可能结果都至少执行一次，也就是说使程序的每个判断分支至少通过一次。</p></blockquote><h3 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3. 条件覆盖"></a>3. 条件覆盖</h3><blockquote><p>条件覆盖是指：选择足够的测试用例，使得程序中每个判定表达式的每个条件都取到各种可能的结果。</p></blockquote><blockquote><p>条件覆盖通常比判定覆盖强，但是条件覆盖不一定包含判定覆盖。</p></blockquote><h3 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定/条件覆盖"></a>4. 判定/条件覆盖</h3><blockquote><p>选取足够的测试用例使得同时满足判定覆盖和条件覆盖的要求。</p></blockquote><h3 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5. 条件组合覆盖"></a>5. 条件组合覆盖</h3><blockquote><p>选取足够的测试用例，使得每个判定表达式中条件的各种可能的组合都至少出现一次。</p></blockquote><p>如果从对程序路径的覆盖程度分析，可以提出下面一些逻辑覆盖标准：</p><h3 id="6-点覆盖"><a href="#6-点覆盖" class="headerlink" title="6. 点覆盖"></a>6. 点覆盖</h3><blockquote><p>选取足够多的测试用例，使得程序执行路径至少经过程序图中每个节点一次。</p></blockquote><h3 id="7-边覆盖"><a href="#7-边覆盖" class="headerlink" title="7.  边覆盖"></a>7.  边覆盖</h3><blockquote><p>边覆盖是指：选取足够多的测试用例，使得程序执行路径至少经过程序图中每条边一次。</p></blockquote><h3 id="8-路径覆盖"><a href="#8-路径覆盖" class="headerlink" title="8. 路径覆盖"></a>8. 路径覆盖</h3><blockquote><p>路径覆盖是指：选取足够多的测试用例，使得程序的每条可能路径都至少执行一次。</p></blockquote><hr><h2 id="黑盒测试：等价划分、边界值检测和错误推测"><a href="#黑盒测试：等价划分、边界值检测和错误推测" class="headerlink" title="黑盒测试：等价划分、边界值检测和错误推测"></a>黑盒测试：等价划分、边界值检测和错误推测</h2><hr><h2 id="调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）"><a href="#调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）" class="headerlink" title="调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）"></a>调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-实现&quot;&gt;&lt;a href=&quot;#第七章-实现&quot; class=&quot;headerlink&quot; title=&quot;第七章 实现&quot;&gt;&lt;/a&gt;第七章 实现&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;实现包括：编码和测试&quot;&gt;&lt;a href=&quot;#实现包括：编码和测试&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第六章 详细设计</title>
    <link href="http://example.com/2021/05/21/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/05/21/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-05-20T17:36:06.000Z</published>
    <updated>2021-05-23T16:19:21.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-详细设计"><a href="#第六章-详细设计" class="headerlink" title="第六章_详细设计"></a>第六章_详细设计</h1><hr><blockquote><p><strong>概要设计说明书</strong><br>该说明书是概要实际阶段的工作成果，它应说明功能分配、模块划分、程序的总体结构、输入输出以及接口设计、运行设计、数据结构设计和出错处理设计等，为详细设计提供基础。</p></blockquote><hr><h2 id="什么是结构化程序设计？经典、扩展和修正的控制结构；"><a href="#什么是结构化程序设计？经典、扩展和修正的控制结构；" class="headerlink" title="什么是结构化程序设计？经典、扩展和修正的控制结构；"></a>什么是结构化程序设计？经典、扩展和修正的控制结构；</h2><h3 id="经典定义"><a href="#经典定义" class="headerlink" title="经典定义"></a>经典定义</h3><blockquote><p>如果一个程序的代码块仅仅通过<strong>顺序、选择和循环</strong>这三种基本控制结构进行链接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。<br><img src="/img/soft_intro_c6/3%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="3种基本的控制结构"></p></blockquote><h3 id="更全面定义"><a href="#更全面定义" class="headerlink" title="更全面定义"></a>更全面定义</h3><blockquote><p>结构程序设计是尽可能少用 GOTO 语句的程序设计方法。最好仅在检测出错误时才使用 GOTO 语句，而且应该总是使用前向 GOTO 语句。</p></blockquote><blockquote><ul><li>为了实际使用方便起见，常常还允许使用 DO-UNTIL 和 DO-CASE 两种控制结构。<br><img src="/img/soft_intro_c6/%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="其他常用的控制结构"></li><li>有时需要立即从循环（甚至嵌套的循环）中转移出来，允许使用 LEAVE（或 BREAK）结构。LEAVE 或 BREAK 结构实质上是受限制的 GOTO 语句，用于转移到循环结构后面</li></ul></blockquote><h3 id="经典的结构程序设计"><a href="#经典的结构程序设计" class="headerlink" title="经典的结构程序设计"></a>经典的结构程序设计</h3><blockquote><p>只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这三种基本控制结构；</p></blockquote><h3 id="扩展的结构程序设计"><a href="#扩展的结构程序设计" class="headerlink" title="扩展的结构程序设计"></a>扩展的结构程序设计</h3><blockquote><p>如果除了上述3中基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构；</p></blockquote><h3 id="修正的结构程序设计"><a href="#修正的结构程序设计" class="headerlink" title="修正的结构程序设计"></a>修正的结构程序设计</h3><blockquote><p>再加上允许使用LEAVE（或BREAK）结构。</p></blockquote><hr><h2 id="人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；"><a href="#人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；" class="headerlink" title="人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；"></a>人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；</h2><blockquote><ul><li>人机界面设计是接口设计的重要组成部分。对于交互式系统来说，人机界面设计和数据设计、体系结构设计及过程设计一样重要。</li><li>人机界面的设计质量，直接影响用户对软件产品的评价，从而影响软件产品的竞争力和寿命，必须对人机界面设计给予足够重视。</li></ul></blockquote><h3 id="设计人机界面过程中会遇到的4个问题"><a href="#设计人机界面过程中会遇到的4个问题" class="headerlink" title="设计人机界面过程中会遇到的4个问题:"></a>设计人机界面过程中会遇到的4个问题:</h3><h4 id="1-系统响应时间"><a href="#1-系统响应时间" class="headerlink" title="1. 系统响应时间:"></a>1. 系统响应时间:</h4><blockquote><p>系统相应时间指从用户完成某个控制动作，到软件给出预期的相应之间的这段时间。系统响应时间有两个重要属性：长度和易变性。</p><ul><li><strong>长度：</strong> 如果系统响应时间过长，用户就会感到紧张</li><li><strong>易变性：</strong> 指系统响应时间相对于平均相应时间的偏差，即使系统响应时间较长，响应时间易变性低也有助于用户建立起稳定的工作节奏。</li></ul></blockquote><h4 id="2-用户帮助设施"><a href="#2-用户帮助设施" class="headerlink" title="2. 用户帮助设施"></a>2. 用户帮助设施</h4><blockquote><p>大多数现代软件都提供联机帮助设施，用户无须离开用户界面就能解决自己的问题。常见的帮助设施可分为集成的和附加的两类。</p><ul><li><strong>集成的帮助设施</strong> 设计在软件里面，它对用户工作内容是敏感的，用户可以从与刚刚完成的操作有关的主题中选择一个请求帮助。</li><li><strong>附加的帮助设施</strong> 是在系统建成后再添加到软件中的，它实际上是一种查询能力有限的联机用户手册。</li></ul><p>集成的帮助设施优于附加的帮助设施。</p></blockquote><h4 id="3-出错信息处理"><a href="#3-出错信息处理" class="headerlink" title="3. 出错信息处理"></a>3. 出错信息处理</h4><blockquote><p>出错信息和警告信息，是出现问题时交互式系统给出的“坏消息”。</p></blockquote><h4 id="4-命令交互"><a href="#4-命令交互" class="headerlink" title="4. 命令交互"></a>4. 命令交互</h4><blockquote><p>多数情况下，用户既可以从菜单中选择软件功能，也可以通过键盘命令序列调用软件功能。<br>在理想的情况下，所有应用软件都有一致的命令使用方法。</p></blockquote><hr><h2 id="过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树"><a href="#过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树" class="headerlink" title="过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树"></a>过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树</h2><blockquote><ul><li>定义：描述程序处理工程的工具</li><li>分类：图形、表格和语言</li><li>基本要求：不论是哪类工具，<strong>对它们的基本要求都是能提供对设计的无歧义的描述，</strong> 也就是应该指明控制流程、处理功能、数据组织以及其他方面的实现细节，从而在编码阶段能把对设计的描述直接翻译成程序代码。</li></ul></blockquote><h3 id="1-程序流程图"><a href="#1-程序流程图" class="headerlink" title="1. 程序流程图"></a>1. 程序流程图</h3><blockquote><ul><li>程序流程图又称为程序框图，它是历史最悠久、使用最广泛的描述过程设计的方法。</li><li>它的主要优点是对控制流程的描绘很直观，便于初学者掌握。</li><li>程序流程图历史悠久，至今仍在广泛使用着。</li></ul></blockquote><h4 id="程序流程图的符号"><a href="#程序流程图的符号" class="headerlink" title="程序流程图的符号"></a>程序流程图的符号</h4><blockquote><p><img src="/img/soft_intro_c6/%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%AC%A6%E5%8F%B7.png" alt="程序流程图符号"></p></blockquote><h4 id="程序流程图的主要缺点："><a href="#程序流程图的主要缺点：" class="headerlink" title="程序流程图的主要缺点："></a>程序流程图的主要缺点：</h4><blockquote><ul><li>程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。</li><li>程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。</li><li>程序流程图不易表示数据结构。</li></ul></blockquote><h3 id="2-盒图（N-S图）"><a href="#2-盒图（N-S图）" class="headerlink" title="2. 盒图（N-S图）"></a>2. 盒图（N-S图）</h3><h4 id="盒图的特点："><a href="#盒图的特点：" class="headerlink" title="盒图的特点："></a>盒图的特点：</h4><blockquote><ul><li>功能域明确。</li><li>不可能任意转移控制。</li><li>很容易确定局部和全称数据的作用域。</li><li>很容易表示嵌套关系，也可以表示模块的层次结构。</li></ul></blockquote><h4 id="盒图的基本符号"><a href="#盒图的基本符号" class="headerlink" title="盒图的基本符号:"></a>盒图的基本符号:</h4><blockquote><p><img src="/img/soft_intro_c6/%E7%9B%92%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7.png" alt="盒图的基本符号"><br>(a) 顺序；(b) IF_THEN_ELSE型分支；(c) CASE型多分支；(d) 循环；(e) 调用子程序 A</p></blockquote><h3 id="3-PAD图"><a href="#3-PAD图" class="headerlink" title="3. PAD图"></a>3. PAD图</h3><blockquote><ul><li>PAD是问题分析图(problem analysis diagram)的英文缩写，自1973年由日本日立公司发明以后，已得到一定程度的推广。</li><li>它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易。</li></ul></blockquote><h4 id="PAD图的基本符号："><a href="#PAD图的基本符号：" class="headerlink" title="PAD图的基本符号："></a>PAD图的基本符号：</h4><blockquote><p><img src="/img/soft_intro_c6/PAD%E5%9B%BE%E7%AC%A6%E5%8F%B7.png" alt="PAD图的基本符号"><br>(a)顺序（先执行P1后执行P2）；(b)选择（IF C THEN P1 ELSE P2）；(c)CASE型多分支(d)WHILE型循环（WHILE C DO P）；(e)UNTIL型循环（REPEAT P UNTIL C）;(f)语句标号；(g)定义</p></blockquote><h4 id="PAD图的主要优点："><a href="#PAD图的主要优点：" class="headerlink" title="PAD图的主要优点："></a>PAD图的主要优点：</h4><blockquote><ul><li>使用表示结构化控制结构的PAD符号设计出来的程序必然是结构化程序。</li><li>PAD图所描绘的程序结构十分清晰。</li><li>PAD图表现程序逻辑易读、易懂、易记。</li><li>容易将PAD图转换成高级语言源程序，这种转换可用软件工具自动完成。</li><li>既可表示程序逻辑，也可描绘数据结构。</li><li>PAD图的符号支持自顶向下、逐步求精方法的使用。</li></ul></blockquote><blockquote><p>使用PAD提供的定义功能来逐步求精的例子<br><img src="/img/soft_intro_c6/PAD_%E9%80%90%E6%AD%A5%E6%B1%82%E7%B2%BE.png" alt="使用PAD提供的定义功能逐步求精_例"></p></blockquote><h3 id="4-判定表"><a href="#4-判定表" class="headerlink" title="4. 判定表"></a>4. 判定表</h3><blockquote><ul><li>当算法中包含 <strong>多重嵌套的条件选择</strong> 时，用程序流程图、盒图、PAD图或后面即将介绍的过程设计语言（PDL）都不易清楚地描述。</li><li>判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。</li></ul></blockquote><h4 id="判定表组成（4部分）"><a href="#判定表组成（4部分）" class="headerlink" title="判定表组成（4部分）"></a>判定表组成（4部分）</h4><blockquote><ul><li>左上部列出所有条件；</li><li>左下部是所有可能做的动作；</li><li>右上部是表示各种条件组合的一个矩阵；</li><li>右下部是和每种条件组合相对应的动作。</li></ul><p><img src="/img/soft_intro_c6/%E5%88%A4%E5%AE%9A%E8%A1%A8%E7%BB%84%E6%88%90.png" alt="判定表组成"></p></blockquote><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><blockquote><p>能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p></blockquote><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><ul><li>判定表的含义不是一眼就能看出来的，初次接触这种工具的人理解它需要有一个简短的学习过程。</li><li>当数据元素的值多于两个时，判定表的简洁程度也将下降。</li></ul></blockquote><h3 id="5-判定树"><a href="#5-判定树" class="headerlink" title="5. 判定树"></a>5. 判定树</h3><blockquote><ul><li>判定树是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</li><li>多年来判定树一直受到人们的重视，是一种比较常用的系统分析和设计的工具。</li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c6/%E5%88%A4%E5%AE%9A%E6%A0%91%E4%BE%8B%E5%AD%90.png" alt="判定树例子"></p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><blockquote><p>形式简单，一眼就可以看出其含义，因此易于掌握和使用。</p></blockquote><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><ul><li>简洁性不如判定表，数据元素的同一个值往往要重复写多遍，而且越接近树的叶端重复次数越多。</li><li>画判定树时分枝的次序可能对最终画出的判定树的简洁程度有较大影响。</li></ul></blockquote><h3 id="6-过程设计语言"><a href="#6-过程设计语言" class="headerlink" title="6. 过程设计语言"></a>6. 过程设计语言</h3><hr><h2 id="过程设计语言（PDL）：伪码"><a href="#过程设计语言（PDL）：伪码" class="headerlink" title="过程设计语言（PDL）：伪码"></a>过程设计语言（PDL）：伪码</h2><blockquote><ul><li>过程设计语言(PDL)也称为伪码，它是用正文形式表示数据和处理过程的设计工具。</li><li>PDL具有严格的关键字外部语法，用于定义控制结构和数据结构；另一方面，PDL表示实际操作和条件的内部语法通常又是灵活自由的，可以适应各种工程项目的需要。</li><li>PDL是一种“混杂”语言，它使用一种语言的词汇，同时却使用另一种语言的语法。 </li></ul></blockquote><h3 id="伪代码的基本控制结构："><a href="#伪代码的基本控制结构：" class="headerlink" title="伪代码的基本控制结构："></a>伪代码的基本控制结构：</h3><blockquote><ul><li>简单陈述句结构：避免复合语句。</li><li>判定结构：IF_THEN_ELSE 或 CASE_OF 结构。</li><li>选择结构：WHILE_DO或REPEAT_UNTIL 结构</li></ul></blockquote><h3 id="PDL的特点："><a href="#PDL的特点：" class="headerlink" title="PDL的特点："></a>PDL的特点：</h3><blockquote><ol><li>关键字的固定用法，它提供了结构化控制结构、数据说明和模块化的特点。</li><li>自然语言的自由语言，它描绘处理特点。</li><li>数据说明的手段。应该既包括简单的数据结构，又包括复杂的数据结构。</li><li>模块定义和调用的技术，应该提供各种接口描述模式。</li></ol></blockquote><h3 id="PDL的优点："><a href="#PDL的优点：" class="headerlink" title="PDL的优点："></a>PDL的优点：</h3><blockquote><ul><li>可以作为注释直接插在源程序中间。有助于保持文档和程序的一致性，提高了文档的质量。</li><li>可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的书写和编辑工作。</li><li>已经有自动处理程序存在，并且可以自动由PDL生成代码。</li></ul></blockquote><h3 id="PDL的缺点："><a href="#PDL的缺点：" class="headerlink" title="PDL的缺点："></a>PDL的缺点：</h3><blockquote><p>不如图形工具直观，描述复杂的条件组合与动作间的对应关系时，不如判定表清晰简单。</p></blockquote><hr><h2 id="面向数据结构的设计方法-Jackson图，和步骤"><a href="#面向数据结构的设计方法-Jackson图，和步骤" class="headerlink" title="面向数据结构的设计方法-Jackson图，和步骤"></a>面向数据结构的设计方法-Jackson图，和步骤</h2><ul><li>数据结构既影响程序的结构又影响程序的处理过程<ul><li>重复出现的数据通常由具有循环控制结构的程序来处理</li><li>选择数据要用带有分支控制结构的程序来处理</li><li>层次的数据组织通常和使用这些数据的程序的层次结构十分相似。</li></ul></li><li>面向数据结构的设计方法的最终目标是得出对程序处理过程的描述。</li></ul><h3 id="Jackson图"><a href="#Jackson图" class="headerlink" title="Jackson图"></a>Jackson图</h3><h4 id="数据结构中数据元素彼此间的逻辑关系："><a href="#数据结构中数据元素彼此间的逻辑关系：" class="headerlink" title="数据结构中数据元素彼此间的逻辑关系："></a>数据结构中数据元素彼此间的逻辑关系：</h4><blockquote><ul><li><p>顺序结构，顺序结构的数据由一个或多个数据元素组成，每个元素按确定次序出现一次。<br><img src="/img/soft_intro_c6/Jackson%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84.png" alt="顺序结构"></p></li><li><p>选择结构，选择结构的数据包含两个或多个元素，每次使用这个数据时按一定条件从这些数据元素中选择一个。<br><img src="/img/soft_intro_c6/Jackson%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84.png" alt="选择结构"></p></li><li><p>重复结构，重复结构的数据，根据使用时的条件由一个数据元素出现零次或多次构成。<br><img src="/img/soft_intro_c6/Jackson%E9%87%8D%E5%A4%8D%E7%BB%93%E6%9E%84.png" alt="重复结构"></p></li></ul></blockquote><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><blockquote><ul><li>便于表示层次结构，而且是对结构进行自顶向下分解的有力工具；</li><li>形象直观可读性好；</li><li>技能表示数据结构也能表示程序结构。</li></ul></blockquote><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><p>表示选择或重复结构时，选择条件或循环结束条件不能直接在图上表示出来，影响了图的表达能力，也不易直接把图翻译成程序；<br>框间连线为斜线，不易在行式打印机上输出。</p></blockquote><h3 id="改进的Jackson图"><a href="#改进的Jackson图" class="headerlink" title="改进的Jackson图"></a>改进的Jackson图</h3><blockquote><p><img src="/img/soft_intro_c6/%E6%94%B9%E8%BF%9B%E7%9A%84Jackson%E5%9B%BE.png" alt="改进的Jackson图"><br>(a) 顺序结构，B、C、D中任一个都不能是选择出现或重复出现的数据元素（即不能是右上角有小圆圈或星号标记的元素；<br>(b) 选择结构，S 右面括号中的数字 i 是分支条件的编号；<br>(c) 可选结构，A 或者是元素 B 或者不出现（可选结构是选择结构的一种常见的特殊形式）；<br>(d) 重复结构，循环结束条件的编号为 i 。</p></blockquote><h3 id="Jackson程序设计方法由5个步骤组成："><a href="#Jackson程序设计方法由5个步骤组成：" class="headerlink" title="Jackson程序设计方法由5个步骤组成："></a>Jackson程序设计方法由5个步骤组成：</h3><ol><li><p>分析并确定输入数据和输出数据的逻辑结构，用 Jackson 图描绘数据结构。</p></li><li><p>找出输入数据结构和输出数据结构中有对应关系的数据单元。所谓有对应关系是指有直接的因果关系，在程序中可以同时处理的数据单元（对于重复出现的数据单元必须重复的次序和次序都相同才可能有对应关系）。</p></li><li><p>用下述规则从描绘数据结构的 Jackson 图导出描绘程序结构的 Jackson 图：</p><blockquote><ul><li>第一，为每对有对应关系的数据单元，按照它们在数据结构图中的层次在程序结构图的相应层次画一个处理框(层次不同时与图中层次低的那个对应)；</li><li>第二，根据输入数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框；</li><li>第三，根据输出数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。</li><li>改进的Jackson图规定在构成顺序结构的元素中不能有重复出现或选择出现的元素，因此可能需要增加中间层次的处理框。</li></ul></blockquote></li><li><p>列出所有操作和条件（包括分支条件和循环结束条件），并且把它们分配到程序结构图的适当位置。</p></li><li><p>用伪码表示程序。</p></li></ol><blockquote><table><thead><tr><th align="center">顺序结构</th><th align="left">选择结构</th><th align="left">循环结构</th></tr></thead><tbody><tr><td align="center">A seq</br>B</br>C</br>D</br>A end</td><td align="left">A select cond1</br>$\quad$B</br>A or cond2</br>$\quad$C</br>A or cond3</br>$\quad$D</br>A end</td><td align="left">A iter until(或while) cond</br>$\quad$B</br>A end$\quad$</td></tr></tbody></table></blockquote><h3 id="设计步骤如下："><a href="#设计步骤如下：" class="headerlink" title="设计步骤如下："></a>设计步骤如下：</h3><ol><li>用Jackson图描绘的输入输出结构。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="输入输出结构"></p></blockquote><ol start="2"><li>分析确定在输入数据结构和输出数据结构中有对应关系的数据单元。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83.png" alt="对应关系的数据单元"></p></blockquote><ol start="3"><li>从数据结构图导出程序结构图。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="从数据结构图导出程序结构图"></p></blockquote><ol start="4"><li>列出所有操作和条件，并且把它们分配到程序结构图的适当位置。</li></ol><blockquote><p><img src="/img/soft_intro_c6/%E6%93%8D%E4%BD%9C%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%88%86%E6%95%A3%E5%88%B0%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%9B%BE%E9%80%82%E5%BD%93%E7%9A%84%E4%BD%8D%E7%BD%AE.png"></p></blockquote><ol start="5"><li>用伪码表示程序处理程序。</li></ol><hr><h2 id="Jackson、层次图和层次方框图的区别"><a href="#Jackson、层次图和层次方框图的区别" class="headerlink" title="Jackson、层次图和层次方框图的区别"></a>Jackson、层次图和层次方框图的区别</h2><blockquote><table><thead><tr><th align="center"></th><th align="center">Jackson图</th><th align="center">层次图</th><th align="center">层次方框图</th></tr></thead><tbody><tr><td align="center">作用</td><td align="center">1. 描述数据结构</br>2. 描绘程序结构</td><td align="center">描绘软件结构</td><td align="center">描绘数据结构</td></tr><tr><td align="center">矩形框</td><td align="center">1. 数据结构</br>2. 几个语句</td><td align="center">模块</td><td align="center">数据元素</td></tr><tr><td align="center">连线</td><td align="center">组成关系</td><td align="center">调用关系</td><td align="center">组成关系</td></tr></tbody></table></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第六章-详细设计&quot;&gt;&lt;a href=&quot;#第六章-详细设计&quot; class=&quot;headerlink&quot; title=&quot;第六章_详细设计&quot;&gt;&lt;/a&gt;第六章_详细设计&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;概要设计说明书&lt;/strong&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第五章_总体设计</title>
    <link href="http://example.com/2021/05/19/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2021/05/19/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/</id>
    <published>2021-05-19T04:39:17.000Z</published>
    <updated>2021-05-23T12:32:53.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-总体设计"><a href="#第五章-总体设计" class="headerlink" title="第五章_总体设计"></a>第五章_总体设计</h1><p>总体设计/概要设计基本目的：“系统如何实现”</p><ol><li>划分组成系统的物理元素</li><li>设计软件的结构，确定模块构成和之间的联系</li></ol><hr><h3 id="1-设计过程由两个主要阶段组成（9个步骤）"><a href="#1-设计过程由两个主要阶段组成（9个步骤）" class="headerlink" title="1. 设计过程由两个主要阶段组成（9个步骤）"></a>1. 设计过程由两个主要阶段组成（9个步骤）</h3><h4 id="系统设计阶段，确定系统的具体实现方案"><a href="#系统设计阶段，确定系统的具体实现方案" class="headerlink" title="系统设计阶段，确定系统的具体实现方案"></a>系统设计阶段，确定系统的具体实现方案</h4><ol><li><p>设想供选择的方案</p><blockquote><p>根据需求分析阶段得出的数据流图考虑各种可能的实现方案，力求从中选出最佳方案。</p></blockquote></li><li><p>选取合理的方案</p><blockquote><p>从前一步得到的一系列供选择的方案中选取若干个合理的方案。对每个合理的方案分析员都应该准备下列4份资料：</p><ol><li>系统流程图；</li><li>组成系统的物理元素清单；</li><li>成本/效益分析；</li><li>实现这个系统的进度计划。</li></ol></blockquote></li><li><p>推荐最佳方案</p><blockquote><p>分析员应该综合对比各种合理方案的利弊,推荐一个最佳的方案, 并且为推荐的方案制定详细地实现计划。</p></blockquote></li></ol><h4 id="结构设计阶段，确定软件结构"><a href="#结构设计阶段，确定软件结构" class="headerlink" title="结构设计阶段，确定软件结构"></a>结构设计阶段，确定软件结构</h4><ol start="4"><li><p>功能分解</p><blockquote><p>首先进行结构设计，然后进行过程设计。</p><ul><li>结构设计确定程序由哪些模块组成, 以及这些模块之间的关系；$\quad$过程设计 确定每个模块的处理过程。</li><li>结构设计是总体设计阶段的任务,$\quad$过程设计是详细设计阶段的任务。</li></ul></blockquote></li><li><p>设计软件的结构</p><blockquote><ul><li>通常程序中的一个模块完成一个适当的子功能。应该把模块组织成良好的层次系统。软件结构可以用层次图或结构图来描绘。</li><li>如果数据流图已经细化到适当的层次，则可以直接从数据流图映射出软件结构，这就是面向数据流的设计方法。</li></ul></blockquote></li><li><p>设计数据库</p><blockquote><p>对于需要使用数据库的那些应用系统，软件工程师应该在需求分析阶段所确定的系统数据需求的基础上，进一步设计数据库。</p></blockquote></li><li><p>制定测试计划</p><blockquote><p>在软件开发的早期阶段考虑测试问题，能促使软件设计人员在设计时注意提高软件的可测试性。</p></blockquote></li><li><p>书写文档</p><blockquote><p>应该用正式的稳定记录总体设计的结果，在这个阶段应该完成的文档通常有下述几种：</p><ol><li>系统说明；</li><li>用户手册；</li><li>测试计划；</li><li>详细的实现计划；</li><li>数据库设计结果；</li></ol></blockquote></li><li><p>审查和复审</p><blockquote><p>最后应该对总体设计的结果进行严格的技术审查和管理复审。</p></blockquote></li></ol><hr><h3 id="2-设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）"><a href="#2-设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）" class="headerlink" title="2. 设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）"></a>2. 设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）</h3><h4 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1. 模块化"></a>1. 模块化</h4><blockquote><ul><li>模块：由边界元素限定的相邻程序元素的序列，还有一个总体标识符代表</li><li>模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。</li></ul></blockquote><blockquote><p>为什么要模块化?</p><ul><li>使一个复杂的大型程序能被人的智力所管理,软件应该具备的唯一属性。</li><li>如果一个大型程序仅由一个模块组成，它将很难被人所理解。</li></ul></blockquote><blockquote><p>决定模块效率化的因素:</p><ol><li>模块的数量；</li><li>模块之间的接口；</li></ol></blockquote><blockquote><p><strong>评价一种设计方法定义模块能力的五条标准:</strong></p><ul><li>模块可分解性</li><li>模块可组装性</li><li>模块可理解性</li><li>模块连续性</li><li>模块保护性</li></ul></blockquote><blockquote><p><strong>模块化的作用:</strong></p><ul><li>采用模块化原理可以使软件结构清晰,不仅容易设计也容易阅读和理解。</li><li>模块化使软件容易测试和调试, 因而有助于提高软件的可靠性。</li><li>模块化能够提高软件的可修改性。</li><li>模块化也有助于软件开发工程的组织管理。</li></ul></blockquote><h4 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2. 抽象"></a>2. 抽象</h4><blockquote><ul><li><strong>抽象:</strong> 现实世界中一定事物、状态或过程之间总存在着某些相似的方面(共性)。把这些相似的方面集中和概括起来，暂时忽略它们之间的差异，这就是抽象。</li><li>抽象就是抽出事物本质特性而暂时不考虑细节。</li></ul></blockquote><blockquote><p><strong>一般抽象过程:</strong></p><ul><li>处理复杂系统的惟一有效的方法是用层次的方式构造和分析它。</li><li>一个复杂的动态系统首先可以用一些高级的抽象概念构造和理解，这些高级概念又可以用一些较低级的概念构造和理解，如此进行下去，直至最低层次的具体元素。</li><li>例：过程抽象、数据抽象</li></ul></blockquote><blockquote><p>软件工程抽象过程: 软件工程过程的每一步都是对软件解法的抽象层次的一次精化。</p><ul><li>在可行性研究阶段，软件作为系统的一个完整部件；</li><li>在需求分析期间，软件解法是使用在问题环境内熟悉的方式描述的；</li><li>当由总体设计向详细设计过渡时，抽象的程度也就随之减少了；</li><li>最后，当源程序写出来以后，也就达到了抽象的最低层。</li></ul></blockquote><h4 id="3-逐步求精"><a href="#3-逐步求精" class="headerlink" title="3. 逐步求精"></a>3. 逐步求精</h4><blockquote><p>为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。逐步求精是人类解决复杂问题时采用的基本方法，也是许多软件工程技术的基础。</p></blockquote><blockquote><p><strong>作用:</strong></p><ul><li>帮助软件工程师把精力集中在与当前开发阶段最相关的那些方面上，而忽略那些对整体解决方案来说虽然是必要的，然而目前还不需要考虑的细节。</li><li>确保每个问题都将被解决，而且每个问题都将在适当的时候被解决，但是，在任何时候一个人都不需要同时处理7个以上知识块。</li></ul></blockquote><h4 id="4-信息隐藏和局部化"><a href="#4-信息隐藏和局部化" class="headerlink" title="4. 信息隐藏和局部化"></a>4. 信息隐藏和局部化</h4><blockquote><ul><li><strong>信息隐藏:</strong> 应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。</li><li><strong>局部化:</strong> 局部化的概念和信息隐藏概念是密切相关的。所谓局部化是指把一些关系密切的软件元素物理地放得彼此靠近。显然，局部化有助于实现信息隐藏。</li></ul></blockquote><blockquote><p><strong>信息隐藏和局部化的作用:</strong></p><ul><li>“隐藏”意味着有效的模块化可以通过定义一组独立的模块而实现，这些独立的模块彼此间仅仅交换那些为了完成系统功能而必须交换的信息。</li><li>使用信息隐藏原理作为模块化系统设计的标准就会带来极大好处。因为绝大多数数据和过程对于软件的其他部分而言是隐藏的，在修改期间由于疏忽而引入的错误就很少可能传播到软件的其他部分。</li></ul></blockquote><h4 id="5-模块独立"><a href="#5-模块独立" class="headerlink" title="5. 模块独立"></a>5. 模块独立</h4><blockquote><p>模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果。<br>希望这样设计软件结构，使得每个模块完成一个相对独立的特定子功能，并且和其他模块之间的关系很简单。</p></blockquote><blockquote><ul><li>重要性:<ul><li>有效的模块化的软件比较容易开发出来。</li><li>独立的模块比较容易测试和维护。</li></ul></li></ul></blockquote><blockquote><ul><li><strong>模块独立程度的两个定性标准度量:</strong><ul><li><strong>耦合</strong>衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低，即每个模块和其他模块之间的关系要简单；</li><li><strong>内聚</strong>衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高，每个模块完成一个相对独立的子功能。</li></ul></li></ul></blockquote><h5 id="1-耦合"><a href="#1-耦合" class="headerlink" title="1. 耦合"></a>1. 耦合</h5><blockquote><ul><li>耦合:是对一个软件结构内不同模块之间互连程度的度量。</li><li>要求：在软件设计中应该追求尽可能松散耦合的系统。</li><li>可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解；</li><li>模块间联系简单，发生在一处的错误传播到整个系统的可能性很小；</li><li>模块间的耦合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性。</li></ul></blockquote><h6 id="耦合程度的度量"><a href="#耦合程度的度量" class="headerlink" title="耦合程度的度量"></a>耦合程度的度量</h6><blockquote><ol><li>非直接耦合/完全独立(no direct coupling)</li></ol><blockquote><p>如果两个模块中的每一个都能独立地工作而不需要另一个模块的存在，那么它们完全独立。在一个软件系统中不可能所有模块之间都没有任何连接。</p></blockquote><ol start="2"><li>数据耦合(data coupling)</li></ol><blockquote><p>如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。</p></blockquote><blockquote><p>评价:</p><ul><li>系统中至少必须存在这种耦合。一般说来，一个系统内可以只包含数据耦合。$\qquad$数据耦合是理想的目标。</li><li>维护更容易，对一个模块的修改不会是另一个模块产生退化错误。</li></ul></blockquote><ol start="3"><li>控制耦合(control coupling)</li></ol><blockquote><p>如果两个模块彼此间传递的信息中有控制信息，这种耦合成为控制耦合。</p></blockquote><blockquote><p><strong>评价:</strong></p><ul><li>控制耦合往往是多余的,把模块适当分解之后通常可以用数据耦合代替它。</li><li>被调用的模块需知道调用模块的内部结构和逻辑，降低了重用的可能性。</li></ul></blockquote><ol start="4"><li>特征耦合(stamp coupling)</li></ol><blockquote><p>当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。<br>评价：</p></blockquote><blockquote><p>被调用的模块可使用的数据多于它确实需要的数据，这将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。<br>无论何时把指针作为参数进行传递，都应该仔细检查该耦合。</p></blockquote><ol start="5"><li>公共环境耦合(common coupling)<blockquote><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等等。</p></blockquote></li></ol><blockquote><p>类型:<br><img src="/img/soft_intro_c5/%E5%85%AC%E5%85%B1%E7%8E%AF%E5%A2%83%E8%80%A6%E5%90%88.png" alt="公共环境耦合的两种类型"></p><ul><li>一个模块往公告环境送数据,另一个模块从公共环境取数据。数据耦合的一种形式，是比较松散的耦合。</li><li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li></ul></blockquote><ol start="6"><li>内容耦合(content coupling)</li></ol><blockquote><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合：</p><ul><li>一个模块访问另一个模块的内部数据；</li><li>一个模块不通过正常入口转到另一个模块的内部；</li><li>两个模块有一部分程序代码重叠；</li><li>一个模块有多个入口。</li></ul></blockquote></blockquote><blockquote><p>耦合是影响软件复杂程度的一个重要因素。</p></blockquote><blockquote><p>应该采取下述设计原则:</p><ul><li><strong>尽量使用数据耦合，</strong></li><li><strong>少用控制耦合和特征耦合，</strong></li><li><strong>限制公共环境耦合的范围，</strong></li><li><strong>完全不用内容耦合。</strong></li></ul></blockquote><h5 id="2-内聚"><a href="#2-内聚" class="headerlink" title="2. 内聚"></a>2. 内聚</h5><blockquote><ul><li>内聚: 标志一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。简单地说，理想内聚的模块只做一件事情。</li><li>要求:设计时应该力求做到高内聚，通常中等程度的内聚也是可以采用的，而且效果和高内聚相差不多；但是，低内聚不要使用。</li><li>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。</li></ul></blockquote><h6 id="内聚程度的度量"><a href="#内聚程度的度量" class="headerlink" title="内聚程度的度量"></a>内聚程度的度量</h6><ol><li>偶然内聚(coincidental cohesion)————低内聚</li></ol><blockquote><p>如果一个模块完成一组任务,  这些任务彼此间即使有关系, 关系也是很松散的, 就叫做偶然内聚。<br><img src="/img/soft_intro_c5/%E5%81%B6%E7%84%B6%E5%86%85%E8%81%9A.png" alt="偶然内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>模块内各元素之间没有实质性联系，很可能在一种应用场合需要修改这个模块，在另一种应用场合又不允许这种修改，从而陷入困境；</li><li>可理解性差，可维护性产生退化；</li><li>模块是不可重用的。</li></ul></blockquote><blockquote><p>解决方案:将模块分成更小的模块, 每个小模块执行一个操作。</p></blockquote><ol start="2"><li>逻辑内聚（logical cohesion）————低内聚</li></ol><blockquote><p>如果一个模块完成的任务在逻辑上属于相同或相似的一类，则称为逻辑内聚。<br><img src="/img/soft_intro_c5/%E9%80%BB%E8%BE%91%E5%86%85%E8%81%9A.png" alt="逻辑内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>接口难以理解, 造成整体上不易理解；</li><li>完成多个操作的代码互相纠缠在一起，即使局部功能的修改有时也会影响全局，导致严重的维护问题；</li><li>难以重用。</li></ul></blockquote><blockquote><p>解决方案: 模块分解。<br><img src="/img/soft_intro_c5/%E6%A8%A1%E5%9D%97%E5%88%86%E8%A7%A3.png" alt="模块分解示意"></p></blockquote><ol start="3"><li>时间内聚(temporal cohesion)————低内聚</li></ol><blockquote><p>如果一个模块包含的任务必须在同一段时间内执行，就叫时间内聚。<br><img src="/img/soft_intro_c5/%E6%97%B6%E9%97%B4%E5%86%85%E8%81%9A.png" alt="时间内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>时间关系在一定程度上反映了程序某些实质，所以时间内聚比逻辑内聚好一些。</li><li>模块内操作之间的关系很弱，与其他模块的操作却有很强的关联。</li><li>时间内聚的模块不太可能重用。</li></ul></blockquote><ol start="4"><li>过程内聚(procedural cohesion)</li></ol><blockquote><ul><li>如果一个模块内的处理元素是相关的，而且必须以特定次序执行，则称为过程内聚。</li><li>使用程序流程图作为工具设计软件时，常常通过研究流程图确定模块的划分，这样得到的往往是过程内聚的模块。</li></ul></blockquote><blockquote><p>评价:</p><ul><li>比时间内聚好，至少操作之间是过程关联的。</li><li>仍是弱连接，不太可能重用模块。</li></ul></blockquote><blockquote><p>解决方案：分割为单独的模块，每个模块执行一个操作</p></blockquote><ol start="5"><li>通信内聚（communicational cohesion）</li></ol><blockquote><p>如果模块中所有元素都使用同一个输入数据和(或)产生同一个输出数据，则称为通信内聚。即在同一个数据结构上操作。</p></blockquote><blockquote><p>评价：模块中各操作紧密相连，比过程内聚更好。不能重用。</p></blockquote><blockquote><p>解决方案：分成多个模块，每个模块执行一个操作。</p></blockquote><ol start="6"><li>顺序内聚(sequential cohesion)</li></ol><blockquote><p>如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。</p></blockquote><blockquote><p>评价：根据数据流图划分模块时，通常得到顺序内聚的模块，这种模块彼此间的连接往往比较简单。</p></blockquote><ol start="7"><li>功能内聚(functional cohesion)</li></ol><blockquote><p>如果模块内所有处理元素属于一个整体，完成一个单一的功能，则称为功能内聚。功能内聚是最高程度的内聚。</p></blockquote><blockquote><p>评价：</p><ul><li>模块可重用，应尽可能重用；</li><li>可隔离错误，维护更容易；</li><li>扩充产品功能时更容易。</li></ul></blockquote><h6 id="七种内聚的优劣评分结果"><a href="#七种内聚的优劣评分结果" class="headerlink" title="七种内聚的优劣评分结果"></a>七种内聚的优劣评分结果</h6><blockquote><table><thead><tr><th align="center"></th><th align="center">类型</th><th align="center">分数</th></tr></thead><tbody><tr><td align="center"><strong>高内聚</strong></td><td align="center"><strong>功能内聚</strong></td><td align="center"><strong>10分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>顺序内聚</strong></td><td align="center"><strong>9分</strong></td></tr><tr><td align="center"><strong>中内聚</strong></td><td align="center"><strong>通信内聚</strong></td><td align="center"><strong>7分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>过程内聚</strong></td><td align="center"><strong>5分</strong></td></tr><tr><td align="center"><strong>低内聚</strong></td><td align="center"><strong>时间内聚</strong></td><td align="center"><strong>3分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>逻辑内聚</strong></td><td align="center"><strong>1分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>偶然内聚</strong></td><td align="center"><strong>0分</strong></td></tr></tbody></table><p>设计时力争做到高内聚，并且能够辨认出低内聚的模块。</p></blockquote><hr><h3 id="3-启发准则"><a href="#3-启发准则" class="headerlink" title="3. 启发准则"></a>3. 启发准则</h3><h4 id="1-改进软件结构提高模块独立性"><a href="#1-改进软件结构提高模块独立性" class="headerlink" title="1. 改进软件结构提高模块独立性"></a>1. 改进软件结构提高模块独立性</h4><blockquote><p>通过模块分解或合并，降低耦合提高内聚。<br>两个方面：</p><blockquote><ul><li>模块功能完善化。 一个完整的模块包含：<ul><li>执行规定的功能的部分</li><li>出错处理的部分</li><li>返回一个”结束标志”</li></ul></li><li>消除重复功能, 改善软件结构。</li></ul></blockquote></blockquote><h4 id="2-模块规模应该适中"><a href="#2-模块规模应该适中" class="headerlink" title="2. 模块规模应该适中"></a>2. 模块规模应该适中</h4><blockquote><ul><li>经验表明，一个模块的规模不应过大，最好能写在一页纸内。通常规定50~100行语句，最多不超过500行。数字只能作为参考，根本问题是要保证模块的独立性。</li><li>过大的模块往往是由于分解不充分，但是进一步分解必须符合问题结构，一般说来，分解后不应该降低模块独立性。</li><li>过小的模块开销大于有效操作，而且模块数目过多将使系统接口复杂。</li></ul></blockquote><h4 id="3-深度、宽度、扇出和扇入都应适当"><a href="#3-深度、宽度、扇出和扇入都应适当" class="headerlink" title="3. 深度、宽度、扇出和扇入都应适当"></a>3. 深度、宽度、扇出和扇入都应适当</h4><blockquote><p><strong>深度：</strong> 软件结构中控制的层数，它往往能粗略地标志一个系统的大小和复杂程度。<br><strong>宽度：</strong> 软件结构内同一个层次上的模块总数的最大值。<br><strong>扇出：</strong> 一个模块直接控制（调用）的模块数目。<br><strong>扇入：</strong> 有多少个上级模块直接调用它。<br><img src="/img/soft_intro_c5/%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="软件结构"><br><img src="/img/soft_intro_c5/%E6%89%87%E5%87%BA%E6%89%87%E5%85%A5%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%E6%83%85%E5%86%B5.png" alt="不好的情况"></p></blockquote><h4 id="4-模块的作用域应该在控制域之内"><a href="#4-模块的作用域应该在控制域之内" class="headerlink" title="4. 模块的作用域应该在控制域之内"></a>4. 模块的作用域应该在控制域之内</h4><blockquote><ul><li><strong>模块的作用域：</strong> 定义为受该模块内一个判定影响的所有模块的集合。</li><li><strong>模块的控制域：</strong> 这个模块本身以及所有直接或间接从属于它的模块的集合。</li><li>在一个设计得很好的系统中，所有受判定影响的模块应该都从属于做出判定的那个模块，最好局限于做出判定的那个模块本身及它的直属下级模块。</li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E8%BF%9D%E5%8F%8D%E8%A7%84%E5%88%99%E7%9A%84%E6%83%85%E5%86%B5.png" alt="违反规则的情况"><br><strong>解决方案:</strong></p><ul><li>把模块 A 中的判定移到模块 M 中；</li><li>把模块 G 移到模块A下面，作为它的下级模块。</li></ul><p><img src="/img/soft_intro_c5/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="解决方案"></p></blockquote><h4 id="5-力争降低模块接口的复杂程度"><a href="#5-力争降低模块接口的复杂程度" class="headerlink" title="5. 力争降低模块接口的复杂程度"></a>5. 力争降低模块接口的复杂程度</h4><blockquote><p>模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。</p></blockquote><p><strong>例:解一元二次方程的函数</strong></p><ul><li><input disabled="" type="checkbox"> <strong>QUAD_ROOT(TBL, X)</strong><blockquote><ul><li>其中数组 TBL 传送方程的系数</li><li>数组 X 送回求得的根  </li></ul></blockquote></li><li><input checked="" disabled="" type="checkbox"> <strong>QUAD_ROOT(A, B, C, ROOT1, ROOT2)</strong></li></ul><h4 id="6-设计单入口单出口的模块"><a href="#6-设计单入口单出口的模块" class="headerlink" title="6. 设计单入口单出口的模块"></a>6. 设计单入口单出口的模块</h4><blockquote><p>警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。</p></blockquote><h4 id="7-模块功能应该可以预测"><a href="#7-模块功能应该可以预测" class="headerlink" title="7. 模块功能应该可以预测"></a>7. 模块功能应该可以预测</h4><blockquote><ul><li>模块的功能应该能够预测，但也要防止模块功能过分局限。</li><li>功能可预测：如果一个模块可以当做一个黑盒子，只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。</li></ul></blockquote><hr><h3 id="4-软件结构的图形工具：层次图（H图）、HIPO图、结构图"><a href="#4-软件结构的图形工具：层次图（H图）、HIPO图、结构图" class="headerlink" title="4. 软件结构的图形工具：层次图（H图）、HIPO图、结构图"></a>4. 软件结构的图形工具：层次图（H图）、HIPO图、结构图</h3><h4 id="1-层次图-H图"><a href="#1-层次图-H图" class="headerlink" title="1. 层次图(H图)"></a>1. 层次图(H图)</h4><blockquote><p>层次图用来描绘软件的层次结构。很适于在自顶向下设计软件的过程中使用。</p></blockquote><blockquote><p>层次图和层次方框图的区别：</p><table><thead><tr><th align="center"></th><th align="center">层次图</th><th align="center">层次方框图</th></tr></thead><tbody><tr><td align="center">作用</td><td align="center">描绘软件结构</td><td align="center">描绘数据结构</td></tr><tr><td align="center">矩形框</td><td align="center">模块</td><td align="center">数据元素</td></tr><tr><td align="center">连线</td><td align="center">调用关系</td><td align="center">组成关系</td></tr></tbody></table></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E6%AD%A3%E6%96%87%E5%8A%A0%E5%B7%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E5%9B%BE.png" alt="正文加工系统的层次图"></p></blockquote><h4 id="2-HIPO图"><a href="#2-HIPO图" class="headerlink" title="2. HIPO图"></a>2. HIPO图</h4><blockquote><ul><li>HIPO图是美国IBM公司发明的“层次图+输入/处理/输出图”的英文缩写。</li><li>为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。<br><img src="/img/soft_intro_c5/HIPO%E5%9B%BE.png" alt="HIPO图"><br>和H图中每个方框相对应，应该有一张IPO图描绘这个方框代表的模块的处理过程。模块在H图中的编号便于追踪了解这个模块在软件结构中的位置。</li></ul></blockquote><h4 id="3-结构图"><a href="#3-结构图" class="headerlink" title="3. 结构图"></a>3. 结构图</h4><blockquote><p><strong>基本符号:</strong></p><ul><li>方框代表一个模块；</li><li>方框之间的直线表示模块的调用关系；</li><li>尾部是空心圆箭头表示传递的是数据；</li><li>尾部是实心圆箭头表示传递的是控制信息。<br><img src="/img/soft_intro_c5/%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="结构图"></li></ul></blockquote><blockquote><p><strong>附加符号:</strong><br><img src="/img/soft_intro_c5/%E7%BB%93%E6%9E%84%E5%9B%BE%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7.png" alt="结构图附加符号"></p><ul><li>选择调用: 判定为真时调用 A，为假时调用 B。</li><li>模块 M 循环调用模块 A、B、C。</li></ul></blockquote><blockquote><p><strong>注意:</strong></p><ul><li>层次图和结构图并不严格表示模块的调用次序，多数人习惯从左到右画模块；</li><li>层次图和结构图并不指明合适调用下层模块；<br>层次图和结构图只表明一个模块调用哪些模块，没有表示模块内还有没有其他成分；<br>通常用层次图作为描绘软件结构的文档；<br>由层次图导出结构图的过程可以作为检查设计正确性和评价模块独立性的好方法。</li></ul></blockquote><hr><h3 id="5-面向数据流的设计方法：变换流和事务流"><a href="#5-面向数据流的设计方法：变换流和事务流" class="headerlink" title="5. 面向数据流的设计方法：变换流和事务流"></a>5. 面向数据流的设计方法：变换流和事务流</h3><h4 id="1-变换流"><a href="#1-变换流" class="headerlink" title="1. 变换流"></a>1. 变换流</h4><blockquote><p>信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。<br><img src="/img/soft_intro_c5/%E5%8F%98%E6%8D%A2%E6%B5%81.png" alt="变换流"></p></blockquote><h4 id="2-事务流"><a href="#2-事务流" class="headerlink" title="2. 事务流"></a>2. 事务流</h4><blockquote><p>数据沿输入通路到达一个处理T，T根据输入数据的类型在若干个动作序列中选出一个来执行。处理T称为事务中心，它完成下述任务：</p><ul><li>接收输入数据</li><li>分析每个事务以确定它的类型；</li><li>根据事务类型选取一条活动通路。<br><img src="/img/soft_intro_c5/%E4%BA%8B%E5%8A%A1%E6%B5%81.png" alt="事务流"></li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png" alt="设计过程"></p></blockquote><h4 id="3-变换分析"><a href="#3-变换分析" class="headerlink" title="3. 变换分析"></a>3. 变换分析</h4><blockquote><p>变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图按预先确定的模式映射成软件结构。</p></blockquote><blockquote><p><strong>设计步骤:</strong></p><ol><li>复查基本系统模型</li></ol><blockquote><ul><li>确保系统的输入数据和输出数据符合实际。</li></ul></blockquote><ol start="2"><li>复查并精化数据流图</li></ol><blockquote><ul><li>对需求分析阶段得出的数据流图认真复查，并且在必要时进行精化。</li><li>不仅要确保数据流图给出了目标系统的正确逻辑模型，而且应该使数据流图中每个处理都代表一个规模适中相对独立的子功能。</li></ul></blockquote><ol start="3"><li>确定数据流图具有变换特性还是事务特性</li></ol><blockquote><ul><li>一个系统中的所有信息流都可以认为是变换流，但是，当遇到有明显事务特性的信息流时，建议采用事务分析方法进行设计。确定数据流的全局特性和局部特性。</li></ul></blockquote><ol start="4"><li>确定输入流和输出流的边界，从而孤立出变换中心</li></ol><blockquote><ul><li>输入流和输出流的边界和对它们的解释有关,不同设计人员可能会在流内选取稍微不同的点作为边界的位置。</li></ul></blockquote><ol start="5"><li>完成“第一级分解”。</li></ol><blockquote><ul><li>位于软件结构最顶层的控制模块 $C_m$ 协调下述从属的控制功能：<ul><li>输入信息处理控制模块 $C_a$ ，管理对内部形式的数据的所有操作；</li><li>变换中心控制模块 $C_t$，管理对内部形式的数据的所有操作；</li><li>输出信息处理控制模块 $C_e$，协调输出信息的产生过程。</li></ul></li></ul><p><img src="/img/soft_intro_c5/%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%88%86%E8%A7%A3.png" alt="第一级分解"></p></blockquote><ol start="6"><li>完成“第二级分解”</li></ol><blockquote><ul><li>处理映射成软件结构中一个适当的模块。完成第二级分解的方法是：<ul><li>从变换中心的边界开始逆着输入通路向外移动，把输入通路中每个处理映射成软件结构中Ca控制下的一个低层模块；</li><li>然后沿输出通路向外移动，把输出通路中每个处理映射成直接或间接受模块Ce控制的一个低层模块；</li><li>最后把变换中心内的每个处理映射成受Ct控制的一个模块。</li></ul></li></ul><p><img src="/img/soft_intro_c5/%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E8%A7%A3.png" alt="第二级分解"><br><img src="/img/soft_intro_c5/%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E8%A7%A31.png" alt="第二级分解"></p></blockquote><ol start="7"><li>使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化</li></ol><blockquote><p>为了产生合理的分解，得到尽可能高的内聚、尽可能松散的耦合，为了得到一个易于实现、易于测试和易于维护的软件结构，应该对初步分割得到的模块进行再分解或合并。 </p></blockquote></blockquote><h4 id="4-事务分析"><a href="#4-事务分析" class="headerlink" title="4. 事务分析"></a>4. 事务分析</h4><blockquote><p>虽然在任何情况下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。</p></blockquote><blockquote><ul><li>事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同；</li><li>由事务流映射成的软件结构包括一个接收分支和一个发送分支；</li><li>映射出接收分支结构的方法和变换分析映射出输入结构的方法很相像，即从事务中心的边界开始，把沿着接收流通路的处理映射成模块；</li><li>发送分支的结构包含一个调度模块，它控制下层的所有活动模块；然后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构<br><img src="/img/soft_intro_c5/%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95.png" alt="事务分析的映射方法"></li></ul></blockquote><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结:"></a>5. 总结:</h4><blockquote><ul><li>一般说来，如果数据流不具有显著的事务特点，最好使用变换分析；反之，如果具有明显的事务中心，则应该采用事务分析技术。</li><li>机械地遵循变换分析或事务分析的映射规则，可能会得到一些不必要的控制模块，如果它们确实用处不大，那么可以而且应该把它们合并。</li><li>如果一个控制模块功能过分复杂，这应该分解为两个或多个控制模块，或者增加中间层次的控制模块。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五章-总体设计&quot;&gt;&lt;a href=&quot;#第五章-总体设计&quot; class=&quot;headerlink&quot; title=&quot;第五章_总体设计&quot;&gt;&lt;/a&gt;第五章_总体设计&lt;/h1&gt;&lt;p&gt;总体设计/概要设计基本目的：“系统如何实现”&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;划分组成系统的物理元</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第三章 需求分析</title>
    <link href="http://example.com/2021/05/18/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/05/18/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</id>
    <published>2021-05-17T16:22:55.000Z</published>
    <updated>2021-05-23T02:27:37.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-需求分析"><a href="#第三章-需求分析" class="headerlink" title="第三章 需求分析"></a>第三章 需求分析</h1><hr><h4 id="需求分析的任务；获取需求的方法"><a href="#需求分析的任务；获取需求的方法" class="headerlink" title="需求分析的任务；获取需求的方法"></a>需求分析的任务；获取需求的方法</h4><h5 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h5><ul><li><p><strong>确定对系统的综合要求</strong></p><blockquote><ol><li><em>功能需求</em></li><li><em>性能需求</em></li><li><em>可靠性和可用性需求</em></li><li><em>出错处理需求</em></li><li><em>接口需求</em></li><li><em>约束</em></li><li><em>逆向需求</em></li><li><em>将来可能提出的要求</em></li></ol></blockquote></li><li><p><strong>分析系统的数据要求</strong></p><blockquote><ul><li>建立数据模型——ER图 </li><li>描绘数据结构——层次方框图和Warnier图  </li><li>数据结构规范化 </li></ul></blockquote></li><li><p><strong>导出系统的逻辑模型</strong></p><blockquote><p>综合上述两项分析的结果可以导出系统的详细的逻辑模型，通常用 <strong>数据流图</strong> 、<strong>实体-联系图</strong> 、<strong>状态转换图</strong> 、<strong>数据字典</strong> 和 <strong>主要的处理算法</strong> 描述这个逻辑模型。</p></blockquote></li><li><p><strong>修正系统开发计划</strong></p><blockquote><p>根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。 </p></blockquote></li></ul><h5 id="获取需求的方法"><a href="#获取需求的方法" class="headerlink" title="获取需求的方法"></a>获取需求的方法</h5><ul><li><p><strong>访谈</strong></p><blockquote><ol><li><em>正式访谈</em> : 系统分析员将提出一些事先准备好的具体问题。</li><li><em>非正式访谈</em> : 分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法。</li><li><em>调查表</em> : 经过仔细考虑写出的书面回答可能比被访者对问题的口头回答更准确。</li><li><em>情景分析技术</em> :<blockquote><p>对用户将来使用目标系统解决某个具体问题的方法和结果进行分析。<br><strong>情景分析技术的用处：</strong></p><ul><li>能在某种程度上演示目标系统的行为，从而便于用户理解，而且还可能进一步揭示出一些分析员目前还不知道的需求。</li><li>能保证用户在需求分析过程中始终扮演一个积极主动的角色。让用户起积极主动的作用对需求分析工作获得成功是至关重要的。</li></ul></blockquote></li></ol></blockquote></li><li><p><strong>面向数据流自顶向下求精</strong></p><blockquote><ol><li><em>分析追踪数据流图</em> : 需求分析的目标之一就是把数据流和数据存储定义到元素级，通常从数据流图的输出端着手分析。</li><li><em>用户复查</em> : <ul><li>必须请用户对上述分析过程中得出的结果仔细地复查。复查过程验证了已知的元素，补充了未知的元素，填补了文档中的空白。</li><li>随着分析过程的进展，经过问题和解答的反复循环，分析员越来越深入具体地定义了目标系统，最终得到对系统数据和功能要求的<del>满意</del>充足了解。<br><img src="/img/soft_intro_c3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B1%82%E7%B2%BE.png" alt="面向数据流自顶向下求精"></li></ul></li></ol></blockquote></li><li><p><strong>简易的应用规格说明技术</strong></p><blockquote><ul><li>简易的应用规格说明技术是一种面向团队的需求收集法。</li><li>这种方法提倡用户与开发者密切合作，共同标识问题，提出解决方案要素，商讨不同方案并指定基本需求。 </li></ul></blockquote><blockquote><p><strong>优点:</strong></p><ul><li>开发者与用户不分彼此，齐心协力，密切合作；</li><li>即时讨论并求精；</li><li>有能导出规格说明的具体步骤。 </li></ul></blockquote></li></ul><blockquote><p><strong>分析需求的典型过程如下:</strong></p><ol><li>初步访谈, 提出建议;</li><li>会前审查需求, 确定列表;</li><li>会上讨论列表, 创建组合列表;</li><li>分组制定小型规格说明;</li><li>制定确认标准, 起草需求规格说明书 </li></ol></blockquote><ul><li><p><strong>快速建立软件原型</strong></p><blockquote><ul><li>快速建立软件原型是最准确、最有效、最强大的需求分析技术。</li><li>快速原型就是快速建立起来的旨在演示目标系统主要功能的可运行的程序。</li><li>构建原型的要点是，它应该实现用户看得见的功能，省略目标系统的“隐含”功能。</li></ul></blockquote><blockquote><p><strong>特性:</strong></p><ul><li>“快速”。快速原型的目的是尽快向用户提供一个可在计算机上运行的目标系统的模型。因此，原型的某些缺陷是可以忽略的。</li><li>“容易修改”。如果原型的第一版不是用户所需要的，就必须根据用户的意见迅速地修改它，构建出原型的第二版，以更好地满足用户需求。如果修改耗时过多，势必延误软件开发时间。 </li></ul></blockquote></li></ul><blockquote><p><strong>通常使用的3种方法和工具：</strong></p><ol><li>第四代技术（4GL）</li><li>可重用的软件构建</li><li>形式化规格说明和原型环境</li></ol></blockquote><blockquote><p>第四代技术特点：<br>简单易学，用户界面良好，面向问题、非过程化程度高，用户只需告知系统做什么，而无需说明怎么做。用4GL编程使用的代码量较少，并可成数量级地提高软件生产率。</p></blockquote><blockquote><p>程序设计语言划代：<br>1GL是汇编语言；<br>2GL是高级程序设计语言，如FORTRAN，ALGOL，BASIC，LISP等；<br>3GL是增强性的高级程序设计语言，如PASCAL，ALGOL68，FORTRAN77等；<br>4GL是按计算机科学理论指导设计出来的语言，如ADA，MODULA－2，SMALLTALK－80，JAVA，VB，VC，VF等。 </p></blockquote><hr><h4 id="需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；"><a href="#需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；" class="headerlink" title="需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；"></a>需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；</h4><hr><h4 id="实体-联系图（E-R图）：三种信息、符号和应用"><a href="#实体-联系图（E-R图）：三种信息、符号和应用" class="headerlink" title="实体-联系图（E-R图）：三种信息、符号和应用"></a>实体-联系图（E-R图）：三种信息、符号和应用</h4><ul><li><p><strong>数据模型(E-R图):</strong> 描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形。</p></li><li><p><strong>三种相互关联的信息:</strong></p><ol><li><strong>数据对象</strong></li></ol><blockquote><ul><li>是对软件必须理解的复合信息的抽象。复合信息是指具有一系列不同性质或属性的事物，仅有单个值的事物不是数据对象。</li><li>数据对象可以是外部实体、事物、行为、事件、角色、单位、地点或结构等。数据对象彼此间是有关联的。</li></ul></blockquote><ol start="2"><li>数据对象的 <strong>属性</strong></li></ol><blockquote><ul><li><strong>属性</strong> 定义了数据对象的性质。必须把一个或多个属性定义为“标识符” 。</li><li>根据对问题的理解来确定特定数据对象的合适的属性。 </li></ul></blockquote><ol start="3"><li>数据对象彼此间相互连接的 <strong>关系</strong></li></ol><blockquote><ul><li><strong>联系:</strong> 数据对象彼此之间相互连接的方式称为联系，也称为关系。</li><li><strong>联系可分为以下3种类型：</strong><ol><li>一对一联系(1∶1)</li><li>一对多联系(1∶N)</li><li>多对多联系(M∶N)</li></ol></li><li><strong>联系也可能有属性。</strong></li></ul></blockquote></li><li><p><strong>E-R图的符号</strong></p><blockquote><p><img src="/img/soft_intro_c3/E-R%E5%9B%BE%E7%9A%84%E7%AC%A6%E5%8F%B7.png"></p></blockquote></li><li><p><strong>应用</strong></p></li><li><p><strong>优点</strong></p><blockquote><ul><li>比较接近人的习惯思维方式；</li><li>用简单的图形符号表达系统分析员对问题域的理解，用户也容易理解，可以作为用户与分析员之间有效的交流工具。 </li></ul></blockquote></li></ul><hr><h4 id="状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；"><a href="#状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；" class="headerlink" title="状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；"></a>状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；</h4><ul><li><p><strong>状态转换图:</strong> 通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。还指明了作为特定事件的结果系统将做哪些动作(例如，处理数据)。</p></li><li><p><strong>状态：</strong> 是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。</p><blockquote><p>状态主要有:</p><ul><li>初态(即初始状态), 只能有一个</li><li>终态(即最终状态)，可以有0至多个</li><li>中间状态</li></ul></blockquote><blockquote><p>状态图分类：</p><ul><li>表示系统循环运行过程，通常不关心循环是怎样启动的。</li><li>表示系统单程生命期，需要标明初始状态和最终状态。</li></ul></blockquote></li><li><p><strong>事件:</strong> 是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。简而言之，事件就是引起系统做动作或(和)转换状态的控制信息。 </p></li><li><p><strong>符号:</strong></p><blockquote><ul><li>初态:用实心圆表示；</li><li>终态:用一对同心圆(内圆为实心圆)表示；</li><li>中间状态: 用圆角矩形表示, 分成上、中、下3部分。<ul><li>上面部分—–为状态的名称；</li><li>中间部分—–为状态变量的名字和值；</li><li>下面部分—–是活动表（可选）。 </li></ul></li><li>带箭头的连线: 称为状态转换, 箭头指明了传播方向。</li></ul></blockquote></li><li><p><strong>活动表的语法格式</strong></p><blockquote><p><strong>语法格式: 事件名(参数表)/动作表达式</strong></p><ul><li>entry事件指定进入该状态的动作；</li><li>exit事件指定退出该状态的动作；</li><li>do事件则指定在该状态的动作。</li></ul><p>需要时可以为事件指定参数表。活动表中的动作表达式描述应做的具体动作。</p></blockquote></li><li><p><strong>事件表达式的语法格式</strong></p><blockquote><p>状态转换: 状态图中两个状态之间带箭头的连线，箭头指明了传播方向<br>状态变迁: 通常由事件触发, 在此情况下, 应在表示状态转换的箭头线上标出触发状态转换的事件表达式。如果未标明,则表示自动触发。</p></blockquote><blockquote><p>语法: <strong>事件说明[守卫条件] / 动作表达式</strong></p><ul><li>时间说明的语法为: 事件名(参数表)。</li><li>守卫条件是一个布尔表达式。如果同时使用时间说明和守卫条件，则当且仅当事件发生且布尔表达式为真时，状态转换才会发生。如果只有守卫条件没有事件说明，则只要守卫条件为真状态转换就发生。</li><li>动作表达式是一个过程表达式,当状态转换开始时执行该表达式<br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B01.png"><br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B021.png"><br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B022.png"></li></ul></blockquote></li></ul><hr><h4 id="其他图形工具：层次方框图、Warnier图、IPO图"><a href="#其他图形工具：层次方框图、Warnier图、IPO图" class="headerlink" title="其他图形工具：层次方框图、Warnier图、IPO图"></a>其他图形工具：层次方框图、Warnier图、IPO图</h4><ul><li><p><strong>层次方框图</strong></p><blockquote><p><strong>层次方框图:</strong> 用树形结构的一系列多层次的矩形框来描绘数据的层次结构。<br><img src="/img/soft_intro_c3/%E5%B1%82%E6%AC%A1%E6%96%B9%E6%A1%86%E5%9B%BE.png" alt="层次方框图"></p><ul><li>树形结构的顶层是一个单独的矩形框,它代表完整的数据结构；</li><li>下面的各层矩形框代表这个数据的子集；</li><li>最底层的各个框代表组成这个数据的实际数据元素(不能再分割的元素)。</li></ul></blockquote></li><li><p><strong>Warnier图</strong></p><blockquote><p><strong>Warnier图:</strong> 和层次方框图类似, Waarnier图也用树形结构描绘信息, 但是这种图形工具比层次方框图提供了更丰富的描绘手段。<br><img src="/img/soft_intro_c3/%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81%E7%9A%84Warnier%E5%9B%BE.png"><br><strong>特点:</strong> 用Warnier图可以表明信息的逻辑组织，也可以表示特定信息在某一类信息中是有条件地出现的。因为重复和条件约束是说明软件处理过程的基础，所以很容易把Warnier图转变成软件设计的工具。 </p></blockquote></li><li><p><strong>IPO图</strong></p><blockquote><p>IPO图: 是输入、处理、输出图的简称，它是美国IBM公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。<br>基本形式: 是在左边的框中列出有关的输入数据，在中间的框内列出主要的处理，在右边的框内列出产生的输出数据。在IPO图中还用类似向量符号的粗大箭头清楚地指出数据通信的情况。<br><img src="/img/soft_intro_c3/IPO%E5%9B%BE%E4%BE%8B%E5%AD%90.png" alt="IPO图例子"></p></blockquote><blockquote><p><strong>改进的IPO图:</strong> 这种图中包含某些附加的信息, 在软件设计过程中将比原始的IPO图更有用。<br><img src="/img/soft_intro_c3/IPO%E5%9B%BE_%E6%94%B9%E8%BF%9B.png" alt="改进的IPO图"><br>在需求分析阶段可以使用IPO图简略地描述系统的主要算法(即数据流图中各个处理的基本算法)。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-需求分析&quot;&gt;&lt;a href=&quot;#第三章-需求分析&quot; class=&quot;headerlink&quot; title=&quot;第三章 需求分析&quot;&gt;&lt;/a&gt;第三章 需求分析&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;需求分析的任务；获取需求的方法&quot;&gt;&lt;a href=&quot;#需求分析的任务；获</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第二章 可行性研究</title>
    <link href="http://example.com/2021/05/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/"/>
    <id>http://example.com/2021/05/16/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/</id>
    <published>2021-05-16T02:46:43.000Z</published>
    <updated>2021-05-19T04:49:47.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-可行性研究"><a href="#第二章-可行性研究" class="headerlink" title="第二章 可行性研究"></a>第二章 可行性研究</h1><hr><h4 id="可行性研究的内容"><a href="#可行性研究的内容" class="headerlink" title="可行性研究的内容"></a>可行性研究的内容</h4><p><strong>1. 技术可行性:</strong></p><blockquote><p>使用现有的技术能否实现这个系统？<br>是否有胜任开发该项目的熟练技术人员？<br>能否按期得到开发该项目所需的软件、硬件资源？</p></blockquote><p><strong>2. 经济可行性:</strong></p><blockquote><p>这个系统的经济效益能否超过它的开发成本？<br>需要对项目进行价格/利益分析，即“投入/产出”分析。<br>由于利益分析取决于软件系统的特点，因此在软件开发之前，很难对新系统产生的效益作出精确的定量描述，所以往往采用一些估算方法。</p></blockquote><p><strong>3. 操作可行性:</strong></p><blockquote><p>操作可行性评价系统运行后会引起的各方面变化，如：对组织机构管理模式、用户工作环境等产生的影响。</p></blockquote><p><strong>4. 社会可行性:</strong></p><blockquote><p>社会可行性主要讨论法律方面和使用方面的可行性。<br>例如，被开发软件的权利归属问题、软件所使用的技术是否会造成侵权等问题。</p></blockquote><hr><h4 id="可行性研究过程-7步骤"><a href="#可行性研究过程-7步骤" class="headerlink" title="可行性研究过程(7步骤)"></a>可行性研究过程(7步骤)</h4><ol><li>复查定义，确定系统规模和目标；<blockquote><p>确认目标问题（用户需要的是否等于我们认为用户需要的）</p></blockquote></li><li>研究目前正在使用的系统；<blockquote><p>确认成本，缺点，流程图，接口等</p></blockquote></li><li>导出新系统的高层逻辑模型（数据流图、数据字典）；<blockquote><p>输入输出，数据格式</p></blockquote></li><li>重新定义问题；</li></ol><blockquote><p>前 4 个步骤实质上构成一个循环</p></blockquote><ol start="5"><li>导出和评价供选择的解法（物理解决方案）；<blockquote><p>技术、操作、经济和市场上接受同时满足，给出供选择的方案。</p></blockquote></li><li>推荐行动方案；<blockquote><p>哪一种方案最好，为什么，给出定论和原因。</p></blockquote></li><li>草拟开发计划（粗略）；<blockquote><ul><li>任务分解，确定负责人</li><li>大致进度规划</li><li>财务预算</li><li>风险分析及对策</li></ul></blockquote></li><li>书写文档提交审查。 （作为下一个阶段工作的基础）</li></ol><p><strong>可行性报告，必须给出明确结论：</strong></p><ul><li>行或不行。</li><li>或者给出系统开始前需要首先具备哪些条件</li><li>或系统目标需要先行修改等。</li></ul><hr><h4 id="系统流程图概念，特点、符号和应用；"><a href="#系统流程图概念，特点、符号和应用；" class="headerlink" title="系统流程图概念，特点、符号和应用；"></a>系统流程图概念，特点、符号和应用；</h4><ul><li>概念和特点:<blockquote><p>系统流程图是概括的描述物理系统的传统工具。<br>系统流程图反映的是信息在系统各部分之间流动的情况；<br>系统流程图 $\neq$ 控制、处理信息（不同于程序流程图）</p></blockquote></li><li>符号:<br><img src="/img/soft_intro_c2/%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE_%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7.png" alt="基本符号"><br><img src="/img/soft_intro_c2/%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE_%E7%B3%BB%E7%BB%9F%E7%AC%A6%E5%8F%B7.png" alt="系统符号"></li><li>应用</li><li>分层:<blockquote><p>面对复杂的系统时,一个比较好的方法是分层次地描绘这个系统。首先用一张高层次的系统流程图描绘系统总体概貌,表明系统的关键功能。然后分别把每个关键功能扩展到适当的详细程度,画在单独的一页纸上。这种分层次的描绘方法便于阅读者按从抽象到具体的过程逐步深入地了解一个复杂的系统。</p></blockquote></li></ul><hr><h4 id="数据流图概念、要素、特点、符号和应用；"><a href="#数据流图概念、要素、特点、符号和应用；" class="headerlink" title="数据流图概念、要素、特点、符号和应用；"></a>数据流图概念、要素、特点、符号和应用；</h4><ul><li>定义:<blockquote><p>数据流图是系统逻辑功能的图形表示, 图中没有任何具体的物理部件。<br>数据流图描绘数据在软件系统内从输入移动到输出过程中所经受的变换。通常用数据流图建立软件结构的功能模型。</p></blockquote></li><li>要素及符号:<br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E6%BA%90%E7%82%B9or%E7%BB%88%E7%82%B9.png"><br><img src="/img/soft_intro_c2/DFD_%E5%A4%84%E7%90%86.png"><br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.png"><br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="基本符号"><br><img src="/img/soft_intro_c2/DFD_%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7.png" alt="附加符号"></li></ul><p><strong>注意:</strong></p><blockquote><ul><li>“处理”可表示：单个程序、一系列程序、程序的一个模块、人工处理过程等等；</li><li>“数据存储”可表示：一个文件、文件的一部分、数据库记录等等；</li><li>数据流图 <strong>忽略</strong> 出错处理、打开文件、关闭文件。</li></ul></blockquote><ul><li>特点:<blockquote><p>抽象性，概括性，层次性</p></blockquote></li><li>应用:<blockquote><p>见课本</p></blockquote></li></ul><p><strong>怎样画数据流图?</strong></p><blockquote><ol><li>提取数据流图的4种成分<ol><li><strong>考虑数据的源点和终点</strong></li><li><strong>考虑处理</strong></li><li><strong>考虑数据流和数据存储</strong></li></ol></li><li>画出基本系统模型并将其细化, 描绘系统的主要功能<br>   一旦把数据流程图中的四种成份都分离出来之后，就可着手绘制系统的数据流程图了。数据流程图的绘制也是采用自顶向下的方法，由粗到细，逐层细化，最后形成一套完整的拟建系统的数据流程图。 </li></ol></blockquote><p><strong>命名:</strong></p><blockquote><ol><li><strong>为数据流(或数据存储)命名</strong><ol><li>名字应该代表整个数据流(或数据存储)的内容；</li><li> 不要使用空洞的、缺乏具体含义的名字（如“数据”、“输入”）；</li><li>如果为某个数据流（或数据存储）起名字时遇到困难，则很可能是因为对数据流图的分解不恰当造成的，应该试试重新分解数据流图； </li></ol></li><li><strong>为处理命名</strong><ol><li>通常先为数据流命名，然后再为与之相关联的处理命名；</li><li>名字应该反映整个处理的功能；</li><li>应该尽量避免空洞笼统的动词做名字，如“处理”、“加工”；</li><li>通常用一个动词命名，如果必须用两个动词才能描述整个处理的功能，则可能要把这个处理分解成两个处理更恰当；</li><li>如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的情况，应考虑重新分解。</li></ol></li><li><strong>数据源点/终点并不需要在开发目标系统的过程中设计和实现,它并不属于数据流图的核心内容,只不过是目标系统的外围环境部分(可能是人员、计算机外部设备或传感器装置)。通常,为数据源点/终点命名时采用它们在问题域中习惯使用的名字(如“采购员”、“仓库管理员”等)。</strong></li></ol></blockquote><blockquote><p>作用:</p><ul><li>利用它作为交流信息的工具；</li><li>作为软件分析和设计的工具。</li></ul></blockquote><hr><h4 id="数据字典定义、包含内容："><a href="#数据字典定义、包含内容：" class="headerlink" title="数据字典定义、包含内容："></a>数据字典定义、包含内容：</h4><blockquote><p>关于数据的信息的集合，也就是对数据流图中包含元素的定义的集合。<br>与数据流图共同构成系统的 <strong>逻辑模型</strong></p><p>数据字典由下列四类元素的定义组成：</p><ul><li>数据流；</li><li>数据流分量（即数据元素）</li><li>数据存储；</li><li>处理。</li></ul></blockquote><h5 id="定义数据的方法"><a href="#定义数据的方法" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h5><ol><li><strong>数据元素字典</strong> 定义基本内容:<ul><li>数据元素编号、名称及其含义；</li><li>数据类型和长度；</li><li>合理取值；</li><li>其他内容，如它和其它数据的逻辑关系等。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据元素字典定义实例"></li></ul></li><li><strong>数据流字典</strong> 定义基本内容：<ul><li>数据流编号及名称；</li><li>数据流来源；</li><li>数据流去处；</li><li>数据流的组成； </li><li>流通量；</li><li>峰值。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据流字典定义实例"></li></ul></li><li><strong>数据存储</strong> 字典定义基本内容:<ul><li>数据存储编号及名称；</li><li>数据存储的组成；</li><li>其它要求。</li></ul></li><li><strong>数据处理</strong> 字典定义基本内容:<ul><li>数据处理编号及名称；</li><li>简单描述；</li><li>输入/输出；</li><li>功能描述；</li><li>有关数据存储。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据处理字典定义实例"></li></ul></li><li>数据元素组成数据的表示方法：<ul><li>顺序：即以确定次序连接两个或多个分量。</li><li>选择：即从两个或多个可能的元素中选取一个。</li><li>重复：即把指定的分量重复零次或多次。</li><li>可选：即一个分量是可有可无的(重复零次或一次)。</li></ul></li></ol><h5 id="数据字典的用途"><a href="#数据字典的用途" class="headerlink" title="数据字典的用途:"></a>数据字典的用途:</h5><ol><li>作为分析阶段的重要工具；</li><li>数据元素的控制信息非常有用；</li><li>有助于开发数据库。</li></ol><hr><h4 id="定义数据的方法-1"><a href="#定义数据的方法-1" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h4><p><img src="/img/soft_intro_c2/%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="定义数据的方法"></p><hr><h4 id="成本估算技术"><a href="#成本估算技术" class="headerlink" title="成本估算技术"></a>成本估算技术</h4><h5 id="1-代码行技术"><a href="#1-代码行技术" class="headerlink" title="1. 代码行技术"></a>1. 代码行技术</h5><blockquote><p>软件成本 = 每行代码的平均成本×估计的源代码总行数</p></blockquote><h5 id="2-任务分解技术"><a href="#2-任务分解技术" class="headerlink" title="2. 任务分解技术"></a>2. 任务分解技术</h5><blockquote><p>软件开发项目分解为若干个相对独立的任务，分别估计每个单独任务的成本；<br>单独任务成本 = 任务所需人力估计值×每人每月平均工资；<br>软件开发项目总成本估计 = 各个单独任务成本估计值之和。<br><img src="/img/soft_intro_c2/%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3%E6%8A%80%E6%9C%AF.png" alt="任务分解技术"></p></blockquote><h5 id="3-自动估计成本技术"><a href="#3-自动估计成本技术" class="headerlink" title="3. 自动估计成本技术"></a>3. 自动估计成本技术</h5><blockquote><p>采用自动估计成本的软件工具估计</p></blockquote><h5 id="成本-效应分析的方法"><a href="#成本-效应分析的方法" class="headerlink" title="成本/效应分析的方法"></a>成本/效应分析的方法</h5><p><strong>1. 货币的时间价值</strong></p><blockquote><p>假设年利率为i,如果现在存入P元钱，则n年以后可以得到的钱数为：<br>$$F = P(1+i)^n$$</p><p>反之，如果 <strong>n</strong> 年后能收入 <strong>F</strong> 元钱，那么这些钱现在的价值是：<br>$$P = F/(1+i)^n$$</p></blockquote><p><img src="/img/soft_intro_c2/%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90%E4%BE%8B01.png"><br><img src="/img/soft_intro_c2/%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90%E4%BE%8B02.png"><br><strong>2. 投资回收期</strong></p><blockquote><ul><li>第一、第二年回收：4225元</li><li>第三年回收投资要：(5000 - 4225)/1779 = 0.44 年</li><li>总的投资回收期 = 2.44 年</li></ul></blockquote><p><strong>3. 纯收入:</strong> 9011.94 - 5000 = 4011.94 (元)<br><strong>4. 投资回收率</strong><br>$$P = \frac{F_1}{(1+j)} + \frac{F_2}{(1+j)^2} +···+\frac{F_n}{(1+n)^n}$$</p><p>其中:</p><blockquote><p>P是现在的投资额；<br>Fi是第i年年底的效益（i=1,2,3,…,n）;<br>n是系统的使用寿命（一般假设n=5）；<br>j是投资回收率。</p></blockquote><p>上述修改系统的工程的投资回收率是41%-42%</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-可行性研究&quot;&gt;&lt;a href=&quot;#第二章-可行性研究&quot; class=&quot;headerlink&quot; title=&quot;第二章 可行性研究&quot;&gt;&lt;/a&gt;第二章 可行性研究&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;可行性研究的内容&quot;&gt;&lt;a href=&quot;#可行性研究的内容&quot; cl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第一章 软件工程概述</title>
    <link href="http://example.com/2021/05/15/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2021/05/15/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/</id>
    <published>2021-05-14T16:53:14.000Z</published>
    <updated>2021-05-19T16:00:24.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h1><ul><li><h4 id="软件包含几部分、软件本身特点"><a href="#软件包含几部分、软件本身特点" class="headerlink" title="软件包含几部分、软件本身特点"></a>软件包含几部分、软件本身特点</h4></li></ul><blockquote><table><thead><tr><th align="center">软件</th><th></th></tr></thead><tbody><tr><td align="center">程序(指令集)</td><td>可执行代码，由字符、数字等组成</td></tr><tr><td align="center">数据</td><td>输入输出数据</td></tr><tr><td align="center">相关文档</td><td>规格说明文档、设计文档、用户手册和其他管理文档</td></tr></tbody></table><p>特点:  </p><ol><li>抽象：逻辑实体非物理实体（不直观）；</li><li>不存在磨损问题，可无限期使用；</li><li>可移植性；（零成本无限复制）；</li><li>复杂性，实现、维护等越来越复杂；</li><li>昂贵性，开发维护成本高；</li></ol></blockquote><ul><li><h4 id="软件危机概念，包含的两方面内容，提出的时间"><a href="#软件危机概念，包含的两方面内容，提出的时间" class="headerlink" title="软件危机概念，包含的两方面内容，提出的时间"></a>软件危机概念，包含的两方面内容，提出的时间</h4></li></ul><blockquote><p>软件危机的概念:计算机软件的开发和维护过程中遇到的一系列严重问题。<br>两方面内容:</p><ol><li>如何开发软件，满足对软件日益增长的需求</li><li>如何维护数量不断膨胀的已有软件。</li></ol><p>提出的时间:<br>1968年，NATO北大西洋公约组织的计算机科学家召开了计算机国际会议，提出“软件危机”的概念，并提出了“软件工程”学科</p></blockquote><ul><li><h4 id="为消除软件危机，需要采取哪两方面措施？"><a href="#为消除软件危机，需要采取哪两方面措施？" class="headerlink" title="为消除软件危机，需要采取哪两方面措施？"></a>为消除软件危机，需要采取哪两方面措施？</h4><blockquote><pre><code>  1. 对计算机软件有正确的认识，消除“软件就是程序”的错误认识。认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目，充分借鉴吸取已有经验。  2. 应该推广使用在实践中总结出来的开发软件的成功技术和方法，并继续研究探索。  3. 应该开发和使用更好的软件工具。  </code></pre><p>总之，为了解决软件危机，既要有<strong>技术</strong>措施(方法和工具)，又要有必要的组织<strong>管理</strong>措施<br><strong>管理:</strong> 通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程。<br><strong>技术(软件工程方法学):</strong> 通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学(methodology)，也称为范型(paradigm)。  </p></blockquote></li><li><h4 id="软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点"><a href="#软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点" class="headerlink" title="软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点"></a>软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点</h4><blockquote><ol><li><p>概念: 是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p></li><li><p>软件工程方法学:</p><ul><li><p>概念: 通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学(methodology)，也称为范型(paradigm)。</p></li><li><p>3要素:</p><ul><li>方法：是完成软件开发的各项任务的技术方法，回答“怎样做”的问题；</li><li>工具：是为运用方法而提供的自动的或半自动的软件工程支撑环境；如，CASE(Computer-Aided Software Engineering )工具</li><li>过程：需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</li></ul></li><li><p>传统方法学(生命周期方法学或结构化范型)——强调自顶向下:</p><ul><li>采用结构化技术来完成软件开发的各项任务；</li><li>划分为若干个阶段，然后顺序地完成每个阶段的任务；</li><li><strong>每个阶段的任务相对独立，而且比较简单，降低了整个软件开发工程的困难程度；</strong> 前一个阶段是后一个阶段的前提和基础，而后一阶段提出的解法更具体，细节更多；</li><li><strong>每个阶段结束前必须从技术和管理两方面对这个阶段的开发成果进行严格的检查，通过之后这个阶段才算结束；保证了质量，提高可维护性；</strong></li><li>当软件规模庞大，或者的需求模糊或随时间而变化时，传统方法学往往不成功；维护起来仍然很困难。</li></ul></li><li><p>面向对象方法学——强调主动地多次反复迭代</p><ul><li>面向对象方法: 把数据和行为看成同等重要，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。</li><li>面向对象方法学4个要点：<ul><li>对象(object)：融合了数据及在数据上的操作行为。</li><li>类(class)：类是对具有相同数据和相同操作的一组相似对象的定义。</li><li>继承：按照父类与子类的关系，把若干个相关类组成一个层次结构的系统。</li><li>消息：对象彼此间仅能通过发送消息互相联系。</li></ul></li><li>优点:<ol><li>面向对象方法学的尽量模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程。</li><li>面向对象方法学开发软件的过程，是一个主动地多次反复迭代的演化过程，保证了在各项开发活动之间的平滑过渡。</li><li>促进了软件重用。最终的软件产品由许多较小的、基本上独立的对象组成，每个对象相当于一个微型程序，而且大多数对象都与现实世界中的实体相对应，降低了复杂性，提高了可理解性，简化了开发和维护工作。</li></ol></li></ul></li></ul></li></ol></blockquote></li><li><h4 id="软件生命周期（三个时期八个阶段）"><a href="#软件生命周期（三个时期八个阶段）" class="headerlink" title="软件生命周期（三个时期八个阶段）"></a>软件生命周期（三个时期八个阶段）</h4></li></ul><blockquote><p><img src="/img/soft_intro_c1/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="软件生命周期"></p><ol><li><p>问题定义:</p><blockquote><p><strong>任务: 问题是什么?</strong></p><ul><li>通过对客户的访问调查，系统分析员扼要地写出关于问题性质、工程目标和工程规模的书面报告。</li><li>经过讨论和必要的修改之后这份报告应该得到客户的确认。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 关于系统规模和目标的</p></blockquote></li><li><p>可行性研究:</p><blockquote><p><strong>任务: 有可行的解吗?</strong></p><ul><li>系统分析员需要进行一次大大压缩和简化了的系统分析和设计过程。</li><li>研究问题的范围，探索这个问题是否值得去解，是否有可行的解决办法。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>系统的高层逻辑模型（数据流图、成本效益分析）</li><li>可行性论证报告（立即进行/推迟进行/不能或不值得进行）</li></ul></blockquote></li><li><p>需求分析:</p><blockquote><p><strong>任务: 必须做什么</strong></p><ul><li>主要是确定目标系统必须具备哪些功能。</li><li>系统分析员必须和用户密切配合，充分交流信息，以得出经过用户确认的系统逻辑模型。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>系统的逻辑模型（数据流图、数据字典、简要的算法描述）</li><li>用规格说明书（Specification）准确地记录对目标系统的需求</li></ul></blockquote></li><li><p>总体设计:</p><blockquote><p><strong>任务: 如何提出已提出的问题</strong></p><ul><li>设计出实现目标系统的几种可能的方案（低、中、高成本）。</li><li>用适当的表达工具描述每种方案，分析优缺点，推荐一个最佳方案，制定出实现最佳方案的详细计划。设计程序的体系结构。</li></ul></blockquote><blockquote><p>**结果: **</p><ul><li>可能的解法(系统流程图、成本效益分析)</li><li>推荐的系统体系结构(层次图或结构图)</li></ul></blockquote></li><li><p>详细设计:</p><blockquote><p><strong>任务: 怎样具体实现该系统</strong></p><ul><li>详细地设计每个模块, 确定实现模块功能所需要的算法和数据结构</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>每个模块的算法和数据结构(程序流程图、PAD图、N-S图等)</li></ul></blockquote></li><li><p>编码和单元测试:</p><blockquote><p><strong>任务: 得到正确的程序模块</strong></p><ul><li>选取一种适当的高级程序设计语言(必要时用汇编语言)，把详细设计的结果翻译成用选定的语言书写的程序；</li><li>并且仔细测试编写出的每一个模块。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 代码和测试报告</p></blockquote></li><li><p>综合测试:</p><blockquote><p><strong>任务: 得到符合要求的软件</strong></p><ul><li>通过集成测试、验收测试、现场测试、平行运行等方法对目标系统进一步测试检验。</li><li>通过对软件测试结果的分析可以预测软件的可靠性；反之，根据对软件可靠性的要求，也可以决定测试和调试过程什么时候可以结束。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>测试计划、详细测试方案以及实际测试结果</li><li>完整一致的软件配置 </li></ul></blockquote></li><li><p>软件维护:<br><img src="/img/soft_intro_c1/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4.png" alt="软件维护"></p><blockquote><p><strong>任务: 使系统持久地满足用户的需要</strong></p><ul><li>改正性维护,诊断和改正在使用过程中发现的软件错误；</li><li>适应性维护，修改软件以适应环境的变化；</li><li>完善性维护，根据用户的要求改进或扩充软件；</li><li>预防性维护，修改软件为将来的维护活动做准备。</li><li>每一项维护活动经历了一次压缩和简化了的软件定义和开发的全过程。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 完整准确的维护记录</p></blockquote></li></ol></blockquote><ul><li><h4 id="软件过程（几个模型）"><a href="#软件过程（几个模型）" class="headerlink" title="软件过程（几个模型）"></a>软件过程（几个模型）</h4></li></ul><blockquote><p><strong>1. 瀑布模型</strong> (文档驱动型)<br><img src="/img/soft_intro_c1/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="瀑布模型"></p><ul><li>瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落</li><li>特点:<blockquote><p><strong>1. 阶段间具有顺序性和依赖性</strong></p><ul><li>前一阶段的工作完成之后，才能开始后一阶段的工作；</li><li>前一阶段的输出文档就是后一阶段的输入文档。</li></ul><p><strong>2. 推迟实现的观点</strong></p><ul><li>对于规模较大的软件项目来说，往往编码开始得越早最终完成开发工作所需要的时间反而越长。</li></ul><p><strong>3. 质量保证的观点</strong></p><ul><li>每个阶段都必须完成规定的文档，是“文档驱动”的模型；</li><li>每个阶段结束前都要对所完成的文档进行评审，尽早发现问题，改正错误。</li></ul></blockquote></li><li><strong>优点:</strong><blockquote><ul><li>可强迫开发人员采用规范的方法；</li><li>严格地规定了每个阶段必须提交的文档；</li><li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li><strong>只能通过文档了解产品，不经过实践的需求是不切实际的。</strong></li></ul></blockquote></li><li><strong>适用于:</strong><blockquote><ul><li>需求是预知的；</li><li>软件实现方法是成熟的；</li><li>项目周期较短。</li></ul></blockquote></li></ul><p><strong>2. 快速原型模型</strong><br><img src="/img/soft_intro_c1/%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B.png" alt="快速原型模型"></p><ul><li>特点:<blockquote><ul><li>快速原型模型不带反馈环，软件产品的开发基本上是线性顺序进行的。</li><li>快速原型的本质是“快速”。应该尽可能快地建造出原型系统，以加速软件开发过程，节约成本。</li></ul></blockquote></li><li><strong>根据原型的不同作用,有三类原型模型</strong><blockquote><ul><li>探索型原型——用于开发的需求分析阶段</li><li>实验型原型——主要用于设计阶段</li><li>演化型原型——用于及早向用户提交一个原型系统</li></ul></blockquote></li><li><strong>快速原型模型的运用方式:</strong><blockquote><ul><li>抛弃策略——探索型和实验型采用此策略</li><li>附加策略——演化型快速原型采用此策略 </li></ul></blockquote></li></ul><p><strong>3. 增量模型</strong><br><img src="/img/soft_intro_c1/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B.png" alt="增量模型"></p><ul><li><strong>优点:</strong><blockquote><ul><li>人员分配灵活，刚开始不用投入大量人力资源。 </li><li>当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径。 </li><li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。</li></ul></blockquote></li><li><strong>难点:</strong><blockquote><ul><li>软件体系结构必须是开放的。</li><li>模型本身是自相矛盾的。整体——独立构件。</li><li>不同的构件并行地构建有可能加快工程进度，但是冒无法集成到一起的风险。</li></ul></blockquote></li><li><strong>适用于:</strong><blockquote><ul><li>适用于需求经常改变的软件开发过程。</li><li>如果在项目既定的商业要求期限之前不可能找到足够的开发人员，在这种情况下，增量模型显得特别有用。</li></ul></blockquote></li></ul><p><strong>4. 螺旋模型</strong> (风险驱动型)<br><img src="/img/soft_intro_c1/%E7%AE%80%E5%8C%96%E7%9A%84%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png" alt="简化的螺旋模型"></p><ul><li><strong>优点:</strong><blockquote><ul><li>主要优势在于它是风险驱动的。</li><li>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标；</li><li>减少了过多测试或测试不足所带来的风险；</li><li>维护只是模型的另一个周期，维护和开发之间没有本质区别。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li>采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失。 </li><li>过多的迭代次数会增加开发成本，延迟提交时间。 </li></ul></blockquote></li></ul><p><img src="/img/soft_intro_c1/%E5%AE%8C%E6%95%B4%E7%9A%84%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png" alt="完整的螺旋模型"></p><ul><li><strong>适用于:</strong><blockquote><ul><li>特别适用于庞大、复杂并具有高风险的系统。</li><li>适用于内部开发的大规模软件项目。</li></ul></blockquote></li></ul><p><strong>5. 喷泉模型</strong><br><img src="/img/soft_intro_c1/%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B.png" alt="喷泉模型"></p><ul><li><strong>优点:</strong><blockquote><ul><li>该模型的各个阶段没有明显的界限，开发人员可以同步进行开发。</li><li>多次反复地增加或明确目标系统，而不是本质性的改动，降低错误的可能性。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li>由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，不利于项目的管理。</li><li>要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。</li></ul></blockquote></li><li><strong>适用于:</strong> 面向对象的软件开发过程。</li></ul></blockquote><h3 id="如有错误-请在博客页下方评论"><a href="#如有错误-请在博客页下方评论" class="headerlink" title="如有错误, 请在博客页下方评论"></a>如有错误, 请在<a href="https://ckxgzxa.github.io/2021/05/15/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/">博客页</a>下方评论</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-软件工程概述&quot;&gt;&lt;a href=&quot;#第一章-软件工程概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 软件工程概述&quot;&gt;&lt;/a&gt;第一章 软件工程概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;软件包含几部分、软件本身特点&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统概论第四章第7题</title>
    <link href="http://example.com/2021/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%AC7%E9%A2%98/"/>
    <id>http://example.com/2021/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%AC7%E9%A2%98/</id>
    <published>2021-05-13T13:42:24.000Z</published>
    <updated>2021-05-14T18:36:18.428Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>今有以下两个关系模式:<br>&ensp;&ensp;&ensp;&ensp;职工(职工号，姓名，年龄，职务，工资，部门号)<br>&ensp;&ensp;&ensp;&ensp;部门(部门号，名称，经理名，地址，电话号)<br>请用SQL的GRANT和REVOKE语句（加上视图机制）完成以下授权定义或存储控制功能:<br>(1)用户王明对两个表有SELECT权限。<br>(2)用户李勇对两个表有NSERT和DELETE权限。<br>(3)每个职工只对自己的记录有SELECT权限。<br>(4)用户刘星对职工表有SELECT权限，对工资字段具有更新权限。<br>(5)用户张新具有修改这两个表的结构的权限。<br>(6)用户周平具有对两个表的所有权限(读、插、改、删数据)，并具有给其他用户授权的权限。<br>(7)用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限，她不能查看每个人的工资。</p></blockquote><hr><h3 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h3><h5 id="建表"><a href="#建表" class="headerlink" title="建表:"></a>建表:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 部门 (<br>    部门号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    名称 <span class="hljs-type">CHAR</span>(<span class="hljs-number">16</span>),<br>    经理名 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    地址 <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>    电话号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 职工 (<br>    职工号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    姓名 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    年龄 <span class="hljs-type">SMALLINT</span>,<br>    职务 <span class="hljs-type">CHAR</span>(<span class="hljs-number">12</span>),<br>    工资 <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>),<br>    部门号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">FOREIGN</span> KEY ( 部门号 ) <span class="hljs-keyword">REFERENCES</span> 部门(部门号)<br>);<br></code></pre></td></tr></table></figure><h5 id="创建习题中涉及用户"><a href="#创建习题中涉及用户" class="headerlink" title="创建习题中涉及用户:"></a>创建习题中涉及用户:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 王明 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 李勇 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 刘星 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 张新 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 周平 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 杨兰 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="插入一些测试数据"><a href="#插入一些测试数据" class="headerlink" title="插入一些测试数据:"></a>插入一些测试数据:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM001&#x27;</span>,<span class="hljs-string">&#x27;部门一&#x27;</span>,<span class="hljs-string">&#x27;经理一&#x27;</span>,<span class="hljs-string">&#x27;地址一&#x27;</span>,<span class="hljs-string">&#x27;12345678901&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM002&#x27;</span>,<span class="hljs-string">&#x27;部门二&#x27;</span>,<span class="hljs-string">&#x27;经理二&#x27;</span>,<span class="hljs-string">&#x27;地址二&#x27;</span>,<span class="hljs-string">&#x27;12345678902&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM003&#x27;</span>,<span class="hljs-string">&#x27;部门三&#x27;</span>,<span class="hljs-string">&#x27;经理三&#x27;</span>,<span class="hljs-string">&#x27;地址三&#x27;</span>,<span class="hljs-string">&#x27;12345678903&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG001&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-number">31</span>,<span class="hljs-string">&#x27;职位一&#x27;</span>,<span class="hljs-number">11000</span>,<span class="hljs-string">&#x27;BM001&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG002&#x27;</span>,<span class="hljs-string">&#x27;李勇&#x27;</span>,<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;职位二&#x27;</span>,<span class="hljs-number">12000</span>,<span class="hljs-string">&#x27;BM002&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG003&#x27;</span>,<span class="hljs-string">&#x27;刘星&#x27;</span>,<span class="hljs-number">33</span>,<span class="hljs-string">&#x27;职位三&#x27;</span>,<span class="hljs-number">13000</span>,<span class="hljs-string">&#x27;BM003&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG004&#x27;</span>,<span class="hljs-string">&#x27;张新&#x27;</span>,<span class="hljs-number">34</span>,<span class="hljs-string">&#x27;职位四&#x27;</span>,<span class="hljs-number">14000</span>,<span class="hljs-string">&#x27;BM002&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG005&#x27;</span>,<span class="hljs-string">&#x27;周平&#x27;</span>,<span class="hljs-number">35</span>,<span class="hljs-string">&#x27;职位五&#x27;</span>,<span class="hljs-number">15000</span>,<span class="hljs-string">&#x27;BM003&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG006&#x27;</span>,<span class="hljs-string">&#x27;杨兰&#x27;</span>,<span class="hljs-number">36</span>,<span class="hljs-string">&#x27;职位六&#x27;</span>,<span class="hljs-number">16000</span>,<span class="hljs-string">&#x27;BM001&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="1-用户王明对两个表有SELECT权限"><a href="#1-用户王明对两个表有SELECT权限" class="headerlink" title="1. 用户王明对两个表有SELECT权限"></a>1. 用户王明对两个表有SELECT权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 王明;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 王明;<br></code></pre></td></tr></table></figure><h5 id="2-用户李勇对两个表有INSERT和DELETE权限"><a href="#2-用户李勇对两个表有INSERT和DELETE权限" class="headerlink" title="2. 用户李勇对两个表有INSERT和DELETE权限"></a>2. 用户李勇对两个表有INSERT和DELETE权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 李勇;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 李勇;<br></code></pre></td></tr></table></figure><h5 id="3-每个职工只对自己的记录有SELECT权利"><a href="#3-每个职工只对自己的记录有SELECT权利" class="headerlink" title="3. 每个职工只对自己的记录有SELECT权利"></a>3. 每个职工只对自己的记录有SELECT权利</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 职工视图 <br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> 职工 <br><span class="hljs-keyword">WHERE</span> concat(姓名,<span class="hljs-string">&#x27;@localhost&#x27;</span>) <span class="hljs-operator">=</span> <span class="hljs-keyword">USER</span>();<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> 职工视图<br><span class="hljs-keyword">TO</span> 王明,李勇,刘星, 张新,周平,杨兰;<br></code></pre></td></tr></table></figure><h5 id="4-用户刘星对职工表有SELECT权限-对工资字段有更新权限"><a href="#4-用户刘星对职工表有SELECT权限-对工资字段有更新权限" class="headerlink" title="4. 用户刘星对职工表有SELECT权限, 对工资字段有更新权限"></a>4. 用户刘星对职工表有SELECT权限, 对工资字段有更新权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, UPDATE(工资)<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 刘星;<br></code></pre></td></tr></table></figure><h5 id="5-用户张新具有修改两个表结构权限"><a href="#5-用户张新具有修改两个表结构权限" class="headerlink" title="5. 用户张新具有修改两个表结构权限"></a>5. 用户张新具有修改两个表结构权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALTER</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 张新;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALTER</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 张新;<br></code></pre></td></tr></table></figure><h5 id="6-用户周平具有对两个表的所有权限-读、插、改、删数据-并具有给其他用户授权的权限"><a href="#6-用户周平具有对两个表的所有权限-读、插、改、删数据-并具有给其他用户授权的权限" class="headerlink" title="6. 用户周平具有对两个表的所有权限(读、插、改、删数据),并具有给其他用户授权的权限"></a>6. 用户周平具有对两个表的所有权限(读、插、改、删数据),并具有给其他用户授权的权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 周平<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 周平<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><h5 id="7-用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资"><a href="#7-用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资" class="headerlink" title="7. 用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资"></a>7. 用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 部门工资(名称,最高工资,最低工资,平均工资)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> `部门`.`名称`, <span class="hljs-built_in">MAX</span>(`工资`), <span class="hljs-built_in">MIN</span>(`工资`), <span class="hljs-built_in">AVG</span>(`工资`)<br><span class="hljs-keyword">FROM</span> `职工`, `部门`<br><span class="hljs-keyword">WHERE</span> `职工`.`部门号` <span class="hljs-operator">=</span> `部门`.`部门号`<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> `职工`.`部门号`;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> 部门工资<br><span class="hljs-keyword">TO</span> 杨兰;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;今有以下两个关系模式:&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;职工(职工号，姓名，年龄，职务，工资，部门号)&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;部门(部门号，名称，经理名，地址，电话号)&lt;br&gt;请用SQ</summary>
      
    
    
    
    
    <category term="数据库系统概论" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>软件工程导论复习</title>
    <link href="http://example.com/2021/05/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    <id>http://example.com/2021/05/08/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/</id>
    <published>2021-05-08T07:53:45.769Z</published>
    <updated>2021-05-14T17:06:43.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><h2 id="1-软件工程概论"><a href="#1-软件工程概论" class="headerlink" title="1. 软件工程概论"></a>1. 软件工程概论</h2><h3 id="1-1-软件危机-Soft-Crisis"><a href="#1-1-软件危机-Soft-Crisis" class="headerlink" title="1.1. 软件危机(Soft Crisis)"></a>1.1. 软件危机(Soft Crisis)</h3><ul><li><p>计算机软件的开发和维护过程中遇到的一系列严重问题</p></li><li><p>两方面问题</p><ul><li>如何开发软件,满足对软件日益增长的需求</li><li>如何维护数量不断膨胀的已有软件</li></ul></li><li><p>具体表现</p><ul><li><ol><li>对软件开发成本和进度的估计常常很不准确</li></ol></li><li><ol start="2"><li>用户不满意的现象经常发生</li></ol></li><li><ol start="3"><li>软件产品的质量往往靠不住</li></ol></li><li><ol start="4"><li>软件常常是不可维护的</li></ol></li><li><ol start="5"><li>软件没有适当的文档资料</li></ol></li><li><ol start="6"><li>软件成本在计算机系统总成本占比逐年上升</li></ol></li><li><ol start="7"><li>软件开发生产率提高的速度远不及计算机应用迅速普及深入的趋势</li></ol></li></ul></li><li><p>产生原因</p><ul><li><ol><li>与软件本身特点有关</li></ol><ul><li><p>逻辑部件</p><ul><li>质量难以评价, 管理、开发和维护困难</li></ul></li><li><p>规模庞大</p><ul><li>开发繁琐，多人分工协作，设计技术和管理等问题</li></ul></li></ul></li><li><ol start="2"><li>与软件开发与维护不正确有关</li></ol><ul><li>早期软件开发具有个体化特点</li><li>忽视软件需求分析的重要性</li><li>认为软件开发就是写程序并设法使之运行</li><li>轻视软件维护</li></ul></li></ul></li><li><p>消除途径</p><ul><li>对计算机软件有正确的认识, 消除”软件就是程序”的错误认识. 认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目,充分借鉴吸取已有经验</li><li>推广使用在实践中总结出的开发软件的成功技术和方法,并继续研究探索</li><li>开发和使用更好地软件工具</li></ul></li></ul><h3 id="2-1-软件工程"><a href="#2-1-软件工程" class="headerlink" title="2.1 软件工程"></a>2.1 软件工程</h3><ul><li><p>简介</p><ul><li><p>定义</p><ul><li>指导计算机软件开发和维护的一门工程学科, 该学科的目的是生产出能按期交付的、在预算范围内的、满足用户需求的、质量合格的软件产品</li></ul></li><li><p>本质特性</p><ul><li>关注于大型程序的构造</li><li>中心课题是控制复杂性</li><li>软件经常变化</li><li>开发软件效率非常重要</li><li>和谐地合作是开发软件的关键（标准和规程）</li><li>软件必须有效地支持它的用户（满足各方面需求）</li><li>在软件工程领域中通常由具有一种文化的人替具有另一种文化的人开发产品</li></ul></li></ul></li><li><p>基本原理</p><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该小而精</li></ul></li><li><p>方法学</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件工程导论&quot;&gt;&lt;a href=&quot;#软件工程导论&quot; class=&quot;headerlink&quot; title=&quot;软件工程导论&quot;&gt;&lt;/a&gt;软件工程导论&lt;/h1&gt;&lt;h2 id=&quot;1-软件工程概论&quot;&gt;&lt;a href=&quot;#1-软件工程概论&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="软件工程导论" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
</feed>
