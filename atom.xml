<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术匝记簿</title>
  
  
  <link href="https://www.ckxgzxa.top/atom.xml" rel="self"/>
  
  <link href="https://www.ckxgzxa.top/"/>
  <updated>2022-02-18T16:27:44.564Z</updated>
  <id>https://www.ckxgzxa.top/</id>
  
  <author>
    <name>残魁斜罡</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MCPE 我的世界基岩版level.dat相关配置</title>
    <link href="https://www.ckxgzxa.top/mcpe_level_intro.html"/>
    <id>https://www.ckxgzxa.top/mcpe_level_intro.html</id>
    <published>2022-02-18T13:27:10.000Z</published>
    <updated>2022-02-18T16:27:44.564Z</updated>
    
    <content type="html"><![CDATA[<table>    <tr>        <th bgcolor="yellow" align = "center">配置名</th>        <th bgcolor="yellow" align = "center">中文翻译</th>        <th bgcolor="yellow" align = "center">十六进制表示</th>        <th bgcolor="yellow" align = "center">备注</th>    </tr>    <tr>        <td align = "center">showcoordinates</td>        <td>坐标显示</td>        <td>73 68 6F 77 63 6F 6F 72 64 69 6E 61 74 65 73 [00 | 01]</td>        <td>中括号内如果为00, 则坐标显示为关闭, 为01, 坐标显示开</td>    </tr>    <tr>        <td align = "center">Difficulty</td>        <td>难度</td>        <td>44 69 66 66 69 63 75 6C 74 79 [00 | 01 | 02 | 03]</td>        <td>中括号内数字分别对应:和平|简单|普通|困难</td>    </tr>    <tr>        <td align = "center">RandomSeed</td>        <td>世界的种子号码</td>        <td>52 61 6E 64 6F 6D 53 65 65 64 [FF FF FF FF]</td>        <td>括号中4个字节为种子,规则为:若种子十进制为123456789, 化为十六进制07 5B CD 15,则在文件中为15 CD 5B 07</td>    </tr>    <tr>        <td align = "center">hasBeenLoadedInCreative</td>        <td>曾在创造模式加载</td>        <td>68 61 73 42 65 65 6E 4C 6F 61 64 65 64 49 6E 43 72 65 61 74 69 76 65 [00 | 01]</td>        <td>将此处设置为01将导致游戏无法获得成就,当在游戏中切换到创造模式,此处被置1,同时commandsEnabled也会置1,成就无法获得,需退出游戏将上述两项置0才可恢复成就</td>    </tr>    <tr>        <td align = "center">GameType</td>        <td>游戏模式</td>        <td>47 61 6D 65 54 79 70 65 [00 | 01 | 02]</td>        <td>00 为生存模式, 01 为创造模式, 02 为冒险模式</td>    </tr>    <tr>        <td align = "center">commandsEnabled</td>        <td>启用命令</td>        <td>63 6F 6D 6D 61 6E 64 73 45 6E 61 62 6C 65 64 [00 | 01]</td>        <td>当开启作弊时,此配置和hasBeenLoadedInCreative将会被置1,成就无法获得,将上述两项重新置为0可以重新开启成就</td>    </tr>    <tr>        <td align = "center">keepinventory</td>        <td>保留物品栏</td>        <td>6B 65 65 70 69 6E 76 65 6E 74 6F 72 79 [00 | 01]</td>        <td>开启死亡不掉落将此项置为1即可</td>    </tr>        <tr>        <td align = "center">randomtickspeed</td>        <td>随机刻速度</td>        <td>72 61 6E 64 6F 6D 74 69 63 6B 73 70 65 65 64 [XX | XX]</td>        <td>默认值为1</td>    </tr>    <tr>        <td align = "center">playerPermissionsLevel</td>        <td>其他玩家的权限等级</td>        <td>70 6C 61 79 65 72 50 65 72 6D 69 73 73 69 6F 6E 73 4C 65 76 65 6C [00 | 01 | 02]</td>        <td>00:访客, 01: 成员, 02: 操作员</td>    </tr>    <tr>        <td align = "center">startWithMapEnabled</td>        <td>初始地图</td>        <td>73 74 61 72 74 57 69 74 68 4D 61 70 45 6E 61 62 6C 65 64 [00 | 01]</td>        <td>玩家是否携带地图首次生成</td>    </tr>    <tr>        <td>bonusChestEnabled</td>        <td>奖励箱</td>        <td>62 6F 6E 75 73 43 68 65 73 74 45 6E 61 62 6C 65 64 [00 | 01]</td>        <td>是否允许生成奖励箱</td>    </tr>    <tr>        <td>serverChunkTickRange</td>        <td>渲染距离</td>        <td>73 65 72 76 65 72 43 68 75 6E 6B 54 69 63 6B 52 61 6E 67 65 [XX]</td>        <td>模拟距离</td>    </tr>    <tr>        <td>attackplayers</td>        <td>误伤</td>        <td>61 74 74 61 63 6B 70 6C 61 79 65 72 73 [00 | 01]</td>    </tr>    <tr>        <td>tntexplodes</td>        <td>TNT爆炸</td>        <td>74 6E 74 65 78 70 6C 6F 64 65 73 [00 | 01]</td>    </tr>    <tr>        <td>espawnblocksexplode</td>        <td>重生方块爆炸</td>        <td>72 65 73 70 61 77 6E 62 6C 6F 63 6B 73 65 78 70 6C 6F 64 65 [00 | 01]</td>    </tr>    <tr>        <td>tntexplodes</td>        <td>TNT爆炸</td>        <td>74 6E 74 65 78 70 6C 6F 64 65 73 [00 | 01]</td>    </tr>    <tr>        <td>tntexplodes</td>        <td>TNT爆炸</td>        <td>74 6E 74 65 78 70 6C 6F 64 65 73 [00 | 01]</td>    </tr>    <tr>        <td>tntexplodes</td>        <td>TNT爆炸</td>        <td>74 6E 74 65 78 70 6C 6F 64 65 73 [00 | 01]</td>    </tr></table>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
    &lt;tr&gt;
        &lt;th bgcolor=&quot;yellow&quot; align = &quot;center&quot;&gt;配置名&lt;/th&gt;
        &lt;th bgcolor=&quot;yellow&quot; align = &quot;center&quot;&gt;中文翻译&lt;/th&gt;
        &lt;th </summary>
      
    
    
    
    
    <category term="游戏" scheme="https://www.ckxgzxa.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件工程导论复习</title>
    <link href="https://www.ckxgzxa.top/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.html"/>
    <id>https://www.ckxgzxa.top/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA.html</id>
    <published>2022-01-27T18:32:19.260Z</published>
    <updated>2021-05-14T17:06:43.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><h2 id="1-软件工程概论"><a href="#1-软件工程概论" class="headerlink" title="1. 软件工程概论"></a>1. 软件工程概论</h2><h3 id="1-1-软件危机-Soft-Crisis"><a href="#1-1-软件危机-Soft-Crisis" class="headerlink" title="1.1. 软件危机(Soft Crisis)"></a>1.1. 软件危机(Soft Crisis)</h3><ul><li><p>计算机软件的开发和维护过程中遇到的一系列严重问题</p></li><li><p>两方面问题</p><ul><li>如何开发软件,满足对软件日益增长的需求</li><li>如何维护数量不断膨胀的已有软件</li></ul></li><li><p>具体表现</p><ul><li><ol><li>对软件开发成本和进度的估计常常很不准确</li></ol></li><li><ol start="2"><li>用户不满意的现象经常发生</li></ol></li><li><ol start="3"><li>软件产品的质量往往靠不住</li></ol></li><li><ol start="4"><li>软件常常是不可维护的</li></ol></li><li><ol start="5"><li>软件没有适当的文档资料</li></ol></li><li><ol start="6"><li>软件成本在计算机系统总成本占比逐年上升</li></ol></li><li><ol start="7"><li>软件开发生产率提高的速度远不及计算机应用迅速普及深入的趋势</li></ol></li></ul></li><li><p>产生原因</p><ul><li><ol><li>与软件本身特点有关</li></ol><ul><li><p>逻辑部件</p><ul><li>质量难以评价, 管理、开发和维护困难</li></ul></li><li><p>规模庞大</p><ul><li>开发繁琐，多人分工协作，设计技术和管理等问题</li></ul></li></ul></li><li><ol start="2"><li>与软件开发与维护不正确有关</li></ol><ul><li>早期软件开发具有个体化特点</li><li>忽视软件需求分析的重要性</li><li>认为软件开发就是写程序并设法使之运行</li><li>轻视软件维护</li></ul></li></ul></li><li><p>消除途径</p><ul><li>对计算机软件有正确的认识, 消除”软件就是程序”的错误认识. 认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目,充分借鉴吸取已有经验</li><li>推广使用在实践中总结出的开发软件的成功技术和方法,并继续研究探索</li><li>开发和使用更好地软件工具</li></ul></li></ul><h3 id="2-1-软件工程"><a href="#2-1-软件工程" class="headerlink" title="2.1 软件工程"></a>2.1 软件工程</h3><ul><li><p>简介</p><ul><li><p>定义</p><ul><li>指导计算机软件开发和维护的一门工程学科, 该学科的目的是生产出能按期交付的、在预算范围内的、满足用户需求的、质量合格的软件产品</li></ul></li><li><p>本质特性</p><ul><li>关注于大型程序的构造</li><li>中心课题是控制复杂性</li><li>软件经常变化</li><li>开发软件效率非常重要</li><li>和谐地合作是开发软件的关键（标准和规程）</li><li>软件必须有效地支持它的用户（满足各方面需求）</li><li>在软件工程领域中通常由具有一种文化的人替具有另一种文化的人开发产品</li></ul></li></ul></li><li><p>基本原理</p><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该小而精</li></ul></li><li><p>方法学</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件工程导论&quot;&gt;&lt;a href=&quot;#软件工程导论&quot; class=&quot;headerlink&quot; title=&quot;软件工程导论&quot;&gt;&lt;/a&gt;软件工程导论&lt;/h1&gt;&lt;h2 id=&quot;1-软件工程概论&quot;&gt;&lt;a href=&quot;#1-软件工程概论&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="软件工程导论" scheme="https://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Authentication required. System policy prevents WiFi scans</title>
    <link href="https://www.ckxgzxa.top/LinuxProblem001.html"/>
    <id>https://www.ckxgzxa.top/LinuxProblem001.html</id>
    <published>2022-01-11T16:24:38.000Z</published>
    <updated>2022-01-11T16:50:25.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Authentication-required-System-policy-prevents-WiFi-scans"><a href="#Authentication-required-System-policy-prevents-WiFi-scans" class="headerlink" title="Authentication required. System policy prevents WiFi scans"></a>Authentication required. System policy prevents WiFi scans</h1><p>那天装了Ubuntu树莓派的系统，由于没有显示器，于是给树莓派连的网线和VNC，发现打开 WIFI 的时候总是弹出 “Authentication required. System policy prevents WiFi scans” 这样的标识让你输入密码，输完之后还是不能用 WIFI，点击又会不断弹出这样的标识，好像输完密码会自动退出 WIFI 扫描列表的界面吧，写此文的时候没用Ubuntu了，不记得了。于是 Google 找到了类似的问题，记录如下：</p><p>在 <code>/etc/polkit-1/localauthority/50-local-d</code> 目录下新建一个扩展名为 <code>pkla</code> 的文件，在其中写入如下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Allow Wifi Scan]</span><br><span class="hljs-attr">Identity</span>=unix-user:*<br><span class="hljs-attr">Action</span>=org.freedesktop.NetworkManager.wifi.scan<span class="hljs-comment">;org.freedesktop.NetworkManager.enable-disable-wifi;org.freedesktop.NetworkManager.settings.modify.own;org.freedesktop.NetworkManager.settings.modify.system;org.freedesktop.NetworkManager.network-control</span><br><span class="hljs-attr">ResultAny</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">ResultInactive</span>=<span class="hljs-literal">yes</span><br><span class="hljs-attr">ResultActive</span>=<span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><p>不过好像只要加入<code>Action=org.freedesktop.NetworkManager.wifi.scan;</code>就行，其他的不加也无所谓。</p><p>原贴链接:<a href="https://askubuntu.com/questions/1291512/authentication-required-system-policy-prevents-wifi-scans-in-focalfossa">https://askubuntu.com/questions/1291512/authentication-required-system-policy-prevents-wifi-scans-in-focalfossa</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Authentication-required-System-policy-prevents-WiFi-scans&quot;&gt;&lt;a href=&quot;#Authentication-required-System-policy-prevents-WiFi-scans&quot; clas</summary>
      
    
    
    
    <category term="Linux" scheme="https://www.ckxgzxa.top/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>Java套接字</title>
    <link href="https://www.ckxgzxa.top/ComputerNetworkingSocket.html"/>
    <id>https://www.ckxgzxa.top/ComputerNetworkingSocket.html</id>
    <published>2021-12-11T06:11:26.000Z</published>
    <updated>2021-12-11T09:26:21.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><h2 id="1-套接字"><a href="#1-套接字" class="headerlink" title="1. 套接字"></a>1. 套接字</h2><p>当两个程序需要通信时,它们可以通过使用Socket类建立套接字对象并连接在一起(端口号与IP地址的组合得出一个网络套接字),本节将讲解怎样将客户端和服务器端的套接字对象连接在一起来交互信息。</p><h2 id="2-客户端套接字"><a href="#2-客户端套接字" class="headerlink" title="2. 客户端套接字"></a>2. 客户端套接字</h2><p>客户端的程序使用 Socket类建立负责连接到服务器的套接字对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>Socket clientSocket = newSocket(<span class="hljs-string">&quot;http://192.168.0.78&quot;</span>,<span class="hljs-number">2010</span>);<span class="hljs-comment">//[c1]</span><br>   InputStream inClient = clientSocket.getInputStream();<span class="hljs-comment">//[c2]</span><br>    OutputStream outClient = clientSocket.getOutputStream();<span class="hljs-comment">//[c3]</span><br>&#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="3-ServerSocket-对象与服务器端套接字"><a href="#3-ServerSocket-对象与服务器端套接字" class="headerlink" title="3. ServerSocket 对象与服务器端套接字"></a>3. ServerSocket 对象与服务器端套接字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>ServerSocket serverForClient = <span class="hljs-keyword">new</span> ServerSocket();<span class="hljs-comment">//[s1]</span><br>&#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    Socket sc = serverForClient.accept();<span class="hljs-comment">//[s2]</span><br>    OutputStream outServer = sc.getOutputStream();<span class="hljs-comment">//[s3]</span><br>    InputStream inServer = sc.getInputStream();<span class="hljs-comment">//[s4]</span><br>&#125; <span class="hljs-keyword">catch</span>(IOException e) &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="4-例子"><a href="#4-例子" class="headerlink" title="4. 例子"></a>4. 例子</h2><p>通过一个简单的例子说明上面讲的套接字连接。在例子中,客户端向服务器问了三句话,服务器都一一给出了回答。首先将例子3中服务器端的Server. java编译通过,并运行起来,等待客户的呼叫,然后运行客户端程序</p><p>Client.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.DataInputStream;<br><span class="hljs-keyword">import</span> java.io.DataOutputStream;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String [] mess = &#123;<span class="hljs-string">&quot;2014世界杯在哪举行?&quot;</span>, <span class="hljs-string">&quot;巴西进入世界杯了吗?&quot;</span>, <span class="hljs-string">&quot;中国进入世界杯了吗?&quot;</span>&#125;;<br>        Socket mysocket;<br>        DataInputStream in = <span class="hljs-keyword">null</span>;<br>        DataOutputStream out = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mysocket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">2010</span>);<br>            in = <span class="hljs-keyword">new</span> DataInputStream(mysocket.getInputStream());<br>            out = <span class="hljs-keyword">new</span> DataOutputStream(mysocket.getOutputStream());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mess.length; i++) &#123;<br>                out.writeUTF(mess[i]);<br>                <span class="hljs-comment">// in读取信息, 状态堵塞</span><br>                String s = in.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;客户收到服务器的回答:&quot;</span> + s);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务器已断开&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Server.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.DataInputStream;<br><span class="hljs-keyword">import</span> java.io.DataOutputStream;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String[] answer = &#123;<span class="hljs-string">&quot;巴西&quot;</span>, <span class="hljs-string">&quot;进入世界杯了&quot;</span>, <span class="hljs-string">&quot;哈哈...问题真逗!&quot;</span>&#125;;<br>        ServerSocket serverForClient = <span class="hljs-keyword">null</span>;<br>        Socket socketOnServer = <span class="hljs-keyword">null</span>;<br>        DataOutputStream out = <span class="hljs-keyword">null</span>;<br>        DataInputStream in = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serverForClient = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">2010</span>);<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e1) &#123;<br>            System.out.println(e1);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;等待客户呼叫&quot;</span>);<br>            <span class="hljs-comment">//堵塞状态，除非有客户呼叫</span><br>            socketOnServer = serverForClient.accept();<br>            out = <span class="hljs-keyword">new</span> DataOutputStream(socketOnServer.getOutputStream());<br>            in = <span class="hljs-keyword">new</span> DataInputStream(socketOnServer.getInputStream());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; answer.length; i++) &#123;<br>                <span class="hljs-comment">// in读取信息，堵塞状态</span><br>                String s = in.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;服务器收到客户的提问:&quot;</span> + s);<br>                out.writeUTF(answer[i]);<br>                Thread.sleep(<span class="hljs-number">500</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;客户已断开&quot;</span>+e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-使用多线程技术"><a href="#5-使用多线程技术" class="headerlink" title="5. 使用多线程技术"></a>5. 使用多线程技术</h2><ul><li>服务器端收到一个客户的套接字后,就应该启动一个专门为该客户服务的线程.</li><li>使用套接字连接时,可能在另一端数据发送出来之前,就已经开始试着读取了,这时,就会堵塞本线程,直到该读取方法成功读取到信息,本线程才继续执行后续的操作.</li></ul><p>例子中,</p><ul><li>客户输入圆的半径并发送给服务器。</li><li>服务器把计算出的圆的面积返回给客户。</li><li>因此可以将计算量大的工作放在服务器端,客户负责计算量小的工作,实现客户-服务器交互计算,来完成某项任务。</li><li>首先将例子中服务器端的程序编译通过,并运行起来,等待客户的呼叫。</li></ul><p>Client.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span>  </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>      Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>      Socket mysocket=<span class="hljs-keyword">null</span>;<br>      DataInputStream in=<span class="hljs-keyword">null</span>;<br>      DataOutputStream out=<span class="hljs-keyword">null</span>;<br>      Thread readData ; <br>      Read read=<span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">try</span>&#123;  mysocket=<span class="hljs-keyword">new</span> Socket();<br>            read = <span class="hljs-keyword">new</span> Read();<br>            readData = <span class="hljs-keyword">new</span> Thread(read);<br>            System.out.print(<span class="hljs-string">&quot;输入服务器的IP:&quot;</span>);<br>            String IP = scanner.nextLine();<br>            System.out.print(<span class="hljs-string">&quot;输入端口号:&quot;</span>);<br>            <span class="hljs-keyword">int</span> port = scanner.nextInt();<br>            <span class="hljs-keyword">if</span>(mysocket.isConnected())&#123;&#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>              InetAddress  address=InetAddress.getByName(IP);<br>              InetSocketAddress socketAddress=<span class="hljs-keyword">new</span> InetSocketAddress(address,port);<br>              mysocket.connect(socketAddress); <br>              in =<span class="hljs-keyword">new</span> DataInputStream(mysocket.getInputStream());<br>              out = <span class="hljs-keyword">new</span> DataOutputStream(mysocket.getOutputStream());<br>              read.setDataInputStream(in);<br>              readData.start();<br>            &#125;<br>       &#125;<br>       <span class="hljs-keyword">catch</span>(Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务器已断开&quot;</span>+e);<br>       &#125;<br>       System.out.print(<span class="hljs-string">&quot;输入园的半径(放弃请输入N):&quot;</span>);<br>       <span class="hljs-keyword">while</span>(scanner.hasNext()) &#123;<br>           <span class="hljs-keyword">double</span> radius=<span class="hljs-number">0</span>; <br>           <span class="hljs-keyword">try</span> &#123;<br>               radius = scanner.nextDouble();<br>           &#125;<br>           <span class="hljs-keyword">catch</span>(InputMismatchException exp)&#123;<br>              System.exit(<span class="hljs-number">0</span>);<br>           &#125;   <br>           <span class="hljs-keyword">try</span> &#123; <br>               out.writeDouble(radius);<br>           &#125;<br>           <span class="hljs-keyword">catch</span>(Exception e) &#123;&#125;<br>       &#125; <br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Server.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>      ServerSocket server=<span class="hljs-keyword">null</span>;<br>      ServerThread thread;<br>      Socket you=<span class="hljs-keyword">null</span>;<br>      <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>        <span class="hljs-keyword">try</span>&#123;  server=<span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">2010</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(IOException e1) &#123; <br>              System.out.println(<span class="hljs-string">&quot;正在监听&quot;</span>); <span class="hljs-comment">//ServerSocket对象不能重复创建</span><br>        &#125; <br>        <span class="hljs-keyword">try</span>&#123;  System.out.println(<span class="hljs-string">&quot; 等待客户呼叫&quot;</span>);<br>              you=server.accept();<br>              System.out.println(<span class="hljs-string">&quot;客户的地址:&quot;</span>+you.getInetAddress());<br>        &#125; <br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>              System.out.println(<span class="hljs-string">&quot;正在等待客户&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span>(you!=<span class="hljs-keyword">null</span>) &#123; <br>              <span class="hljs-keyword">new</span> ServerThread(you).start(); <span class="hljs-comment">//为每个客户启动一个专门的线程  </span><br>        &#125;<br>      &#125;<br>   &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>   Socket socket;<br>   DataOutputStream out=<span class="hljs-keyword">null</span>;<br>   DataInputStream  in=<span class="hljs-keyword">null</span>;<br>   String s=<span class="hljs-keyword">null</span>;<br>   ServerThread(Socket t) &#123;<br>      socket=t;<br>      <span class="hljs-keyword">try</span> &#123;  out=<span class="hljs-keyword">new</span> DataOutputStream(socket.getOutputStream());<br>             in=<span class="hljs-keyword">new</span> DataInputStream(socket.getInputStream());<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (IOException e)&#123;&#125;<br>   &#125;  <br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <br>      <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>         <span class="hljs-keyword">try</span>&#123;  <span class="hljs-keyword">double</span> r=in.readDouble();<span class="hljs-comment">//堵塞状态，除非读取到信息</span><br>               <span class="hljs-keyword">double</span> area=Math.PI*r*r;<br>               out.writeDouble(area);<br>         &#125;<br>         <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>               System.out.println(<span class="hljs-string">&quot;客户离开&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>         &#125;<br>      &#125;<br>   &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p>Read.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Read</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    DataInputStream in;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDataInputStream</span><span class="hljs-params">(DataInputStream in)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.in = in;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">double</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>) &#123;<br>            <span class="hljs-keyword">try</span>&#123; result=in.readDouble();<br>                System.out.println(<span class="hljs-string">&quot;圆的面积:&quot;</span>+result);<br>                System.out.print(<span class="hljs-string">&quot;输入圆的半径(放弃请输入N):&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">catch</span>(IOException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;与服务器已断开&quot;</span>+e);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;套接字&quot;&gt;&lt;a href=&quot;#套接字&quot; class=&quot;headerlink&quot; title=&quot;套接字&quot;&gt;&lt;/a&gt;套接字&lt;/h1&gt;&lt;h2 id=&quot;1-套接字&quot;&gt;&lt;a href=&quot;#1-套接字&quot; class=&quot;headerlink&quot; title=&quot;1. 套接字&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="https://www.ckxgzxa.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络与信息安全</title>
    <link href="https://www.ckxgzxa.top/SDE01.html"/>
    <id>https://www.ckxgzxa.top/SDE01.html</id>
    <published>2021-11-28T16:10:26.000Z</published>
    <updated>2021-12-08T08:09:06.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络与信息安全"><a href="#计算机网络与信息安全" class="headerlink" title="计算机网络与信息安全"></a>计算机网络与信息安全</h1><h2 id="课程内容提要"><a href="#课程内容提要" class="headerlink" title="课程内容提要"></a>课程内容提要</h2><ul><li>开放系统互连参考模型$（\star\star）$</li><li>TCP/IP协议族$\color{red}{（\star\star\star\star）}$</li><li>IP地址与子网划分 $\color{red}{（\star\star\star\star\star）}$</li><li>网络规划与设计$（\star）$</li><li>3G 与 4G 标准 $（\star\star）$</li><li>HTML 语言$（\star\star）$</li></ul><h2 id="一、OSI-RM-七层模型"><a href="#一、OSI-RM-七层模型" class="headerlink" title="一、OSI/RM 七层模型"></a>一、OSI/RM 七层模型</h2><table>    <tr>        <th bgcolor="yellow" align = "center">层次</th>        <th bgcolor="yellow" align = "center">名称</th>        <th bgcolor="yellow" align = "center">主要功能</th>        <th bgcolor="yellow" align = "center">主要设备及协议</th>    </tr>    <tr>        <td align = "center">7</td>        <td>应用层</td>        <td>实现具体的应用功能</td>        <td rowspan="3">POP3、FTP、Telnet、</br>SMTP</br>DHCP、TFTP、SNMP、DNS</th>    </tr>    <tr>        <td align = "center">6</td>        <td>表示层</td>        <td>数据的格式与表达、加密、压缩</td>    </tr>    <tr>        <td align = "center">5</td>        <td>会话层</td>        <td>建立、管理和终止会话</td>    </tr>    <tr>        <td align = "center">4</td>        <td>传输层</td>        <td>端到端的连接</td>        <td>TCP、UDP</td>    </tr>    <tr>        <td align = "center">3</td>        <td>网络层</td>        <td>分组传输和路由选择</td>        <td>三层交换机、路由器</br>ARP、RARP、IP、ICMP、IGMP</td>    </tr>    <tr>        <td align = "center">2</td>        <td>数据链路层</td>        <td>传送以帧为单位的信息</td>        <td>网桥、交换机（多端口网桥）、网卡、PPTP、L2TP、SLIP、PPP</td>    </tr>    <tr>        <td align = "center">1</td>        <td>物理层</td>        <td>二进制传输</td>        <td>中继器、集线器（多端口中继器）</td>    </tr></table><h2 id="二、TCP-IP协议族"><a href="#二、TCP-IP协议族" class="headerlink" title="二、TCP/IP协议族"></a>二、TCP/IP协议族</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111290054003.png"></p><table>    <tr>        <th frame=void align="center">TCP/IP 模型</th>        <th frame=void align="center">OSI 七层模型</th>    </tr>    <tr>        <td align="center" rowspan=3>应用层</td>        <td align="center">应用层</td>    </tr>    <tr>        <td align="center">表示层</td>    </tr>    <tr>        <td align="center">会话层</td>    </tr>    <tr>        <td align="center" bgcolor="yellow">传输层</td>        <td align="center" bgcolor="yellow">传输层</td>    </tr>       <tr>        <td align="center" bgcolor="#9393FF">网际层</td>        <td align="center" bgcolor="#9393FF">网络层</td>    </tr>    <tr>        <td align="center" rowspan="2" bgcolor="pink">网络接口层</td>        <td align="center" bgcolor="pink">数据链路层</td>    </tr>    <tr>        <td align="center" bgcolor="pink">物理层</td>    </tr></table><!-- flag of hidden posts -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络与信息安全&quot;&gt;&lt;a href=&quot;#计算机网络与信息安全&quot; class=&quot;headerlink&quot; title=&quot;计算机网络与信息安全&quot;&gt;&lt;/a&gt;计算机网络与信息安全&lt;/h1&gt;&lt;h2 id=&quot;课程内容提要&quot;&gt;&lt;a href=&quot;#课程内容提要&quot; class=&quot;</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件设计师考试" scheme="https://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>百度高效研发实战训练营</title>
    <link href="https://www.ckxgzxa.top/bitTraingClub.html"/>
    <id>https://www.ckxgzxa.top/bitTraingClub.html</id>
    <published>2021-11-27T00:10:12.000Z</published>
    <updated>2021-12-05T05:42:21.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、百度高效研发实战训练营Step1"><a href="#一、百度高效研发实战训练营Step1" class="headerlink" title="一、百度高效研发实战训练营Step1"></a>一、百度高效研发实战训练营Step1</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-设计方法与实践"><a href="#1-设计方法与实践" class="headerlink" title="1 设计方法与实践"></a>1 设计方法与实践</h2><h3 id="1-1-软件设计原则"><a href="#1-1-软件设计原则" class="headerlink" title="1.1 软件设计原则"></a>1.1 软件设计原则</h3><ol><li><p>软件设计的目的</p><blockquote><p>软件设计是为了使软件在长期范围内能够容易的进行变化。我们从下面这三个点来理解这句话。</p><blockquote><ol><li><p>变化：<em>软件不是一成不变的</em>，无论是软件本身的需求、软件依赖的其他软件资源都是一直在发生变化的，唯一不变的就是变化。</p></li><li><p>容易：任何一个软件的变化都需要成本，要尽可能的降低变化的成本，使得软件可以很容易应对软件的变化。</p></li><li><p>长期：事实上需要长期进行维护的软件更应该做好软件设计，因为软件长期的变化非常多，难以提前作出预测，需要良好的软件设计来应对。</p></li></ol></blockquote></blockquote></li><li><p>软件设计原则</p></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111232319206.png"></p><blockquote><p>软件设计有着很多的原则，<em>最基本的原则是高内聚低耦合，它也是软件设计追求的最高目标</em>。 <em><strong>内聚</strong></em> 指的是一个软件内部间元素相关联的程度。</p><p><em><strong>高内聚</strong></em>追求的是紧密相关联的元素要放在一起。</p><p><em><strong>低耦合</strong></em>指的是单位之间尽可能少地关联，依赖。</p></blockquote><blockquote><p>在高内聚低耦合之上有很多其他的原则：如SOLID原则、简单设计、正交设计，在这之上还会有设计模式作为最高层的软件设计原则。</p></blockquote><h3 id="1-2-clean-code"><a href="#1-2-clean-code" class="headerlink" title="1.2 clean code"></a>1.2 clean code</h3><ol><li><p>clean code的概念</p><blockquote><p>clean code中文解释为<em>整洁代码</em>，是指写的代码能够在尽可能短的时间内被别人读懂，且代码看上去排版整洁、逻辑清晰、扩展性好。</p></blockquote></li><li><p>命名规则</p><blockquote><p>代码中命名需要遵循以下的几个规则：</p><blockquote><ol><li><p>表达它是什么，不要表达怎么做。</p></li><li><p>代码要做到自注释。</p></li><li><p>使用有意义的循环迭代变量。</p></li><li><p>避免缩写，尤其拼音缩写。</p></li><li><p>不要使用非约定俗成的缩写。</p></li><li><p>避免使用魔法数。</p></li><li><p>不要害怕长变量名。</p></li></ol></blockquote></blockquote></li><li><p>注释</p><blockquote><p>注释对于代码来说是必不可少的。通常情况下，<em>好的注释包含：版权信息，设计意图，警示信息。</em></p><p>不好的注释则具有以下一个或几个特点：同义反复、隐晦关联关系、套用模板、提供历史修改记录以及注释掉的代码。</p></blockquote></li><li><p>函数</p><blockquote><p>在写函数时，应当注意，<em>每个函数只做一件事</em>，每个函数应是单一职责。</p><p>函数分为骨架函数和步骤函数。</p><ul><li><em>骨架函数</em> 是业务逻辑和算法是在高层次上的抽象描述。</li><li><em>步骤函数</em> 是业务逻辑和算法的一些实现细节，是被隐藏起来的。</li></ul></blockquote></li><li><p>编码细节</p><blockquote><p>在编码细节方面，需要遵循以下几点规则：</p><blockquote><ol><li>使用自然的比较顺序。</li><li>简化逻辑层次，避免多层嵌套。</li><li>在写三元表达式时不要出现复杂的逻辑和过长的条件。</li><li>需要控制变量的作用域，也就是缩小变量作用域的范围，越小越好。</li></ol></blockquote></blockquote></li></ol><h3 id="1-3-单元测试"><a href="#1-3-单元测试" class="headerlink" title="1.3 单元测试"></a>1.3 单元测试</h3><ol><li><p>为什么进行单元测试</p><blockquote><p>测试是分为不同层次的：最底层是单元测试，中间是基于模块级、组件级的测试，再往上则是系统级别的测试。</p><p><em>越底层的测试，越能够快速地发现问题。</em>底层的测试集成性更好，能够安全的进行代码修改。上层的测试一般情况下获得反馈的速度比较慢，测试过程也比较笨重。</p><p>所以单元测试具有<em>更早发现问题，更容易集成，更安全地代码修改的优点</em>。</p></blockquote></li><li><p>写好单元测试的重要性</p><blockquote><p>写好单元很费时。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111232334866.webp"></p><p><em>好的单元测试能够降低产品开发的成本。</em> 然而单元测试写得不好的话，不但会增加产品开发的成本，而且还会增加单元测试成本。</p></blockquote></li><li><p>单元测试原则与模式</p><p><strong>第一个原则：Tests As Documentation</strong></p><p>将测试当成一个文档工作，也就是说我们需要把测试写得像文档一样简洁，通过一些描述，可以清晰地知道这个测试的作用。在之后对项目修改时，只需要查看单元测试即可。</p><p><strong>第二个原则：Fully Automated and Self-Checking</strong></p><p>单元测试都是可以进行自我检查、自我校验的，通过代码的编写，能够知道测试是否成功，不需要人为判定。</p><p><strong>第三个原则：Do No Harm，不可破坏性。</strong></p><p>部分开发人员在进行测试时，为了完成目的，会基于测试代码创立一些逻辑，这种做法是错误的。在写测试时不能单独为测试创建特别的逻辑，更不能破坏原有代码的逻辑。</p><p><strong>第四个原则：Keep tests as simple as possible，简洁性。</strong></p><p>单元测试虽然是用来保证代码的正确性，但单元测试也是一份代码，为了避免过多的测试代码相覆盖，要尽可能地把单元测试的代码写得简单，保证其不会出错。</p></li></ol><h3 id="1-4-重构"><a href="#1-4-重构" class="headerlink" title="1.4 重构"></a>1.4 重构</h3><p>​    重构时需要遵循的规则如下:</p><blockquote><ol><li><strong>业务导向</strong></li></ol><p>重构一定是要解决实际的业务问题的，而不是为了重构去重构。</p><ol start="2"><li><strong>小步快跑</strong></li></ol><p>​        通常重构是需要多人同时参与，重构过程中开发人员要随时对比主干与分支的情况。当某一个开发人员在分支上进行了大量改动并准备将其合并到主干时，有可能主干和分支的代码有很大的差异。所以进行重构时，要<em>将问题拆分成多个小的单元进行修改，并且每修改一个就进行一次分支合并</em>。这种小步快跑的模式可以随时同步主干上的代码，减少出错的可能。</p><ol start="3"><li><strong>演进式设计</strong></li></ol><p>​        在进行代码重构之前，我们不可能知道重构的最终结果是什么。为了保证能够得到一个比较好的结果，我们采用演进式设计方法。在重构过程中<em>遵循包括高内聚低耦合、正交设计原则、SOLID原则等软件设计原则，不断地用小步快跑的方式去重构</em>，只有这样结果才能令人满意。</p><ol start="4"><li><p><strong>正交设计原则</strong></p><p>分离关注点、消除重复、缩小依赖范围、向着稳定的方向依赖。</p></li></ol></blockquote><p>​        在代码中，根据功能的不同，将其分为不同的变化方向。每个变化方向都是一个职责，我们把每一个不同的变化方向称作关注点，根据它的变化方向来进行相应的处理。</p><h3 id="1-5-配置化架构"><a href="#1-5-配置化架构" class="headerlink" title="1.5 配置化架构"></a>1.5 配置化架构</h3><ol><li><strong>配置化架构的定义：</strong></li></ol><p>以可配置的方式构建软件的方法。它是在领域建模的基础上，以配置表述业务，以配置组织架构元素，比如服务、组件、数据等，并对配置进行规范化、自动化的管理。</p><p>定义的原因：</p><blockquote><ol><li><p>通常情况下配置指的是对数据的抽象，需要架构上的描述；</p></li><li><p>架构上描述的配置指的是对架构元素的抽象，描述配置化不完整；</p></li><li><p>配置化包括对业务的抽象，尤其是逻辑；</p></li><li><p>配置化还包括对配置的管理以及分支。</p></li></ol></blockquote><ol start="2"><li><strong>如何应用配置化架构</strong></li></ol><p>应用配置化架构包括三方面：从业务上改造，提高配置本身的开发效率，降低配置的维护成本。</p><blockquote><ol><li><strong>业务配置化改造</strong></li></ol><blockquote><ol><li>组件配置化</li></ol><p>组件配置化表达<em>是业务层面上非常重要的一环</em>，组件是一个独立升级发布的单元，这样的单元关联了很多配置，可将这些配置分为两类。一类是<em>组件内部的配置</em>，另二类是<em>描述组件与组件间关系的配置</em>。只有组件配置化是不够的，往往还需要构建DSL来帮助。</p><ol start="2"><li>构建DSL：</li></ol><p>DSL是工程师针对不同的领域创建的语言。具有很强的针对性，在专业领域有时很长的代码只需要将其改为一行配置就足够了。</p></blockquote><ol start="2"><li><strong>提高配置的开发效率</strong></li></ol><p>通过下面的持续发布的系统，能够很好地提高配置的开发效率。它只针对配置，可以独立的发布配置。在系统中：需要配置前端编辑逻辑，后端校验逻辑，当存储发生变更时，触发测试流水线，当测试流水线无异常后，才会借用部署的工具，将配置分发到线上去。</p><ol start="3"><li><strong>降低配置的维护成本</strong></li></ol><p>通常来说，代码数量很大的项目，配置也会很多。这样的配置在维护起来需要花费大量的成本。所以在设计配置的时候，要满足以下这些规则：</p><blockquote><ol><li><p>让配置尽可能地在部署、数据版本、业务属性和架构描述这四个不同维度间参数能够共用。把部署的配置和策略的配置分离开来。</p></li><li><p>针对配置本身的语法，让配置支持合并.</p></li><li><p>减少冗余信息。</p></li><li><p>消除信息重复。</p></li><li><p>使用配置的默认值。</p></li></ol></blockquote></blockquote><h2 id="2-高效研发流程脚本"><a href="#2-高效研发流程脚本" class="headerlink" title="2. 高效研发流程脚本"></a>2. 高效研发流程脚本</h2><h3 id="2-1-从产品目标到产品路线图"><a href="#2-1-从产品目标到产品路线图" class="headerlink" title="2.1 从产品目标到产品路线图"></a><strong>2.1 从产品目标到产品路线图</strong></h3><blockquote><p>满足用户诉求是产品的基础功能，在此之上还有一个更高的期望，即产品的目标。通常情况下产品目标与产品的收益、市场份额、流水有关。在制定具体产品目标时，需要考虑产品的商业模式以及产品所处的阶段。<em>好的产品目标是具体的、可衡量的、相对稳定的。</em></p><p>在进行产品目标阶段性地拆解时，需要考虑拆解的维度与方法。除了根据阶段性的时间维度进行拆分外，还可以根据产品的里程碑进行拆分。</p></blockquote><h3 id="2-2-从产品路线图到发布计划"><a href="#2-2-从产品路线图到发布计划" class="headerlink" title="2.2 从产品路线图到发布计划"></a>2.2 <strong>从产品路线图到发布计划</strong></h3><p>在了解如何制定产品发布计划之前，我们需要先了解一个工具：<em>用户故事地图</em>。用户故事地图实际上是一个完整的用户故事。它可以帮助我们增强团队协作、洞察真实需求、打磨优良产品。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242041157.png" alt="image-20211124204157089"></p><p>想要创建用户故事地图，首先要有用户故事地图的框架。它的核心是一条从左到右的时间线，然后从上到下按照归纳结构分为三个层级。这一条时间线上方的一级粒度的功能需求，在工作中，我们称之为Epic，也就是橙色卡片。这条时间线下方的第一行为二级粒度的功能需求，在工作中，称之为Feature，是黄色卡片。在二级粒度功能下，蓝色的卡片为三级粒度的需求，工作中，称之为Story，是蓝色卡片。</p><p>用户故事地图创建中五个重要的步骤：</p><blockquote><ol><li><p>一步一步写出你的故事</p></li><li><p>组织情节</p></li><li><p>探索替代故事</p></li><li><p>提取故事地图的主干</p></li><li><p>切分出能帮你达成特定目标的任务</p></li></ol></blockquote><p><strong>“训练智能机器人小A从起床到出门”</strong>的简单例子</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242043740.png" alt="image-20211124204337683"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242053569.png"></p><p><em>首先我们使用蓝色卡片</em> 按照步骤写出每个任务，每张卡片只写一个任务，任务以动词开头，如“睁眼”、“关闹钟”、“穿拖鞋”、“叠被子”等等。然后按照任务的发生顺序从左到右的组织卡片摆放。</p><p>接下来第二步，对所有的任务进行提取，得到概括性的行为，把这些<em>行为放到黄色卡片</em>上，也就是feature。如：“睁眼”、“关闹钟”这些行为可以归为“醒来”后要做的事情；“穿拖鞋”、“叠被子”这两个行为可以归为“起来”后要做的事情。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242055033.png"></p><p>接下来进入第三步：探索替代故事。细节、替代、变化和异常构成故事地图的主题。比如：时间充裕可以睡个回笼觉，楼上装修被提前吵醒等等可能发生的变化和异常。我们需要将这些任务补充进地图。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242057602.png"></p><p>然后进入第四步：将一系列类似的任务提取出来，形成更大的目标。在类似任务的上方，放一张<em>橙色的卡片,也就是之前提到的Epic,卡片贴上一个动词短语</em>，使其足以覆盖其下方所有任务卡片所要表达的意思。例如：“起床”可以概括“醒来”和“起来”；“如厕”可以概括“如厕”和“刷牙”。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242058456.png"></p><p>此时已经完成了较为完整的故事地图。然后进入第五步，切分出能达成特定目标的任务。先确定本次迭代需要完成的特性/目标，使用切分来识别和特定相关的所有任务和细节。</p><p>在“训练智能机器人小A从起床到出门”这个例子中，分为了三个版本。在第一个版本15分钟起床，回笼觉这张卡片明显是不需要放到其中的。在这些的story中选出满足15分钟起床的事务并将其放入都第一个版本中。至此我们也就完成了一个简单的用户故事地图的创建。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242002082.webp"></p><p>上面这张图片是实际工作中对用户故事地图的应用，可以看到在实际工作中完整的用户故事地图所包含的内容非常庞杂。</p><p>完成用户故事地图之后，就需要制订发布计划。在创建用户故事地图的第五步中，我们切分出了达成特定功能的任务目标，每一个发布计划都对应着一个版本。具体的步骤如下：</p><blockquote><ol><li><p>Big Story进行细化讨论</p></li><li><p>按照价值和重要程度进行版本规划</p></li><li><p>确定每个版本的期望达成目标</p></li><li><p>确定每个版本的内容</p></li><li><p>团队达成共识</p></li></ol></blockquote><p>通过以上步骤，就基本确定了用户故事地图的发布计划。</p><h3 id="2-3-从发布计划到迭代计划"><a href="#2-3-从发布计划到迭代计划" class="headerlink" title="2.3 从发布计划到迭代计划"></a>2.3 <strong>从发布计划到迭代计划</strong></h3><p>第三部分主要讲解 <em>集中发布式模式</em> 这一常用的模式，在集中发布式模式中<em>，一次发布包含多次迭代</em>；在迭代发布模式中，一次发布等于一次迭代。</p><p>很多大型项目都在使用这一模式，通常是每月发布一次，<em>一次发布包含四个迭代</em>，四个迭代之后，发布一次版本。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242101886.png"></p><p>从发布计划到迭代计划共包括四个内容。</p><ol><li><strong>用户故事拆分</strong></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242101974.png"></p><p>​        用户故事的拆分<em>对迭代速率有一定影响</em>。对用户故事的拆分要做到拆分出的故事尽量小，但是要适当，并不是越小越好。避免出现一个迭代内无法完成的故事。</p><ol start="2"><li><strong>用户故事优先级</strong></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242104291.webp"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242006342.webp"></p><p>​        在完成用户故事拆分后，需要对用户故事的优先级进行排序。用户故事的排序其实是对需求的一个排序，优先级排序有许多方法，如高中低、数字排序、衣服尺码L、XL等方式。<em>优先级决定排入迭代的顺序。</em></p><p>​        以一个两周的迭代时间为例，假设我们有这样一个需求，前面的数字是需求卡片的序号，后面的数字从100到45，这是项目优先级排序的一个方式。每一次迭代能做4个卡片时，我们就会<em>把优先级最高的卡片放入迭代池</em>。</p><p>​        而当第二次迭代时，需求发生了变化，出现了x和y两个新的需求，x和y有着较高的优先级，那么我们仍然将优先级最高的四个卡片放入迭代池中。</p><p>​        第三次迭代中又插入了新需求z，需求z也有较高的优先级，那么当我们进行迭代的时候，需求z就会顶替另一个需求被放入迭代池中。</p><p>​        通过以上的例子可以看到，在原本的迭代计划中，12张卡片会被按顺序放入迭代池中，而真实情况是插入了更高优先级的需求，替换了低优先级的需求，把低优先级的需求放入了下一次迭代中。这就是优先级排序对迭代计划的影响。</p><ol start="3"><li><strong>用户故事估算</strong></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242105269.png"></p><p>​        在迭代之前，需要对用户故事进行估算，<em>用户故事估算实际上是对工作量的估算</em>。这个工作量体现的是团队均值能力。</p><p>​        通常在公司内有不同级别的员工，高级别的员工和低级别的员工完成同一任务所需的时间是不同的。所以在进行用户故事估算时就需要规避掉技能的差异，根据团队的均值能力来进行估算。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242106613.png"></p><ol start="4"><li><strong>迭代计划制定</strong></li></ol><p>当前面三步全部完成后，才能开始指定迭代计划。</p><p>将已拆分好的用户故事按照优先级依次放入迭代池中，对每个要进行迭代的用户故事进行估算，确定好迭代的时间期限。所以我们就制定出了迭代计划。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242107859.png"></p><p><em>推荐采用范围调整、需求置换</em>方式，即插入高优先级用户故事，顺延低优先级故事到下一次迭代。</p><h3 id="2-4-从迭代计划到迭代的落地执行"><a href="#2-4-从迭代计划到迭代的落地执行" class="headerlink" title="2.4 从迭代计划到迭代的落地执行"></a>2.4 <strong>从迭代计划到迭代的落地执行</strong></h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242108710.png" alt="迭代计划会、站会、需求评审会、迭代回顾会"></p><p>在整个过程中开发和测试以story的力度进行。<em>分析、开发与测试三个步骤并行。</em></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242110996.png" alt="卡片墙"></p><p>团队可以使用卡片墙标注完成的任务和未完成的任务以及遇到的bug等。通过这种方式，能够对执行情况有清晰的认知，对执行过程产生积极的影响。</p><h2 id="3-研发工具链介绍"><a href="#3-研发工具链介绍" class="headerlink" title="3 研发工具链介绍"></a>3 研发工具链介绍</h2><h3 id="3-1-项目管理工具-iCafe"><a href="#3-1-项目管理工具-iCafe" class="headerlink" title="3.1 项目管理工具: iCafe"></a>3.1 项目管理工具: iCafe</h3><h4 id="3-1-1-需求管理"><a href="#3-1-1-需求管理" class="headerlink" title="3.1.1 需求管理"></a>3.1.1 需求管理</h4><p><strong>需求管理是一个项目的基石。</strong>在互联网行业中，因为产品需求迭代快速这一特点，需求管理一直非常令人头疼。所以如何对需求进行更好的管理，更好的做出产品规划对互联网行业的项目来说是一个重要的问题。</p><blockquote><p>传统的需求管理方法有以下几种：</p><ol><li><p>直接将需求写在文档上面，</p></li><li><p>将需求制作成需求卡片，通过这样的方式让研发人员与需求人员保持信息的一致。</p></li><li><p>使用Excel进行需求管理和排序。</p></li></ol></blockquote><p>这三种方法都存在很多的缺点，如撰写文档耗时长、文档编写需求较多人力、文档维护成本高、文档使用过程中沟通不畅等等。文字因为其阅读特性，不方便对任务进行直观的展现。所以在很多项目开发过程中，经常会出现文档交给研发人员后，开发出的产品与文档设计不一致的问题。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111250059343.png"></p><p>互联网的需求管理需要具有<strong>需求完整性、沟通高效性、表达准确性，沟通便捷性</strong>等特点。</p><p>研究表明，不同的沟通方式产生的沟通效果各有不同。在所有的沟通方式中，文档沟通是最低效的沟通方式，而面对面使用白板沟通是最高效的沟通方式。结合多种高效沟通方式，就产生了用户故事地图这种新颖的需求管理、排序的方式。</p><p><strong>用户故事地图是敏捷项目管理中一种重要的管理方式。</strong></p><p>首先<strong>使用卡片在白板上将所有的需求列出来，</strong>这样有助于展现产品全貌，而且将需求转化为可视的卡片能更好的根据用户反馈对任务需求进行排序；</p><p>然后<strong>使用不同的颜色对卡片进行分层。</strong>蓝色卡片是第一层，黄色卡片是第二层，白色卡片是第三层。将颗粒度最小的需求放在白色卡片这一层，低颗粒度的需求更容易被研发人员接受。</p><p>最后通过横向的分组，把迭代计划每一期的每一版本的<strong>需求进行归类分组。</strong>这样有利于打通产品视图和研发计划视图。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292131175.png"></p><p>通过以上步骤可以得到一个较为完整的用户故事地图。</p><h4 id="3-1-2-迭代计划"><a href="#3-1-2-迭代计划" class="headerlink" title="3.1.2 迭代计划"></a>3.1.2 迭代计划</h4><p>在完成产品的版本规划后，研发团队需要制定相应的迭代计划。敏捷、快速、合理地迭代计划能够更高效地促进项目的迭代。</p><p>基于用户故事地图，可以在制定迭代计划的过程中中直接对需求进行<strong>上下拖拽修改优先级，左右拖拽更改计划。</strong>这样可以更清晰的展现迭代计划，使开发团队更好定位到的里程碑，完善整个迭代计划。</p><h4 id="3-1-3-进度追踪"><a href="#3-1-3-进度追踪" class="headerlink" title="3.1.3 进度追踪"></a>3.1.3 进度追踪</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111250103932.png"></p><p>进度跟踪的三大法宝：<strong>站会、卡片墙、燃尽图。</strong></p><p>站会同卡片墙相结合，在站会过程中可以直接通过电子看板共享项目进度和项目问题，提升站会沟通效率。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270116972.png"></p><p><strong>用户故事地图是一种非常高效需求管理方式，</strong>目前所有的研发团队都可以在效率云上不受物理条件限制的直接使用它进行需求管理和追踪。</p><h4 id="3-1-4-持续改进"><a href="#3-1-4-持续改进" class="headerlink" title="3.1.4 持续改进"></a>3.1.4 持续改进</h4><p>针对持续改进，有卡片状态时长散点图和卡片状态累积流图这两种工具。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270127171.png"></p><p><strong>卡片状态时长散点图</strong>能够精确展示团队工作速率，从需求提出到需求上线的单个周期时长和平均周期时长，精确的展示团队在每一个状态的工作速率及工作速率的变化。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270128848.png"></p><p><strong>卡片状态累积流图</strong>能够宏观展示项目各流程效率趋势，颜色的色块宽表示该流程积压的需求和任务比较多，色条变窄表明团队状态流动速率提高。</p><p>基于这两幅图工具，研发团队可以周期性地进行自检，对过去一段时间的工作进行自我审视，然后持续改进。</p><h3 id="3-2-代码管理工具-iCode"><a href="#3-2-代码管理工具-iCode" class="headerlink" title="3.2 代码管理工具:iCode"></a>3.2 代码管理工具:iCode</h3><h4 id="3-2-1-工作流"><a href="#3-2-1-工作流" class="headerlink" title="3.2.1 工作流"></a>3.2.1 工作流</h4><p>运转无序，开发混乱是困扰很多团队的一个问题，严重影响产品的交付。</p><p>典型的问题有：代码处理随意、bug重复发生、测试不完善、发布版本混乱等。</p><p>支持以下两种标准的工作流，用来保障团队有序协作。</p><h5 id="1-基于主干的工作流"><a href="#1-基于主干的工作流" class="headerlink" title="1.  基于主干的工作流"></a>1.  基于主干的工作流</h5><p>​            在基于主干的工作流中，整个团队维护一条主干分支。为了保证主干分支的质量，需要配套严    格的准入机制，变更点在合入前需要经过机器、人工的双重评审，通过后才能合入主干。</p><p>​            需要发布的时候，会基于主干拉取发布分支，这个分支其实是主干特定点的快照，单纯用于发        布，如果发布问题过程中发现问题，回到主干修复Bug或进行功能增强，必要时再将主干提交拣        选到相应的发布分支上。</p><p>​            分支发布和主干并行不悖，不用担心开发中的功能被带到线上，发布完成后恢复到一条主干的        简明模式。</p><blockquote><p>  基于主干的工作流<strong>优点</strong>有：</p><ol><li>主干质量高，随时可以发布。</li><li>模型简单，只有一条主干，节省分支合并的成本。</li></ol></blockquote><p>​    缺点: 在开发高质量的工程项目时，团队需要建设完备的测试用例，在提交环节要求提交人保持原子提交，即功能和提交一一对应。</p><h5 id="2-基于分支的工作流"><a href="#2-基于分支的工作流" class="headerlink" title="2. 基于分支的工作流"></a>2. 基于分支的工作流</h5><p>在基于分支的工作流中，<strong>主干用于存储线上代码</strong>，需要变更时，基于主干最新代码开分支完成功能的开发、测试和发布；分支发布前，需要先同步主干的更新；上线之后，需要将分支合并回主干。</p><blockquote><p>基于分支的工作流的<strong>优点</strong>有：</p><ol><li>分支并行，独立开发，分支不会相互影响；</li><li>对团队而言，使用门槛低，分支贯穿一个独立功能开发、测试、发布的整个过程，给予团队充分的时间完善测试用例及完成人工测试；</li><li>容易上手，系统会引导开发人员完成新建分支、同步主干、合会主干等全部操作。</li></ol></blockquote><p>缺点：需要花费分支合并的成本、需要不断地同步主干，来发现分支的冲突风险点并提前解决。</p><h3 id="3-2-2-评审"><a href="#3-2-2-评审" class="headerlink" title="3.2.2 评审"></a>3.2.2 评审</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270327159.png"></p><p>评审是<strong>保证团队工程质量</strong>的一个重要的过程。如果不经过评审直接提交代码，可能会污染代码历史，增加后期维护成本，严重时可能还会产生代码质量问题。</p><p>在项目开发过程中，可能会出现本地运行正常的代码，在测试环境或者线上环境突然崩溃的情况。针对这样的问题，可以使用<strong>质量防护网</strong>。质量防护网包括代码扫描、持续集成、人工评审三个层次。</p><p><strong>代码扫描</strong>能够找出不符合代码规范的地方，在行间距中插入代码评论，同时出具一个风格报告，方便工程师对代码风格问题进行修改。</p><p><strong>持续集成</strong>会配置一个云端构建，通过云端构建，快速探测出代码初期Bug，帮助开发人员提早修复。</p><p>在前两步做好后，团队的资深成员就可以就架构、逻辑、设计等问题进行深入评审。</p><p>通过这三步，实现了机器、人工双重评审，层层递进，确保团队的工程质量。</p><h3 id="3-3-交付平台-iPipe"><a href="#3-3-交付平台-iPipe" class="headerlink" title="3.3 交付平台:iPipe"></a>3.3 交付平台:iPipe</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270329017.png"></p><h4 id="3-3-1-固化端到端的交付流程"><a href="#3-3-1-固化端到端的交付流程" class="headerlink" title="3.3.1 固化端到端的交付流程"></a>3.3.1 固化端到端的交付流程</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270333279.png"></p><p>标准的软件交付的过程包括以下几点：</p><blockquote><ol><li><p>会有一个明确的发布版本的输入，</p></li><li><p>基于这个发布版本，会进行代码提交。</p></li><li><p>代码提交之后会进行编译、测试。其中测试环节可能包含模块级的测试和系统级的测试。</p></li><li><p>进行发布。发布上线的过程可能会分为预上线、生产灰度、生产全量几个环节。</p></li></ol></blockquote><p>为了使代码变更流程标准化，需要<strong>使用交付流水线的方式来落地</strong>。通过标准化交付过程从而达到可靠、可重复的作用。交付流水线是<strong>串行执行</strong>的，上一个阶段成功执行后，就会触发下一个阶段。执行阶段由任务组成，这些任务可以是穿行的也可是并行的。任务的执行状态决定阶段执行状态。</p><p><strong>iPipe这一工具目前包含了标准的交付流水线</strong>，用户可以在iPipe中看到流水线的构建情况。在使用交付流水线的过程中，如果当前阶段失败，后面的阶段就不会继续进行，这样可以节省资源并且快速的发现问题，及时修复问题。</p><h4 id="3-3-2-插件化现有工具和服务"><a href="#3-3-2-插件化现有工具和服务" class="headerlink" title="3.3.2 插件化现有工具和服务"></a>3.3.2 插件化现有工具和服务</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130209.png"></p><p>在交付流水线中执行各种任务时需要依赖很多工具和服务，比如maven，docker、jenkins、git等工具和服务。</p><p>我们通过一套<strong>标准的插件化开发规范</strong>将这些工具和服务集成到了流水线中，用户在使用流水线的过程中就可以很方便的使用这些插件和服务。如果流水线中没有想使用的插件、服务或工具，可以根据效率云提供的插件规范，自行扩展以满足项目需求。</p><h4 id="3-3-3-数据度量驱动过程改进"><a href="#3-3-3-数据度量驱动过程改进" class="headerlink" title="3.3.3 数据度量驱动过程改进"></a>3.3.3 数据度量驱动过程改进</h4><p>通过交付流水线，可以快速获取项目所有的数据和信息，如：一个版本从代码提交到交付上线的周期或者一个项目各个阶段发现的缺陷数量等等。</p><p>用户可以通过调用API获取数据来进行数据的度量，从而推动交付过程的改进。在后续的发展中，平台会识别项目中关键的数据指标并且自动化的形成更加鲜明的数据报表。这样就可以持续的进行数据度量，给个人及团队提供一个维度丰富的平台。</p><h2 id="4-持续交付方法与实践"><a href="#4-持续交付方法与实践" class="headerlink" title="4 持续交付方法与实践"></a>4 持续交付方法与实践</h2><h3 id="4-1-为什么要做持续交付"><a href="#4-1-为什么要做持续交付" class="headerlink" title="4.1 为什么要做持续交付"></a>4.1 为什么要做持续交付</h3><h4 id="4-1-1-软件交付流程"><a href="#4-1-1-软件交付流程" class="headerlink" title="4.1.1 软件交付流程"></a>4.1.1 软件交付流程</h4><p>传统软件交付流程通常包括四个步骤：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271338880.png"></p><ol><li><p>首先业务人员会诞生一个软件的想法；</p></li><li><p>然后开发人员将这个想法变为一个产品或者功能；</p></li><li><p>经过测试人员的测试之后提交给用户使用并产生收益；</p></li><li><p>最后运维人员参与产品或功能的后期运维。</p></li></ol><h4 id="4-1-2-传统软件交付的问题和困境"><a href="#4-1-2-传统软件交付的问题和困境" class="headerlink" title="4.1.2 传统软件交付的问题和困境"></a>4.1.2 传统软件交付的问题和困境</h4><p>通过分析以上流程，可以发现一些传统软件交付流程<strong>存在的问题</strong>。</p><ol><li><p><strong>业务人员产生的需求文档沟通效率较低</strong>，有时会产生需求文档描述不明确、需求文档变更频繁等问题。</p></li><li><p>随着开发进度的推进，测试人员的工作量会逐步增加，测试工作的比重会越来越大。而且由于测试方法和测试工具有限，自动化测试程度低，<strong>无法很好地把控软件质量</strong>。</p></li><li><p>真实项目中运维的排期经常会被挤占，又因为手工运维繁琐复杂，<strong>时间和技术上的双重压迫</strong>会导致运维质量难以保证。</p></li></ol><p>因为存在以上问题，所以传统的软件交付经常会出现开发团队花费大量成本开发出的功能或产品并不能满足客户需求这一双输的局面。由此可以总结出传统的软件交付存在<strong>两个层面的困境：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271339450.png"></p><p>从<strong>表现层</strong>来看，传统软件交付存在进度不可控；流程不可靠；环境不稳定；协作不顺畅等困境。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271339695.png"></p><p>表现层的问题其实都是由<strong>底层问题</strong>引起的，从根源上来说，存在分支冗余导致合并困难；缺陷过多导致阻塞测试；开发环境、测试环境、部署环境不统一导致的未知错误；代码提交版本混乱无法回溯；等待上线周期过长；项目部署操作复杂经常失败；上线之后出现问题需要紧急回滚；架构设计不合理导致发生错误之后无法准确定位等困境。</p><h4 id="4-1-3-持续交付的流程与优势"><a href="#4-1-3-持续交付的流程与优势" class="headerlink" title="4.1.3 持续交付的流程与优势"></a>4.1.3 持续交付的流程与优势</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271340504.png"></p><p>经过对传统软件交付问题的分析和总结，持续交付应运而生，持续交付是一系列开发实践方法，用来确保让代码能够快速、安全的部署到生产环境中。持续交付是一个完全自动化的过程，当业务开发完成的时候，可以做到一键部署。持续交付提供了一套更为完善的解决传统软件开发流程的方案。</p><ol><li><p>在需求阶段，抛弃了传统的需求文档的方式，使用便于开发人员理解的用户故事。</p></li><li><p>在开发测试阶段，做到持续集成，让测试人员尽早进入项目开始测试。</p></li><li><p>在运维阶段，打通开发和运维之间的通路，保持开发环境和运维环境的统一。</p></li></ol><p><strong>持续交付具备以下几个优势：</strong></p><blockquote><ol><li>持续交付能够有效缩短提交代码到正式部署上线的时间，降低部署风险。</li><li>持续交付能够自动的、快速的提供反馈，及时发现和修复缺陷。</li><li>持续交付让软件在整个生命周期内都处于可部署的状态。</li><li>持续交付能够简化部署步骤，使软件版本更加清晰。</li><li>持续交付能够让交付过程成为一种可靠的、可预期的、可视化的过程。</li></ol></blockquote><h4 id="4-1-4-敏捷开发与Devops"><a href="#4-1-4-敏捷开发与Devops" class="headerlink" title="4.1.4 敏捷开发与Devops"></a>4.1.4 敏捷开发与Devops</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271341155.png"></p><p>持续交付依靠<strong>敏捷开发（Agile）</strong>和<strong>Devops</strong>两个组件的支撑可以更好地发挥作用。</p><p>敏捷开发（Agile）主要作用于需求阶段和研发阶段。</p><p>Devops主要作用于开发测试和运维部署阶段。</p><blockquote><p>了解Devops的相关知识。</p><blockquote><ol><li><p>Devops的趋势</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271341165.png"></p><p>根据最近的一项集体研究，DevOps的市场在2020年创造了约50亿美元的产值，预计到2022年，这个数字将达到约66亿美元。随着Devops的影响力不断扩大，目前DevOps已经成为软件工程的主流模式。</p></li></ol></blockquote><blockquote><ol start="2"><li><p>Devops效能</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271342341.png"></p><p>Devops的效能跟发布频率、部署时间、平均修复故障的时间点、部署变更的失败率四个因素紧密相关。通常在高效的团队内，发布频率会达到每天多次发布、部署时间和平均修复故障时间都小于一小时，部署变更的失败率也能维持在15%以下。</p></li></ol></blockquote></blockquote><h4 id="4-1-5-软件交付能力指标"><a href="#4-1-5-软件交付能力指标" class="headerlink" title="4.1.5 软件交付能力指标"></a>4.1.5 软件交付能力指标</h4><p>在评价互联网公司的软件交付能力的时候，通常会使用两个指标：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271343658.png"></p><ol><li><p>仅涉及一行代码的改动需要花费多少时间才能部署上线，这也是<strong>核心指标</strong>。</p></li><li><p>开发团队是否在以一种可重复、可靠的方式在执行软件交付。</p></li></ol><p>目前，国外的主流互联网企业部署周期都以分钟为单位， Amazon、Google这些头部互联网企业单日的部署频率都在20000次以上。国内以百度、阿里、腾讯三大互联网巨头的数据来看，单日部署的频率也达到了单日8000次以上。高频率的部署代表着能够更快更好的响应客户的需求。</p><h3 id="4-2-如何做到高效的持续交付"><a href="#4-2-如何做到高效的持续交付" class="headerlink" title="4.2 如何做到高效的持续交付"></a>4.2 如何做到高效的持续交付</h3><h4 id="4-2-1-持续交付方法"><a href="#4-2-1-持续交付方法" class="headerlink" title="4.2.1 持续交付方法"></a>4.2.1 持续交付方法</h4><p>为了能更好的做到高效的持续交付。在此我们提供了一个<strong>三层叠加的持续交付方法</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271345629.png"></p><p>首先最上层，持续交付的<strong>总目标是价值交付</strong>，要为用户交付有价值的内容。</p><p>然后第二层包含了业务、流程、组织三个维度。</p><p>在业务这一维度，主要通过精益、用户故事地图、看板三种方式来减少业务部门与开发部门的沟通困难。</p><p>在流程这一维度，主要集中于创建一个供开发、测试、运维人员使用的可靠、可重复的流水线，将这种流水线应用于项目的流程中。</p><p>在组织这一维度，要求加强团队协作，提高项目质量和项目改进能力，并且引入了成熟度模型用于评估团队的能力层级。</p><p>如果没有技术能力的支撑，仅依靠方法和指导思想不足以做到高效持续交付。所以<strong>第三层也是最重要的底层是技术层</strong>。技术层包括了基础架构和应用架构。<strong>基础架构</strong>引入了容器集群管理、研发工具平台、持续交付工具链。<strong>应用框架</strong>引入了浮现式设计、微服务框架还有能够抽离出来的配置化架构。</p><h4 id="4-2-2-持续交付、持续集成、持续部署的关系"><a href="#4-2-2-持续交付、持续集成、持续部署的关系" class="headerlink" title="4.2.2 持续交付、持续集成、持续部署的关系"></a>4.2.2 持续交付、持续集成、持续部署的关系</h4><p>要进一步构建可靠可重复的流水线，首先就是要理清持续交付、持续集成和持续部署三者之间的关系。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271348755.png"></p><p>简单来说<strong>持续集成和持续部署是持续交付的基础，持续交付包括但不限于持续集成和持续部署。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271350656.png"></p><p>持续集成是包含了代码的编译、近代检查、单元测试任务的集成，虽然持续集成也能构成一条流水线，但是这条流水线并不完整，而且集成并没有明确的目标。</p><p>近几年得益于虚拟机技术和容器技术的迅速发展，持续部署也逐渐变得简单高效，能够运用这些工具快速将项目部署到例如准入环境、预生产环境等等各种环境中。</p><h4 id="4-2-3-如何构建一个可靠可重复的流水线"><a href="#4-2-3-如何构建一个可靠可重复的流水线" class="headerlink" title="4.2.3 如何构建一个可靠可重复的流水线"></a>4.2.3 如何构建一个可靠可重复的流水线</h4><p>在理清持续交付的关系后，需要通过持续交付来构建一条可靠可重复的流水线，构建这条流水线的目的是为了让开发人员、测试人员、运维人员能更好的协作完成整个项目并上线到生产环境。</p><p>通过对比传统流水线和持续交付流水线，能更加清晰地展现出持续交付流水线的强大。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271351747.png"></p><p>在传统流水线中，首先代码提交要用过填写表单的形式进行版本申请，然后开发人员在离线环境上手工进行代码编译和单元测试，单元测试完成后需要撰写对应的测试报告文档并且向上提测，在系统测试环节需要测试人员手动构建和部署测试环境，完成测试之后再次撰写测试报告，并且申请上线，在通过上线审批之后，在线上生产环境需要再次手动构建环境以及进行生产环境的测试，最终完成整体的开发。</p><p>在持续交付流水线中，代码合入到主干之后会直接触发自动编译，自动编译完成之后会进行初步的自动化单元测试、模块测试和系统测试，在测试过程中持续交付可以自动构建和部署环境。完成系统测试之后会将问题抛出来，解决完成后再次提测，会自动化的再次进行系统测试，通过系统测试之后可以一键操作进行项目发布，并进行预上线，在完成预上线后，可以再次进行一键操作完成正式生产环境的上线。</p><p>通过两种流水线的对比，可以看出来，持续交付的流水线有显著的优势。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271352109.png"></p><p>实际生产中的产品级流水线，可以视为多个模块级流水线的组合，多个模块级流水线组合成为复杂的多线并发的产品级流水线，最终可以完成整个项目的持续交付。</p><h4 id="4-2-4-交付流水线落地工具"><a href="#4-2-4-交付流水线落地工具" class="headerlink" title="4.2.4 交付流水线落地工具"></a>4.2.4 交付流水线落地工具</h4><p>交付流水线的落地需要依靠<strong>落地方案</strong>和<strong>落地工具</strong>，目前常用的落地方案有GoCD，这是thoughtworks的一个产品。还有目前广泛应用的Jenkins和Spinnakeer。</p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271354818.png" style="zoom:50%;" /><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271354355.png" style="zoom:50%;" /><p>常用的交付流水线落地工具有效率云平台中的iPipe工具，在这个工具中可以根据需求创建流水线，并且将相关内容全都关联到流水线中，这样可以让开发人员、测试人员和运维人员在这个工具中直观的看到产品的状态以及质量情况。</p><h3 id="4-3-持续部署"><a href="#4-3-持续部署" class="headerlink" title="4.3 持续部署"></a>4.3 持续部署</h3><p>对于持续交付整体来说，持续部署非常重要。</p><h4 id="4-3-1-持续部署方案"><a href="#4-3-1-持续部署方案" class="headerlink" title="4.3.1 持续部署方案"></a>4.3.1 持续部署方案</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130946.png"></p><p>容器技术目前是部署中最流行的技术，常用的持续部署方案有Kubernetes+Docker和Matrix系统两种。容器技术一经推出就被广泛的接受和应用，主要原因是对比传统的虚拟机技术有以下几个<strong>优点</strong>：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130129.png"></p><ol><li>容器技术上手简单，轻量级架构，体积很小。</li><li>容器技术的集合性更好，能更容易对环境和软件进行打包复制和发布。</li></ol><p>容器技术的引入为软件的部署带来了前所未有的改进，不但<strong>解决了复制和部署麻烦</strong>的问题，还能<strong>更精准的将环境中的各种依赖进行完整的打包。</strong></p><h4 id="4-3-2-部署原则"><a href="#4-3-2-部署原则" class="headerlink" title="4.3.2 部署原则"></a>4.3.2 部署原则</h4><p><strong>在持续部署管理的时候，需要遵循一定的原则，内容包括以下几点：</strong></p><ol><li>部署包全部来自统一的存储库。</li><li>所有的环境使用相同的部署方式。</li><li>所有的环境使用相同的部署脚本。</li><li>部署流程编排阶梯式晋级，即在部署过程中需要设置多个检查点，一旦发生问题可以有序的进行回滚操作。</li><li>整体部署由运维人员执行。</li><li>仅通过流水线改变生产环境，防止配置漂移。</li><li>不可变服务器。部署方式采用蓝绿部署或金丝雀部署。</li></ol><h4 id="4-3-3-部署层次"><a href="#4-3-3-部署层次" class="headerlink" title="4.3.3 部署层次"></a>4.3.3 部署层次</h4><p>部署层次的设置对于部署管理来说也是非常重要的。首先要明确部署的目的并不是部署一个可工作的软件，而是<strong>部署一套可正常运行的环境</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271634406.png"></p><p><strong>完整的镜像部署包括三个环节：Build – Ship – Run。</strong></p><p>Build跟传统的编译类似，将软件编译形成RPM包或者Jar包。</p><p>Ship则是将所需的第三方依赖和第三方插件安装到环境中。</p><p>Run就是在不同的地方启动整套环境。</p><p>制作完成部署包之后，每次需要变更软件或者第三方依赖、插件升级的时候，不需要重新打包，直接更新部署包即可。</p><h4 id="4-3-4-不可变服务器"><a href="#4-3-4-不可变服务器" class="headerlink" title="4.3.4 不可变服务器"></a>4.3.4 不可变服务器</h4><p>在部署原则中提到的不可变服务器原则对于部署管理来说非常重要。不可变服务器<strong>是技术逐步演化的结果。</strong></p><p>在早期阶段，软件的部署是在物理机上进行的，每一台服务器的网络、存储、软件环境都是不同的，物理机的不稳定让环境重构变得异常困难。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271635334.png"></p><p>后来逐渐发展为虚拟机部署，在虚拟机上借助流程化的部署能较好的构建软件环境，但是第三方依赖库的重构不稳定为整体部署带来了困难。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130431.png"></p><p>现阶段使用容器部署不但继承和优化了虚拟机部署的优点，而且很好的解决了第三方依赖库的重构问题，容器部署就像一个集装箱，直接把所有需要的内容全部打包进行复制和部署。</p><h4 id="4-3-5-蓝绿部署和金丝雀部署"><a href="#4-3-5-蓝绿部署和金丝雀部署" class="headerlink" title="4.3.5 蓝绿部署和金丝雀部署"></a>4.3.5 蓝绿部署和金丝雀部署</h4><p>在部署原则中提到两大部署方式分别为蓝绿部署和金丝雀部署。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271635700.png"></p><p><strong>蓝绿部署</strong>是指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速的将用户环境切回旧版本，并对新版本进行修复和调整。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271636728.png"></p><p><strong>金丝雀部署</strong>是指当有新版本发布的时候，先让少量的用户使用新版本并且观察新版本是否存在问题，如果出现问题，就及时处理并重新发布，如果一切正常，就稳步的将新版本适配给所有的用户。</p><h4 id="4-3-6-服务描述"><a href="#4-3-6-服务描述" class="headerlink" title="4.3.6 服务描述"></a>4.3.6 服务描述</h4><p>服务描述要实现的目标是当软件部署到不同的环境中时，通过服务描述来<strong>规避环境配置的差异</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637518.png"></p><p>在服务描述中，通常会对不同的环境下所需的配置进行描述，例如所需要的CPU、内存、网络等。当实际部署的时候，如果出现环境差异，调度工具就可以按照服务描述的配置发放资源，使环境能够正常运行。</p><h4 id="4-3-7-流程控制"><a href="#4-3-7-流程控制" class="headerlink" title="4.3.7 流程控制"></a>4.3.7 流程控制</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637506.png"></p><p>在部署阶段，为了防止意外问题的发生，会在一些环节<strong>加入人工审核</strong>。例如在灰度发布工具中，就会先对线上机器进行分组部署，然后由人工去分组检查，如果没有问题，就进行下一组的部署，如果出现问题，人工就可以及时的进行回滚操作，避免问题扩大到更多地线上环境中。</p><h4 id="4-3-8-数据度量和分析"><a href="#4-3-8-数据度量和分析" class="headerlink" title="4.3.8 数据度量和分析"></a>4.3.8 数据度量和分析</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637498.png"></p><p>在完成持续部署或持续交付之后，需要结合多个维度的数据对项目整体的<strong>研发效率和部署效率进行分析</strong>。例如通过交付时间周期的长短变化来反映流水线为团队带来的价值。再比如通过筛选和展示团队的相关数据，方便团队来进行决策。还有通过环比汇总数据来分析变化的趋势。系统也会通过数据的自动分析和异常报表监控一些关键指标，一旦关键数据出现问题，系统能够及时联系关键人员关注。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271640201.png"></p><p>通过以上的例子能够发现，<strong>持续交付与量化驱动改进是密不可分的</strong>，团队能够在度量中发现问题，在度量中看到进步。持续交付就是这样一个不断改进不断优化的过程，通过数据可以量化产出并且指引团队找到痛点并且进一步的深化改进。</p><h1 id="二、百度高效研发实战训练营Step2"><a href="#二、百度高效研发实战训练营Step2" class="headerlink" title="二、百度高效研发实战训练营Step2"></a>二、百度高效研发实战训练营Step2</h1><h2 id="1-代码的艺术"><a href="#1-代码的艺术" class="headerlink" title="1 代码的艺术"></a>1 代码的艺术</h2><h3 id="1-1-《代码的艺术》目的解读"><a href="#1-1-《代码的艺术》目的解读" class="headerlink" title="1.1 《代码的艺术》目的解读"></a>1.1 《代码的艺术》目的解读</h3><h4 id="1-1-1-了解公司与学校写代码的不同"><a href="#1-1-1-了解公司与学校写代码的不同" class="headerlink" title="1.1.1 了解公司与学校写代码的不同"></a>1.1.1 了解公司与学校写代码的不同</h4><p>在公司写程序和在学校写程序有很大的不同。</p><p>在学校写程序时，对于代码的质量要求比较低。</p><p>当进入公司之后，做的是工业级的产品，服务用户量可能会到达亿万级，所以相对而言对于代码的质量要求比较高。<em>一些伟大产品中的代码，甚至可以被称为艺术品。</em></p><h4 id="1-1-2-消除对于程序员这个职业的误解"><a href="#1-1-2-消除对于程序员这个职业的误解" class="headerlink" title="1.1.2 消除对于程序员这个职业的误解"></a>1.1.2 消除对于程序员这个职业的误解</h4><p>很多人都对程序员这个职业有误解，认为程序员就是码农，认为程序员35岁之后就写不出代码了。还有人认为程序员未来的唯一出路是以后做管理。</p><p>希望通过这门课程的学习，能使大家对于程序员有一个新的认识，消除误解。</p><h4 id="1-1-3-建立对软件编程的正确认识"><a href="#1-1-3-建立对软件编程的正确认识" class="headerlink" title="1.1.3 建立对软件编程的正确认识"></a>1.1.3 建立对软件编程的正确认识</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272315701.png"></p><p>在做一件事物时，我们常说“知”与“行”要合一。即：我们需要对这件事物有一个正确的认识，才会有正确的行动。同理，<em>写出好代码的前提，是对软件编程有正确的认识</em>。</p><h4 id="1-1-4-明确作为软件工程师的修炼方向"><a href="#1-1-4-明确作为软件工程师的修炼方向" class="headerlink" title="1.1.4 明确作为软件工程师的修炼方向"></a>1.1.4 明确作为软件工程师的修炼方向</h4><p>艺术品是由艺术家创造的。艺术家的修炼是有方式方法的。同样，软件工程师的修炼也是方式有方法的。希望通过这门课程，能使大家对软件工程师这个职业有一个全新的认识。</p><h3 id="1-2-代码与艺术之间的关系"><a href="#1-2-代码与艺术之间的关系" class="headerlink" title="1.2 代码与艺术之间的关系"></a>1.2 代码与艺术之间的关系</h3><h4 id="1-2-1-代码是可以被称为艺术的"><a href="#1-2-1-代码是可以被称为艺术的" class="headerlink" title="1.2.1 代码是可以被称为艺术的"></a>1.2.1 代码是可以被称为艺术的</h4><p>艺术，是多种多样、丰富多彩的。同时艺术也是有多个层次的，其实，在我们编写代码时，我们的脑海中也会有类似的感觉。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272319344.png"></p><p>艺术就是人类通过借助特殊的物质材料与工具，运用一定的审美能力和技巧，在精神与物质材料、心灵与审美对象的相互作用下，进行的充满激情与活力的创造性劳动，可以说它是一种精神文化的创造行为，是人的意识形态和生产形态的有机结合体。</p><p>写代码也恰恰要经历这样的一个过程。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272319626.png"></p><p>在编写代码的过程中：</p><p>我们<em>借助的物质是计算机系统，借助的工具是设计、编写、编译、调试、测试等</em>。</p><p>同样，编写代码需要激情。而且，编写代码是一件非常具有创造性的工作。</p><p>代码是人类智慧的结晶，代码反映了一个团队或一个人的精神。<em>代码可以被称为是艺术的。</em></p><h4 id="1-4-2-艺术可以从不同的角度进行解读、研究与创造"><a href="#1-4-2-艺术可以从不同的角度进行解读、研究与创造" class="headerlink" title="1.4.2 艺术可以从不同的角度进行解读、研究与创造"></a><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272320545.png">1.4.2 艺术可以从不同的角度进行解读、研究与创造</h4><p>达芬奇有多幅著名的画作。拿著名的《蒙娜丽莎》这幅画来举例：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272322121.png"></p><p>站在观众的角度，可能只是在欣赏画中的人物微笑。但是对于画家来说，可能就会考虑画画的手法、构图、光线明暗、色彩对比等等方面。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272323753.png"></p><p>在艺术方面，可以站在很多不同的角度进行解读。</p><p>但是如果要成为一名创作者，我们需要的不仅仅是欣赏的能力，更重要的是<em>从多角度进行解读、研究与创造的能力</em>。</p><h4 id="1-4-3-写代码如同艺术创作"><a href="#1-4-3-写代码如同艺术创作" class="headerlink" title="1.4.3 写代码如同艺术创作"></a>1.4.3 写代码如同艺术创作</h4><p>写代码的内涵是：</p><ol><li>写代码这个过程是一个<em>从无序到有序</em>的过程。</li><li>写代码需要把现实问题转化为数学模型。在写代码的过程中，我们需要有很好的模型能力。</li><li>写代码实际是一个认识的过程。很多时候，编码的过程也是我们认识未知问题的过程。</li><li>在写代码的过程中，我们需要综合的全方位的能力。包括把握问题的能力、建立模型的能力、沟通协助的能力、编码执行的能力等等。</li><li>在写好代码之前，首先需要建立品位。品味是指我们首先要知道什么是好的代码，什么是不好的代码。这样我们才能去不断地调整自己的行为，然后去学习，去提高我们的编码能力，写出具有艺术感的代码。</li></ol><h3 id="1-3-软件工程师不等于码农"><a href="#1-3-软件工程师不等于码农" class="headerlink" title="1.3 软件工程师不等于码农"></a>1.3 软件工程师不等于码农</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272336586.png"></p><p>软件工程师不能只会写代码，更需要具有综合的素质。这个综合的素质包括：</p><h4 id="1、技术"><a href="#1、技术" class="headerlink" title="1、技术"></a>1、技术</h4><p><em><strong>技术能力是基础。</strong></em>包括但不限于编码能力、数据结构和算法能力、系统结构知识、操作系统知识、计算机网络知识、分布式系统知识等等。</p><h4 id="2、产品"><a href="#2、产品" class="headerlink" title="2、产品"></a>2、产品</h4><p>要对产品业务有深刻的理解，需要了解产品交互设计、产品数据统计、产品业务运营等。</p><h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><p>要了解一些管理知识，需要知道项目是怎么管理的 ，如何去协调多个人一起去完成一个项目。有一些项目需要具有很强的研究与创新方面的能力。</p><p>以上这些能力素质，是一个软件工程师需要具有的综合素质。要成为一个全部掌握这些素质系统工程师至少需要8~10年的时间。</p><p>所以，软件工程师绝对不是一个只会简单编写代码就可以的职业。<em><strong>软件工程师不等于码农。</strong></em></p><h3 id="1-4-正确认识代码实践方面的问题"><a href="#1-4-正确认识代码实践方面的问题" class="headerlink" title="1.4 正确认识代码实践方面的问题"></a>1.4 正确认识代码实践方面的问题</h3><h4 id="1-4-1-什么是好代码，好的代码有哪些标准"><a href="#1-4-1-什么是好代码，好的代码有哪些标准" class="headerlink" title="1.4.1 什么是好代码，好的代码有哪些标准"></a>1.4.1 什么是好代码，好的代码有哪些标准</h4><p><strong>好代码的标准是：</strong></p><p>①高效、②鲁棒、③简洁、④简短、⑤可共享、</p><p>⑥可测试、⑦可移植、⑧可监控、⑨可运维、⑩可扩展。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130734.png"></p><blockquote><p>将以上十条标准进行总结精简，可以归纳为：</p><p>（1）代码的正确和性能；</p><p>（2）代码的可读和可维护性；</p><p>（3）代码的可运维和可运营；</p><p>（4）代码的可共享和可重用。</p></blockquote><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280007786.png"></p><p>了解完好代码的标准，接下来我们来看一下不好的代码主要表现在哪些方面：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280005709.png"></p><ol><li>不好的函数名</li></ol><p>​    比如，在函数名中，加my等单词，这属于很不专业的用法。</p><ol start="2"><li>不好的变量名</li></ol><p>​    比如，看不出任何含义的a,b,c,j,k,temp等变量名。</p><ol start="3"><li>没有注释或注释不清晰</li></ol><p>​    没有注释的代码是非常难读懂的。注释不清晰往往是因为文字功底或者描述能力欠缺，从而导致无法通过注释把代码的执行原理讲解清楚。</p><ol start="4"><li>一个函数执行多个功能</li></ol><p>​    比如LoadFromFileAndCalculate()函数，它既执行了文件中去加载数据，还执行了计算功能。像这样的函数，我们建议把它切分成两个单独的函数。</p><ol start="5"><li>不好的代码样式排版</li></ol><p>​    代码的样式排版在某种程度上体现了代码的一种逻辑。好的代码排版能增强代码的可读性和逻辑性。我们在写代码时，要规避不好的代码样式排版。</p><ol start="6"><li>难以测试的代码</li></ol><p>​    代码没法测试，难写测试用例，这些都是一些不好的表现。</p><h4 id="1-4-2-好的代码从哪里来"><a href="#1-4-2-好的代码从哪里来" class="headerlink" title="1.4.2 好的代码从哪里来"></a>1.4.2 好的代码从哪里来</h4><p>代码不只是“写”出来的。实际上，在整个项目中，真正的编码时间约占项目整体时间的10%。<em>好的代码是多个环节工作共同作用的结果。</em></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280009655.png"></p><p>这些环节包括：</p><blockquote><ol><li>在编码前，要进行需求分析和系统设计。</li><li>在编码过程中，要注意做单元测试。</li><li>在编码后，要做集成测试，要上线，要持续运营，要迭代改进。</li></ol></blockquote><p>一个好的系统或产品，是以上几个环节持续循环的结果。</p><p>接下来我们着重介绍一下重点环节——<em>需求分析和系统设计</em>。</p><p><strong>1. 认识需求分析和系统设计的重要性</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280011841.png"></p><p>需求分析和系统设计在软件开发中经常被忽略或轻视，但是这两点都是非常重要的环节。</p><p>人们的直觉往往是拿到一个项目就想尽快把它写出来并运行，感觉这样的路径是最快的。</p><p>但是实际上在软件前期需求分析和系统设计投入更多的成本，会在后期节省更多的消耗。即：<em>前期更多的投入，收益往往最大</em>。</p><p>原因是：如果我们开始的设计做错的话，那么后期开发、测试、上线、调试这些成本都会被浪费掉。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280010793.png"></p><p><strong>2. 清楚需求分析和系统设计的差别</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292126264.png"></p><p>需求分析和系统设计是有泾渭分明的区别的，为了避免这两者相互混杂，我们需要清楚需求分析和系统设计各自的内涵。</p><p><em>需求分析主要是定义系统或软件的黑盒行为，即：外部行为。</em>比如，系统从外部来看能够执行什么功能。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280011809.png"></p><p><em>系统设计主要是设计系统或软件的白盒机制。即：内部行为。</em>比如，系统从内部来看，是怎么做出来的，为什么这么做。</p><p><strong>3.  需求分析的注意要点</strong></p><p>要点一：清楚怎么用寥寥数语勾勒出一个系统的功能。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280012501.png"></p><p>每个系统都有自己的定位，我们可以从简洁的总体描述，展开到具体的需求描述。</p><blockquote><p>需求描述的内容基本包括：</p><ol><li><p>系统类型描述</p></li><li><p>系统规模描述</p></li><li><p>系统定位和系统差异描述</p></li><li><p>系统对外接口功能描述</p></li></ol></blockquote><p>要点二：需求分析需要用精确的数字来描述。</p><p>需求分析中会涉及大量的数据分析，这些分析都需要精确的数字来进行支撑。</p><p><strong>4. 系统设计的注意要点</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280014355.png"></p><p><strong>要点一、清楚什么是系统架构</strong></p><p><em>系统架构，英文名 System Architectrue。</em>在wiki上有一个英文定义阐述了系统架构是一个概念的模型，它定义了系统的结构、行为、更多的视图。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280017695.png"></p><p>进一步解读系统架构，它的几个要素是：</p><p>①系统要完成哪些功能</p><p>②系统如何组成</p><p>③功能在这些组成部分之间如何划分</p><p><strong>要点二、注意系统设计的约束</strong></p><p><em>重点是资源的限制。</em>比如，计算的资源限制，存储的资源限制，IO网络的资源限制等。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280018199.png"></p><p><strong>要点三、清楚需求是系统设计决策的来源</strong></p><p>精确定义需求中的各个细节，以及量的定义，对系统设计的决策起着重要的作用。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130393.png"></p><p><strong>要点四、系统设计的风格与哲学</strong></p><p><em>在同样的需求下，可能出现不同的设计方式。</em>即目的相同，设计不同。比如：复杂指令集和精简指令集的设计差异。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130655.png"></p><p>一个好的系统是<em>在合适假设下的精确平衡</em>。一个通用的系统在某些方面是不如专用系统的。每个系统每个组件的功能都应该足够的专一和单一。每个组件是指子系统或模块等。功能的单一是复用和扩展的基础。倘若不单一，未来就有可能很难进行复用和扩展。</p><p>子系统或模块之间的关系应该是<em>简单而清晰的</em>。软件中最复杂的是耦合，如果各系统之间的接口定义非常复杂，那么未来便很难控制系统的健康发展。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280019144.png"></p><p>值得注意的是，使用全局变量就是在增加系统的耦合，从而增加系统的复杂性，所以<em>在系统中需要减少使用全局变量。</em></p><p><strong>要点五、清楚接口的重要性</strong></p><p><em>接口，英文名Interface。</em>系统对外的接口比系统实现本身还要更加重要，接口的设计开发不容忽视。</p><p><strong>接口主要包括：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280019599.png"></p><p><strong>接口重要的原因在于：</strong></p><p>①接口定义了功能。如果定义的功能不正确，那么系统的可用性与价值便会大打折扣。</p><p>②接口决定了系统和系统外部之间的关系。相对于内部而言，外部关系确定后非常难以修改。</p><p>接口的修改需要非常慎重且要考虑周全。</p><p><strong>后期接口修改时主要注意两点：</strong></p><ol><li>合理好用。新改的接口应该是非常合理好用的。不能使调度方感觉我们做的接口非常难以使用。</li><li>修改时需要向前兼容。新改的接口应该尽量实现前项的兼容。不能出现当新接口上线时其他程序无法使用的情况。</li></ol><h4 id="1-4-3-如何写好代码"><a href="#1-4-3-如何写好代码" class="headerlink" title="1.4.3 如何写好代码"></a>1.4.3 如何写好代码</h4><h5 id="1-代码也是一种表达方式"><a href="#1-代码也是一种表达方式" class="headerlink" title="1 代码也是一种表达方式"></a>1 代码也是一种表达方式</h5><p>在一个项目中，软件的维护成本远远高于开发成本，而且超过50%的项目时间都是用于沟通。</p><p>常规意义的沟通方式主要有面对面交流、Email、文档或网络电话会议等。但是其实 <em>代码也是一种沟通方式</em>。</p><p>在计算机早期，我们使用机器语言或汇编语言，更多的是考虑代码如何更高效率地执行。</p><p>然而，随着技术的进步，代码编译器的逐渐完善，我们写代码时更多的是要考虑如何让其他人看得懂、看得清楚。于是，<strong><em>编程规范应运而生</em>。</strong></p><p><strong>编程规范主要包含：</strong></p><ol><li>如何规范的表达代码。 </li><li>语言使用的相关注意事项。</li></ol><p><strong>基于编程规范，看代码的理想场景是：</strong></p><ol><li>看别人的代码，感觉和看自己的代码一样。</li><li>看代码时能够专注于逻辑，而不是格式方面。</li><li>看代码时不用想太多。</li></ol><h5 id="2-代码书写过程中的细节问题"><a href="#2-代码书写过程中的细节问题" class="headerlink" title="2 代码书写过程中的细节问题"></a>2 代码书写过程中的细节问题</h5><h6 id="1-关于模块"><a href="#1-关于模块" class="headerlink" title="1. 关于模块"></a>1. 关于模块</h6><p><strong>模块，是程序的基本组成单位</strong>。在一个模块内，会涉及它的数据、函数或类。对于Python、Go、C语言这样的程序来说，一个后缀名为.py 、 .c或.go的文件就是一个模块。</p><p>每一个模块需要有明确的功能。需要符合<em><strong>紧内聚，松耦合</strong></em>。模块切分的是否合理对于软件架构的稳定起着至关重要的左右。</p><p>切分模块的方法：</p><p>先区分数据类的模块和过程类的模块。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280041920.png"></p><p><strong>数据类的模块：</strong>主要是要完成<em><strong>对数据的封装</strong></em>。封装往往是通过模块内部变量或类的内部变量来实现的。</p><p><strong>过程类的模块：</strong>本身不含数据。过程类模块可以<em><strong>从文件中去读取一个数据</strong></em>，或者执行一些相关的操作。过程类模块可以调用其他数据类模块或过程类模块。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292131236.png"></p><p>编写程序时，我们需要注意减少模块间的耦合。<em><strong>减少模块间的耦合，有利于降低软件复杂性，明确接口关系</strong>。</em></p><h6 id="2-关于类和函数"><a href="#2-关于类和函数" class="headerlink" title="2. 关于类和函数"></a>2. 关于类和函数</h6><p>类和函数是两种不同的类型，有他们各自适用的范围。另外，遇见和类的成员变量无关的函数时，可以将该函数抽出来，作为一个独立的函数使用，这样便于未来的复用。</p><h6 id="3-关于面向对象"><a href="#3-关于面向对象" class="headerlink" title="3. 关于面向对象"></a>3. 关于面向对象</h6><p>面向对象，是一个优秀的编程方法和范式，但是真正理解的人并不多。</p><p>面向对象的<em><strong>本质是数据封装</strong></em>。这就要求我们在写程序的过程中应该<em><strong>从数据的角度开始想问题</strong></em>，而不是从执行过程的角度开始想问题。</p><p>我们需要注意一个普遍的错误认知，即：C语言是面向过程的，C++是面向对象的。</p><p>实际上，<strong><em>C语言是基于对象的，它和C++的区别主要是没有多态和继承</em>。</strong></p><p>C++是一个经常被滥用的语言。因为C++有太强的功能。</p><p>作为软件工程师，我们最重要的任务是去实现出我们所需要的功能，语言只是我们的工具。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280052593.png"></p><p>另外，在系统中，我们应该<em><strong>谨慎地使用多态和继承</strong></em>。如果一个系统中，类的继承超过三层，那么这个系统的复杂度便很难把握。</p><p>有这样一个悖论：很好的继承模型是基于对需求的准确把握，而在我们在初始设计阶段往往对需求理解的不透彻。系统在初始阶段可能只是一个很简单的原型，然后通过不断地迭代完善，才逐步发展起来变好的。</p><h6 id="4-关于模块内部的组成"><a href="#4-关于模块内部的组成" class="headerlink" title="4. 关于模块内部的组成"></a>4. 关于模块内部的组成</h6><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280051076.png"></p><p>一个模块，比如.py、.c或.go这样一个模块，它的内部组成主要是：在文件头中，需要对模块的功能进行简要说明。需要把文件的修改历史写清楚，包括修改时间、修改人和修改内容。在模块内，内容的顺序尽量保持一致，以方便未来对内容的搜索查询。</p><h6 id="5-关于函数"><a href="#5-关于函数" class="headerlink" title="5. 关于函数"></a>5. 关于函数</h6><p>函数的切分同样是非常重要的。对于一个函数来说，要有明确的单一功能。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280051088.png"></p><p>函数描述三要素包括<em><strong>功能、传入参数和返回值</strong></em>。</p><ol><li>功能描述是指描述这个函数是做什么的、实现了哪些功能。</li><li> 传入参数描述是指描述这个函数中传入参数的含义和限制条件。</li><li>返回值描述是指描述这个函数中返回值都有哪些可能性。</li></ol><p><em><strong>函数的规模要足够的短小</strong></em>，这是写好程序的秘诀之一。bug往往出现在那些非常长的函数里。</p><p>在函数头中，需要对函数的语义做出清晰和准确的说明。我们需要<em><strong>注意函数的返回值</strong></em>。在写函数时，要判断函数的语义，确定返回值的类型。</p><p><strong>基于函数的语义，函数的返回值有三种类型。</strong></p><p><em><strong>第一种类型</strong></em>：在“逻辑判断型”函数中，返回布尔类型的值——True或False，表示“真”或“假”。</p><p><em><strong>第二种类型</strong>：</em>在“操作型”函数中，作为一个动作，返回成功或失败的结果——SUCCESS或ERROR。</p><p><em><strong>第三种类型</strong>：</em>在“获取数据型”函数中，返回一个“数据”，或者返回“无数据/获取数据失败”。</p><p><em><strong>以“单入口、单出口”的方式书写</strong></em>的方式能够比较清晰地反映出函数的逻辑。尤其是在实现多线程的数据表中，推荐使用一个内部函数来实现“单入口单出口”的方式。</p><h6 id="6-关于代码注释"><a href="#6-关于代码注释" class="headerlink" title="6. 关于代码注释"></a>6. 关于代码注释</h6><p>要重视注释，书写注释要做到清晰明确。在编写程序的过程中，<strong><em>先写注释，后写代码</em>。</strong></p><h6 id="7-关于代码块"><a href="#7-关于代码块" class="headerlink" title="7. 关于代码块"></a>7. 关于代码块</h6><p>代码块的讨论范围是在一个函数内的代码实现。书写代码块的思路是<em><strong>先把代码中的段落分清楚</strong></em>。文章有段落，代码同样有段落。代码的段落背后表达的是我们对于代码的逻辑理解。包括<em><strong>代码的层次、段落划分、逻辑</strong></em>。代码中的空行或空格是帮助我们表达代码逻辑的，并非可有可无。好的代码可以使人在观看时做过一眼明了。</p><h6 id="8-关于命名"><a href="#8-关于命名" class="headerlink" title="8. 关于命名"></a>8. 关于命名</h6><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280053731.png"></p><p>命名包括系统命名、子系统命名、模块命名、函数命名、变量命名、常量命名等。</p><p>我们要清楚命名的重要性。<strong>命名重要的主要原因为：</strong></p><p>一是“望名生义”是人的自然反应。不准确的命名会使人产生误导。</p><p>二是概念是建立模型的出发点。好的命名是系统设计的基础。</p><p>命名中普遍存在的问题有：</p><p>一是名字中不携带任何信息。</p><p>二是名字携带的信息是错误的。</p><p>命名<strong><em>关系着代码的可读性</em>，</strong>需要仔细思考。<em><strong>命名的基本要求是准确、易懂。</strong></em>提高代码命名可读性的方式之一是：<em><strong>在名字的格式中加入下划线、驼峰等。</strong></em></p><h6 id="9-关于系统的运营"><a href="#9-关于系统的运营" class="headerlink" title="9. 关于系统的运营"></a>9. 关于系统的运营</h6><p>在互联网时代，系统非常依赖运营。并不是我们把代码写完调试通了就可以。</p><p>在系统运营过程中，<strong><em>代码的可监测性非常重要</em>。</strong>很多程序都是通过线上的不断运行、不断监测、不断优化而迭代完善的，所以我们在编写代码的过程中，要注意尽可能多地暴露出可监控接口。</p><p>对于一个系统来说，<strong><em>数据和功能同等重要</em>。</strong></p><p>数据收集很重要，数据量够大才能知道这个项目或这个系统的具体收益。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280056080.png"></p><p>关于系统的运营，我们在设计和编码阶段就需要考虑。即：在设计和编码阶段，提供足够的状态记录，提供方便的对外接口。</p><h3 id="1-5-怎样修炼成为优秀的软件工程师"><a href="#1-5-怎样修炼成为优秀的软件工程师" class="headerlink" title="1.5 怎样修炼成为优秀的软件工程师"></a>1.5 怎样修炼成为优秀的软件工程师</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280057161.png"></p><p>通常人们在判断一名软件工程师的水平时，都会用工作时间、代码量、学历、曾就职的公司等等这类外部因素作为评判标准。</p><p>修炼成为优秀的软件工程师，<strong>重要的因素有三点：</strong></p><ol><li>学习-思考-实践</li><li>知识-方法-精神</li><li>基础知识是根本</li></ol><h4 id="1-5-1-学习-思考-实践"><a href="#1-5-1-学习-思考-实践" class="headerlink" title="1.5.1 学习-思考-实践"></a>1.5.1 <strong>学习-思考-实践</strong></h4><h5 id="（1）多学习"><a href="#（1）多学习" class="headerlink" title="（1）多学习"></a><strong>（1）多学习</strong></h5><p>软件编写的历史已经超过半个世纪，有太多的经验可以借鉴学习。要不断的学习进步。</p><h5 id="（2）多思考"><a href="#（2）多思考" class="headerlink" title="（2）多思考"></a><strong>（2）多思考</strong></h5><p>学而不思则罔，思而不学则殆。对于做过的项目要去深入思考，复盘写心得。</p><h5 id="（3）多实践"><a href="#（3）多实践" class="headerlink" title="（3）多实践"></a><strong>（3）多实践</strong></h5><p>要做到知行合一，我们大部分的心得和成长其实是来自于实践中的经历。在学习和思考的基础之上，要多做项目，把学到的理论运用到真正的工作中。</p><h4 id="1-5-2-知识-方法-精神"><a href="#1-5-2-知识-方法-精神" class="headerlink" title="1.5.2 知识-方法-精神"></a>1.5.2 知识-方法-精神</h4><p>互联网的发展日新月异，对于软件开发来说，知识永远在增加，所以在变化快速的知识世界中，<strong><em>最好的方式是找到方法</em>。</strong></p><p>方法就是用来分析问题和解决问题的。虽然说起来简单，但是适合每个人的方法都需要自己去寻找和总结。</p><p>在大多数人的成长过程中，并不单单只是鲜花和掌声，更多的时候是在和困难荆棘做斗争。而真正能做出成就的人，都有着远大理想和宏伟志向。所以，光有知识和方法往往是不够的，还需要有精神作为支撑。</p><p>几个精神理念：</p><ol><li><strong>自由精神、独立思想。</strong></li></ol><p>人一定要有自己的思考。不要人云亦云，不要随波逐流。</p><ol start="2"><li><strong>对完美的不懈追求。</strong></li></ol><p>不要做到一定程度就满意了，而是要去不断的追求一个更好的结果。</p><h4 id="1-5-3-基础知识是根本"><a href="#1-5-3-基础知识是根本" class="headerlink" title="1.5.3 基础知识是根本"></a>1.5.3 基础知识是根本</h4><p>唐朝著名宰相魏征曾经对唐太宗说过：“求木之长者，必固其根本；欲流之远者，必浚其泉源”，充分表达了基础乃治学之根本。</p><p>对于一个软件工程师来说，需要掌握的基础是非常全面的。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280058449.png"></p><p>包括数据结构、算法、操作系统、系统结构、计算机网络。包括软件工程、编程思想。包括逻辑思维能力、归纳总结能力、表达能力。还包括研究能力、分析问题、解决问题的能力等。这些基础的建立，至少也要5~8年的时间。</p><h2 id="2-Mini-Spider实践"><a href="#2-Mini-Spider实践" class="headerlink" title="2 Mini-Spider实践"></a>2 Mini-Spider实践</h2><h3 id="2-1-多线程编程"><a href="#2-1-多线程编程" class="headerlink" title="2.1 多线程编程"></a>2.1 多线程编程</h3><h4 id="2-1-1-数据互斥访问"><a href="#2-1-1-数据互斥访问" class="headerlink" title="2.1.1 数据互斥访问"></a>2.1.1 数据互斥访问</h4><p>多线程中数据互斥访问的情况非常常见，在真实生产的环境中，经常有开发人员会将一张表的“添加”和“判断是否存在”分为两个接口，这是一种非常常见的错误。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281424954.png"></p><p>以图中的代码为例，左边的代码是正确的写法，<strong>将添加和判断写进一个函数中</strong>。右边的代码是典型的错误代码，编写了两个函数，分别是添加和判断函数。</p><p>事实上，这种将添加和判断写进一个函数并且运行的实现机制是同8086的底层指令集支持密不可分的。</p><h4 id="2-1-2-临界区的注意事项"><a href="#2-1-2-临界区的注意事项" class="headerlink" title="2.1.2 临界区的注意事项"></a>2.1.2 临界区的注意事项</h4><p>在代码中，<strong>有锁来保护的区域被称为临界区</strong>。以图中代码为例，临界区为self.lock.acquire()和self.lock.release()两句话之间的区域。在使用临界区的时候要注意，不要把耗费时间的操作放在临界区内执行。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281429165.png"></p><p>很多开发人员在编写多线程的时候会将耗费时间很多的逻辑放入临界区内，这样会导致无法发挥多线程对于硬件资源最大化利用的优势。</p><h4 id="2-1-3-I-O操作的处理"><a href="#2-1-3-I-O操作的处理" class="headerlink" title="2.1.3 I/O操作的处理"></a>2.1.3 I/O操作的处理</h4><p>在多线程编程中还要注意对于I/O操作的处理。首先在编写代码的时候要注意不能出现无捕捉的exception，以图中最左边的代码为例，如果不对异常进行捕捉，那么一旦出现问题就不会执行self.lock.release()语句，进而导致死锁的发生。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281444010.png"></p><p>其次，因为异常处理是非常消耗资源的，所以我们也不能像图中中间的代码一样，将异常放在临界区内，要像最右边的代码一样处理。</p><h3 id="2-2-细节处理"><a href="#2-2-细节处理" class="headerlink" title="2.2 细节处理"></a>2.2 细节处理</h3><h4 id="2-2-1-种子信息的读取"><a href="#2-2-1-种子信息的读取" class="headerlink" title="2.2.1 种子信息的读取"></a>2.2.1 种子信息的读取</h4><p>很多开发人员会将种子信息读取的逻辑和其他逻辑耦合在一起，这样是错误的。以图中代码为例，虽然通过_get_seeds函数直接读取文件中的信息并没有书写错误，但是如果后续的开发中文件的格式发生了变化，那就需要重新回来修改这部分的代码。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281445680.png"></p><p>通过上述代码可以发现，模块划分和逻辑的复杂程度是没有关系的。即使是逻辑简单的代码，如果没有做好模块划分，也会变得难于维护。</p><h4 id="2-2-2-程序优雅退出"><a href="#2-2-2-程序优雅退出" class="headerlink" title="2.2.2 程序优雅退出"></a>2.2.2 程序优雅退出</h4><p>在真实应用中，很多开发人员在实现程序退出功能的时候使用了非常复杂的机制，导致后期维护难度较高。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281446653.png"></p><p>在实际应用中可以使用python系统库中关于队列的task_done()和join()的机制。</p><p>以图中代码为例，左边的代码就是使用了task_done()，中间的代码是主程序中的一种常规逻辑使用。右边是对中间主程序的一种优化，增加了spider.wait()，让整个逻辑可读性更强，更容易被理解。</p><h4 id="2-2-3-爬虫的主逻辑编码"><a href="#2-2-3-爬虫的主逻辑编码" class="headerlink" title="2.2.3 爬虫的主逻辑编码"></a>2.2.3 爬虫的主逻辑编码</h4><p>很多开发人员编写的主逻辑非常的复杂且难懂。事实上，图中的代码就是一个爬虫的主逻辑的所有代码。可以看到，里面包含了六个步骤。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281448571.png"></p><p>第一步，从队列中拿到任务。</p><p>第二步，读取内容。如果读取失败，则重新读取。如果读取成功，则执行第三步。</p><p>第三步，存储数据。</p><p>第四步，检查数据深度。</p><p>第五步，如果数据深度不足，就进一步解析，并且放到队列中。</p><p>第六步，结束任务。</p><h2 id="3-代码检查规则背景及总体介绍"><a href="#3-代码检查规则背景及总体介绍" class="headerlink" title="3 代码检查规则背景及总体介绍"></a>3 代码检查规则背景及总体介绍</h2><h3 id="3-1-代码检查的意义"><a href="#3-1-代码检查的意义" class="headerlink" title="3.1 代码检查的意义"></a>3.1 代码检查的意义</h3><ol><li>提高代码可读性，统一规范，方便他人维护，长远来看符合公司内部开源战略。</li><li>帮助发现代码缺陷，弥补人工代码评审的疏漏，节省代码评审的时间与成本。</li><li>有助于提前发现问题，节约时间成本，降低缺陷修复成本。</li><li>促进公司编码规范的落地，在规范制定后借助工具进行准入检查。</li><li>提升编码规范的可运营性，针对反馈较多的不合理规范进行调整更新。</li></ol><h3 id="3-2-代码检查场景及工具"><a href="#3-2-代码检查场景及工具" class="headerlink" title="3.2 代码检查场景及工具"></a>3.2 代码检查场景及工具</h3><h4 id="3-2-1-代码检查场景"><a href="#3-2-1-代码检查场景" class="headerlink" title="3.2.1 代码检查场景"></a>3.2.1 代码检查场景</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281541973.png"></p><p>首先是<strong>本地研发环节</strong>，借助客户端工具，在push发起评审之前进行检查。</p><p>若本地代码扫描没有出现问题，就进入第二个环节：<strong>代码准入环节，即Code Review</strong>，这一环节进行增量检查，属于公司强制要求。</p><p>第三个环节：<strong>持续集成环节</strong>，当代码合入到代码库之后，进行全量检查，业务线根据自身需求来配置。</p><h4 id="3-2-2-代码检查工具与服务"><a href="#3-2-2-代码检查工具与服务" class="headerlink" title="3.2.2 代码检查工具与服务"></a>3.2.2 代码检查工具与服务</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281543538.png"></p><p>代码检查的产品，客户端、SCM(icode)、CI(Agile)之间具有交互性，共同构成整个代码检查环节。</p><h4 id="3-2-3-代码检查覆盖范围"><a href="#3-2-3-代码检查覆盖范围" class="headerlink" title="3.2.3 代码检查覆盖范围"></a>3.2.3 代码检查覆盖范围</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281544909.png"></p><p>在<strong>覆盖语言</strong>方面，代码检查目前已经覆盖了包括C++，Java/android, PHP, Python, Go, JS, OC, Kotlin在内的几乎所有主流语言。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281544915.png"></p><p>在<strong>检查维度</strong>方面，代码检查包括编码规范 代码缺陷，开源框架引用安全检查，可维护性(MI)。</p><h4 id="3-2-4-代码检查速度"><a href="#3-2-4-代码检查速度" class="headerlink" title="3.2.4 代码检查速度"></a>3.2.4 代码检查速度</h4><p>编码规范：只扫描变更文件，检查代码变更行是否符合规范，速度较快。</p><p>缺陷检查：需考虑文件依赖、函数调用关系、代码上下文等，相对耗时。</p><h3 id="3-3-代码检查规则分级"><a href="#3-3-代码检查规则分级" class="headerlink" title="3.3 代码检查规则分级"></a>3.3 代码检查规则分级</h3><h4 id="3-3-1-规则等级梳理"><a href="#3-3-1-规则等级梳理" class="headerlink" title="3.3.1 规则等级梳理"></a>3.3.1 规则等级梳理</h4><p>Code Review阶段，所有维度扫描出的问题可以分为以下3个等级：</p><ol><li><p>Error：属于需要强制解决的类型，影响代码合入，应视具体情况不同采取修复、临时豁免、标记误报等措施及时处理；</p></li><li><p>Warning：非强制解决类型，不影响代码含入，很可能存在风险，应尽量修复；</p></li><li><p>Advice：非强制解决类型，级别相对较低，不影响代码含入，可以选择性修复。</p></li></ol><h4 id="3-3-2-机检任务统一"><a href="#3-3-2-机检任务统一" class="headerlink" title="3.3.2 机检任务统一"></a>3.3.2 机检任务统一</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281548620.png"></p><h4 id="3-3-3-评审页行间提示"><a href="#3-3-3-评审页行间提示" class="headerlink" title="3.3.3 评审页行间提示"></a>3.3.3 评审页行间提示</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550018.png"></p><h4 id="3-3-4-针对豁免、误报、咨询的说明"><a href="#3-3-4-针对豁免、误报、咨询的说明" class="headerlink" title="3.3.4 针对豁免、误报、咨询的说明"></a>3.3.4 针对豁免、误报、咨询的说明</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550799.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550899.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550116.png"></p><h2 id="4-代码检查规则：Python语言案例详解"><a href="#4-代码检查规则：Python语言案例详解" class="headerlink" title="4 代码检查规则：Python语言案例详解"></a>4 代码检查规则：Python语言案例详解</h2><h3 id="4-1-Python的代码检查规则"><a href="#4-1-Python的代码检查规则" class="headerlink" title="4.1 Python的代码检查规则"></a>4.1 Python的代码检查规则</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281552034.png"></p><p>Python代码检查规则主要分为四个大类，分别是<strong>代码风格规范、引用规范、定义规范和异常处理规范</strong>。</p><h4 id="4-1-1-代码风格规范"><a href="#4-1-1-代码风格规范" class="headerlink" title="4.1.1 代码风格规范"></a>4.1.1 代码风格规范</h4><h5 id="（1）程序规模规范："><a href="#（1）程序规模规范：" class="headerlink" title="（1）程序规模规范："></a><strong>（1）程序规模规范：</strong></h5><ol><li><p>每行不得超过 120 个字符。</p></li><li><p>定义的函数长度不得超过 120 行。</p></li></ol><p>这意味着，在编写代码时，需要时刻注意自己的程序规模，避免冗余，确保写出简洁而高效的代码。</p><h5 id="（2）语句规范"><a href="#（2）语句规范" class="headerlink" title="（2）语句规范"></a><strong>（2）语句规范</strong></h5><p>因为Python与其他语言不同，可以不需要明确的标识符表示语句的结尾，所以规定：</p><ol start="3"><li><p>禁止以分号结束语句。</p></li><li><p>在任何情况下，一行只能写一条语句。</p></li></ol><h5 id="（3）括号使用规范"><a href="#（3）括号使用规范" class="headerlink" title="（3）括号使用规范"></a><strong>（3）括号使用规范</strong></h5><ol start="5"><li>除非用于明确算术表达式优先级、元组或者隐式行连接，否则尽量避免冗余的括号。</li></ol><h5 id="（4）缩进规范"><a href="#（4）缩进规范" class="headerlink" title="（4）缩进规范"></a><strong>（4）缩进规范</strong></h5><ol start="6"><li>禁止使用Tab进行缩进，而统一使用4个空格进行缩进</li></ol><p>需要将单行内容拆成多行写时规定：</p><ol start="7"><li>与首行保持对齐；或者首行留空，从第二行起统一缩进4个空格。</li></ol><h5 id="（5）空行规范"><a href="#（5）空行规范" class="headerlink" title="（5）空行规范"></a><strong>（5）空行规范</strong></h5><ol start="8"><li>文件级定义（类或全局函数）之间，相隔两个空行；类方法之间，相隔一个空行。</li></ol><h5 id="（6）空格规范"><a href="#（6）空格规范" class="headerlink" title="（6）空格规范"></a><strong>（6）空格规范</strong></h5><ol start="9"><li><p>括号之内均不添加空格。</p></li><li><p>参数列表、索引或切片的左括号前不应加空格。</p></li><li><p>逗号、分号、冒号之前均不添加空格，而是在它们之后添加一个空格。</p></li><li><p>所有二元运算符前后各加一个空格。</p></li><li><p>关键字参数或参数默认值的等号前后不加空格。</p></li></ol><h5 id="（7）注释规范"><a href="#（7）注释规范" class="headerlink" title="（7）注释规范"></a><strong>（7）注释规范</strong></h5><ol start="14"><li>每个文件都必须有文件声明，每个文件声明至少必须包括以下三个方面的信息：版权声明、功能和用途介绍、修改人及联系方式。</li></ol><p>另外在使用文档字符串（docstirng）进行注释时，规定：</p><ol start="15"><li><p>使用docstring描述模块、函数、类和类方法接口时，docstring必须用三个双引号括起来。</p></li><li><p>对外接口部分必须使用docstring描述，内部接口视情况自行决定是否写docstring。</p></li><li><p>接口的docstring描述内容至少包括以下三个方面的信息：功能简介、参数、返回值。如果可能抛出异常，必须特别注明。</p></li></ol><h4 id="4-1-2-引用规范"><a href="#4-1-2-引用规范" class="headerlink" title="4.1.2 引用规范"></a>4.1.2 引用规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281600533.png"></p><p><strong>严格而具体的规定：</strong></p><ol><li>禁止使用 from……import…… 句式直接导入类或函数，而应在导入库后再行调用。</li><li>每行只导入一个库。</li><li>按标准库、第三方库、应用程序自有库的顺序排列import，三个部分之间分别留一个空行。</li></ol><h4 id="4-1-3-定义规范"><a href="#4-1-3-定义规范" class="headerlink" title="4.1.3 定义规范"></a>4.1.3 定义规范</h4><p><strong>（1）在变量定义方面，我们有强制的规范规定：</strong></p><ol><li>局部变量使用全小写字母，单词间使用下划线分隔。</li><li>定义的全局变量必须写在文件头部。</li><li>常量使用全大写字母，单词间使用下划线分隔</li></ol><p><strong>（2）函数的定义规范主要体现在函数的返回值以及默认参数的定义上。</strong></p><p>为提高代码可读性，对于函数的返回值，规范要求为：</p><ol><li>函数返回值必须小于或等于3个。若返回值大于3个，则必须通过各种具名的形式进行包装。</li></ol><p>为了保障函数的运行效率以及降低后期维护和纠错的成本，对于函数默认参数的定义有如下要求：</p><ol start="2"><li>仅可使用以下基本类型的常量或字面常量作为默认参数：整数、bool、浮点数、字符串、None。</li></ol><p><strong>（3）类定义的规范包括了四个方面的内容：</strong></p><ol><li>类的命名使用首字母大写的驼峰式命名法。</li><li>对于类定义的成员：protected成员使用单下划线前缀；private成员使用双下划线前缀。</li><li>如果一个类没有基类，必须继承自object类。</li><li>类构造函数应尽量简单，不能包含可能失败或过于复杂的操作。</li></ol><h4 id="4-1-4-异常处理规范"><a href="#4-1-4-异常处理规范" class="headerlink" title="4.1.4 异常处理规范"></a>4.1.4 异常处理规范</h4><p>在代码编写中应该<strong>尽量避免出现代码异常状态</strong>，然而错误有时在所难免，对于这些异常状态的处理，有着明确的规范要求：</p><ol><li>禁止使用双参数形式或字符串形式的语法抛出异常。</li><li>如需自定义异常，应在模块内定义名为 Error 的异常基类。并且，该基类必须继承自 Exception 。其他异常均由该基类派生而来。</li><li>除非重新抛出异常，禁止使用 except：语句捕获所有异常， 一般情况下，应使except……：语句捕获具体的异常。</li><li>捕捉异常时，应当使用 as 语法，禁止使用逗号语法。</li></ol><h3 id="4-2-Python编码惯例"><a href="#4-2-Python编码惯例" class="headerlink" title="4.2 Python编码惯例"></a>4.2 Python编码惯例</h3><h4 id="4-2-1-让模块既可被导入又可被执行"><a href="#4-2-1-让模块既可被导入又可被执行" class="headerlink" title="4.2.1 让模块既可被导入又可被执行"></a>4.2.1 让模块既可被导入又可被执行</h4><p>python不同于编译型语言，而<strong>属于脚本语言</strong>，是动态的逐行解释运行，没有统一的程序入口。所以，为了方便模块之间的相互导入，我们通常<strong>自定义一个 main 函数，并使用一个if 语句</strong>， if 内置变量 <strong>name</strong> == ‘__main__’ ，在这个if 条件下，再去执行 main函数。这样，我们就能够实现，让模块既可被导入又可执行。</p><h4 id="4-2-2-in运算符的使用"><a href="#4-2-2-in运算符的使用" class="headerlink" title="4.2.2 in运算符的使用"></a>4.2.2 in运算符的使用</h4><p>in一种简洁而高效的运算符，很多时候，合理的使用in运算符，可以<strong>代替大量的重复判断过程</strong>，降低时间复杂度，提高代码的运行效率。</p><h4 id="4-2-3-不使用临时变量交换两个值"><a href="#4-2-3-不使用临时变量交换两个值" class="headerlink" title="4.2.3 不使用临时变量交换两个值"></a>4.2.3 不使用临时变量交换两个值</h4><p>Python有更简洁而高效的语句可以实现交换两个值的操作，并<strong>无必要引入临时变量</strong>来交换两个值。</p><h4 id="4-2-4-用序列构建字符串"><a href="#4-2-4-用序列构建字符串" class="headerlink" title="4.2.4 用序列构建字符串"></a>4.2.4 用序列构建字符串</h4><p>对于一个字符串列表、元组等，可以用序列来构建字符串，<strong>利用一个空字符串和join函数</strong>，就可以避免重复，高效完成相应字符串的构建。</p><h1 id="三、百度高效研发实战训练营Step3"><a href="#三、百度高效研发实战训练营Step3" class="headerlink" title="三、百度高效研发实战训练营Step3"></a>三、百度高效研发实战训练营Step3</h1><h2 id="1-质量意识"><a href="#1-质量意识" class="headerlink" title="1 质量意识"></a>1 质量意识</h2><h3 id="1-1-质量的基本概念"><a href="#1-1-质量的基本概念" class="headerlink" title="1.1 质量的基本概念"></a>1.1 质量的基本概念</h3><h4 id="1-1-1-质量重要性的认识"><a href="#1-1-1-质量重要性的认识" class="headerlink" title="1.1.1 质量重要性的认识"></a>1.1.1 质量重要性的认识</h4><p>随着技术更新，市场竞争的加剧，质量问题成为困扰不少企业的一大难题，也给一些企业造成了巨大的损失，这就使得项目质量的重要性不断凸显。</p><p>通过对于这些失败案例的分析不难发现，项目的质量保证是一个需要<strong>项目全体成员参与</strong>的重要工作，只有在项目团队的共同努力下，才能有效保证项目的质量，为企业和社会创造价值。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281614025.png"></p><p>项目管理三要素为<strong>质量、时间、成本</strong>，三个要素缺一不可、相互制约，一味追求某一要素的做法是不明智的。一个成功的项目必然是在三者的取舍间达成了一个平衡。</p><h4 id="1-1-2-质量保证和测试的关系"><a href="#1-1-2-质量保证和测试的关系" class="headerlink" title="1.1.2 质量保证和测试的关系"></a>1.1.2 质量保证和测试的关系</h4><p>质量问题有很多种，常见的有代码缺陷、产品缺陷、Bug、用户体验差、性能差、服务不稳、安全问题、可兼容性差等。我们经常通过测试来发现问题，并将发现的问题分<strong>功能性测试类问题和用户体验评估类问题。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281615870.png"></p><p>测试工作是质量保证工作中的重要一环，但是我们应该认识到，质量保证工作不能只依靠测试的反馈，而应该贯穿项目开发的整个过程。</p><h4 id="1-1-3-Bug的基本认识"><a href="#1-1-3-Bug的基本认识" class="headerlink" title="1.1.3 Bug的基本认识"></a>1.1.3 Bug的基本认识</h4><p><strong>Bug</strong>是程序中的缺陷和问题，<strong>属于功能性测试类问题的范畴</strong>， Bug是一种很常见的质量问题，也是我们在项目开发中应该尽量减少或避免的质量问题。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281617228.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281618840.png"></p><p>Bug的修复有一套完整的规定流程。</p><p>首先，测试人员或者用户发现Bug后，将其置为<strong>激活状态</strong>；开发人员收到激活状态的Bug后，对其进行修复，修复过程中， Bug状态为<strong>处理中</strong>；修复完成后，开发人员将其置为<strong>解决状态</strong>；测试人员再对其进行<strong>验证</strong>，若通过，则将其关闭，否则，重新激活Bug即重启状态，交予开发人员继续修复，直至验证通过。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292129042.png"></p><p>从这一流程可以看到，<strong>Bug有五种状态，Open（激活）、In Process（处理中）、Resolved（解决）、closed（关闭）、Reopen（重启）</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281621054.png"></p><p>Bug生命周期有一定规律性。以传统软件中的瀑布模型举例，85%的问题在项目初期的编码阶段引入，在后期测试阶段，发现Bug的数量会逐渐增多，与之对应的修复成本也会急剧增加。可见，降低<strong>修复成本最有效的方式，就是在Bug引入的阶段就及时发现并修复Bug。</strong></p><h3 id="1-2-Bug提交方法"><a href="#1-2-Bug提交方法" class="headerlink" title="1.2 Bug提交方法"></a>1.2 Bug提交方法</h3><blockquote><p>Bug提交需要反馈渠道，Bug的反馈渠道分为内部用户反馈渠道和外部用户反馈渠道两种。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281623796.png"></p><ol><li>内部用户反馈渠道包括：产品Icafe空间、产品论坛、Bugs邮件组、Bugs平台。</li><li>外部用户反馈渠道包括：产品自身反馈渠道和产品接入反馈平台。</li></ol></blockquote><p><strong>Bug的提交有严格的格式要求，提交的Bug反馈应包括以下七个方面的内容：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281624518.png"></p><p>正确提交Bug能确保负责人能够清晰了解问题，直接进行数据挖掘，找到Bug所有的属性，便于后续维护工作的开展。</p><h3 id="1-3-质量保证在项目各阶段的实现"><a href="#1-3-质量保证在项目各阶段的实现" class="headerlink" title="1.3 质量保证在项目各阶段的实现"></a>1.3 质量保证在项目各阶段的实现</h3><p>质量的保证不能仅仅依靠测试人员，而是需要贯穿项目的各个阶段。</p><p>Bug的发现和修复是项目质量保证的一个重要方面，但质量保证工作绝不仅仅是修复Bug这么简单。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281626934.png"></p><p>项目的开发整体路径包括：需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、上线阶段以及线上阶段。</p><p>在一个项目开发的各个不同阶段，质量保证工作的要求和思路均有一定的不同，下面我们来展现质量保证工作在各个阶段的具体实现。</p><h4 id="1-3-1-需求与设计阶段的质量保证工作"><a href="#1-3-1-需求与设计阶段的质量保证工作" class="headerlink" title="1.3.1 需求与设计阶段的质量保证工作"></a>1.3.1 需求与设计阶段的质量保证工作</h4><p>需求与设计阶段是项目开始的重要阶段，只有从客户真正的需求出发，才能设计出真正令客户满意的产品。</p><p>在一阶段，质量保证工作的关键点有三：</p><ol><li><p><strong>需求评审：</strong>站在用户的角度思考和挖掘需求，是设计和开发的前提性条件。</p></li><li><p><strong>需求的变更管理：</strong>用户的需求始终在改变，建立一套完善机制去及时适应需求的变更十分重要。</p></li><li><p><strong>设计评审：</strong>通过评审需求的可行性和设计的相关风险，可以极大降低设计风险，避免人力浪费。</p></li></ol><h4 id="1-3-2-开发与测试阶段的质量保证工作"><a href="#1-3-2-开发与测试阶段的质量保证工作" class="headerlink" title="1.3.2 开发与测试阶段的质量保证工作"></a>1.3.2 开发与测试阶段的质量保证工作</h4><p>在开发阶段，质量保证工作最重要的有两点：<strong>单元测试和代码评审。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281632782.png"></p><blockquote><p>单元测试的作用很多，主要有：</p><p>（1） 调试代码，确保代码实时可编译。</p><p>（2） 验证逻辑，减少代码中的Bug。</p><p>（3） 作为一个最细粒度回归测试，实时反馈代码的质量。</p></blockquote><blockquote><p>代码评审也同样十分重要，它的作用主要为：</p><p>（1） 保持代码风格的一致和可读性，利于贯彻编程规范。</p><p>（2） 提高代码质量，减少Bug。</p><p>（3） 促进互相交流学习，提升团队的整体研发能力，进而提高企业的整体竞争力。</p></blockquote><p>而在测试阶段，我们的主要任务是<strong>测试功能性测试类问题。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281632723.png"></p><blockquote><p>测试阶段一般流程为：</p><p>第一步：<strong>撰写测试方案</strong>。由测试人员编写方案并提交开发人员评审。</p><p>第二步：<strong>进行单元测试</strong>。由开发人员编写用例，并交给测试人员评审。</p><p>第三步：<strong>进行功能性测试</strong>。由测试人员设计和编写用例。</p><p>第四步：<strong>进行性能/压力等测试</strong>。测试人员根据项目情况决定是否进行。</p><p>第五步：<strong>自动化和持续集成</strong>。将测试自动化，并把流程加入持续集成。</p><p>第六步：<strong>撰写测试报告</strong>。测试人员要在大版本时编写测试报告。</p></blockquote><p>测试环节涉及很多的内容，包括了：</p><p>（1）测试方案。</p><p>（2）自动化/持续集成。</p><p>（3）测试报告。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281634364.png"></p><p>在这一环节中，<strong>撰写测试方案是对该阶段工作的整体规划。</strong>测试方案描绘了测试和质量保证的各种工作，规划了如何组织测试，方案中包括了：质量目标、风险评估、测试范围、测试优先级、测试方法、测试流程、测试计划和测试设计的内容。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281634848.png"></p><p><strong>常用的测试方法有</strong>：黑盒/白盒、静态测试/动态测试、自动化测试/手工测试、验收测试/α测试/β测试、单元测试/模块测试/集成测试/联调测试/系统测试、功能性测试/性能测试/压力测试/异常测试/安全测试、接口测试/用户场景测试、回归测试、探索性测试等。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281635604.png"></p><p>不同的测试方法有不同的特点和擅长解决的问题。测试的侧重点不同，发现的问题也不同。我们需要根据测试方案，来选择合适的测试方法，提高测试的效率。为此，在前期的测试和设计方案评审时要及早发现问题，避免无效劳动，提高测试效率。</p><p>同样，自动化和持续集成也是有效提高测试效率的方法。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281635791.png"></p><p><strong>自动化包括流程自动化和测试自动化。</strong>流程自动化包括编译、部署、发布、回滚、上线和测试阶段。测试自动化可以降低成本并保证测试结果，降低风险。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281636766.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281637773.png"></p><p>而基于自动化，我们可以搭建串联工作流，即持续集成，可以将代码提交、编译、模块测试、部署、系统测试、发布这一循环性流程集成在一起，从而提高工作效率，保证持续的质量反馈。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281637103.png"></p><p>测试完成后需要撰写详细的测试报告，以方便后期的持续维护和迭代，其内容包括：</p><p>测试结果、质量风险评估、质量评估、测试过程描述、缺陷分析、评估改进意见、测试版本/测试人员/测试时间。</p><h4 id="1-3-3-上线与线上阶段的质量保证工作"><a href="#1-3-3-上线与线上阶段的质量保证工作" class="headerlink" title="1.3.3 上线与线上阶段的质量保证工作"></a>1.3.3 上线与线上阶段的质量保证工作</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281638579.png" alt="image-20211128163800434"></p><p><strong>上线阶段包括上线过程和回滚过程。</strong></p><p>上线阶段的上线方案需要经过评审和测试，对于重点项目，还应有回滚方案和相应的评审和测试工作。</p><p>上线后，我们需要进行线上测试，常用的线上测试有三类：众包测试、用户反馈和业务监控、产品评测。</p><blockquote><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281641413.png"></p><p>（1）<strong>众包测试：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281642738.png">众包测试的目的是使更多的用户参与测试，降低测试成本。众测服务分为四类：测试类（包括探索性测试、用例组合爆炸测试），产品体验（包括产品建议、Badcase收集）、评估评测（包括大数据量评估标注、降低成本）、用户调研（产品需求调研、用户反馈)。一个众测平台：<a href="http://test.baidu.com/">http://test.baidu.com</a></p><p>（2）<strong>用户反馈和业务监控</strong>：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281642375.png">目的则是为了实现线上问题闭环，通过用户反馈和业务监控可以解决大部分的线上问题。步骤分为收集、分发、定位和解决。主要平台有反馈平台、Bugs平台和 Monitor平台。</p><p>（3）<strong>产品评测：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281643572.png"></p><p>包括用户反馈分析、产品Bug分析、Top问题梳理和竞品对比分析。</p><p>→ <strong>用户反馈分析</strong>是指对用户反馈的问题进行分析。→ 产品Bug分析是指对产品的Bug进行分析，然后解决问题最大的Bug。</p><p>→ <strong>Top问题梳理</strong>是指，对问题进行梳理分类，解决最突出的问题。</p><p>→ <strong>竞品对比分析</strong>是指对自家产品和市场上同类型产品进行分析。</p></blockquote><p>从对各个阶段质量保证工作的分析中，我们不难看出，每一个阶段的质量保证工作都需要多方角色的共同参与。可见，项目的出色质量来源于<strong>每个环节的严格把控和每个成员的共同参与，这是团队质量意识的两大核心。</strong></p><h3 id="1-4-质量保证意识的4个核心内容"><a href="#1-4-质量保证意识的4个核心内容" class="headerlink" title="1.4 质量保证意识的4个核心内容"></a>1.4 质量保证意识的4个核心内容</h3><h4 id="1-4-1-质量保证工作存在于每一个环节"><a href="#1-4-1-质量保证工作存在于每一个环节" class="headerlink" title="1.4.1 质量保证工作存在于每一个环节"></a>1.4.1 质量保证工作存在于每一个环节</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647902.png"></p><h4 id="1-4-2-每一个成员都需要对质量负责"><a href="#1-4-2-每一个成员都需要对质量负责" class="headerlink" title="1.4.2 每一个成员都需要对质量负责"></a>1.4.2 每一个成员都需要对质量负责</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647522.png"></p><h4 id="1-4-3-测试是一种核心的质量保证工作"><a href="#1-4-3-测试是一种核心的质量保证工作" class="headerlink" title="1.4.3 测试是一种核心的质量保证工作"></a>1.4.3 测试是一种核心的质量保证工作</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281646302.png"></p><h4 id="1-4-4-尽早发现问题，尽早解决问题"><a href="#1-4-4-尽早发现问题，尽早解决问题" class="headerlink" title="1.4.4 尽早发现问题，尽早解决问题"></a>1.4.4 尽早发现问题，尽早解决问题</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647888.png"></p><h2 id="2-代码单元测试总体介绍"><a href="#2-代码单元测试总体介绍" class="headerlink" title="2 代码单元测试总体介绍"></a>2 代码单元测试总体介绍</h2><h3 id="2-1-单元测试基础"><a href="#2-1-单元测试基础" class="headerlink" title="2.1 单元测试基础"></a>2.1 单元测试基础</h3><h4 id="2-1-1-单元测试的误区"><a href="#2-1-1-单元测试的误区" class="headerlink" title="2.1.1 单元测试的误区"></a>2.1.1 单元测试的误区</h4><p>单元测试存在一些认识上的误区，包括：</p><ol><li>开发单元测试代码的工作量大。</li><li>做单元测试不属于开发人员的职责。</li><li>代码正确率高，进行单元测试必要性不大。</li><li>后期有集成测试，前期进行单元测试必要性不大。</li><li>单元测试无法带来显著收益，效率不高。</li></ol><h4 id="2-1-2-单元测试的概念"><a href="#2-1-2-单元测试的概念" class="headerlink" title="2.1.2 单元测试的概念"></a>2.1.2 单元测试的概念</h4><p><em><strong>在维基百科中，单元测试的定义为：一段代码调用另一段代码，随后检验一些假设的正确性。</strong></em></p><p><em><strong>在百度百科中，单元测试是指对软件中的最小可测试单元进行检查和验证。</strong></em></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281653449.png"></p><p>那么我们不禁要问：一次编写的单元测试是否只是为了验证该次开发过程中对应的代码逻辑的正确性？</p><p>其实不然，单元测试不仅在于实现问题中的功能，优秀的单元测试作用长久，可以减少后续工作的负担，从而提升整体生产力。</p><h4 id="2-1-3-常见的单元测试问题"><a href="#2-1-3-常见的单元测试问题" class="headerlink" title="2.1.3 常见的单元测试问题"></a>2.1.3 常见的单元测试问题</h4><p>目前单元测试中存在一些常见的问题：</p><ol><li>使用System.out输出测试结果，依赖人去判断测试是否正确。</li><li>不使用Assert(断言)对测试结果进行判断。</li></ol><p><em>在以上两种情形都需要依赖人与电脑的交互来判断此case是否成功，人的工作量较大；**在实际的单元测试中，应当使用断言进行判断，使 case运行时自动输出结果。</em></p><ol start="3"><li>没有边界检查。</li><li>多个测试分支放入一个单元测试方法中。</li></ol><p><em>这种情况会导致一旦出现运行失败时，难以判断出现错误的分支所在。</em></p><ol start="5"><li>测试case环境相关（依赖已知库表、时间）。</li></ol><p><em>对于这种情况，应当做出修改，使输入参数为确定的值。</em></p><ol start="6"><li>测试方法执行有先后顺序。</li></ol><p><em>在实际测试过程中，由于不同的用于运行单元测试的测试框架对于case执行顺序有自己的行为，故单元测试实际执行顺序存在不确定性。</em></p><h4 id="2-1-4-优秀的单元测试"><a href="#2-1-4-优秀的单元测试" class="headerlink" title="2.1.4 优秀的单元测试"></a>2.1.4 优秀的单元测试</h4><p>优秀的单元测试需要以下原则：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281655957.png"></p><ol><li>单元测试彼此之间应具备<strong>独立性</strong>。一个单元测试应独立于其它测试及运行它的环境。</li><li>一个优秀的单元测试是<strong>可重复</strong>的。它需要具备多次运行的能力，若不可重复，则不能算作优秀的单元测试。</li><li>优秀的单元测试<strong>可自动化</strong>。自动化具备双重含义：第一，单元测试<strong>可依赖于现有工具自动化运行</strong>；第二，单元测试执行成功与否<strong>可自动进行判断</strong>，而不依赖于人为判断。</li><li>优秀的单元测试是<strong>彻底的</strong>。单元测试对于被测试对象而言需要覆盖全部的分支。</li></ol><h3 id="2-2-单元测试的意义与建议"><a href="#2-2-单元测试的意义与建议" class="headerlink" title="2.2 单元测试的意义与建议"></a>2.2 单元测试的意义与建议</h3><h4 id="2-2-1-什么情况下做单元测试"><a href="#2-2-1-什么情况下做单元测试" class="headerlink" title="2.2.1 什么情况下做单元测试"></a>2.2.1 什么情况下做单元测试</h4><p><strong>（1）单元测试的好处</strong></p><p>①带来<strong>更高的测试覆盖率</strong>：有些分支问题在集成测试过程中很难发现，但在单元测试中极易发现。</p><p>②<strong>提高团队效率</strong>：单元测试在开发完后立即执行，将测试提前一步，不必等集成测试时才发现问题。</p><p>③<strong>自信的重构和改进实现。</strong></p><p>④<strong>将预期的行为文档化</strong>：完整的单元测试是产品代码的最好文档。</p><p><strong>（2）不当的单元测试会降低生产力</strong></p><p>单元测试并不是越多越好，不当的单元测试会降低生产力。</p><p>①单元测试的工作量与普通代码的工作量的比例介于1:1~1.5:1。</p><p>②整体项目的单元测试运行时间随着单元测试case增多线性增长，测试的执行速度影响每次变更等待的时间。</p><p>③单元测试的代码，也需要长期维护。</p><p><strong>（3）如何选择单元测试的对象</strong></p><p>不写单元测试不好，单元测试写多了也不好，这就要求我们要细心选择单元测试的对象。</p><p>在进行单元测试的时候，应<strong>重点关注核心业务逻辑代码、重用性高的代码与调用频繁的代码</strong>，后两者较为相近。</p><h4 id="2-2-2-不同场景下的单元测试tips"><a href="#2-2-2-不同场景下的单元测试tips" class="headerlink" title="2.2.2 不同场景下的单元测试tips"></a>2.2.2 不同场景下的单元测试tips</h4><p>1）Java Web项目底层的BO\DAO大体都是工具自动生成，无需额外单测，但是<strong>Action(Controller)<strong>层不含有较多的业务逻辑，</strong>需要通过集成测试</strong>发现问题。要注意的是<strong>java web项目</strong>的核心业务逻辑主要存在于Service层代码中，需要<strong>着重进行单元测试</strong>。</p><p>（2）平台类Java项目虽然在单独的场景下几乎不会出现问题，但是交叉混合时可能存在问题。而且由于平台类项目更多的兼顾不同的复杂的应用场景，所以在测试时要尽量做到全面。值得注意的是平台类Java项目的分支较多，所以<strong>要求在单元测试时要做到覆盖分支全面</strong>。</p><p>（3）组件类Java项目和平台类项目类似，也需要侧重分支覆盖全面，包括异常调用情况的覆盖。</p><p>（4）Hadoop的MR任务属于特殊的JAVA程序，集成测试成本高，主要体现在时间成本上。在进行单测时，<strong>可以将核心逻辑代码抽取出来，单独测试。</strong></p><h2 id="3-Python单元测试"><a href="#3-Python单元测试" class="headerlink" title="3 Python单元测试"></a>3 Python单元测试</h2><h3 id="3-1-单元测试的概念、工具与方法"><a href="#3-1-单元测试的概念、工具与方法" class="headerlink" title="3.1 单元测试的概念、工具与方法"></a>3.1 单元测试的概念、工具与方法</h3><h4 id="3-1-1-单元测试的概念"><a href="#3-1-1-单元测试的概念" class="headerlink" title="3.1.1 单元测试的概念"></a>3.1.1 单元测试的概念</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281703584.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281704541.png"></p><p>测试具有许多种不同的类型，比如说单元测试、模块测试、联调测试、系统测试、交付测试等。在这些测试之中，<strong>单元测试是最先要完成的</strong>。单元测试通常是由开发者去完成，用来验证代码中的函数是否符合预期。因此，它聚焦于函数的逻辑以及核心的算法是否正确。<em><strong>通常而言，一个单元测试用例是用于判断在某个特定条件或场景下，某个特定函数的行为。</strong></em></p><h4 id="3-1-2-单元测试的意义"><a href="#3-1-2-单元测试的意义" class="headerlink" title="3.1.2 单元测试的意义"></a>3.1.2 单元测试的意义</h4><p><strong>单元测试的意义包括两个方面。</strong></p><p>（1）质量</p><blockquote><p>①单元测试主要针对函数，<strong>颗粒度小、测试针对性强</strong>，bug更容易暴露；</p><p>②由于单元测试覆盖面较窄，无需考虑其它函数或者所依赖的模块，所以它的<strong>场景易构造，核心功能验证更充分</strong>；</p><p>③进行单元测试保证整体代码结构良好，使代码就具有较高的可测性和可维护性。</p></blockquote><p>（2）效率</p><p>单元测试能够提高开发效率，主要表现在：</p><blockquote><p>①单元测试<strong>进行的时间较早，测试场景构建快</strong>，可有效减少调试时间。</p><p>②由于单元测试<strong>只针对修改的代码</strong>展开测试，无需考虑额外内容，所以在较短时间内即可把预期的逻辑测试充分。</p><p>③单元测试<strong>能够在项目开发初期发现的bug</strong>，bug发现的时间越早，所带来的收益越大。由于尽早发现bug能够节省整个项目开发的时间，所以单元测试可加快开发效率，缩短开发周期。</p></blockquote><h4 id="3-1-3-单元测试框架"><a href="#3-1-3-单元测试框架" class="headerlink" title="3.1.3 单元测试框架"></a>3.1.3 单元测试框架</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281706919.png"></p><p><strong>Unitest的基础概念</strong></p><blockquote><p>在做单元测试之前，需要先了解一下Unittest的几个基础概念。</p><p>①**Test(测试用例)**，针对一个特定场景，特定目的具体测试过程。</p><p><em>比如说一个函数通过一组输入测试它，就是一个测试用例；如果一个函数通过三组输入来测试，即为三个测试用例。</em></p><p>②<strong>TestCase（测试类）</strong>，可以包含同一个测试对象的多个测试用例。</p><p><em>如果一个函数通过三组输入来测试，也就是三个测试用例，这三个测试用例可以合成为一个测试类。</em></p><p>③<strong>TestSuite（测试集）</strong>，可以包含多个测试类的多个测试用例。</p><p>④<strong>Assertion（断言）</strong>，必须使用断言判断测试结果。</p><p>⑤<strong>TestFixture</strong>，为测试做统一的准备和清除工作，通常是初始化，连接数据库，准备数据，断开数据库，清除现场等。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281711746.png"></p><p>扩展来说，TestFixture有四种最常使用的作用范围，分别为：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281710167.png"></p><blockquote><ol><li>setUp：在测试类的每个测试用例执行前执行。</li><li>teardown：在测试类的每个测试用例执行后执行。</li><li>setUpClass：在测试类的第一个测试用例执行前执行。</li><li>tearDownClass：在测试类的最后一个测试用例执行后执行。</li></ol></blockquote><p>TestFixture可以让单元测试代码更简单，但并非必须使用，也不要求配对出现。</p></blockquote><h4 id="3-1-4-单元测试的规范"><a href="#3-1-4-单元测试的规范" class="headerlink" title="3.1.4 单元测试的规范"></a>3.1.4 单元测试的规范</h4><p>如下是单元测试涉及的规范。</p><p>（1）所有的单元测试<strong>必须使用断言（assert）判断结果</strong>，禁止出现无断言的测试用例；</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281712364.webp"></p><p>使用断言，不但有利于他人理解，而且一旦出现不符合预期的情况，可以立即找出问题。</p><p>可以使用assertEqual, assertNotEqual 来判断相等或不相等，assertTrue,assertFalse 来判断Boolean, assertRaises 判断抛出的异常是否符合预期。</p><p>（2）测试用例需要具有自表述能力，达到见名知意。</p><p>比如命名test_login_with_invalid_password()，通过它的名字便可知它是用一个非法的密码去测试登录功能，具有自表述能力；但是如果命名为 test_login_case_（），名字减少了很多信息，难以得知它具体在做什么，不具有自表述能力。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281714852.png"></p><p>（3）测试用例之间相互独立，不应相互依赖、相互调用。</p><p>（4）<strong>一个测试用例只测一个函数。</strong>一个测试用例里面可以包含这一个函数的多个场景，但不能包含有多个参数的函数。原因在于，复杂测试用例出现错误时，无法定位问题的出处。</p><h4 id="3-1-5-单元测试对编码的要求"><a href="#3-1-5-单元测试对编码的要求" class="headerlink" title="3.1.5  单元测试对编码的要求"></a>3.1.5  单元测试对编码的要求</h4><p>单元测试中代码需保持一致性，尽量不要出现结果不一致的情况。假设有的代码会带来不一致性，导致单元测试无法稳定运行。针对这种情况，有两种解决方案：</p><p><strong>第一，将带来不一致性的代码抽取出来，</strong>把它作为一种变量传入我们需要调用或使用一致性变量的时候；</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281715404.png"></p><p><strong>第二，借助第三部分即将讲到的一个工具——mock</strong>——来解决这种问题。</p><h3 id="3-2-Coverage-统计单元测试覆盖率的工具"><a href="#3-2-Coverage-统计单元测试覆盖率的工具" class="headerlink" title="3.2 Coverage 统计单元测试覆盖率的工具"></a>3.2 Coverage 统计单元测试覆盖率的工具</h3><p>单元测试做完之后如何评价我们单元测试的效果。此时需要用到覆盖率工具，即Coverage。Coverage是一个第三方的工具，需要提前下载安装。</p><h4 id="3-2-1-统计覆盖率方法"><a href="#3-2-1-统计覆盖率方法" class="headerlink" title="3.2.1 统计覆盖率方法"></a>3.2.1 统计覆盖率方法</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281719654.png"></p><p>把python替换为coverage run-branch，然后会生成coverage文件，文件里会记录所有我们需要的覆盖率信息。</p><h4 id="3-2-2-打印覆盖率信息"><a href="#3-2-2-打印覆盖率信息" class="headerlink" title="3.2.2 打印覆盖率信息"></a>3.2.2 打印覆盖率信息</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718158.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281716523.webp"></p><p>执行coverage report-m 命令，读取当前目录下.coverage文件，打印覆盖率信息。输出Stmts(总行数), Miss(未覆盖行数), Branch（总分支数）, BrPart （未覆盖分支数）, Cover（覆盖率） , Missing（未覆盖具体信息）等信息。</p><h4 id="3-2-3-覆盖率中排除某些文件"><a href="#3-2-3-覆盖率中排除某些文件" class="headerlink" title="3.2.3 覆盖率中排除某些文件"></a>3.2.3 覆盖率中排除某些文件</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718278.png"></p><p>执行coverage report-m—omit=file 1[,file 2,……] 命令, 在统计并打印覆盖率时，排除某些文件。若有多个文件用逗号分隔。</p><h4 id="3-2-4-生成HTML格式的覆盖率信息"><a href="#3-2-4-生成HTML格式的覆盖率信息" class="headerlink" title="3.2.4 生成HTML格式的覆盖率信息"></a>3.2.4 生成HTML格式的覆盖率信息</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718034.png"></p><p>针对代码量较大，查找覆盖率信息难度较大、耗时较长的情况，执行coverage html [–omit=file1[,file2,……]]命令，将覆盖率信息以html格式显示。</p><h3 id="3-3-Mock-简化单元测试的工具"><a href="#3-3-Mock-简化单元测试的工具" class="headerlink" title="3.3 Mock 简化单元测试的工具"></a>3.3 Mock 简化单元测试的工具</h3><h4 id="3-3-1-使用mock工具的原因与其功能"><a href="#3-3-1-使用mock工具的原因与其功能" class="headerlink" title="3.3.1 使用mock工具的原因与其功能"></a>3.3.1 使用mock工具的原因与其功能</h4><p>Mock基于实际进行单元测试的场景而产生，以下三类场景非常具有代表性：</p><ol><li><p><strong>构造模块</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281724821.png">需要测试模块A,但它要调用的模块B还未开发，可是测试却不容推迟、需按时进行，面对这种情况，我们可以使用Mock生成一个还未写完的代码，即可进行相应的测试。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281724884.png"></p></li><li><p><strong>改变函数逻辑</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281725807.png">代码中含有结果不可预知的代码，例如time.time()(时间)， random.random()(随机数)。Mock可以改变含有结果不可预知代码的函数的逻辑，强行让其返回我们想要的返回值，使其结果可预知。</p></li><li><p><strong>减少依赖</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281725930.png" alt="image-20211128172546775">在所有模块代码都已完成，但无法保证代码稳定性的情况下。针对其他模块的质量不可靠的情况，可通过Mock工具构造一个相对稳定的模块，从而规避其他模块的问题。</p></li></ol><h4 id="3-3-2-Mock使用场景"><a href="#3-3-2-Mock使用场景" class="headerlink" title="3.3.2 Mock使用场景"></a>3.3.2 Mock使用场景</h4><p>通过以下10个场景来讲述Mock的常见用法。</p><p>场景01：通过 <strong>return_value</strong>，Mock可以强行修改，永远返回我们想要的返回值，支持的类型包括string,number,Boolean,list,dict等。</p><p>场景02：将前一个例子的<strong>实例名改为类名</strong>，可实现替换类方法的返回值。</p><p>场景03：通过 <strong>side_effect</strong>,根据调用次数返回想要的结果,当超出调用次数时抛StopIteration 异常。</p><p>场景04：通过 <strong>side_effect</strong>可以完全修改函数的逻辑，使用另一个函数来替换它，根据参数返回想要的结果。</p><p>场景05：通过 <strong>side_effect</strong>抛出想要的异常或错误。</p><p>场景06：针对需要mock在特定要求下生效的情况，通过<strong>with.patch.object</strong>设定一个作用域以达到限制mock作用域的目的。</p><p>场景07：<strong>获取调用信息</strong>，如函数是否被调用、函数被调用的次数、函数被调用的形式、函数调用的参数等。</p><p>场景08：通过<strong>create_autospec</strong>在返回值改变的同时，确保api不会因mock而改变。</p><p>场景09：针对需要调用的函数、调用的接口完全没有开发的情况，可以通过<strong>Mock从零构造依赖模块</strong>从而完成测试。</p><p>场景10 ：<strong>替换函数调用链。</strong>比如说用popen去执行一个命令，然后用read函数把它读取出来，再用split去做切分，这就是一个函数调用链(os.popen(cmd).read().split())。</p><h4 id="3-3-3-Mock对编码的要求"><a href="#3-3-3-Mock对编码的要求" class="headerlink" title="3.3.3 Mock对编码的要求"></a>3.3.3 Mock对编码的要求</h4><p>在模块引入方式上，推荐以import XXX的形式引入，以XXX.func()形式调用，不要from.xxx import *,因为需要一个链条指向它，否则无法达到我们的预期。</p><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281727442.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281727860.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281728367.png"></p><h2 id="4-单元测试实践"><a href="#4-单元测试实践" class="headerlink" title="4 单元测试实践"></a>4 单元测试实践</h2><h3 id="4-1-Unittest-简单应用"><a href="#4-1-Unittest-简单应用" class="headerlink" title="4.1 Unittest 简单应用"></a>4.1 Unittest 简单应用</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736705.webp"></p><p>如图所示，这是一个要被测试的类，这个类代表了一个人，类中有一个函数为<strong>get_name()，作用是获取这个人的名字</strong>。围绕着这个函数首先想到的测试点就是函数能否正确输出人名。因此就有了如下图所示的单元测试代码。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281738269.webp"></p><p>第一步，将使用到的unittest框架和所需要的函数导入。</p><p>第二步，针对被测试的函数写一个测试类，这里要注意<strong>测试类必须继承自unittest和TestCase。</strong></p><p>第三步，构建实例化的函数，可以理解为生成两个人，一个叫张三，一个叫李四。</p><p>第四步，编写一个用于测试的函数，这里注意<strong>函数名必须是以test开头</strong>。通过图片里的代码可以看到，通过使用assertEqual断言来做相应的测试，断言中包括了两部分，第一部分是预期，第二部分是实际的值。通过对两个值的比较来完成测试。</p><h3 id="4-2-Unittest复杂应用"><a href="#4-2-Unittest复杂应用" class="headerlink" title="4.2 Unittest复杂应用"></a>4.2 Unittest复杂应用</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736271.webp"></p><p>下面来看一个复杂的例子。如图所示，这个被测试的类是一个公司。这个公司的信息包含了公司的名字、公司的老板、公司的员工数。在这个公司的类中设置了三个函数，老板是谁、雇佣一个新员工、解雇一个员工。通过这些信息，可以想到的测试点有：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281735339.webp"></p><p>（1）who_is_boss()这个函数能够正确的返回老板的姓名；</p><p>（2）使用hire()函数雇佣新人，公司的员工总数+1；</p><p>（3）使用hire()函数重复雇佣一个人，函数会报错或者公司员工数量不变；</p><p>（4）使用fire()函数解雇一个人，公司的员工总数-1；</p><p>（5）使用fire()函数解雇非公司的员工，函数会报错或者员工数量不变。</p><p>针对以上的几个测试点，可以编写出相应的测试类。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736693.webp"></p><p>首先将所需要的类库导入，并且测试类要继承自unittest和TestCase。然后使用setUpClass()函数构建一个公司，设置老板的姓名和公司的名字。在这里设置了一个tearDown()清理函数，是为了方便测试的时候将员工全部清理掉。</p><p>通过图片可以看到，下面的三个函数原理基本跟上一个案例相同，都是通过断言来进行测试。测试类编写完成之后，需要运行这个类进行测试。如果需要执行全部的测试用例，如图所示，使用unittest.main()这个函数且不需要添加任何参数。执行完成后会得到如下图所示的结果，测试结果分为几个部分：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736738.webp"></p><p>第一部分的代码展示的是执行测试用例的结果，“.”说明测试用例执行通过，“E”说明测试用例发生了特殊情况异常中断，“F”说明测试用例执行失败。</p><p>第二部分则是打印的报错信息，当出现“E”或者“F”的时候，系统会打印出异常中断和执行失败的原因。</p><p>第三部分为统计信息，包括了共执行了几个测试用例，测试用例执行共花费了多少时间，测试用例执行成功或失败的数量。</p><h1 id="四、百度高效研发实战训练营Step4"><a href="#四、百度高效研发实战训练营Step4" class="headerlink" title="四、百度高效研发实战训练营Step4"></a>四、百度高效研发实战训练营Step4</h1><h2 id="1-代码检查规则：Java语言案例讲解"><a href="#1-代码检查规则：Java语言案例讲解" class="headerlink" title="1 代码检查规则：Java语言案例讲解"></a>1 代码检查规则：Java语言案例讲解</h2><h3 id="1-1-源文件规范"><a href="#1-1-源文件规范" class="headerlink" title="1.1 源文件规范"></a>1.1 源文件规范</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281859378.png"></p><h4 id="1-1-1-文件名"><a href="#1-1-1-文件名" class="headerlink" title="1.1.1 文件名"></a>1.1.1 文件名</h4><p>Java源文件名必须和它包含的顶层类名保持一致，包括大小写，并以**.java作为后缀名**。</p><h4 id="1-1-2-文件编码"><a href="#1-1-2-文件编码" class="headerlink" title="1.1.2 文件编码"></a>1.1.2 文件编码</h4><p>为保持编码风格的一致性，避免编码不一致导致的乱码问题，要求所有源文件编码<strong>必须使用UTF-8格式</strong>。</p><h4 id="1-1-3-特殊字符"><a href="#1-1-3-特殊字符" class="headerlink" title="1.1.3 特殊字符"></a>1.1.3 特殊字符</h4><p>特殊字符方面的规则主要是针对<strong>换行、缩进、空格</strong>等操作而制定，有以下强制规定：</p><ol><li>除换行符以外，<strong>ASCII空格（0x20）是唯一合法的空格字符</strong>。</li><li>由于不同系统将Tab转化成空格的数目不一致，统一使用空格进行缩进。</li><li>文件的换行符统一使用Unix格式（\n），而不要使用Windows格式（\r\n）。</li></ol><h3 id="1-2-源文件组织结构规范"><a href="#1-2-源文件组织结构规范" class="headerlink" title="1.2 源文件组织结构规范"></a>1.2 源文件组织结构规范</h3><blockquote><p>这一大类规则主要规定了源文件所应包含的具体组成部分和各个部分之间应遵循的一系列规则。</p><p><strong>对于源文件的组成部分，规定如下：</strong></p><p>源文件必须按顺序包含：许可证或版权声明、package语句、import语句、唯一的顶层类，四个方面的内容。</p><p>同时，每两个部分之间用一个空行进行分隔，不允许出现多余空行。对于以上四个方面的内容，每个组成部分又有相应的编码规则。</p></blockquote><h4 id="1-2-1-许可证或版权声明规范"><a href="#1-2-1-许可证或版权声明规范" class="headerlink" title="1.2.1 许可证或版权声明规范"></a>1.2.1 许可证或版权声明规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281903514.png"></p><h4 id="1-2-2-package语句规范"><a href="#1-2-2-package语句规范" class="headerlink" title="1.2.2 package语句规范"></a>1.2.2 package语句规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281911018.png"></p><h4 id="1-2-3-import语句规范"><a href="#1-2-3-import语句规范" class="headerlink" title="1.2.3 import语句规范"></a>1.2.3 import语句规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281904436.png"></p><h4 id="1-2-4-类声明规范"><a href="#1-2-4-类声明规范" class="headerlink" title="1.2.4 类声明规范"></a>1.2.4 类声明规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281905480.png"></p><h3 id="1-3-代码结构规范"><a href="#1-3-代码结构规范" class="headerlink" title="1.3 代码结构规范"></a>1.3 代码结构规范</h3><h4 id="1-3-1-花括号"><a href="#1-3-1-花括号" class="headerlink" title="1.3.1 花括号"></a>1.3.1 花括号</h4><p>花括号经常在<strong>类和方法定义以及代码块划分</strong>中使用，花括号在使用中常需要合理的换行操作进行配合。规定为：在非空代码块中使用花括号时要遵循<strong>K&amp;R风格（Kernighan and Ritchie Style）</strong>，三个主要原则为:</p><ol><li>在左花括号（{）前不能换行，在其后换行；</li><li>在右花括号（}）前应有换行；</li><li>表示终止的右花括号（}）后必须换行，否则，右花括号后不换行。</li></ol><h4 id="1-3-2-缩进与换行"><a href="#1-3-2-缩进与换行" class="headerlink" title="1.3.2 缩进与换行"></a>1.3.2 缩进与换行</h4><p>缩进与换行主要是为了保证代码风格的一致性，提升代码的可维护性。主要规范有：</p><ol><li><p>每次开始书写一个新代码块时，使用4个空格进行缩进，在代码块结束时，恢复之前的缩进级别。</p></li><li><p>每条语句之后都要换行，每行只能有一条完整语句。</p></li><li><p>除package语句和import语句外，代码单行字符数限制不超过120个。超出则需要换行，换行时，遵循如下五条原则：</p><blockquote><ol><li>第二行相对第一行缩进四个空格，从第三行开始，不再继续缩进。</li><li>运算符与下文一起换行，即运算符位于行首。</li><li>方法调用的标点符号与下文一起换行。</li><li>方法调用中的多个参数需要换行时，在逗号后进行。</li><li>在括号前不要换行。</li></ol></blockquote></li></ol><h4 id="1-3-3-空行"><a href="#1-3-3-空行" class="headerlink" title="1.3.3 空行"></a>1.3.3 空行</h4><p>合理使用空行可以提高代码的可读性，有利于后期维护。</p><p>对于空行的使用，有如下规范进行约束：</p><ol><li><strong>在类的不同成员间增加空行</strong>，包括：成员变量、构造函数、方法、内部类、静态初始化块、实例初始化块等。</li><li>两个成员变量声明之间可以不加空行。<strong>空行通常对于成员变量进行逻辑分组。</strong></li><li>方法体内，按需增加空行，以便从逻辑上对语句进行分组。</li><li>使用空行时，<strong>禁止使用连续的空行。</strong></li></ol><h4 id="1-3-4-其他说明"><a href="#1-3-4-其他说明" class="headerlink" title="1.3.4 其他说明"></a>1.3.4 其他说明</h4><p><strong><em>Java中有两种数组定义形式</em>，为规范代码书写形式，要求为：</strong></p><p>①类型与中括号紧挨相连来表示数组，即中括号写在数组名之前。</p><p><strong>而当注解与注释同时存在时，统一的规范要求为：</strong></p><p>②添加在类、方法、构造函数、成员属性上的注解直接写在注释块之后，每个注解独占一行。</p><p><strong>当同时存在多个修饰符时，需要<em>按照顺序书写</em>，顺序要求如下：</strong></p><p>public protected private abstract static final transient volatile synchronized native strictfp</p><p>排在首位的一定是访问修饰符，随后是abstract，即抽象类或抽象方法，紧接着是static、final。这是常见的几类修饰符，对于其他的修饰符，可以参考以上列举的顺序进行书写。</p><p><strong>为避免小写字母l与1混淆，有如下规定：</strong></p><p>长整型数字必须使用大写字母L结尾，以便于和数字1进行区分。</p><h3 id="1-4-命名规范"><a href="#1-4-命名规范" class="headerlink" title="1.4 命名规范"></a>1.4 命名规范</h3><h4 id="1-4-1-驼峰命名格式"><a href="#1-4-1-驼峰命名格式" class="headerlink" title="1.4.1 驼峰命名格式"></a>1.4.1 驼峰命名格式</h4><p>对于两种驼峰命名格式的使用范围，有如下规范：</p><ol><li>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，即首字母小写的驼峰命名格式。</li><li>类名使用UpperCamelCase风格，即首字母大写的驼峰命名格式，以下情形例外：DO/BO/DTO/VO/AO/PO/UID等。</li></ol><h4 id="1-4-2-类的命名格式"><a href="#1-4-2-类的命名格式" class="headerlink" title="1.4.2 类的命名格式"></a>1.4.2 类的命名格式</h4><p>除此之外，对于一些类，命名格式有更加具体的规范要求：</p><ol><li>抽象类命名使用Abstract或Base开头；</li><li>异常类命名使用Exception结尾；</li><li>测试类命名以它要测试的类的名称开始，以Test结尾。</li></ol><h4 id="1-4-3-常量命名格式"><a href="#1-4-3-常量命名格式" class="headerlink" title="1.4.3 常量命名格式"></a>1.4.3 常量命名格式</h4><p>常量的命名规范：</p><p>①常量命名全部大写，单词间用下划线隔开。</p><p>②不允许任何未经预先定义的常量直接出现在代码中。</p><h3 id="1-5-OOP规约"><a href="#1-5-OOP规约" class="headerlink" title="1.5 OOP规约"></a>1.5 OOP规约</h3><p><strong>OOP规约主要是针对面向对象编程过程中定义的一些类所制定的一些规则。</strong></p><p>包含的强制规范要求有：</p><ol><li>所有的POJO类属性<strong>必须使用包装数据类型</strong>，禁止使用基本类型。</li><li>所有的覆写方法，<strong>必须加@Override注解。</strong></li><li>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</li><li>定义DO/DTO/VO等POJO类时，均不要设定任何属性默认值。</li></ol><h3 id="1-6-集合处理规范"><a href="#1-6-集合处理规范" class="headerlink" title="1.6 集合处理规范"></a>1.6 集合处理规范</h3><p>集合和数组是我们开发过程中使用频度最高的两个数据结构，对于二者的使用也有严格的强制规范：</p><ol><li>当需要将集合转换为数组时，必须使用集合的toArray方法，传入的是类型完全一样的数组，大小是list.size()。</li><li>对一个集合求子集合时，需高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除，产生ConcurrentModificationException异常。应通过对子集合进行相应操作，来反射到原集合，从而避免异常的发生。</li><li>不要在循环体内部进行集合元素的remove/add操作。remove元素请使用Iterator（迭代器）方式，如果并发操作，需要对Iterator对象加锁。</li></ol><h3 id="1-7-控制语句规范"><a href="#1-7-控制语句规范" class="headerlink" title="1.7 控制语句规范"></a>1.7 控制语句规范</h3><p>Java中的控制语句主要有<strong>switch、if、else、while等</strong>，这些语句的使用在编码过程中需要遵循以下规范：</p><ol><li>在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch快内，都必须包含一个default语句并且放在最后。</li><li>使用if/else/for/while/do语句必须使用花括号。即使只有一行代码，避免采用单行的编码方式。</li><li>在高并发场景中，避免使用“等于”判断作为中断或退出的条件。防止在击穿现象下，程序无法正常中断或退出的情况发生。</li></ol><h3 id="1-8-注释规约"><a href="#1-8-注释规约" class="headerlink" title="1.8 注释规约"></a>1.8 注释规约</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282007834.png"></p><p>合理使用注释可以提高程序可读性，便于后期维护。注释可以是程序说明，也可以是编程思路。<strong>Java中的注释主要分三种形式：文档注释、单行注释和多行注释。</strong>注释规约包括：</p><p>①类、类属性、类方法的注释必须使用文档注释形式，即使用 /<strong>内容</strong>/ 格式，不得使用单行注释的格式。单行注释和多行注释主要使用在方法体内。</p><p>②方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释，使用/<em>内容</em>/注释，注意与代码对齐。</p><h3 id="1-9-异常处理规范"><a href="#1-9-异常处理规范" class="headerlink" title="1.9 异常处理规范"></a>1.9 异常处理规范</h3><p>在Java中，我们通常使用<strong>try catch来进行捕获异常处理</strong>，而Java中的异常又分为运行时异常和非运行时异常。</p><ol><li><strong>对于处理运行时异常，有如下规范：</strong>Java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过try catch的方式来处理，比如：空指针异常和数组越界异常等等。</li><li><strong>对于捕获后异常的处理，有如下规范：</strong>捕获异常是为了处理异常，不要捕获后不进行任何处理而将其抛弃。若不想进行异常的处理，应将该异常抛给它的调用者。最外层的业务使用者必须处理异常，将其转化为用户可以理解的内容。即对于捕获后的异常，要么继续向上抛，要么自己进行处理。</li><li><strong>异常处理的规范要求还包括：</strong>不能在finally块中使用return语句。</li></ol><h3 id="1-10-缺陷检查规则"><a href="#1-10-缺陷检查规则" class="headerlink" title="1.10 缺陷检查规则"></a>1.10 缺陷检查规则</h3><p>缺陷检查主要是<strong>对Java源代码进行静态分析</strong>，扫描其中潜在的缺陷，比如：空指针异常、死循环等，这一阶段所应遵循的规则包括：</p><ol><li>不能使用单个字符定义StringBuffer和StringBuilder。</li><li>任何上锁的对象均需保证其锁可以被释放。</li><li>严格避免死循环的发生。</li><li>对于字符串中的点号（“.”）、竖线（“|”）和文件分隔符（“File.separator”）进行替代时，需要注意其特殊含义。</li></ol><blockquote><p><strong>“.”：匹配任意单个字符。</strong>在replaceAll中使用，它匹配所有内容。</p><p><strong>“|”：通常用作选项分隔符，</strong>它匹配字符间的空格</p><p><strong>“File.separator”：匹配特定平台的文件路径分隔符。</strong>在Windows上，这将被视为转义字符。</p></blockquote><ol start="5"><li>当synchronize对成员变量进行上锁时，该成员变量必须是final类型的。</li><li>synchronize上锁的成员变量类型一定不能是装箱类型。</li><li>所有被spring托管的类，其成员属性的初始化<strong>均要使用注入的方式。</strong></li><li>当使用try catch方式进行异常捕获，且需要在catch中对异常信息进行输出时，不得使用printStackTrace的方式。这种方式会导致后期分析代码困难。而应<strong>采用一些Log框架，方便用户检索和浏览日志。</strong></li><li>方法返回值包含操作状态代码时，该状态码不应被忽略</li><li>【%s】数组具有协变性，元素赋值类型与初始化类型不一致，此种情况可通过编译，但运行阶段会发生错误。</li><li>对于用户名和密码不应直接写在Java的文件中，避免泄露。而应将相应关键信息写在配置文件中进行读取。</li><li>方法和成员变量的命名不应相同，也不应通过大小写来进行区分。</li></ol><h2 id="2-单元测试之Java实践"><a href="#2-单元测试之Java实践" class="headerlink" title="2 单元测试之Java实践"></a>2 单元测试之Java实践</h2><h3 id="2-1-如何写单元测试"><a href="#2-1-如何写单元测试" class="headerlink" title="2.1 如何写单元测试"></a>2.1 如何写单元测试</h3><h4 id="2-1-1-基本流程"><a href="#2-1-1-基本流程" class="headerlink" title="2.1.1 基本流程"></a>2.1.1 基本流程</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282024759.png"></p><p><strong>单元测试的基本流程如下：</strong></p><p>首先，环境初始化；</p><p>其次，准备输入参数；</p><p>再次，调用待测试方法；</p><p>然后，检查输出；</p><p>最后，测试完成后环境复原。</p><h4 id="2-1-2-测试替身"><a href="#2-1-2-测试替身" class="headerlink" title="2.1.2 测试替身"></a>2.1.2 测试替身</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282025752.png"></p><p><strong>测试替身可用于隔离被测试的代码、加速执行顺序、使得随机行为变得确定、模拟特殊情况以及能够使测试访问隐藏信息等。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282025297.png"></p><p>常见的测试替身有四类：桩（Stub)、伪造对象（Fake)、测试间谋（Spy)以及模拟对象（Mock)。</p><ol><li>Stub(桩）:一般什么都不做，实现空的方法调用或者简单的硬编码返回即可。</li><li>Fake(伪造对象）:真实数据的简单版本，伪造真实对象的行为，但是没有副作用或者使用真实事物的其它后果。比如替换数据库的对象，而得到虚假的伪造对象。</li><li>Spy(测试间谋）:需要得到封闭对象内部状态的时候，就要用到测试间谋，事先学会反馈消息，然后潜入对象内部去获取对象的状态。测试间谋是一种测试替身，它用于记录过去发生的情况，这样测试在事后就能知道所发生的一切。</li><li>Mock(模拟对象）:模拟对象是一个特殊的测试间谋。是一个在特定的情况下可以配置行为的对象，规定了在什么情况下，返回什么样的值的一种测试替身。Mock已经有了非常成熟的对象库，包括JMock、Mockito和EasyMock等。</li></ol><blockquote><p><strong>重点讲解一下模拟对象（Mock)：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282028940.png"></p><p>假如我们有业务逻辑→数据存取→数据这三层逻辑，现在需要对“业务逻辑”层进行单元测试，那么我们可以使用Mock对数据存取与数据层的内容进行模拟，从而使上面的单元测试是独立的。</p></blockquote><h4 id="2-1-3-设计思路"><a href="#2-1-3-设计思路" class="headerlink" title="2.1.3 设计思路"></a>2.1.3 设计思路</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282028962.png"></p><p><strong>如何设计单元测试：</strong></p><p>**单元测试case的核心:**结合具体的应用场景、具体的输入数据与当前函数的功能实现，对于输出数据作出具体的预期，即可把全部待测试的分支都罗列了出来。</p><p>即：<strong>应用场景+输入数据+功能实现=输出数据。</strong></p><h4 id="2-1-4-断言-Assertions"><a href="#2-1-4-断言-Assertions" class="headerlink" title="2.1.4 断言(Assertions)"></a>2.1.4 断言(Assertions)</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282029555.png"></p><p>断言是一种在java单元测试中经常使用的测试方法。在单元测试中，我们<strong>使用“断言”来检验当前的测试结果是成功还是失败。</strong></p><blockquote><p><strong>常见的断言：</strong></p><p>Assert.assertNotNull</p><p>Assert.assertEquals</p><p>Assert.assertTrue</p><p>Assert.assertFalse</p><p>Assert.fail     </p></blockquote><p><strong>在单元测试中使用断言可以令预测结果自动呈现，无需人工对单元测试结果进行判断。</strong></p><h3 id="2-2-单元测试的运行"><a href="#2-2-单元测试的运行" class="headerlink" title="2.2 单元测试的运行"></a>2.2 单元测试的运行</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282031441.png"></p><h4 id="2-2-1-手动"><a href="#2-2-1-手动" class="headerlink" title="2.2.1 手动"></a>2.2.1 手动</h4><ol><li><strong>直接在IDE中执行</strong></li></ol><p>在开发编码完成之后，开发人员可以直接在自己的环境和编译器内运行单元测试。</p><ol start="2"><li><strong>使用maven的mvn test</strong></li></ol><p>Maven是目前java开发中最流行的项目构建工具，它非常全面的包含了很多功能。mvn test这个测试模块就可以为我们的单元测试提供极大的便利。</p><h4 id="2-2-2-自动"><a href="#2-2-2-自动" class="headerlink" title="2.2.2 自动"></a>2.2.2 自动</h4><p><strong>持续集成（Jenkins）：</strong>自动化持续集成是我们在项目中常用的一种单元测试的方法。通用工具为Jenkins，Jenkins是一种持续集成的工具，它的功能非常强大。他的主要的功能有软件发布和版本测试、外部调用监控。</p><h3 id="2-3-如何判断单元测试的质量"><a href="#2-3-如何判断单元测试的质量" class="headerlink" title="2.3 如何判断单元测试的质量"></a>2.3 如何判断单元测试的质量</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282032798.png"></p><p>衡量标准：</p><p>从<strong>主观层面</strong>，优秀的单元测试可读性高、易于维护、值得信赖.</p><p>从<strong>客观层面</strong>，使用单元测试代码覆盖率来衡。覆盖率工具包括：集成IDE和单独布署。</p><h2 id="3-如何做好-Code-Review"><a href="#3-如何做好-Code-Review" class="headerlink" title="3 如何做好 Code Review"></a>3 如何做好 Code Review</h2><h3 id="3-1-为什么要做好-Code-Review"><a href="#3-1-为什么要做好-Code-Review" class="headerlink" title="3.1 为什么要做好 Code Review"></a>3.1 为什么要做好 Code Review</h3><h4 id="3-1-1-Code-Review是提升代码质量的最好方法"><a href="#3-1-1-Code-Review是提升代码质量的最好方法" class="headerlink" title="3.1.1 Code Review是提升代码质量的最好方法"></a>3.1.1 Code Review是提升代码质量的最好方法</h4><p>强化Code Review是<strong>提升代码质量的第一选择。</strong></p><p>在代码开发过程中，我们越早发现问题、定位问题，在修复问题时付出的成本越小。</p><p>大约有50%以上的bug，都是在做Code Review时发现的。前期做好Code Review，后期将会减少反复修改等不必要的复工。</p><h4 id="3-1-2-Code-Review能够在团队内传递知识"><a href="#3-1-2-Code-Review能够在团队内传递知识" class="headerlink" title="3.1.2 Code Review能够在团队内传递知识"></a>3.1.2 Code Review能够在团队内传递知识</h4><p>从知识传递的角度看，<strong>Code Review是极为重要的。</strong></p><p>做好Code Review，能够帮助团队传递知识、沟通交流、互相学习，能够提升学习能力、提升编写代码能力、提升代码质量、提升工作效率、降低项目风险。</p><p>另外，基于codebase可以使我们了解项目全局，培养系统的思考方式。</p><h4 id="3-1-3-Code-Review是辅导怎么写代码的最好方法"><a href="#3-1-3-Code-Review是辅导怎么写代码的最好方法" class="headerlink" title="3.1.3 Code Review是辅导怎么写代码的最好方法"></a>3.1.3 Code Review是辅导怎么写代码的最好方法</h4><p>我们要意识到，做Code Review可以学习到别人的经验，同时也可以向别人传递我们的经验。</p><p>如果我们想辅导别人，<strong>最好的办法就是让对方先写一段代码，我们对他的代码进行Code Review。</strong>在辅导他人的过程中，我们可以快速地发现问题，从而帮助改进。</p><h4 id="3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力"><a href="#3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力" class="headerlink" title="3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力"></a>3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力</h4><p>工作中是否有Code Review对于公司或团队来说非常重要。不但对于公司或团队内的人员有所提升，而且能够吸引出色的开发者加入开发团队。</p><p>未做好Code Review的公司或团队有如下特点：</p><ol><li>代码质量差。</li><li>团队内人员备份差。</li><li>团队开发人员得不到有效的辅导，提高慢。</li></ol><h4 id="3-1-5-为什么要提高代码质量？"><a href="#3-1-5-为什么要提高代码质量？" class="headerlink" title="3.1.5 为什么要提高代码质量？"></a>3.1.5 为什么要提高代码质量？</h4><ol><li>提高代码质量可以提高代码的可读性。</li><li>提高代码质量可以提高代码的复用性和参考性。</li><li>提高代码质量可以减少bug出现的风险。</li><li>提高代码质量可以减少后期补丁的风险。</li><li>提高代码质量可以降低代码失控的风险。</li><li>提高代码质量可以降低项目重构和升级的麻烦。</li></ol><h4 id="3-1-6-为什么要提高写代码的能力"><a href="#3-1-6-为什么要提高写代码的能力" class="headerlink" title="3.1.6 为什么要提高写代码的能力"></a>3.1.6 为什么要提高写代码的能力</h4><ol><li>代码能力如果停滞不前，对于个人而言，将导致职业危机。</li><li>代码能力如果停滞不前，对于团队而言，将意味着团队没有成长。</li></ol><p><strong>Code Review是一个非常重要的提升代码质量和代码能力的手段。</strong>无论是从个人发展角度，还是团队发展角度，我们都需要重视Code Review。</p><h3 id="3-2-如何做好-Code-Review"><a href="#3-2-如何做好-Code-Review" class="headerlink" title="3.2 如何做好 Code Review"></a>3.2 如何做好 Code Review</h3><h4 id="3-2-1-在Code-Review中可能发现的问题"><a href="#3-2-1-在Code-Review中可能发现的问题" class="headerlink" title="3.2.1 在Code Review中可能发现的问题"></a>3.2.1 在Code Review中可能发现的问题</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282043808.png"></p><h4 id="3-2-2-在Code-Review中应有的态度"><a href="#3-2-2-在Code-Review中应有的态度" class="headerlink" title="3.2.2 在Code Review中应有的态度"></a>3.2.2 在Code Review中应有的态度</h4><ol><li><p>对所有检查的代码逻辑要做到“完全看懂”，对于审核的代码，熟悉程度要做到“如数家珍”。如果在审核代码后，对代码的逻辑和背后的原因仍然很模糊，则是一个失败的Code Review。</p></li><li><p>好代码的标准，不仅仅是“可以运行通过”，在正确性、可读性、可重用性、可运维性等方面上，都需要综合考虑。</p></li><li><p>建立Code Review和写代码一样重要的意识。即：</p><blockquote><ol><li>Code Review和写代码一样，也有产出，即产出更高质量的代码。</li><li>审核代码在很多情况下比写代码还要辛苦，需要理解和找出问题等。</li></ol></blockquote></li><li><p>以提升代码质量为最终目标。</p></li><li><p>要投入足够的时间和精力。</p><blockquote><pre><code>        1. 审核代码花费的时间经常和写代码一样多，有时甚至比写代码的时间更多，要有时间意识。        1. 要有责任意识。如果出现bug，不仅仅是写代码人员的职责，也不仅仅是QA的职责，代码审核者也需要承担相当大的责任。</code></pre></blockquote></li></ol><h4 id="3-2-3-在Code-Review之前，需要了解一流代码的特性"><a href="#3-2-3-在Code-Review之前，需要了解一流代码的特性" class="headerlink" title="3.2.3 在Code Review之前，需要了解一流代码的特性"></a>3.2.3 在Code Review之前，需要了解一流代码的特性</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282046798.png" alt="一流代码的特性"></p><p><strong>一流代码有以下特性：①高效性；②鲁棒性；③简洁；④简短；⑤可共享；⑥可测试；⑦可移植；⑧可监控；⑨可运维；⑩可扩展。</strong></p><p>将以上十条标准进行总结精简归纳为：</p><blockquote><ol><li>代码的正确和性能；</li><li>代码的可读和可维护性；</li><li>代码的可运维和可运行；</li><li>代码的可共享和可重用；</li></ol></blockquote><p>在Code Review时，综合考虑以上一流代码的特性，可以快速提升代码质量、提升编写代码的能力等。</p><h4 id="3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力"><a href="#3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力" class="headerlink" title="3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力"></a>3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力</h4><p><strong>通常bad code有以下特点：</strong></p><ol><li>5分钟内不能看懂的代码。</li></ol><p>​        不能快速看懂的代码，一定是有问题的代码，可以先抛回给编写代码人员进行修正。<strong>一般一个函数的操作不能超过6个step</strong>，如果超过这个数量，则需要重新调整编码逻辑。</p><ol start="2"><li>需要思考才能看懂的代码。</li></ol><p>​        好的代码阅读时基本不用动脑子，甚至看注释就能看懂。</p><ol start="3"><li>需要来回翻屏才能看懂的代码。</li></ol><p>​        好的代码，经常在一屏内就是一个完整的逻辑。</p><ol start="4"><li>没有空行或注释的代码。</li></ol><p>​        在Code Review时，发现不会用段落、不会写注释的代码，肯定不是好的程序员写的代码，可以直接打回给编写代码人员进行修正。</p><h4 id="3-2-5-Code-Review的注意事项"><a href="#3-2-5-Code-Review的注意事项" class="headerlink" title="3.2.5 Code Review的注意事项"></a>3.2.5 Code Review的注意事项</h4><ol><li>在必要时，review的双方做<strong>面对面的沟通。</strong></li></ol><p>​        面对面沟通并不是单指当面沟通，还包括云共享、电话、视频沟通等。在沟通时，对于背景、关键点等应进行说明，便于reviewer的理解。在必要时，应提供设计文档。</p><ol start="2"><li>对于关键模块，应该建<strong>立owner制度。</strong></li></ol><p>​        所有提交的代码，必须由owner做最终确认。由owner掌握全局，并建立明确的责任关系。</p><ol start="3"><li><p>检查中发现的问题，要一追到底。</p></li><li><p>要<strong>注意细节。</strong>对每一行提交的代码，都要进行检查。</p></li><li><p><strong>Code Review的方式，要小步快跑。</strong>每次提交review的代码量不要太多，降低复杂度。在特殊情况时，比如一个新模块的构建，最好逐步完成，通过多次进行提交。</p></li><li><p>要为Code Review<strong>预留出足够的时间。</strong>Code Review VS Coding的时间，有时可能达到1:1。在这里需要考虑到有时会做大的修改，科学地规划工作量，尽量避免出现时间倒排。</p></li><li><p>注意每天 review代码的数量不宜过多。</p></li></ol><h4 id="3-2-6-Code-Review的步骤"><a href="#3-2-6-Code-Review的步骤" class="headerlink" title="3.2.6 Code Review的步骤"></a>3.2.6 Code Review的步骤</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282051436.png" alt="、"></p><p>Code Review的步骤为以下几点：</p><p><strong>Step1：先看系统全貌</strong></p><p>不深究细节，浏览系统全貌，理清模块划分的逻辑、模块间的关系、如何构成的整个系统等。</p><p><strong>Step2：进入模块级别</strong></p><p>同样不深究细节，浏览模块内的全貌，判断模块切分是否合理，理清模块内的逻辑，明确关键数据、关键的类和函数等。</p><p><strong>Step3：理清类、函数内部的逻辑。</strong></p><p><strong>Step4：进入细节。</strong></p><p>比如Layout、命名等。</p><h4 id="3-2-7-人为因素"><a href="#3-2-7-人为因素" class="headerlink" title="3.2.7 人为因素"></a>3.2.7 人为因素</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282053170.png"></p><p>除了代码上的问题，在Code Review过程中还会有一些人为因素，例如：</p><p><strong>①QA人员</strong></p><p>好的QA人员不仅仅会发现系统中的bug，还会质疑或提出产品需求，挑战或优化系统架构和实现方式。</p><p><strong>②Code Reviewer</strong></p><p>好的代码审核人员不仅仅指出代码表面的问题，还会检查系统需求分析的质量、接口或函数定义的合理性、模块划分的合理性、系统关键机制的合理性等。</p><h3 id="3-3-例子：Python-代码的-Code-Review"><a href="#3-3-例子：Python-代码的-Code-Review" class="headerlink" title="3.3 例子：Python 代码的 Code Review"></a>3.3 例子：Python 代码的 Code Review</h3><h4 id="3-3-1-Python的编码规范"><a href="#3-3-1-Python的编码规范" class="headerlink" title="3.3.1 Python的编码规范"></a>3.3.1 Python的编码规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282111474.png"></p><ul><li><p>代码要写的漂亮。</p></li><li><p>代码要<strong>明确直接</strong>，不要含蓄表达。</p></li><li><p>代码要<strong>简洁</strong>，一个函数可以实现的功能就不要写两个函数。</p></li><li><p><strong>代码深奥胜过代码复杂</strong>。代码可以写的深奥难懂，但是不能写的过于复杂。</p></li><li><p>代码要<strong>平铺直叙</strong>，不要层层嵌套。</p></li><li><p>代码要做到<strong>合理间隔。</strong></p></li><li><p>代码<strong>可读性</strong>非常重要。</p></li><li><p>代码要有普适性。尽量规避代码特殊性，用最简洁最通用的代码来实现。</p></li><li><p>代码要实用。</p></li><li><p>要重视所有发现的错误。</p></li><li><p>代码逻辑要清晰。在含糊混乱的面前，我们要拒绝猜测。读写代码时，不要出现“好像”、“可能”、“似乎”等猜测。当一段代码很难懂的时候，代码一定存在问题。</p></li><li><p>写代码要注重行动。</p></li><li><p>代码实现方法要简洁。如果一个方法很难解释，就意味着这个方法存在一定的问题。</p></li><li><p>要重视命名空间的使用。</p></li></ul><h4 id="3-3-2关于Python编程规范的部分说明"><a href="#3-3-2关于Python编程规范的部分说明" class="headerlink" title="3.3.2关于Python编程规范的部分说明"></a>3.3.2关于Python编程规范的部分说明</h4><p>Python编程规范有九个维度。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282113051.png"></p><h5 id="1-模块的划分"><a href="#1-模块的划分" class="headerlink" title="1 模块的划分"></a>1 模块的划分</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282118231.png"></p><p>我们要对模块有概念，这是整个系统的基础。</p><ol><li><p>一个.py文件是一个模块。</p></li><li><p>模块的划分对软件的长期维护非常重要。</p></li><li><p>每个模块都应该有特定的功能。</p></li></ol><blockquote><p>比如：配置文件的读取，网页文件的写入，网页文件的解析，一个内存数据表，一个抓取的线程等等。</p></blockquote><ol start="4"><li>多个本应独立的模块，写到一个.py文件中是常见的错误。从Code Review角度看，首先就是要看模块切分的对不对。</li></ol><h5 id="2-数据的封装"><a href="#2-数据的封装" class="headerlink" title="2 数据的封装"></a>2 数据的封装</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282117284.png"></p><p>在Code Review时，要着重注意数据是否封装这一问题。</p><h5 id="3-import"><a href="#3-import" class="headerlink" title="3 import"></a>3 import</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282118516.png"></p><p>Import在使用过程中，禁止使用from xxx import yyy语法直接导入类或函数。禁止使用from xxx import *这样的方法。这样做的目标是：容易判断代码中使用外部变量或函数的来源。</p><p>如果使用禁止中的语法，会大大增加判断来源的难度，以及代码阅读的难度。</p><p>在Code Review时，遇到这种情况，及时将代码打回给编程人员进行修正。</p><h5 id="4-异常"><a href="#4-异常" class="headerlink" title="4 异常"></a>4 异常</h5><p>对于异常的处理有以下几点需要注意：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282120853.png"></p><blockquote><ol><li>异常的使用</li></ol><p>​        使用异常前请需要详细了解异常的行为。不要主动抛出异常，使用返回值。如果一定要抛异常，需要注释进行说明。</p><ol start="2"><li>异常的获取强制</li></ol><p>​        除非重新抛出异常，否则禁止使用except:捕获所有异常，不建议捕获Exception或StandardError。</p><p>​        在实际编码中建议try中的代码尽可能少，避免catch住未预期的异常，掩藏掉真正的错误。底线是至少要打印异常的日志，而不是捕获后直接pass通过。</p><p>​        在对异常进行处理时尽量针对特定操作的特定异常来捕获。</p><ol start="3"><li>函数的返回值</li></ol><p>​        如果函数会抛出异常，需要在函数的注释中明确说明。</p></blockquote><p>在Code Review时，需要注意上述问题，及时返回给编程人员进行修正。</p><h5 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5 构造函数"></a>5 构造函数</h5><p>对于构造函数有以下几点需要注意：</p><ol><li>规范：</li></ol><p>类构造函数应该尽量简单，不能包含可能失败或过于复杂的操作。</p><ol start="2"><li>解读：</li></ol><p>在构造函数中常出现的错误是：无法判断、或捕获异常。</p><h5 id="6-函数返回值"><a href="#6-函数返回值" class="headerlink" title="6 函数返回值"></a>6 函数返回值</h5><p>对于函数返回值有以下几点需要注意：</p><ol><li>规范：</li></ol><blockquote><p>函数返回值必须小于等于3个。返回值超过3个时必须通过class/namedtuple/dict等具名形式进行包装。</p></blockquote><ol start="2"><li>解读：</li></ol><blockquote><p>a. 多数情况下的错误，是因为很多人不会思考和设计函数的语义。</p><p>函数描述涉及的三要素为：功能描述、传入参数描述和返回值描述。</p><p>每个函数都应该有足够明确的语义。基于函数的语义，函数的返回值有三种类型：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282122993.png"></p><p>b .另外，函数需要有返回值，对于正确或错误的情况，在返回值中要有体现。</p><p>c .还有一个问题是：Python的数据格式不需要定义，过于灵活。当程序规模变大、维护周期变长时，会导致后期极难维护。</p><p>应对措施是：多写注释，写清楚返回值说明、参数说明。</p></blockquote><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282123350.png"></p><p>在Code Review时，注释未写清楚的代码，一定要打回给编程人员，进行修正、补注释。</p><h5 id="7-代码长度"><a href="#7-代码长度" class="headerlink" title="7 代码长度"></a>7 代码长度</h5><p>关于代码长度有以下几点需要注意：</p><ol><li>每行不得超过120个字符。避免在终端上显示出现折行。</li><li>函数长度不得超过100行。函数过长会增加理解函数逻辑的难度。Python的函数应尽量控制在30~40行之间。</li></ol><p>在Code Review时，代码过长，建议全部打回给编程人员进行修正。</p><h5 id="8-空行、空格"><a href="#8-空行、空格" class="headerlink" title="8 空行、空格"></a>8 空行、空格</h5><p>关于空行、空格有以下几点需要注意：</p><ol><li>空行</li></ol><p>​        文件及定义之间隔两个空行。比如类或全局函数。类方法之间隔一个空行。</p><ol start="2"><li>空格</li></ol><p>​        逗号、分号、冒号前不加空格，后边加一个空格。所有二元运算符前后各加一个空格。</p><p>在Code Review时，需要着重注意空行和空格。空行和空格不是可有可无的。空行和空格的存在，是为了增加可读性。不好读的代码，一律打回给编程人员进行修正。</p><h5 id="9-注释"><a href="#9-注释" class="headerlink" title="9 注释"></a>9 注释</h5><p>关于注释有以下几点需要注意：</p><p>Python中的注释有一个特殊之处是docstring，<strong>docstring要和“＃”注意区分开。</strong></p><blockquote><p>相关规范有：</p><ol><li><p>使用docstring描述module、 function 、class和method接口时，<strong>docstring必须用三个双引号括起来。</strong></p></li><li><p>对外接口部分必须用docstring描述。内部接口视情况自行决定是否写docstring。</p></li><li><p>接口的docstring描述<strong>至少包括功能简介、参数、返回值。</strong>如果可能抛出异常，必须使用注释进行说明。</p></li><li><p><strong>每个文件都必须有文件声明</strong>，文件声明必须包括以下信息：版权声明、功能和用途简介、修改人及联系方式。</p></li></ol></blockquote><p>在Code Review时，不符合上述规范的，及时打回给编程人员进行修正。</p><h3 id="3-4-如何成为一个好的reviewer"><a href="#3-4-如何成为一个好的reviewer" class="headerlink" title="3.4 如何成为一个好的reviewer"></a>3.4 如何成为一个好的reviewer</h3><p>代码审核的质量，和审核者的代码能力直接相关。代码审核的质量差，反映的是审核者的代码水平。如果作为一个代码审核员不会写代码，就要承认真相，并且要不断提高自己的代码能力。</p><p>学习资料：</p><ol><li>关于代码的书籍：《编写可读代码的艺术》，《代码整洁之道》。</li><li>综合的书籍：《代码大全》，《201  principles of software development》。</li><li>其他：《代码的艺术》课程，Python Good Coder考试指南。</li></ol><h3 id="3-5-公司针对-Code-Review-的措施"><a href="#3-5-公司针对-Code-Review-的措施" class="headerlink" title="3.5 公司针对 Code Review 的措施"></a>3.5 公司针对 Code Review 的措施</h3><p><strong>1、建立高效可运营的代码审核机制，提升代码质量，降低代码评审成本。</strong></p><blockquote><p>①基于平台：icode+bugbye</p><p>②代码检查规则分级，分为ERROR、WARNING、ADVICE三类，对ERROR级别阻塞提交。</p><p>③通过统计数据驱动代码检测规则的优化。</p></blockquote><p><strong>2、通过工程能力地图考察项目的Code Review情况。</strong></p><p><strong>3、所有的Code Review行为，都基于icode平台进行。良好的工具可以帮助更好的进行代码审核</strong></p><h3 id="3-6-Code-Review-总结"><a href="#3-6-Code-Review-总结" class="headerlink" title="3.6 Code Review 总结"></a>3.6 Code Review 总结</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、百度高效研发实战训练营Step1&quot;&gt;&lt;a href=&quot;#一、百度高效研发实战训练营Step1&quot; class=&quot;headerlink&quot; title=&quot;一、百度高效研发实战训练营Step1&quot;&gt;&lt;/a&gt;一、百度高效研发实战训练营Step1&lt;/h1&gt;&lt;p&gt;&lt;a hre</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="百度高效研发实战训练营" scheme="https://www.ckxgzxa.top/tags/%E7%99%BE%E5%BA%A6%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>百度高效研发实战训练营Step4</title>
    <link href="https://www.ckxgzxa.top/bitTraingClub4.html"/>
    <id>https://www.ckxgzxa.top/bitTraingClub4.html</id>
    <published>2021-11-26T02:10:28.000Z</published>
    <updated>2021-12-08T08:09:03.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度高效研发实战训练营Step4"><a href="#百度高效研发实战训练营Step4" class="headerlink" title="百度高效研发实战训练营Step4"></a>百度高效研发实战训练营Step4</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-代码检查规则：Java语言案例讲解"><a href="#1-代码检查规则：Java语言案例讲解" class="headerlink" title="1 代码检查规则：Java语言案例讲解"></a>1 代码检查规则：Java语言案例讲解</h2><h3 id="1-1-源文件规范"><a href="#1-1-源文件规范" class="headerlink" title="1.1 源文件规范"></a>1.1 源文件规范</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281859378.png"></p><h4 id="1-1-1-文件名"><a href="#1-1-1-文件名" class="headerlink" title="1.1.1 文件名"></a>1.1.1 文件名</h4><p>Java源文件名必须和它包含的顶层类名保持一致，包括大小写，并以**.java作为后缀名**。</p><h4 id="1-1-2-文件编码"><a href="#1-1-2-文件编码" class="headerlink" title="1.1.2 文件编码"></a>1.1.2 文件编码</h4><p>为保持编码风格的一致性，避免编码不一致导致的乱码问题，要求所有源文件编码<strong>必须使用UTF-8格式</strong>。</p><h4 id="1-1-3-特殊字符"><a href="#1-1-3-特殊字符" class="headerlink" title="1.1.3 特殊字符"></a>1.1.3 特殊字符</h4><p>特殊字符方面的规则主要是针对<strong>换行、缩进、空格</strong>等操作而制定，有以下强制规定：</p><ol><li>除换行符以外，<strong>ASCII空格（0x20）是唯一合法的空格字符</strong>。</li><li>由于不同系统将Tab转化成空格的数目不一致，统一使用空格进行缩进。</li><li>文件的换行符统一使用Unix格式（\n），而不要使用Windows格式（\r\n）。</li></ol><h3 id="1-2-源文件组织结构规范"><a href="#1-2-源文件组织结构规范" class="headerlink" title="1.2 源文件组织结构规范"></a>1.2 源文件组织结构规范</h3><blockquote><p>这一大类规则主要规定了源文件所应包含的具体组成部分和各个部分之间应遵循的一系列规则。</p><p><strong>对于源文件的组成部分，规定如下：</strong></p><p>源文件必须按顺序包含：许可证或版权声明、package语句、import语句、唯一的顶层类，四个方面的内容。</p><p>同时，每两个部分之间用一个空行进行分隔，不允许出现多余空行。对于以上四个方面的内容，每个组成部分又有相应的编码规则。</p></blockquote><h4 id="1-2-1-许可证或版权声明规范"><a href="#1-2-1-许可证或版权声明规范" class="headerlink" title="1.2.1 许可证或版权声明规范"></a>1.2.1 许可证或版权声明规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281903514.png"></p><h4 id="1-2-2-package语句规范"><a href="#1-2-2-package语句规范" class="headerlink" title="1.2.2 package语句规范"></a>1.2.2 package语句规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281911018.png"></p><h4 id="1-2-3-import语句规范"><a href="#1-2-3-import语句规范" class="headerlink" title="1.2.3 import语句规范"></a>1.2.3 import语句规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281904436.png"></p><h4 id="1-2-4-类声明规范"><a href="#1-2-4-类声明规范" class="headerlink" title="1.2.4 类声明规范"></a>1.2.4 类声明规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281905480.png"></p><h3 id="1-3-代码结构规范"><a href="#1-3-代码结构规范" class="headerlink" title="1.3 代码结构规范"></a>1.3 代码结构规范</h3><h4 id="1-3-1-花括号"><a href="#1-3-1-花括号" class="headerlink" title="1.3.1 花括号"></a>1.3.1 花括号</h4><p>花括号经常在<strong>类和方法定义以及代码块划分</strong>中使用，花括号在使用中常需要合理的换行操作进行配合。规定为：在非空代码块中使用花括号时要遵循<strong>K&amp;R风格（Kernighan and Ritchie Style）</strong>，三个主要原则为:</p><ol><li>在左花括号（{）前不能换行，在其后换行；</li><li>在右花括号（}）前应有换行；</li><li>表示终止的右花括号（}）后必须换行，否则，右花括号后不换行。</li></ol><h4 id="1-3-2-缩进与换行"><a href="#1-3-2-缩进与换行" class="headerlink" title="1.3.2 缩进与换行"></a>1.3.2 缩进与换行</h4><p>缩进与换行主要是为了保证代码风格的一致性，提升代码的可维护性。主要规范有：</p><ol><li><p>每次开始书写一个新代码块时，使用4个空格进行缩进，在代码块结束时，恢复之前的缩进级别。</p></li><li><p>每条语句之后都要换行，每行只能有一条完整语句。</p></li><li><p>除package语句和import语句外，代码单行字符数限制不超过120个。超出则需要换行，换行时，遵循如下五条原则：</p><blockquote><ol><li>第二行相对第一行缩进四个空格，从第三行开始，不再继续缩进。</li><li>运算符与下文一起换行，即运算符位于行首。</li><li>方法调用的标点符号与下文一起换行。</li><li>方法调用中的多个参数需要换行时，在逗号后进行。</li><li>在括号前不要换行。</li></ol></blockquote></li></ol><h4 id="1-3-3-空行"><a href="#1-3-3-空行" class="headerlink" title="1.3.3 空行"></a>1.3.3 空行</h4><p>合理使用空行可以提高代码的可读性，有利于后期维护。</p><p>对于空行的使用，有如下规范进行约束：</p><ol><li><strong>在类的不同成员间增加空行</strong>，包括：成员变量、构造函数、方法、内部类、静态初始化块、实例初始化块等。</li><li>两个成员变量声明之间可以不加空行。<strong>空行通常对于成员变量进行逻辑分组。</strong></li><li>方法体内，按需增加空行，以便从逻辑上对语句进行分组。</li><li>使用空行时，<strong>禁止使用连续的空行。</strong></li></ol><h4 id="1-3-4-其他说明"><a href="#1-3-4-其他说明" class="headerlink" title="1.3.4 其他说明"></a>1.3.4 其他说明</h4><p><strong><em>Java中有两种数组定义形式</em>，为规范代码书写形式，要求为：</strong></p><p>①类型与中括号紧挨相连来表示数组，即中括号写在数组名之前。</p><p><strong>而当注解与注释同时存在时，统一的规范要求为：</strong></p><p>②添加在类、方法、构造函数、成员属性上的注解直接写在注释块之后，每个注解独占一行。</p><p><strong>当同时存在多个修饰符时，需要<em>按照顺序书写</em>，顺序要求如下：</strong></p><p>public protected private abstract static final transient volatile synchronized native strictfp</p><p>排在首位的一定是访问修饰符，随后是abstract，即抽象类或抽象方法，紧接着是static、final。这是常见的几类修饰符，对于其他的修饰符，可以参考以上列举的顺序进行书写。</p><p><strong>为避免小写字母l与1混淆，有如下规定：</strong></p><p>长整型数字必须使用大写字母L结尾，以便于和数字1进行区分。</p><h3 id="1-4-命名规范"><a href="#1-4-命名规范" class="headerlink" title="1.4 命名规范"></a>1.4 命名规范</h3><h4 id="1-4-1-驼峰命名格式"><a href="#1-4-1-驼峰命名格式" class="headerlink" title="1.4.1 驼峰命名格式"></a>1.4.1 驼峰命名格式</h4><p>对于两种驼峰命名格式的使用范围，有如下规范：</p><ol><li>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，即首字母小写的驼峰命名格式。</li><li>类名使用UpperCamelCase风格，即首字母大写的驼峰命名格式，以下情形例外：DO/BO/DTO/VO/AO/PO/UID等。</li></ol><h4 id="1-4-2-类的命名格式"><a href="#1-4-2-类的命名格式" class="headerlink" title="1.4.2 类的命名格式"></a>1.4.2 类的命名格式</h4><p>除此之外，对于一些类，命名格式有更加具体的规范要求：</p><ol><li>抽象类命名使用Abstract或Base开头；</li><li>异常类命名使用Exception结尾；</li><li>测试类命名以它要测试的类的名称开始，以Test结尾。</li></ol><h4 id="1-4-3-常量命名格式"><a href="#1-4-3-常量命名格式" class="headerlink" title="1.4.3 常量命名格式"></a>1.4.3 常量命名格式</h4><p>常量的命名规范：</p><p>①常量命名全部大写，单词间用下划线隔开。</p><p>②不允许任何未经预先定义的常量直接出现在代码中。</p><h3 id="1-5-OOP规约"><a href="#1-5-OOP规约" class="headerlink" title="1.5 OOP规约"></a>1.5 OOP规约</h3><p><strong>OOP规约主要是针对面向对象编程过程中定义的一些类所制定的一些规则。</strong></p><p>包含的强制规范要求有：</p><ol><li>所有的POJO类属性<strong>必须使用包装数据类型</strong>，禁止使用基本类型。</li><li>所有的覆写方法，<strong>必须加@Override注解。</strong></li><li>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</li><li>定义DO/DTO/VO等POJO类时，均不要设定任何属性默认值。</li></ol><h3 id="1-6-集合处理规范"><a href="#1-6-集合处理规范" class="headerlink" title="1.6 集合处理规范"></a>1.6 集合处理规范</h3><p>集合和数组是我们开发过程中使用频度最高的两个数据结构，对于二者的使用也有严格的强制规范：</p><ol><li>当需要将集合转换为数组时，必须使用集合的toArray方法，传入的是类型完全一样的数组，大小是list.size()。</li><li>对一个集合求子集合时，需高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除，产生ConcurrentModificationException异常。应通过对子集合进行相应操作，来反射到原集合，从而避免异常的发生。</li><li>不要在循环体内部进行集合元素的remove/add操作。remove元素请使用Iterator（迭代器）方式，如果并发操作，需要对Iterator对象加锁。</li></ol><h3 id="1-7-控制语句规范"><a href="#1-7-控制语句规范" class="headerlink" title="1.7 控制语句规范"></a>1.7 控制语句规范</h3><p>Java中的控制语句主要有<strong>switch、if、else、while等</strong>，这些语句的使用在编码过程中需要遵循以下规范：</p><ol><li>在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch快内，都必须包含一个default语句并且放在最后。</li><li>使用if/else/for/while/do语句必须使用花括号。即使只有一行代码，避免采用单行的编码方式。</li><li>在高并发场景中，避免使用“等于”判断作为中断或退出的条件。防止在击穿现象下，程序无法正常中断或退出的情况发生。</li></ol><h3 id="1-8-注释规约"><a href="#1-8-注释规约" class="headerlink" title="1.8 注释规约"></a>1.8 注释规约</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282007834.png"></p><p>合理使用注释可以提高程序可读性，便于后期维护。注释可以是程序说明，也可以是编程思路。<strong>Java中的注释主要分三种形式：文档注释、单行注释和多行注释。</strong>注释规约包括：</p><p>①类、类属性、类方法的注释必须使用文档注释形式，即使用 /<strong>内容</strong>/ 格式，不得使用单行注释的格式。单行注释和多行注释主要使用在方法体内。</p><p>②方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释，使用/<em>内容</em>/注释，注意与代码对齐。</p><h3 id="1-9-异常处理规范"><a href="#1-9-异常处理规范" class="headerlink" title="1.9 异常处理规范"></a>1.9 异常处理规范</h3><p>在Java中，我们通常使用<strong>try catch来进行捕获异常处理</strong>，而Java中的异常又分为运行时异常和非运行时异常。</p><ol><li><strong>对于处理运行时异常，有如下规范：</strong>Java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过try catch的方式来处理，比如：空指针异常和数组越界异常等等。</li><li><strong>对于捕获后异常的处理，有如下规范：</strong>捕获异常是为了处理异常，不要捕获后不进行任何处理而将其抛弃。若不想进行异常的处理，应将该异常抛给它的调用者。最外层的业务使用者必须处理异常，将其转化为用户可以理解的内容。即对于捕获后的异常，要么继续向上抛，要么自己进行处理。</li><li><strong>异常处理的规范要求还包括：</strong>不能在finally块中使用return语句。</li></ol><h3 id="1-10-缺陷检查规则"><a href="#1-10-缺陷检查规则" class="headerlink" title="1.10 缺陷检查规则"></a>1.10 缺陷检查规则</h3><p>缺陷检查主要是<strong>对Java源代码进行静态分析</strong>，扫描其中潜在的缺陷，比如：空指针异常、死循环等，这一阶段所应遵循的规则包括：</p><ol><li>不能使用单个字符定义StringBuffer和StringBuilder。</li><li>任何上锁的对象均需保证其锁可以被释放。</li><li>严格避免死循环的发生。</li><li>对于字符串中的点号（“.”）、竖线（“|”）和文件分隔符（“File.separator”）进行替代时，需要注意其特殊含义。</li></ol><blockquote><p><strong>“.”：匹配任意单个字符。</strong>在replaceAll中使用，它匹配所有内容。</p><p><strong>“|”：通常用作选项分隔符，</strong>它匹配字符间的空格</p><p><strong>“File.separator”：匹配特定平台的文件路径分隔符。</strong>在Windows上，这将被视为转义字符。</p></blockquote><ol start="5"><li>当synchronize对成员变量进行上锁时，该成员变量必须是final类型的。</li><li>synchronize上锁的成员变量类型一定不能是装箱类型。</li><li>所有被spring托管的类，其成员属性的初始化<strong>均要使用注入的方式。</strong></li><li>当使用try catch方式进行异常捕获，且需要在catch中对异常信息进行输出时，不得使用printStackTrace的方式。这种方式会导致后期分析代码困难。而应<strong>采用一些Log框架，方便用户检索和浏览日志。</strong></li><li>方法返回值包含操作状态代码时，该状态码不应被忽略</li><li>【%s】数组具有协变性，元素赋值类型与初始化类型不一致，此种情况可通过编译，但运行阶段会发生错误。</li><li>对于用户名和密码不应直接写在Java的文件中，避免泄露。而应将相应关键信息写在配置文件中进行读取。</li><li>方法和成员变量的命名不应相同，也不应通过大小写来进行区分。</li></ol><h2 id="2-单元测试之Java实践"><a href="#2-单元测试之Java实践" class="headerlink" title="2 单元测试之Java实践"></a>2 单元测试之Java实践</h2><h3 id="2-1-如何写单元测试"><a href="#2-1-如何写单元测试" class="headerlink" title="2.1 如何写单元测试"></a>2.1 如何写单元测试</h3><h4 id="2-1-1-基本流程"><a href="#2-1-1-基本流程" class="headerlink" title="2.1.1 基本流程"></a>2.1.1 基本流程</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282024759.png"></p><p><strong>单元测试的基本流程如下：</strong></p><p>首先，环境初始化；</p><p>其次，准备输入参数；</p><p>再次，调用待测试方法；</p><p>然后，检查输出；</p><p>最后，测试完成后环境复原。</p><h4 id="2-1-2-测试替身"><a href="#2-1-2-测试替身" class="headerlink" title="2.1.2 测试替身"></a>2.1.2 测试替身</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282025752.png"></p><p><strong>测试替身可用于隔离被测试的代码、加速执行顺序、使得随机行为变得确定、模拟特殊情况以及能够使测试访问隐藏信息等。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282025297.png"></p><p>常见的测试替身有四类：桩（Stub)、伪造对象（Fake)、测试间谋（Spy)以及模拟对象（Mock)。</p><ol><li>Stub(桩）:一般什么都不做，实现空的方法调用或者简单的硬编码返回即可。</li><li>Fake(伪造对象）:真实数据的简单版本，伪造真实对象的行为，但是没有副作用或者使用真实事物的其它后果。比如替换数据库的对象，而得到虚假的伪造对象。</li><li>Spy(测试间谋）:需要得到封闭对象内部状态的时候，就要用到测试间谋，事先学会反馈消息，然后潜入对象内部去获取对象的状态。测试间谋是一种测试替身，它用于记录过去发生的情况，这样测试在事后就能知道所发生的一切。</li><li>Mock(模拟对象）:模拟对象是一个特殊的测试间谋。是一个在特定的情况下可以配置行为的对象，规定了在什么情况下，返回什么样的值的一种测试替身。Mock已经有了非常成熟的对象库，包括JMock、Mockito和EasyMock等。</li></ol><blockquote><p><strong>重点讲解一下模拟对象（Mock)：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282028940.png"></p><p>假如我们有业务逻辑→数据存取→数据这三层逻辑，现在需要对“业务逻辑”层进行单元测试，那么我们可以使用Mock对数据存取与数据层的内容进行模拟，从而使上面的单元测试是独立的。</p></blockquote><h4 id="2-1-3-设计思路"><a href="#2-1-3-设计思路" class="headerlink" title="2.1.3 设计思路"></a>2.1.3 设计思路</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282028962.png"></p><p><strong>如何设计单元测试：</strong></p><p>**单元测试case的核心:**结合具体的应用场景、具体的输入数据与当前函数的功能实现，对于输出数据作出具体的预期，即可把全部待测试的分支都罗列了出来。</p><p>即：<strong>应用场景+输入数据+功能实现=输出数据。</strong></p><h4 id="2-1-4-断言-Assertions"><a href="#2-1-4-断言-Assertions" class="headerlink" title="2.1.4 断言(Assertions)"></a>2.1.4 断言(Assertions)</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282029555.png"></p><p>断言是一种在java单元测试中经常使用的测试方法。在单元测试中，我们<strong>使用“断言”来检验当前的测试结果是成功还是失败。</strong></p><blockquote><p><strong>常见的断言：</strong></p><p>Assert.assertNotNull</p><p>Assert.assertEquals</p><p>Assert.assertTrue</p><p>Assert.assertFalse</p><p>Assert.fail     </p></blockquote><p><strong>在单元测试中使用断言可以令预测结果自动呈现，无需人工对单元测试结果进行判断。</strong></p><h3 id="2-2-单元测试的运行"><a href="#2-2-单元测试的运行" class="headerlink" title="2.2 单元测试的运行"></a>2.2 单元测试的运行</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282031441.png"></p><h4 id="2-2-1-手动"><a href="#2-2-1-手动" class="headerlink" title="2.2.1 手动"></a>2.2.1 手动</h4><ol><li><strong>直接在IDE中执行</strong></li></ol><p>在开发编码完成之后，开发人员可以直接在自己的环境和编译器内运行单元测试。</p><ol start="2"><li><strong>使用maven的mvn test</strong></li></ol><p>Maven是目前java开发中最流行的项目构建工具，它非常全面的包含了很多功能。mvn test这个测试模块就可以为我们的单元测试提供极大的便利。</p><h4 id="2-2-2-自动"><a href="#2-2-2-自动" class="headerlink" title="2.2.2 自动"></a>2.2.2 自动</h4><p><strong>持续集成（Jenkins）：</strong>自动化持续集成是我们在项目中常用的一种单元测试的方法。通用工具为Jenkins，Jenkins是一种持续集成的工具，它的功能非常强大。他的主要的功能有软件发布和版本测试、外部调用监控。</p><h3 id="2-3-如何判断单元测试的质量"><a href="#2-3-如何判断单元测试的质量" class="headerlink" title="2.3 如何判断单元测试的质量"></a>2.3 如何判断单元测试的质量</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282032798.png"></p><p>衡量标准：</p><p>从<strong>主观层面</strong>，优秀的单元测试可读性高、易于维护、值得信赖.</p><p>从<strong>客观层面</strong>，使用单元测试代码覆盖率来衡。覆盖率工具包括：集成IDE和单独布署。</p><h2 id="3-如何做好-Code-Review"><a href="#3-如何做好-Code-Review" class="headerlink" title="3 如何做好 Code Review"></a>3 如何做好 Code Review</h2><h3 id="3-1-为什么要做好-Code-Review"><a href="#3-1-为什么要做好-Code-Review" class="headerlink" title="3.1 为什么要做好 Code Review"></a>3.1 为什么要做好 Code Review</h3><h4 id="3-1-1-Code-Review是提升代码质量的最好方法"><a href="#3-1-1-Code-Review是提升代码质量的最好方法" class="headerlink" title="3.1.1 Code Review是提升代码质量的最好方法"></a>3.1.1 Code Review是提升代码质量的最好方法</h4><p>强化Code Review是<strong>提升代码质量的第一选择。</strong></p><p>在代码开发过程中，我们越早发现问题、定位问题，在修复问题时付出的成本越小。</p><p>大约有50%以上的bug，都是在做Code Review时发现的。前期做好Code Review，后期将会减少反复修改等不必要的复工。</p><h4 id="3-1-2-Code-Review能够在团队内传递知识"><a href="#3-1-2-Code-Review能够在团队内传递知识" class="headerlink" title="3.1.2 Code Review能够在团队内传递知识"></a>3.1.2 Code Review能够在团队内传递知识</h4><p>从知识传递的角度看，<strong>Code Review是极为重要的。</strong></p><p>做好Code Review，能够帮助团队传递知识、沟通交流、互相学习，能够提升学习能力、提升编写代码能力、提升代码质量、提升工作效率、降低项目风险。</p><p>另外，基于codebase可以使我们了解项目全局，培养系统的思考方式。</p><h4 id="3-1-3-Code-Review是辅导怎么写代码的最好方法"><a href="#3-1-3-Code-Review是辅导怎么写代码的最好方法" class="headerlink" title="3.1.3 Code Review是辅导怎么写代码的最好方法"></a>3.1.3 Code Review是辅导怎么写代码的最好方法</h4><p>我们要意识到，做Code Review可以学习到别人的经验，同时也可以向别人传递我们的经验。</p><p>如果我们想辅导别人，<strong>最好的办法就是让对方先写一段代码，我们对他的代码进行Code Review。</strong>在辅导他人的过程中，我们可以快速地发现问题，从而帮助改进。</p><h4 id="3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力"><a href="#3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力" class="headerlink" title="3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力"></a>3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力</h4><p>工作中是否有Code Review对于公司或团队来说非常重要。不但对于公司或团队内的人员有所提升，而且能够吸引出色的开发者加入开发团队。</p><p>未做好Code Review的公司或团队有如下特点：</p><ol><li>代码质量差。</li><li>团队内人员备份差。</li><li>团队开发人员得不到有效的辅导，提高慢。</li></ol><h4 id="3-1-5-为什么要提高代码质量？"><a href="#3-1-5-为什么要提高代码质量？" class="headerlink" title="3.1.5 为什么要提高代码质量？"></a>3.1.5 为什么要提高代码质量？</h4><ol><li>提高代码质量可以提高代码的可读性。</li><li>提高代码质量可以提高代码的复用性和参考性。</li><li>提高代码质量可以减少bug出现的风险。</li><li>提高代码质量可以减少后期补丁的风险。</li><li>提高代码质量可以降低代码失控的风险。</li><li>提高代码质量可以降低项目重构和升级的麻烦。</li></ol><h4 id="3-1-6-为什么要提高写代码的能力"><a href="#3-1-6-为什么要提高写代码的能力" class="headerlink" title="3.1.6 为什么要提高写代码的能力"></a>3.1.6 为什么要提高写代码的能力</h4><ol><li>代码能力如果停滞不前，对于个人而言，将导致职业危机。</li><li>代码能力如果停滞不前，对于团队而言，将意味着团队没有成长。</li></ol><p><strong>Code Review是一个非常重要的提升代码质量和代码能力的手段。</strong>无论是从个人发展角度，还是团队发展角度，我们都需要重视Code Review。</p><h3 id="3-2-如何做好-Code-Review"><a href="#3-2-如何做好-Code-Review" class="headerlink" title="3.2 如何做好 Code Review"></a>3.2 如何做好 Code Review</h3><h4 id="3-2-1-在Code-Review中可能发现的问题"><a href="#3-2-1-在Code-Review中可能发现的问题" class="headerlink" title="3.2.1 在Code Review中可能发现的问题"></a>3.2.1 在Code Review中可能发现的问题</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282043808.png"></p><h4 id="3-2-2-在Code-Review中应有的态度"><a href="#3-2-2-在Code-Review中应有的态度" class="headerlink" title="3.2.2 在Code Review中应有的态度"></a>3.2.2 在Code Review中应有的态度</h4><ol><li><p>对所有检查的代码逻辑要做到“完全看懂”，对于审核的代码，熟悉程度要做到“如数家珍”。如果在审核代码后，对代码的逻辑和背后的原因仍然很模糊，则是一个失败的Code Review。</p></li><li><p>好代码的标准，不仅仅是“可以运行通过”，在正确性、可读性、可重用性、可运维性等方面上，都需要综合考虑。</p></li><li><p>建立Code Review和写代码一样重要的意识。即：</p><blockquote><ol><li>Code Review和写代码一样，也有产出，即产出更高质量的代码。</li><li>审核代码在很多情况下比写代码还要辛苦，需要理解和找出问题等。</li></ol></blockquote></li><li><p>以提升代码质量为最终目标。</p></li><li><p>要投入足够的时间和精力。</p><blockquote><pre><code>        1. 审核代码花费的时间经常和写代码一样多，有时甚至比写代码的时间更多，要有时间意识。        1. 要有责任意识。如果出现bug，不仅仅是写代码人员的职责，也不仅仅是QA的职责，代码审核者也需要承担相当大的责任。</code></pre></blockquote></li></ol><h4 id="3-2-3-在Code-Review之前，需要了解一流代码的特性"><a href="#3-2-3-在Code-Review之前，需要了解一流代码的特性" class="headerlink" title="3.2.3 在Code Review之前，需要了解一流代码的特性"></a>3.2.3 在Code Review之前，需要了解一流代码的特性</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282046798.png" alt="一流代码的特性"></p><p><strong>一流代码有以下特性：①高效性；②鲁棒性；③简洁；④简短；⑤可共享；⑥可测试；⑦可移植；⑧可监控；⑨可运维；⑩可扩展。</strong></p><p>将以上十条标准进行总结精简归纳为：</p><blockquote><ol><li>代码的正确和性能；</li><li>代码的可读和可维护性；</li><li>代码的可运维和可运行；</li><li>代码的可共享和可重用；</li></ol></blockquote><p>在Code Review时，综合考虑以上一流代码的特性，可以快速提升代码质量、提升编写代码的能力等。</p><h4 id="3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力"><a href="#3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力" class="headerlink" title="3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力"></a>3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力</h4><p><strong>通常bad code有以下特点：</strong></p><ol><li>5分钟内不能看懂的代码。</li></ol><p>​        不能快速看懂的代码，一定是有问题的代码，可以先抛回给编写代码人员进行修正。<strong>一般一个函数的操作不能超过6个step</strong>，如果超过这个数量，则需要重新调整编码逻辑。</p><ol start="2"><li>需要思考才能看懂的代码。</li></ol><p>​        好的代码阅读时基本不用动脑子，甚至看注释就能看懂。</p><ol start="3"><li>需要来回翻屏才能看懂的代码。</li></ol><p>​        好的代码，经常在一屏内就是一个完整的逻辑。</p><ol start="4"><li>没有空行或注释的代码。</li></ol><p>​        在Code Review时，发现不会用段落、不会写注释的代码，肯定不是好的程序员写的代码，可以直接打回给编写代码人员进行修正。</p><h4 id="3-2-5-Code-Review的注意事项"><a href="#3-2-5-Code-Review的注意事项" class="headerlink" title="3.2.5 Code Review的注意事项"></a>3.2.5 Code Review的注意事项</h4><ol><li>在必要时，review的双方做<strong>面对面的沟通。</strong></li></ol><p>​        面对面沟通并不是单指当面沟通，还包括云共享、电话、视频沟通等。在沟通时，对于背景、关键点等应进行说明，便于reviewer的理解。在必要时，应提供设计文档。</p><ol start="2"><li>对于关键模块，应该建<strong>立owner制度。</strong></li></ol><p>​        所有提交的代码，必须由owner做最终确认。由owner掌握全局，并建立明确的责任关系。</p><ol start="3"><li><p>检查中发现的问题，要一追到底。</p></li><li><p>要<strong>注意细节。</strong>对每一行提交的代码，都要进行检查。</p></li><li><p><strong>Code Review的方式，要小步快跑。</strong>每次提交review的代码量不要太多，降低复杂度。在特殊情况时，比如一个新模块的构建，最好逐步完成，通过多次进行提交。</p></li><li><p>要为Code Review<strong>预留出足够的时间。</strong>Code Review VS Coding的时间，有时可能达到1:1。在这里需要考虑到有时会做大的修改，科学地规划工作量，尽量避免出现时间倒排。</p></li><li><p>注意每天 review代码的数量不宜过多。</p></li></ol><h4 id="3-2-6-Code-Review的步骤"><a href="#3-2-6-Code-Review的步骤" class="headerlink" title="3.2.6 Code Review的步骤"></a>3.2.6 Code Review的步骤</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282051436.png" alt="、"></p><p>Code Review的步骤为以下几点：</p><p><strong>Step1：先看系统全貌</strong></p><p>不深究细节，浏览系统全貌，理清模块划分的逻辑、模块间的关系、如何构成的整个系统等。</p><p><strong>Step2：进入模块级别</strong></p><p>同样不深究细节，浏览模块内的全貌，判断模块切分是否合理，理清模块内的逻辑，明确关键数据、关键的类和函数等。</p><p><strong>Step3：理清类、函数内部的逻辑。</strong></p><p><strong>Step4：进入细节。</strong></p><p>比如Layout、命名等。</p><h4 id="3-2-7-人为因素"><a href="#3-2-7-人为因素" class="headerlink" title="3.2.7 人为因素"></a>3.2.7 人为因素</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282053170.png"></p><p>除了代码上的问题，在Code Review过程中还会有一些人为因素，例如：</p><p><strong>①QA人员</strong></p><p>好的QA人员不仅仅会发现系统中的bug，还会质疑或提出产品需求，挑战或优化系统架构和实现方式。</p><p><strong>②Code Reviewer</strong></p><p>好的代码审核人员不仅仅指出代码表面的问题，还会检查系统需求分析的质量、接口或函数定义的合理性、模块划分的合理性、系统关键机制的合理性等。</p><h3 id="3-3-例子：Python-代码的-Code-Review"><a href="#3-3-例子：Python-代码的-Code-Review" class="headerlink" title="3.3 例子：Python 代码的 Code Review"></a>3.3 例子：Python 代码的 Code Review</h3><h4 id="3-3-1-Python的编码规范"><a href="#3-3-1-Python的编码规范" class="headerlink" title="3.3.1 Python的编码规范"></a>3.3.1 Python的编码规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282111474.png"></p><ul><li><p>代码要写的漂亮。</p></li><li><p>代码要<strong>明确直接</strong>，不要含蓄表达。</p></li><li><p>代码要<strong>简洁</strong>，一个函数可以实现的功能就不要写两个函数。</p></li><li><p><strong>代码深奥胜过代码复杂</strong>。代码可以写的深奥难懂，但是不能写的过于复杂。</p></li><li><p>代码要<strong>平铺直叙</strong>，不要层层嵌套。</p></li><li><p>代码要做到<strong>合理间隔。</strong></p></li><li><p>代码<strong>可读性</strong>非常重要。</p></li><li><p>代码要有普适性。尽量规避代码特殊性，用最简洁最通用的代码来实现。</p></li><li><p>代码要实用。</p></li><li><p>要重视所有发现的错误。</p></li><li><p>代码逻辑要清晰。在含糊混乱的面前，我们要拒绝猜测。读写代码时，不要出现“好像”、“可能”、“似乎”等猜测。当一段代码很难懂的时候，代码一定存在问题。</p></li><li><p>写代码要注重行动。</p></li><li><p>代码实现方法要简洁。如果一个方法很难解释，就意味着这个方法存在一定的问题。</p></li><li><p>要重视命名空间的使用。</p></li></ul><h4 id="3-3-2关于Python编程规范的部分说明"><a href="#3-3-2关于Python编程规范的部分说明" class="headerlink" title="3.3.2关于Python编程规范的部分说明"></a>3.3.2关于Python编程规范的部分说明</h4><p>Python编程规范有九个维度。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282113051.png"></p><h5 id="1-模块的划分"><a href="#1-模块的划分" class="headerlink" title="1 模块的划分"></a>1 模块的划分</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282118231.png"></p><p>我们要对模块有概念，这是整个系统的基础。</p><ol><li><p>一个.py文件是一个模块。</p></li><li><p>模块的划分对软件的长期维护非常重要。</p></li><li><p>每个模块都应该有特定的功能。</p></li></ol><blockquote><p>比如：配置文件的读取，网页文件的写入，网页文件的解析，一个内存数据表，一个抓取的线程等等。</p></blockquote><ol start="4"><li>多个本应独立的模块，写到一个.py文件中是常见的错误。从Code Review角度看，首先就是要看模块切分的对不对。</li></ol><h5 id="2-数据的封装"><a href="#2-数据的封装" class="headerlink" title="2 数据的封装"></a>2 数据的封装</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282117284.png"></p><p>在Code Review时，要着重注意数据是否封装这一问题。</p><h5 id="3-import"><a href="#3-import" class="headerlink" title="3 import"></a>3 import</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282118516.png"></p><p>Import在使用过程中，禁止使用from xxx import yyy语法直接导入类或函数。禁止使用from xxx import *这样的方法。这样做的目标是：容易判断代码中使用外部变量或函数的来源。</p><p>如果使用禁止中的语法，会大大增加判断来源的难度，以及代码阅读的难度。</p><p>在Code Review时，遇到这种情况，及时将代码打回给编程人员进行修正。</p><h5 id="4-异常"><a href="#4-异常" class="headerlink" title="4 异常"></a>4 异常</h5><p>对于异常的处理有以下几点需要注意：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282120853.png"></p><blockquote><ol><li>异常的使用</li></ol><p>​        使用异常前请需要详细了解异常的行为。不要主动抛出异常，使用返回值。如果一定要抛异常，需要注释进行说明。</p><ol start="2"><li>异常的获取强制</li></ol><p>​        除非重新抛出异常，否则禁止使用except:捕获所有异常，不建议捕获Exception或StandardError。</p><p>​        在实际编码中建议try中的代码尽可能少，避免catch住未预期的异常，掩藏掉真正的错误。底线是至少要打印异常的日志，而不是捕获后直接pass通过。</p><p>​        在对异常进行处理时尽量针对特定操作的特定异常来捕获。</p><ol start="3"><li>函数的返回值</li></ol><p>​        如果函数会抛出异常，需要在函数的注释中明确说明。</p></blockquote><p>在Code Review时，需要注意上述问题，及时返回给编程人员进行修正。</p><h5 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5 构造函数"></a>5 构造函数</h5><p>对于构造函数有以下几点需要注意：</p><ol><li>规范：</li></ol><p>类构造函数应该尽量简单，不能包含可能失败或过于复杂的操作。</p><ol start="2"><li>解读：</li></ol><p>在构造函数中常出现的错误是：无法判断、或捕获异常。</p><h5 id="6-函数返回值"><a href="#6-函数返回值" class="headerlink" title="6 函数返回值"></a>6 函数返回值</h5><p>对于函数返回值有以下几点需要注意：</p><ol><li>规范：</li></ol><blockquote><p>函数返回值必须小于等于3个。返回值超过3个时必须通过class/namedtuple/dict等具名形式进行包装。</p></blockquote><ol start="2"><li>解读：</li></ol><blockquote><p>a. 多数情况下的错误，是因为很多人不会思考和设计函数的语义。</p><p>函数描述涉及的三要素为：功能描述、传入参数描述和返回值描述。</p><p>每个函数都应该有足够明确的语义。基于函数的语义，函数的返回值有三种类型：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282122993.png"></p><p>b .另外，函数需要有返回值，对于正确或错误的情况，在返回值中要有体现。</p><p>c .还有一个问题是：Python的数据格式不需要定义，过于灵活。当程序规模变大、维护周期变长时，会导致后期极难维护。</p><p>应对措施是：多写注释，写清楚返回值说明、参数说明。</p></blockquote><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282123350.png"></p><p>在Code Review时，注释未写清楚的代码，一定要打回给编程人员，进行修正、补注释。</p><h5 id="7-代码长度"><a href="#7-代码长度" class="headerlink" title="7 代码长度"></a>7 代码长度</h5><p>关于代码长度有以下几点需要注意：</p><ol><li>每行不得超过120个字符。避免在终端上显示出现折行。</li><li>函数长度不得超过100行。函数过长会增加理解函数逻辑的难度。Python的函数应尽量控制在30~40行之间。</li></ol><p>在Code Review时，代码过长，建议全部打回给编程人员进行修正。</p><h5 id="8-空行、空格"><a href="#8-空行、空格" class="headerlink" title="8 空行、空格"></a>8 空行、空格</h5><p>关于空行、空格有以下几点需要注意：</p><ol><li>空行</li></ol><p>​        文件及定义之间隔两个空行。比如类或全局函数。类方法之间隔一个空行。</p><ol start="2"><li>空格</li></ol><p>​        逗号、分号、冒号前不加空格，后边加一个空格。所有二元运算符前后各加一个空格。</p><p>在Code Review时，需要着重注意空行和空格。空行和空格不是可有可无的。空行和空格的存在，是为了增加可读性。不好读的代码，一律打回给编程人员进行修正。</p><h5 id="9-注释"><a href="#9-注释" class="headerlink" title="9 注释"></a>9 注释</h5><p>关于注释有以下几点需要注意：</p><p>Python中的注释有一个特殊之处是docstring，<strong>docstring要和“＃”注意区分开。</strong></p><blockquote><p>相关规范有：</p><ol><li><p>使用docstring描述module、 function 、class和method接口时，<strong>docstring必须用三个双引号括起来。</strong></p></li><li><p>对外接口部分必须用docstring描述。内部接口视情况自行决定是否写docstring。</p></li><li><p>接口的docstring描述<strong>至少包括功能简介、参数、返回值。</strong>如果可能抛出异常，必须使用注释进行说明。</p></li><li><p><strong>每个文件都必须有文件声明</strong>，文件声明必须包括以下信息：版权声明、功能和用途简介、修改人及联系方式。</p></li></ol></blockquote><p>在Code Review时，不符合上述规范的，及时打回给编程人员进行修正。</p><h3 id="3-4-如何成为一个好的reviewer"><a href="#3-4-如何成为一个好的reviewer" class="headerlink" title="3.4 如何成为一个好的reviewer"></a>3.4 如何成为一个好的reviewer</h3><p>代码审核的质量，和审核者的代码能力直接相关。代码审核的质量差，反映的是审核者的代码水平。如果作为一个代码审核员不会写代码，就要承认真相，并且要不断提高自己的代码能力。</p><p>学习资料：</p><ol><li>关于代码的书籍：《编写可读代码的艺术》，《代码整洁之道》。</li><li>综合的书籍：《代码大全》，《201  principles of software development》。</li><li>其他：《代码的艺术》课程，Python Good Coder考试指南。</li></ol><h3 id="3-5-公司针对-Code-Review-的措施"><a href="#3-5-公司针对-Code-Review-的措施" class="headerlink" title="3.5 公司针对 Code Review 的措施"></a>3.5 公司针对 Code Review 的措施</h3><p><strong>1、建立高效可运营的代码审核机制，提升代码质量，降低代码评审成本。</strong></p><blockquote><p>①基于平台：icode+bugbye</p><p>②代码检查规则分级，分为ERROR、WARNING、ADVICE三类，对ERROR级别阻塞提交。</p><p>③通过统计数据驱动代码检测规则的优化。</p></blockquote><p><strong>2、通过工程能力地图考察项目的Code Review情况。</strong></p><p><strong>3、所有的Code Review行为，都基于icode平台进行。良好的工具可以帮助更好的进行代码审核</strong></p><h3 id="3-6-Code-Review-总结"><a href="#3-6-Code-Review-总结" class="headerlink" title="3.6 Code Review 总结"></a>3.6 Code Review 总结</h3><!-- flag of hidden posts -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度高效研发实战训练营Step4&quot;&gt;&lt;a href=&quot;#百度高效研发实战训练营Step4&quot; class=&quot;headerlink&quot; title=&quot;百度高效研发实战训练营Step4&quot;&gt;&lt;/a&gt;百度高效研发实战训练营Step4&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http:</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="百度高效研发实战训练营" scheme="https://www.ckxgzxa.top/tags/%E7%99%BE%E5%BA%A6%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>百度高效研发实战训练营Step3</title>
    <link href="https://www.ckxgzxa.top/bitTraingClub3.html"/>
    <id>https://www.ckxgzxa.top/bitTraingClub3.html</id>
    <published>2021-11-25T01:00:12.000Z</published>
    <updated>2021-12-08T08:09:00.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度高效研发实战训练营Step3"><a href="#百度高效研发实战训练营Step3" class="headerlink" title="百度高效研发实战训练营Step3"></a>百度高效研发实战训练营Step3</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-质量意识"><a href="#1-质量意识" class="headerlink" title="1 质量意识"></a>1 质量意识</h2><h3 id="1-1-质量的基本概念"><a href="#1-1-质量的基本概念" class="headerlink" title="1.1 质量的基本概念"></a>1.1 质量的基本概念</h3><h4 id="1-1-1-质量重要性的认识"><a href="#1-1-1-质量重要性的认识" class="headerlink" title="1.1.1 质量重要性的认识"></a>1.1.1 质量重要性的认识</h4><p>随着技术更新，市场竞争的加剧，质量问题成为困扰不少企业的一大难题，也给一些企业造成了巨大的损失，这就使得项目质量的重要性不断凸显。</p><p>通过对于这些失败案例的分析不难发现，项目的质量保证是一个需要<strong>项目全体成员参与</strong>的重要工作，只有在项目团队的共同努力下，才能有效保证项目的质量，为企业和社会创造价值。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281614025.png"></p><p>项目管理三要素为<strong>质量、时间、成本</strong>，三个要素缺一不可、相互制约，一味追求某一要素的做法是不明智的。一个成功的项目必然是在三者的取舍间达成了一个平衡。</p><h4 id="1-1-2-质量保证和测试的关系"><a href="#1-1-2-质量保证和测试的关系" class="headerlink" title="1.1.2 质量保证和测试的关系"></a>1.1.2 质量保证和测试的关系</h4><p>质量问题有很多种，常见的有代码缺陷、产品缺陷、Bug、用户体验差、性能差、服务不稳、安全问题、可兼容性差等。我们经常通过测试来发现问题，并将发现的问题分<strong>功能性测试类问题和用户体验评估类问题。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281615870.png"></p><p>测试工作是质量保证工作中的重要一环，但是我们应该认识到，质量保证工作不能只依靠测试的反馈，而应该贯穿项目开发的整个过程。</p><h4 id="1-1-3-Bug的基本认识"><a href="#1-1-3-Bug的基本认识" class="headerlink" title="1.1.3 Bug的基本认识"></a>1.1.3 Bug的基本认识</h4><p><strong>Bug</strong>是程序中的缺陷和问题，<strong>属于功能性测试类问题的范畴</strong>， Bug是一种很常见的质量问题，也是我们在项目开发中应该尽量减少或避免的质量问题。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281617228.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281618840.png"></p><p>Bug的修复有一套完整的规定流程。</p><p>首先，测试人员或者用户发现Bug后，将其置为<strong>激活状态</strong>；开发人员收到激活状态的Bug后，对其进行修复，修复过程中， Bug状态为<strong>处理中</strong>；修复完成后，开发人员将其置为<strong>解决状态</strong>；测试人员再对其进行<strong>验证</strong>，若通过，则将其关闭，否则，重新激活Bug即重启状态，交予开发人员继续修复，直至验证通过。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292217099.png"></p><p>从这一流程可以看到，<strong>Bug有五种状态，Open（激活）、In Process（处理中）、Resolved（解决）、closed（关闭）、Reopen（重启）</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281621054.png"></p><p>Bug生命周期有一定规律性。以传统软件中的瀑布模型举例，85%的问题在项目初期的编码阶段引入，在后期测试阶段，发现Bug的数量会逐渐增多，与之对应的修复成本也会急剧增加。可见，降低<strong>修复成本最有效的方式，就是在Bug引入的阶段就及时发现并修复Bug。</strong></p><h3 id="1-2-Bug提交方法"><a href="#1-2-Bug提交方法" class="headerlink" title="1.2 Bug提交方法"></a>1.2 Bug提交方法</h3><blockquote><p>Bug提交需要反馈渠道，Bug的反馈渠道分为内部用户反馈渠道和外部用户反馈渠道两种。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281623796.png"></p><ol><li>内部用户反馈渠道包括：产品Icafe空间、产品论坛、Bugs邮件组、Bugs平台。</li><li>外部用户反馈渠道包括：产品自身反馈渠道和产品接入反馈平台。</li></ol></blockquote><p><strong>Bug的提交有严格的格式要求，提交的Bug反馈应包括以下七个方面的内容：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281624518.png"></p><p>正确提交Bug能确保负责人能够清晰了解问题，直接进行数据挖掘，找到Bug所有的属性，便于后续维护工作的开展。</p><h3 id="1-3-质量保证在项目各阶段的实现"><a href="#1-3-质量保证在项目各阶段的实现" class="headerlink" title="1.3 质量保证在项目各阶段的实现"></a>1.3 质量保证在项目各阶段的实现</h3><p>质量的保证不能仅仅依靠测试人员，而是需要贯穿项目的各个阶段。</p><p>Bug的发现和修复是项目质量保证的一个重要方面，但质量保证工作绝不仅仅是修复Bug这么简单。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281626934.png"></p><p>项目的开发整体路径包括：需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、上线阶段以及线上阶段。</p><p>在一个项目开发的各个不同阶段，质量保证工作的要求和思路均有一定的不同，下面我们来展现质量保证工作在各个阶段的具体实现。</p><h4 id="1-3-1-需求与设计阶段的质量保证工作"><a href="#1-3-1-需求与设计阶段的质量保证工作" class="headerlink" title="1.3.1 需求与设计阶段的质量保证工作"></a>1.3.1 需求与设计阶段的质量保证工作</h4><p>需求与设计阶段是项目开始的重要阶段，只有从客户真正的需求出发，才能设计出真正令客户满意的产品。</p><p>在一阶段，质量保证工作的关键点有三：</p><ol><li><p><strong>需求评审：</strong>站在用户的角度思考和挖掘需求，是设计和开发的前提性条件。</p></li><li><p><strong>需求的变更管理：</strong>用户的需求始终在改变，建立一套完善机制去及时适应需求的变更十分重要。</p></li><li><p><strong>设计评审：</strong>通过评审需求的可行性和设计的相关风险，可以极大降低设计风险，避免人力浪费。</p></li></ol><h4 id="1-3-2-开发与测试阶段的质量保证工作"><a href="#1-3-2-开发与测试阶段的质量保证工作" class="headerlink" title="1.3.2 开发与测试阶段的质量保证工作"></a>1.3.2 开发与测试阶段的质量保证工作</h4><p>在开发阶段，质量保证工作最重要的有两点：<strong>单元测试和代码评审。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281632782.png"></p><blockquote><p>单元测试的作用很多，主要有：</p><p>（1） 调试代码，确保代码实时可编译。</p><p>（2） 验证逻辑，减少代码中的Bug。</p><p>（3） 作为一个最细粒度回归测试，实时反馈代码的质量。</p></blockquote><blockquote><p>代码评审也同样十分重要，它的作用主要为：</p><p>（1） 保持代码风格的一致和可读性，利于贯彻编程规范。</p><p>（2） 提高代码质量，减少Bug。</p><p>（3） 促进互相交流学习，提升团队的整体研发能力，进而提高企业的整体竞争力。</p></blockquote><p>而在测试阶段，我们的主要任务是<strong>测试功能性测试类问题。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281632723.png"></p><blockquote><p>测试阶段一般流程为：</p><p>第一步：<strong>撰写测试方案</strong>。由测试人员编写方案并提交开发人员评审。</p><p>第二步：<strong>进行单元测试</strong>。由开发人员编写用例，并交给测试人员评审。</p><p>第三步：<strong>进行功能性测试</strong>。由测试人员设计和编写用例。</p><p>第四步：<strong>进行性能/压力等测试</strong>。测试人员根据项目情况决定是否进行。</p><p>第五步：<strong>自动化和持续集成</strong>。将测试自动化，并把流程加入持续集成。</p><p>第六步：<strong>撰写测试报告</strong>。测试人员要在大版本时编写测试报告。</p></blockquote><p>测试环节涉及很多的内容，包括了：</p><p>（1）测试方案。</p><p>（2）自动化/持续集成。</p><p>（3）测试报告。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281634364.png"></p><p>在这一环节中，<strong>撰写测试方案是对该阶段工作的整体规划。</strong>测试方案描绘了测试和质量保证的各种工作，规划了如何组织测试，方案中包括了：质量目标、风险评估、测试范围、测试优先级、测试方法、测试流程、测试计划和测试设计的内容。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281634848.png"></p><p><strong>常用的测试方法有</strong>：黑盒/白盒、静态测试/动态测试、自动化测试/手工测试、验收测试/α测试/β测试、单元测试/模块测试/集成测试/联调测试/系统测试、功能性测试/性能测试/压力测试/异常测试/安全测试、接口测试/用户场景测试、回归测试、探索性测试等。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281635604.png"></p><p>不同的测试方法有不同的特点和擅长解决的问题。测试的侧重点不同，发现的问题也不同。我们需要根据测试方案，来选择合适的测试方法，提高测试的效率。为此，在前期的测试和设计方案评审时要及早发现问题，避免无效劳动，提高测试效率。</p><p>同样，自动化和持续集成也是有效提高测试效率的方法。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281635791.png"></p><p><strong>自动化包括流程自动化和测试自动化。</strong>流程自动化包括编译、部署、发布、回滚、上线和测试阶段。测试自动化可以降低成本并保证测试结果，降低风险。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281636766.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281637773.png"></p><p>而基于自动化，我们可以搭建串联工作流，即持续集成，可以将代码提交、编译、模块测试、部署、系统测试、发布这一循环性流程集成在一起，从而提高工作效率，保证持续的质量反馈。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281637103.png"></p><p>测试完成后需要撰写详细的测试报告，以方便后期的持续维护和迭代，其内容包括：</p><p>测试结果、质量风险评估、质量评估、测试过程描述、缺陷分析、评估改进意见、测试版本/测试人员/测试时间。</p><h4 id="1-3-3-上线与线上阶段的质量保证工作"><a href="#1-3-3-上线与线上阶段的质量保证工作" class="headerlink" title="1.3.3 上线与线上阶段的质量保证工作"></a>1.3.3 上线与线上阶段的质量保证工作</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281638579.png" alt="image-20211128163800434"></p><p><strong>上线阶段包括上线过程和回滚过程。</strong></p><p>上线阶段的上线方案需要经过评审和测试，对于重点项目，还应有回滚方案和相应的评审和测试工作。</p><p>上线后，我们需要进行线上测试，常用的线上测试有三类：众包测试、用户反馈和业务监控、产品评测。</p><blockquote><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281641413.png"></p><p>（1）<strong>众包测试：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281642738.png">众包测试的目的是使更多的用户参与测试，降低测试成本。众测服务分为四类：测试类（包括探索性测试、用例组合爆炸测试），产品体验（包括产品建议、Badcase收集）、评估评测（包括大数据量评估标注、降低成本）、用户调研（产品需求调研、用户反馈)。一个众测平台：<a href="http://test.baidu.com/">http://test.baidu.com</a></p><p>（2）<strong>用户反馈和业务监控</strong>：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281642375.png">目的则是为了实现线上问题闭环，通过用户反馈和业务监控可以解决大部分的线上问题。步骤分为收集、分发、定位和解决。主要平台有反馈平台、Bugs平台和 Monitor平台。</p><p>（3）<strong>产品评测：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281643572.png"></p><p>包括用户反馈分析、产品Bug分析、Top问题梳理和竞品对比分析。</p><p>→ <strong>用户反馈分析</strong>是指对用户反馈的问题进行分析。→ 产品Bug分析是指对产品的Bug进行分析，然后解决问题最大的Bug。</p><p>→ <strong>Top问题梳理</strong>是指，对问题进行梳理分类，解决最突出的问题。</p><p>→ <strong>竞品对比分析</strong>是指对自家产品和市场上同类型产品进行分析。</p></blockquote><p>从对各个阶段质量保证工作的分析中，我们不难看出，每一个阶段的质量保证工作都需要多方角色的共同参与。可见，项目的出色质量来源于<strong>每个环节的严格把控和每个成员的共同参与，这是团队质量意识的两大核心。</strong></p><h3 id="1-4-质量保证意识的4个核心内容"><a href="#1-4-质量保证意识的4个核心内容" class="headerlink" title="1.4 质量保证意识的4个核心内容"></a>1.4 质量保证意识的4个核心内容</h3><h4 id="1-4-1-质量保证工作存在于每一个环节"><a href="#1-4-1-质量保证工作存在于每一个环节" class="headerlink" title="1.4.1 质量保证工作存在于每一个环节"></a>1.4.1 质量保证工作存在于每一个环节</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647902.png"></p><h4 id="1-4-2-每一个成员都需要对质量负责"><a href="#1-4-2-每一个成员都需要对质量负责" class="headerlink" title="1.4.2 每一个成员都需要对质量负责"></a>1.4.2 每一个成员都需要对质量负责</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647522.png"></p><h4 id="1-4-3-测试是一种核心的质量保证工作"><a href="#1-4-3-测试是一种核心的质量保证工作" class="headerlink" title="1.4.3 测试是一种核心的质量保证工作"></a>1.4.3 测试是一种核心的质量保证工作</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281646302.png"></p><h4 id="1-4-4-尽早发现问题，尽早解决问题"><a href="#1-4-4-尽早发现问题，尽早解决问题" class="headerlink" title="1.4.4 尽早发现问题，尽早解决问题"></a>1.4.4 尽早发现问题，尽早解决问题</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647888.png"></p><h2 id="2-代码单元测试总体介绍"><a href="#2-代码单元测试总体介绍" class="headerlink" title="2 代码单元测试总体介绍"></a>2 代码单元测试总体介绍</h2><h3 id="2-1-单元测试基础"><a href="#2-1-单元测试基础" class="headerlink" title="2.1 单元测试基础"></a>2.1 单元测试基础</h3><h4 id="2-1-1-单元测试的误区"><a href="#2-1-1-单元测试的误区" class="headerlink" title="2.1.1 单元测试的误区"></a>2.1.1 单元测试的误区</h4><p>单元测试存在一些认识上的误区，包括：</p><ol><li>开发单元测试代码的工作量大。</li><li>做单元测试不属于开发人员的职责。</li><li>代码正确率高，进行单元测试必要性不大。</li><li>后期有集成测试，前期进行单元测试必要性不大。</li><li>单元测试无法带来显著收益，效率不高。</li></ol><h4 id="2-1-2-单元测试的概念"><a href="#2-1-2-单元测试的概念" class="headerlink" title="2.1.2 单元测试的概念"></a>2.1.2 单元测试的概念</h4><p><em><strong>在维基百科中，单元测试的定义为：一段代码调用另一段代码，随后检验一些假设的正确性。</strong></em></p><p><em><strong>在百度百科中，单元测试是指对软件中的最小可测试单元进行检查和验证。</strong></em></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281653449.png"></p><p>那么我们不禁要问：一次编写的单元测试是否只是为了验证该次开发过程中对应的代码逻辑的正确性？</p><p>其实不然，单元测试不仅在于实现问题中的功能，优秀的单元测试作用长久，可以减少后续工作的负担，从而提升整体生产力。</p><h4 id="2-1-3-常见的单元测试问题"><a href="#2-1-3-常见的单元测试问题" class="headerlink" title="2.1.3 常见的单元测试问题"></a>2.1.3 常见的单元测试问题</h4><p>目前单元测试中存在一些常见的问题：</p><ol><li>使用System.out输出测试结果，依赖人去判断测试是否正确。</li><li>不使用Assert(断言)对测试结果进行判断。</li></ol><p><em>在以上两种情形都需要依赖人与电脑的交互来判断此case是否成功，人的工作量较大；**在实际的单元测试中，应当使用断言进行判断，使 case运行时自动输出结果。</em></p><ol start="3"><li>没有边界检查。</li><li>多个测试分支放入一个单元测试方法中。</li></ol><p><em>这种情况会导致一旦出现运行失败时，难以判断出现错误的分支所在。</em></p><ol start="5"><li>测试case环境相关（依赖已知库表、时间）。</li></ol><p><em>对于这种情况，应当做出修改，使输入参数为确定的值。</em></p><ol start="6"><li>测试方法执行有先后顺序。</li></ol><p><em>在实际测试过程中，由于不同的用于运行单元测试的测试框架对于case执行顺序有自己的行为，故单元测试实际执行顺序存在不确定性。</em></p><h4 id="2-1-4-优秀的单元测试"><a href="#2-1-4-优秀的单元测试" class="headerlink" title="2.1.4 优秀的单元测试"></a>2.1.4 优秀的单元测试</h4><p>优秀的单元测试需要以下原则：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281655957.png"></p><ol><li>单元测试彼此之间应具备<strong>独立性</strong>。一个单元测试应独立于其它测试及运行它的环境。</li><li>一个优秀的单元测试是<strong>可重复</strong>的。它需要具备多次运行的能力，若不可重复，则不能算作优秀的单元测试。</li><li>优秀的单元测试<strong>可自动化</strong>。自动化具备双重含义：第一，单元测试<strong>可依赖于现有工具自动化运行</strong>；第二，单元测试执行成功与否<strong>可自动进行判断</strong>，而不依赖于人为判断。</li><li>优秀的单元测试是<strong>彻底的</strong>。单元测试对于被测试对象而言需要覆盖全部的分支。</li></ol><h3 id="2-2-单元测试的意义与建议"><a href="#2-2-单元测试的意义与建议" class="headerlink" title="2.2 单元测试的意义与建议"></a>2.2 单元测试的意义与建议</h3><h4 id="2-2-1-什么情况下做单元测试"><a href="#2-2-1-什么情况下做单元测试" class="headerlink" title="2.2.1 什么情况下做单元测试"></a>2.2.1 什么情况下做单元测试</h4><p><strong>（1）单元测试的好处</strong></p><p>①带来<strong>更高的测试覆盖率</strong>：有些分支问题在集成测试过程中很难发现，但在单元测试中极易发现。</p><p>②<strong>提高团队效率</strong>：单元测试在开发完后立即执行，将测试提前一步，不必等集成测试时才发现问题。</p><p>③<strong>自信的重构和改进实现。</strong></p><p>④<strong>将预期的行为文档化</strong>：完整的单元测试是产品代码的最好文档。</p><p><strong>（2）不当的单元测试会降低生产力</strong></p><p>单元测试并不是越多越好，不当的单元测试会降低生产力。</p><p>①单元测试的工作量与普通代码的工作量的比例介于1:1~1.5:1。</p><p>②整体项目的单元测试运行时间随着单元测试case增多线性增长，测试的执行速度影响每次变更等待的时间。</p><p>③单元测试的代码，也需要长期维护。</p><p><strong>（3）如何选择单元测试的对象</strong></p><p>不写单元测试不好，单元测试写多了也不好，这就要求我们要细心选择单元测试的对象。</p><p>在进行单元测试的时候，应<strong>重点关注核心业务逻辑代码、重用性高的代码与调用频繁的代码</strong>，后两者较为相近。</p><h4 id="2-2-2-不同场景下的单元测试tips"><a href="#2-2-2-不同场景下的单元测试tips" class="headerlink" title="2.2.2 不同场景下的单元测试tips"></a>2.2.2 不同场景下的单元测试tips</h4><p>1）Java Web项目底层的BO\DAO大体都是工具自动生成，无需额外单测，但是<strong>Action(Controller)<strong>层不含有较多的业务逻辑，</strong>需要通过集成测试</strong>发现问题。要注意的是<strong>java web项目</strong>的核心业务逻辑主要存在于Service层代码中，需要<strong>着重进行单元测试</strong>。</p><p>（2）平台类Java项目虽然在单独的场景下几乎不会出现问题，但是交叉混合时可能存在问题。而且由于平台类项目更多的兼顾不同的复杂的应用场景，所以在测试时要尽量做到全面。值得注意的是平台类Java项目的分支较多，所以<strong>要求在单元测试时要做到覆盖分支全面</strong>。</p><p>（3）组件类Java项目和平台类项目类似，也需要侧重分支覆盖全面，包括异常调用情况的覆盖。</p><p>（4）Hadoop的MR任务属于特殊的JAVA程序，集成测试成本高，主要体现在时间成本上。在进行单测时，<strong>可以将核心逻辑代码抽取出来，单独测试。</strong></p><h2 id="3-Python单元测试"><a href="#3-Python单元测试" class="headerlink" title="3 Python单元测试"></a>3 Python单元测试</h2><h3 id="3-1-单元测试的概念、工具与方法"><a href="#3-1-单元测试的概念、工具与方法" class="headerlink" title="3.1 单元测试的概念、工具与方法"></a>3.1 单元测试的概念、工具与方法</h3><h4 id="3-1-1-单元测试的概念"><a href="#3-1-1-单元测试的概念" class="headerlink" title="3.1.1 单元测试的概念"></a>3.1.1 单元测试的概念</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281703584.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281704541.png"></p><p>测试具有许多种不同的类型，比如说单元测试、模块测试、联调测试、系统测试、交付测试等。在这些测试之中，<strong>单元测试是最先要完成的</strong>。单元测试通常是由开发者去完成，用来验证代码中的函数是否符合预期。因此，它聚焦于函数的逻辑以及核心的算法是否正确。<em><strong>通常而言，一个单元测试用例是用于判断在某个特定条件或场景下，某个特定函数的行为。</strong></em></p><h4 id="3-1-2-单元测试的意义"><a href="#3-1-2-单元测试的意义" class="headerlink" title="3.1.2 单元测试的意义"></a>3.1.2 单元测试的意义</h4><p><strong>单元测试的意义包括两个方面。</strong></p><p>（1）质量</p><blockquote><p>①单元测试主要针对函数，<strong>颗粒度小、测试针对性强</strong>，bug更容易暴露；</p><p>②由于单元测试覆盖面较窄，无需考虑其它函数或者所依赖的模块，所以它的<strong>场景易构造，核心功能验证更充分</strong>；</p><p>③进行单元测试保证整体代码结构良好，使代码就具有较高的可测性和可维护性。</p></blockquote><p>（2）效率</p><p>单元测试能够提高开发效率，主要表现在：</p><blockquote><p>①单元测试<strong>进行的时间较早，测试场景构建快</strong>，可有效减少调试时间。</p><p>②由于单元测试<strong>只针对修改的代码</strong>展开测试，无需考虑额外内容，所以在较短时间内即可把预期的逻辑测试充分。</p><p>③单元测试<strong>能够在项目开发初期发现的bug</strong>，bug发现的时间越早，所带来的收益越大。由于尽早发现bug能够节省整个项目开发的时间，所以单元测试可加快开发效率，缩短开发周期。</p></blockquote><h4 id="3-1-3-单元测试框架"><a href="#3-1-3-单元测试框架" class="headerlink" title="3.1.3 单元测试框架"></a>3.1.3 单元测试框架</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281706919.png"></p><p><strong>Unitest的基础概念</strong></p><blockquote><p>在做单元测试之前，需要先了解一下Unittest的几个基础概念。</p><p>①**Test(测试用例)**，针对一个特定场景，特定目的具体测试过程。</p><p><em>比如说一个函数通过一组输入测试它，就是一个测试用例；如果一个函数通过三组输入来测试，即为三个测试用例。</em></p><p>②<strong>TestCase（测试类）</strong>，可以包含同一个测试对象的多个测试用例。</p><p><em>如果一个函数通过三组输入来测试，也就是三个测试用例，这三个测试用例可以合成为一个测试类。</em></p><p>③<strong>TestSuite（测试集）</strong>，可以包含多个测试类的多个测试用例。</p><p>④<strong>Assertion（断言）</strong>，必须使用断言判断测试结果。</p><p>⑤<strong>TestFixture</strong>，为测试做统一的准备和清除工作，通常是初始化，连接数据库，准备数据，断开数据库，清除现场等。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281711746.png"></p><p>扩展来说，TestFixture有四种最常使用的作用范围，分别为：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281710167.png"></p><blockquote><ol><li>setUp：在测试类的每个测试用例执行前执行。</li><li>teardown：在测试类的每个测试用例执行后执行。</li><li>setUpClass：在测试类的第一个测试用例执行前执行。</li><li>tearDownClass：在测试类的最后一个测试用例执行后执行。</li></ol></blockquote><p>TestFixture可以让单元测试代码更简单，但并非必须使用，也不要求配对出现。</p></blockquote><h4 id="3-1-4-单元测试的规范"><a href="#3-1-4-单元测试的规范" class="headerlink" title="3.1.4 单元测试的规范"></a>3.1.4 单元测试的规范</h4><p>如下是单元测试涉及的规范。</p><p>（1）所有的单元测试<strong>必须使用断言（assert）判断结果</strong>，禁止出现无断言的测试用例；</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281712364.webp"></p><p>使用断言，不但有利于他人理解，而且一旦出现不符合预期的情况，可以立即找出问题。</p><p>可以使用assertEqual, assertNotEqual 来判断相等或不相等，assertTrue,assertFalse 来判断Boolean, assertRaises 判断抛出的异常是否符合预期。</p><p>（2）测试用例需要具有自表述能力，达到见名知意。</p><p>比如命名test_login_with_invalid_password()，通过它的名字便可知它是用一个非法的密码去测试登录功能，具有自表述能力；但是如果命名为 test_login_case_（），名字减少了很多信息，难以得知它具体在做什么，不具有自表述能力。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281714852.png"></p><p>（3）测试用例之间相互独立，不应相互依赖、相互调用。</p><p>（4）<strong>一个测试用例只测一个函数。</strong>一个测试用例里面可以包含这一个函数的多个场景，但不能包含有多个参数的函数。原因在于，复杂测试用例出现错误时，无法定位问题的出处。</p><h4 id="3-1-5-单元测试对编码的要求"><a href="#3-1-5-单元测试对编码的要求" class="headerlink" title="3.1.5  单元测试对编码的要求"></a>3.1.5  单元测试对编码的要求</h4><p>单元测试中代码需保持一致性，尽量不要出现结果不一致的情况。假设有的代码会带来不一致性，导致单元测试无法稳定运行。针对这种情况，有两种解决方案：</p><p><strong>第一，将带来不一致性的代码抽取出来，</strong>把它作为一种变量传入我们需要调用或使用一致性变量的时候；</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281715404.png"></p><p><strong>第二，借助第三部分即将讲到的一个工具——mock</strong>——来解决这种问题。</p><h3 id="3-2-Coverage-统计单元测试覆盖率的工具"><a href="#3-2-Coverage-统计单元测试覆盖率的工具" class="headerlink" title="3.2 Coverage 统计单元测试覆盖率的工具"></a>3.2 Coverage 统计单元测试覆盖率的工具</h3><p>单元测试做完之后如何评价我们单元测试的效果。此时需要用到覆盖率工具，即Coverage。Coverage是一个第三方的工具，需要提前下载安装。</p><h4 id="3-2-1-统计覆盖率方法"><a href="#3-2-1-统计覆盖率方法" class="headerlink" title="3.2.1 统计覆盖率方法"></a>3.2.1 统计覆盖率方法</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281719654.png"></p><p>把python替换为coverage run-branch，然后会生成coverage文件，文件里会记录所有我们需要的覆盖率信息。</p><h4 id="3-2-2-打印覆盖率信息"><a href="#3-2-2-打印覆盖率信息" class="headerlink" title="3.2.2 打印覆盖率信息"></a>3.2.2 打印覆盖率信息</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718158.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281716523.webp"></p><p>执行coverage report-m 命令，读取当前目录下.coverage文件，打印覆盖率信息。输出Stmts(总行数), Miss(未覆盖行数), Branch（总分支数）, BrPart （未覆盖分支数）, Cover（覆盖率） , Missing（未覆盖具体信息）等信息。</p><h4 id="3-2-3-覆盖率中排除某些文件"><a href="#3-2-3-覆盖率中排除某些文件" class="headerlink" title="3.2.3 覆盖率中排除某些文件"></a>3.2.3 覆盖率中排除某些文件</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718278.png"></p><p>执行coverage report-m—omit=file 1[,file 2,……] 命令, 在统计并打印覆盖率时，排除某些文件。若有多个文件用逗号分隔。</p><h4 id="3-2-4-生成HTML格式的覆盖率信息"><a href="#3-2-4-生成HTML格式的覆盖率信息" class="headerlink" title="3.2.4 生成HTML格式的覆盖率信息"></a>3.2.4 生成HTML格式的覆盖率信息</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718034.png"></p><p>针对代码量较大，查找覆盖率信息难度较大、耗时较长的情况，执行coverage html [–omit=file1[,file2,……]]命令，将覆盖率信息以html格式显示。</p><h3 id="3-3-Mock-简化单元测试的工具"><a href="#3-3-Mock-简化单元测试的工具" class="headerlink" title="3.3 Mock 简化单元测试的工具"></a>3.3 Mock 简化单元测试的工具</h3><h4 id="3-3-1-使用mock工具的原因与其功能"><a href="#3-3-1-使用mock工具的原因与其功能" class="headerlink" title="3.3.1 使用mock工具的原因与其功能"></a>3.3.1 使用mock工具的原因与其功能</h4><p>Mock基于实际进行单元测试的场景而产生，以下三类场景非常具有代表性：</p><ol><li><p><strong>构造模块</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281724821.png">需要测试模块A,但它要调用的模块B还未开发，可是测试却不容推迟、需按时进行，面对这种情况，我们可以使用Mock生成一个还未写完的代码，即可进行相应的测试。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281724884.png"></p></li><li><p><strong>改变函数逻辑</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281725807.png">代码中含有结果不可预知的代码，例如time.time()(时间)， random.random()(随机数)。Mock可以改变含有结果不可预知代码的函数的逻辑，强行让其返回我们想要的返回值，使其结果可预知。</p></li><li><p><strong>减少依赖</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281725930.png" alt="image-20211128172546775">在所有模块代码都已完成，但无法保证代码稳定性的情况下。针对其他模块的质量不可靠的情况，可通过Mock工具构造一个相对稳定的模块，从而规避其他模块的问题。</p></li></ol><h4 id="3-3-2-Mock使用场景"><a href="#3-3-2-Mock使用场景" class="headerlink" title="3.3.2 Mock使用场景"></a>3.3.2 Mock使用场景</h4><p>通过以下10个场景来讲述Mock的常见用法。</p><p>场景01：通过 <strong>return_value</strong>，Mock可以强行修改，永远返回我们想要的返回值，支持的类型包括string,number,Boolean,list,dict等。</p><p>场景02：将前一个例子的<strong>实例名改为类名</strong>，可实现替换类方法的返回值。</p><p>场景03：通过 <strong>side_effect</strong>,根据调用次数返回想要的结果,当超出调用次数时抛StopIteration 异常。</p><p>场景04：通过 <strong>side_effect</strong>可以完全修改函数的逻辑，使用另一个函数来替换它，根据参数返回想要的结果。</p><p>场景05：通过 <strong>side_effect</strong>抛出想要的异常或错误。</p><p>场景06：针对需要mock在特定要求下生效的情况，通过<strong>with.patch.object</strong>设定一个作用域以达到限制mock作用域的目的。</p><p>场景07：<strong>获取调用信息</strong>，如函数是否被调用、函数被调用的次数、函数被调用的形式、函数调用的参数等。</p><p>场景08：通过<strong>create_autospec</strong>在返回值改变的同时，确保api不会因mock而改变。</p><p>场景09：针对需要调用的函数、调用的接口完全没有开发的情况，可以通过<strong>Mock从零构造依赖模块</strong>从而完成测试。</p><p>场景10 ：<strong>替换函数调用链。</strong>比如说用popen去执行一个命令，然后用read函数把它读取出来，再用split去做切分，这就是一个函数调用链(os.popen(cmd).read().split())。</p><h4 id="3-3-3-Mock对编码的要求"><a href="#3-3-3-Mock对编码的要求" class="headerlink" title="3.3.3 Mock对编码的要求"></a>3.3.3 Mock对编码的要求</h4><p>在模块引入方式上，推荐以import XXX的形式引入，以XXX.func()形式调用，不要from.xxx import *,因为需要一个链条指向它，否则无法达到我们的预期。</p><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281727442.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281727860.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281728367.png"></p><h2 id="4-单元测试实践"><a href="#4-单元测试实践" class="headerlink" title="4 单元测试实践"></a>4 单元测试实践</h2><h3 id="4-1-Unittest-简单应用"><a href="#4-1-Unittest-简单应用" class="headerlink" title="4.1 Unittest 简单应用"></a>4.1 Unittest 简单应用</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736705.webp"></p><p>如图所示，这是一个要被测试的类，这个类代表了一个人，类中有一个函数为<strong>get_name()，作用是获取这个人的名字</strong>。围绕着这个函数首先想到的测试点就是函数能否正确输出人名。因此就有了如下图所示的单元测试代码。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281738269.webp"></p><p>第一步，将使用到的unittest框架和所需要的函数导入。</p><p>第二步，针对被测试的函数写一个测试类，这里要注意<strong>测试类必须继承自unittest和TestCase。</strong></p><p>第三步，构建实例化的函数，可以理解为生成两个人，一个叫张三，一个叫李四。</p><p>第四步，编写一个用于测试的函数，这里注意<strong>函数名必须是以test开头</strong>。通过图片里的代码可以看到，通过使用assertEqual断言来做相应的测试，断言中包括了两部分，第一部分是预期，第二部分是实际的值。通过对两个值的比较来完成测试。</p><h3 id="4-2-Unittest复杂应用"><a href="#4-2-Unittest复杂应用" class="headerlink" title="4.2 Unittest复杂应用"></a>4.2 Unittest复杂应用</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736271.webp"></p><p>下面来看一个复杂的例子。如图所示，这个被测试的类是一个公司。这个公司的信息包含了公司的名字、公司的老板、公司的员工数。在这个公司的类中设置了三个函数，老板是谁、雇佣一个新员工、解雇一个员工。通过这些信息，可以想到的测试点有：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281735339.webp"></p><p>（1）who_is_boss()这个函数能够正确的返回老板的姓名；</p><p>（2）使用hire()函数雇佣新人，公司的员工总数+1；</p><p>（3）使用hire()函数重复雇佣一个人，函数会报错或者公司员工数量不变；</p><p>（4）使用fire()函数解雇一个人，公司的员工总数-1；</p><p>（5）使用fire()函数解雇非公司的员工，函数会报错或者员工数量不变。</p><p>针对以上的几个测试点，可以编写出相应的测试类。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736693.webp"></p><p>首先将所需要的类库导入，并且测试类要继承自unittest和TestCase。然后使用setUpClass()函数构建一个公司，设置老板的姓名和公司的名字。在这里设置了一个tearDown()清理函数，是为了方便测试的时候将员工全部清理掉。</p><p>通过图片可以看到，下面的三个函数原理基本跟上一个案例相同，都是通过断言来进行测试。测试类编写完成之后，需要运行这个类进行测试。如果需要执行全部的测试用例，如图所示，使用unittest.main()这个函数且不需要添加任何参数。执行完成后会得到如下图所示的结果，测试结果分为几个部分：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736738.webp"></p><p>第一部分的代码展示的是执行测试用例的结果，“.”说明测试用例执行通过，“E”说明测试用例发生了特殊情况异常中断，“F”说明测试用例执行失败。</p><p>第二部分则是打印的报错信息，当出现“E”或者“F”的时候，系统会打印出异常中断和执行失败的原因。</p><p>第三部分为统计信息，包括了共执行了几个测试用例，测试用例执行共花费了多少时间，测试用例执行成功或失败的数量。</p><!-- flag of hidden posts -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度高效研发实战训练营Step3&quot;&gt;&lt;a href=&quot;#百度高效研发实战训练营Step3&quot; class=&quot;headerlink&quot; title=&quot;百度高效研发实战训练营Step3&quot;&gt;&lt;/a&gt;百度高效研发实战训练营Step3&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http:</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="百度高效研发实战训练营" scheme="https://www.ckxgzxa.top/tags/%E7%99%BE%E5%BA%A6%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>百度高效研发实战训练营Step2</title>
    <link href="https://www.ckxgzxa.top/bitTraingClub2.html"/>
    <id>https://www.ckxgzxa.top/bitTraingClub2.html</id>
    <published>2021-11-24T00:00:00.000Z</published>
    <updated>2021-12-08T08:08:58.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度高效研发实战训练营Step2"><a href="#百度高效研发实战训练营Step2" class="headerlink" title="百度高效研发实战训练营Step2"></a>百度高效研发实战训练营Step2</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-代码的艺术"><a href="#1-代码的艺术" class="headerlink" title="1 代码的艺术"></a>1 代码的艺术</h2><h3 id="1-1-《代码的艺术》目的解读"><a href="#1-1-《代码的艺术》目的解读" class="headerlink" title="1.1 《代码的艺术》目的解读"></a>1.1 《代码的艺术》目的解读</h3><h4 id="1-1-1-了解公司与学校写代码的不同"><a href="#1-1-1-了解公司与学校写代码的不同" class="headerlink" title="1.1.1 了解公司与学校写代码的不同"></a>1.1.1 了解公司与学校写代码的不同</h4><p>在公司写程序和在学校写程序有很大的不同。</p><p>在学校写程序时，对于代码的质量要求比较低。</p><p>当进入公司之后，做的是工业级的产品，服务用户量可能会到达亿万级，所以相对而言对于代码的质量要求比较高。<em>一些伟大产品中的代码，甚至可以被称为艺术品。</em></p><h4 id="1-1-2-消除对于程序员这个职业的误解"><a href="#1-1-2-消除对于程序员这个职业的误解" class="headerlink" title="1.1.2 消除对于程序员这个职业的误解"></a>1.1.2 消除对于程序员这个职业的误解</h4><p>很多人都对程序员这个职业有误解，认为程序员就是码农，认为程序员35岁之后就写不出代码了。还有人认为程序员未来的唯一出路是以后做管理。</p><p>希望通过这门课程的学习，能使大家对于程序员有一个新的认识，消除误解。</p><h4 id="1-1-3-建立对软件编程的正确认识"><a href="#1-1-3-建立对软件编程的正确认识" class="headerlink" title="1.1.3 建立对软件编程的正确认识"></a>1.1.3 建立对软件编程的正确认识</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272315701.png"></p><p>在做一件事物时，我们常说“知”与“行”要合一。即：我们需要对这件事物有一个正确的认识，才会有正确的行动。同理，<em>写出好代码的前提，是对软件编程有正确的认识</em>。</p><h4 id="1-1-4-明确作为软件工程师的修炼方向"><a href="#1-1-4-明确作为软件工程师的修炼方向" class="headerlink" title="1.1.4 明确作为软件工程师的修炼方向"></a>1.1.4 明确作为软件工程师的修炼方向</h4><p>艺术品是由艺术家创造的。艺术家的修炼是有方式方法的。同样，软件工程师的修炼也是方式有方法的。希望通过这门课程，能使大家对软件工程师这个职业有一个全新的认识。</p><h3 id="1-2-代码与艺术之间的关系"><a href="#1-2-代码与艺术之间的关系" class="headerlink" title="1.2 代码与艺术之间的关系"></a>1.2 代码与艺术之间的关系</h3><h4 id="1-2-1-代码是可以被称为艺术的"><a href="#1-2-1-代码是可以被称为艺术的" class="headerlink" title="1.2.1 代码是可以被称为艺术的"></a>1.2.1 代码是可以被称为艺术的</h4><p>艺术，是多种多样、丰富多彩的。同时艺术也是有多个层次的，其实，在我们编写代码时，我们的脑海中也会有类似的感觉。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272319344.png"></p><p>艺术就是人类通过借助特殊的物质材料与工具，运用一定的审美能力和技巧，在精神与物质材料、心灵与审美对象的相互作用下，进行的充满激情与活力的创造性劳动，可以说它是一种精神文化的创造行为，是人的意识形态和生产形态的有机结合体。</p><p>写代码也恰恰要经历这样的一个过程。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272319626.png"></p><p>在编写代码的过程中：</p><p>我们<em>借助的物质是计算机系统，借助的工具是设计、编写、编译、调试、测试等</em>。</p><p>同样，编写代码需要激情。而且，编写代码是一件非常具有创造性的工作。</p><p>代码是人类智慧的结晶，代码反映了一个团队或一个人的精神。<em>代码可以被称为是艺术的。</em></p><h4 id="1-4-2-艺术可以从不同的角度进行解读、研究与创造"><a href="#1-4-2-艺术可以从不同的角度进行解读、研究与创造" class="headerlink" title="1.4.2 艺术可以从不同的角度进行解读、研究与创造"></a><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272320545.png">1.4.2 艺术可以从不同的角度进行解读、研究与创造</h4><p>达芬奇有多幅著名的画作。拿著名的《蒙娜丽莎》这幅画来举例：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272322121.png"></p><p>站在观众的角度，可能只是在欣赏画中的人物微笑。但是对于画家来说，可能就会考虑画画的手法、构图、光线明暗、色彩对比等等方面。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272323753.png"></p><p>在艺术方面，可以站在很多不同的角度进行解读。</p><p>但是如果要成为一名创作者，我们需要的不仅仅是欣赏的能力，更重要的是<em>从多角度进行解读、研究与创造的能力</em>。</p><h4 id="1-4-3-写代码如同艺术创作"><a href="#1-4-3-写代码如同艺术创作" class="headerlink" title="1.4.3 写代码如同艺术创作"></a>1.4.3 写代码如同艺术创作</h4><p>写代码的内涵是：</p><ol><li>写代码这个过程是一个<em>从无序到有序</em>的过程。</li><li>写代码需要把现实问题转化为数学模型。在写代码的过程中，我们需要有很好的模型能力。</li><li>写代码实际是一个认识的过程。很多时候，编码的过程也是我们认识未知问题的过程。</li><li>在写代码的过程中，我们需要综合的全方位的能力。包括把握问题的能力、建立模型的能力、沟通协助的能力、编码执行的能力等等。</li><li>在写好代码之前，首先需要建立品位。品味是指我们首先要知道什么是好的代码，什么是不好的代码。这样我们才能去不断地调整自己的行为，然后去学习，去提高我们的编码能力，写出具有艺术感的代码。</li></ol><h3 id="1-3-软件工程师不等于码农"><a href="#1-3-软件工程师不等于码农" class="headerlink" title="1.3 软件工程师不等于码农"></a>1.3 软件工程师不等于码农</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272336586.png"></p><p>软件工程师不能只会写代码，更需要具有综合的素质。这个综合的素质包括：</p><h4 id="1、技术"><a href="#1、技术" class="headerlink" title="1、技术"></a>1、技术</h4><p><em><strong>技术能力是基础。</strong></em>包括但不限于编码能力、数据结构和算法能力、系统结构知识、操作系统知识、计算机网络知识、分布式系统知识等等。</p><h4 id="2、产品"><a href="#2、产品" class="headerlink" title="2、产品"></a>2、产品</h4><p>要对产品业务有深刻的理解，需要了解产品交互设计、产品数据统计、产品业务运营等。</p><h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><p>要了解一些管理知识，需要知道项目是怎么管理的 ，如何去协调多个人一起去完成一个项目。有一些项目需要具有很强的研究与创新方面的能力。</p><p>以上这些能力素质，是一个软件工程师需要具有的综合素质。要成为一个全部掌握这些素质系统工程师至少需要8~10年的时间。</p><p>所以，软件工程师绝对不是一个只会简单编写代码就可以的职业。<em><strong>软件工程师不等于码农。</strong></em></p><h3 id="1-4-正确认识代码实践方面的问题"><a href="#1-4-正确认识代码实践方面的问题" class="headerlink" title="1.4 正确认识代码实践方面的问题"></a>1.4 正确认识代码实践方面的问题</h3><h4 id="1-4-1-什么是好代码，好的代码有哪些标准"><a href="#1-4-1-什么是好代码，好的代码有哪些标准" class="headerlink" title="1.4.1 什么是好代码，好的代码有哪些标准"></a>1.4.1 什么是好代码，好的代码有哪些标准</h4><p><strong>好代码的标准是：</strong></p><p>①高效、②鲁棒、③简洁、④简短、⑤可共享、</p><p>⑥可测试、⑦可移植、⑧可监控、⑨可运维、⑩可扩展。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292216019.png"></p><blockquote><p>将以上十条标准进行总结精简，可以归纳为：</p><p>（1）代码的正确和性能；</p><p>（2）代码的可读和可维护性；</p><p>（3）代码的可运维和可运营；</p><p>（4）代码的可共享和可重用。</p></blockquote><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280007786.png"></p><p>了解完好代码的标准，接下来我们来看一下不好的代码主要表现在哪些方面：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280005709.png"></p><ol><li>不好的函数名</li></ol><p>​    比如，在函数名中，加my等单词，这属于很不专业的用法。</p><ol start="2"><li>不好的变量名</li></ol><p>​    比如，看不出任何含义的a,b,c,j,k,temp等变量名。</p><ol start="3"><li>没有注释或注释不清晰</li></ol><p>​    没有注释的代码是非常难读懂的。注释不清晰往往是因为文字功底或者描述能力欠缺，从而导致无法通过注释把代码的执行原理讲解清楚。</p><ol start="4"><li>一个函数执行多个功能</li></ol><p>​    比如LoadFromFileAndCalculate()函数，它既执行了文件中去加载数据，还执行了计算功能。像这样的函数，我们建议把它切分成两个单独的函数。</p><ol start="5"><li>不好的代码样式排版</li></ol><p>​    代码的样式排版在某种程度上体现了代码的一种逻辑。好的代码排版能增强代码的可读性和逻辑性。我们在写代码时，要规避不好的代码样式排版。</p><ol start="6"><li>难以测试的代码</li></ol><p>​    代码没法测试，难写测试用例，这些都是一些不好的表现。</p><h4 id="1-4-2-好的代码从哪里来"><a href="#1-4-2-好的代码从哪里来" class="headerlink" title="1.4.2 好的代码从哪里来"></a>1.4.2 好的代码从哪里来</h4><p>代码不只是“写”出来的。实际上，在整个项目中，真正的编码时间约占项目整体时间的10%。<em>好的代码是多个环节工作共同作用的结果。</em></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280009655.png"></p><p>这些环节包括：</p><blockquote><ol><li>在编码前，要进行需求分析和系统设计。</li><li>在编码过程中，要注意做单元测试。</li><li>在编码后，要做集成测试，要上线，要持续运营，要迭代改进。</li></ol></blockquote><p>一个好的系统或产品，是以上几个环节持续循环的结果。</p><p>接下来我们着重介绍一下重点环节——<em>需求分析和系统设计</em>。</p><p><strong>1. 认识需求分析和系统设计的重要性</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280011841.png"></p><p>需求分析和系统设计在软件开发中经常被忽略或轻视，但是这两点都是非常重要的环节。</p><p>人们的直觉往往是拿到一个项目就想尽快把它写出来并运行，感觉这样的路径是最快的。</p><p>但是实际上在软件前期需求分析和系统设计投入更多的成本，会在后期节省更多的消耗。即：<em>前期更多的投入，收益往往最大</em>。</p><p>原因是：如果我们开始的设计做错的话，那么后期开发、测试、上线、调试这些成本都会被浪费掉。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280010793.png"></p><p><strong>2. 清楚需求分析和系统设计的差别</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292216299.png"></p><p>需求分析和系统设计是有泾渭分明的区别的，为了避免这两者相互混杂，我们需要清楚需求分析和系统设计各自的内涵。</p><p><em>需求分析主要是定义系统或软件的黑盒行为，即：外部行为。</em>比如，系统从外部来看能够执行什么功能。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280011809.png"></p><p><em>系统设计主要是设计系统或软件的白盒机制。即：内部行为。</em>比如，系统从内部来看，是怎么做出来的，为什么这么做。</p><p><strong>3.  需求分析的注意要点</strong></p><p>要点一：清楚怎么用寥寥数语勾勒出一个系统的功能。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280012501.png"></p><p>每个系统都有自己的定位，我们可以从简洁的总体描述，展开到具体的需求描述。</p><blockquote><p>需求描述的内容基本包括：</p><ol><li><p>系统类型描述</p></li><li><p>系统规模描述</p></li><li><p>系统定位和系统差异描述</p></li><li><p>系统对外接口功能描述</p></li></ol></blockquote><p>要点二：需求分析需要用精确的数字来描述。</p><p>需求分析中会涉及大量的数据分析，这些分析都需要精确的数字来进行支撑。</p><p><strong>4. 系统设计的注意要点</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280014355.png"></p><p><strong>要点一、清楚什么是系统架构</strong></p><p><em>系统架构，英文名 System Architectrue。</em>在wiki上有一个英文定义阐述了系统架构是一个概念的模型，它定义了系统的结构、行为、更多的视图。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280017695.png"></p><p>进一步解读系统架构，它的几个要素是：</p><p>①系统要完成哪些功能</p><p>②系统如何组成</p><p>③功能在这些组成部分之间如何划分</p><p><strong>要点二、注意系统设计的约束</strong></p><p><em>重点是资源的限制。</em>比如，计算的资源限制，存储的资源限制，IO网络的资源限制等。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280018199.png"></p><p><strong>要点三、清楚需求是系统设计决策的来源</strong></p><p>精确定义需求中的各个细节，以及量的定义，对系统设计的决策起着重要的作用。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292216422.png"></p><p><strong>要点四、系统设计的风格与哲学</strong></p><p><em>在同样的需求下，可能出现不同的设计方式。</em>即目的相同，设计不同。比如：复杂指令集和精简指令集的设计差异。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292216443.png"></p><p>一个好的系统是<em>在合适假设下的精确平衡</em>。一个通用的系统在某些方面是不如专用系统的。每个系统每个组件的功能都应该足够的专一和单一。每个组件是指子系统或模块等。功能的单一是复用和扩展的基础。倘若不单一，未来就有可能很难进行复用和扩展。</p><p>子系统或模块之间的关系应该是<em>简单而清晰的</em>。软件中最复杂的是耦合，如果各系统之间的接口定义非常复杂，那么未来便很难控制系统的健康发展。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280019144.png"></p><p>值得注意的是，使用全局变量就是在增加系统的耦合，从而增加系统的复杂性，所以<em>在系统中需要减少使用全局变量。</em></p><p><strong>要点五、清楚接口的重要性</strong></p><p><em>接口，英文名Interface。</em>系统对外的接口比系统实现本身还要更加重要，接口的设计开发不容忽视。</p><p><strong>接口主要包括：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280019599.png"></p><p><strong>接口重要的原因在于：</strong></p><p>①接口定义了功能。如果定义的功能不正确，那么系统的可用性与价值便会大打折扣。</p><p>②接口决定了系统和系统外部之间的关系。相对于内部而言，外部关系确定后非常难以修改。</p><p>接口的修改需要非常慎重且要考虑周全。</p><p><strong>后期接口修改时主要注意两点：</strong></p><ol><li>合理好用。新改的接口应该是非常合理好用的。不能使调度方感觉我们做的接口非常难以使用。</li><li>修改时需要向前兼容。新改的接口应该尽量实现前项的兼容。不能出现当新接口上线时其他程序无法使用的情况。</li></ol><h4 id="1-4-3-如何写好代码"><a href="#1-4-3-如何写好代码" class="headerlink" title="1.4.3 如何写好代码"></a>1.4.3 如何写好代码</h4><h5 id="1-代码也是一种表达方式"><a href="#1-代码也是一种表达方式" class="headerlink" title="1 代码也是一种表达方式"></a>1 代码也是一种表达方式</h5><p>在一个项目中，软件的维护成本远远高于开发成本，而且超过50%的项目时间都是用于沟通。</p><p>常规意义的沟通方式主要有面对面交流、Email、文档或网络电话会议等。但是其实 <em>代码也是一种沟通方式</em>。</p><p>在计算机早期，我们使用机器语言或汇编语言，更多的是考虑代码如何更高效率地执行。</p><p>然而，随着技术的进步，代码编译器的逐渐完善，我们写代码时更多的是要考虑如何让其他人看得懂、看得清楚。于是，<strong><em>编程规范应运而生</em>。</strong></p><p><strong>编程规范主要包含：</strong></p><ol><li>如何规范的表达代码。 </li><li>语言使用的相关注意事项。</li></ol><p><strong>基于编程规范，看代码的理想场景是：</strong></p><ol><li>看别人的代码，感觉和看自己的代码一样。</li><li>看代码时能够专注于逻辑，而不是格式方面。</li><li>看代码时不用想太多。</li></ol><h5 id="2-代码书写过程中的细节问题"><a href="#2-代码书写过程中的细节问题" class="headerlink" title="2 代码书写过程中的细节问题"></a>2 代码书写过程中的细节问题</h5><h6 id="1-关于模块"><a href="#1-关于模块" class="headerlink" title="1. 关于模块"></a>1. 关于模块</h6><p><strong>模块，是程序的基本组成单位</strong>。在一个模块内，会涉及它的数据、函数或类。对于Python、Go、C语言这样的程序来说，一个后缀名为.py 、 .c或.go的文件就是一个模块。</p><p>每一个模块需要有明确的功能。需要符合<em><strong>紧内聚，松耦合</strong></em>。模块切分的是否合理对于软件架构的稳定起着至关重要的左右。</p><p>切分模块的方法：</p><p>先区分数据类的模块和过程类的模块。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280041920.png"></p><p><strong>数据类的模块：</strong>主要是要完成<em><strong>对数据的封装</strong></em>。封装往往是通过模块内部变量或类的内部变量来实现的。</p><p><strong>过程类的模块：</strong>本身不含数据。过程类模块可以<em><strong>从文件中去读取一个数据</strong></em>，或者执行一些相关的操作。过程类模块可以调用其他数据类模块或过程类模块。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292217173.png"></p><p>编写程序时，我们需要注意减少模块间的耦合。<em><strong>减少模块间的耦合，有利于降低软件复杂性，明确接口关系</strong>。</em></p><h6 id="2-关于类和函数"><a href="#2-关于类和函数" class="headerlink" title="2. 关于类和函数"></a>2. 关于类和函数</h6><p>类和函数是两种不同的类型，有他们各自适用的范围。另外，遇见和类的成员变量无关的函数时，可以将该函数抽出来，作为一个独立的函数使用，这样便于未来的复用。</p><h6 id="3-关于面向对象"><a href="#3-关于面向对象" class="headerlink" title="3. 关于面向对象"></a>3. 关于面向对象</h6><p>面向对象，是一个优秀的编程方法和范式，但是真正理解的人并不多。</p><p>面向对象的<em><strong>本质是数据封装</strong></em>。这就要求我们在写程序的过程中应该<em><strong>从数据的角度开始想问题</strong></em>，而不是从执行过程的角度开始想问题。</p><p>我们需要注意一个普遍的错误认知，即：C语言是面向过程的，C++是面向对象的。</p><p>实际上，<strong><em>C语言是基于对象的，它和C++的区别主要是没有多态和继承</em>。</strong></p><p>C++是一个经常被滥用的语言。因为C++有太强的功能。</p><p>作为软件工程师，我们最重要的任务是去实现出我们所需要的功能，语言只是我们的工具。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280052593.png"></p><p>另外，在系统中，我们应该<em><strong>谨慎地使用多态和继承</strong></em>。如果一个系统中，类的继承超过三层，那么这个系统的复杂度便很难把握。</p><p>有这样一个悖论：很好的继承模型是基于对需求的准确把握，而在我们在初始设计阶段往往对需求理解的不透彻。系统在初始阶段可能只是一个很简单的原型，然后通过不断地迭代完善，才逐步发展起来变好的。</p><h6 id="4-关于模块内部的组成"><a href="#4-关于模块内部的组成" class="headerlink" title="4. 关于模块内部的组成"></a>4. 关于模块内部的组成</h6><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280051076.png"></p><p>一个模块，比如.py、.c或.go这样一个模块，它的内部组成主要是：在文件头中，需要对模块的功能进行简要说明。需要把文件的修改历史写清楚，包括修改时间、修改人和修改内容。在模块内，内容的顺序尽量保持一致，以方便未来对内容的搜索查询。</p><h6 id="5-关于函数"><a href="#5-关于函数" class="headerlink" title="5. 关于函数"></a>5. 关于函数</h6><p>函数的切分同样是非常重要的。对于一个函数来说，要有明确的单一功能。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280051088.png"></p><p>函数描述三要素包括<em><strong>功能、传入参数和返回值</strong></em>。</p><ol><li>功能描述是指描述这个函数是做什么的、实现了哪些功能。</li><li> 传入参数描述是指描述这个函数中传入参数的含义和限制条件。</li><li>返回值描述是指描述这个函数中返回值都有哪些可能性。</li></ol><p><em><strong>函数的规模要足够的短小</strong></em>，这是写好程序的秘诀之一。bug往往出现在那些非常长的函数里。</p><p>在函数头中，需要对函数的语义做出清晰和准确的说明。我们需要<em><strong>注意函数的返回值</strong></em>。在写函数时，要判断函数的语义，确定返回值的类型。</p><p><strong>基于函数的语义，函数的返回值有三种类型。</strong></p><p><em><strong>第一种类型</strong></em>：在“逻辑判断型”函数中，返回布尔类型的值——True或False，表示“真”或“假”。</p><p><em><strong>第二种类型</strong>：</em>在“操作型”函数中，作为一个动作，返回成功或失败的结果——SUCCESS或ERROR。</p><p><em><strong>第三种类型</strong>：</em>在“获取数据型”函数中，返回一个“数据”，或者返回“无数据/获取数据失败”。</p><p><em><strong>以“单入口、单出口”的方式书写</strong></em>的方式能够比较清晰地反映出函数的逻辑。尤其是在实现多线程的数据表中，推荐使用一个内部函数来实现“单入口单出口”的方式。</p><h6 id="6-关于代码注释"><a href="#6-关于代码注释" class="headerlink" title="6. 关于代码注释"></a>6. 关于代码注释</h6><p>要重视注释，书写注释要做到清晰明确。在编写程序的过程中，<strong><em>先写注释，后写代码</em>。</strong></p><h6 id="7-关于代码块"><a href="#7-关于代码块" class="headerlink" title="7. 关于代码块"></a>7. 关于代码块</h6><p>代码块的讨论范围是在一个函数内的代码实现。书写代码块的思路是<em><strong>先把代码中的段落分清楚</strong></em>。文章有段落，代码同样有段落。代码的段落背后表达的是我们对于代码的逻辑理解。包括<em><strong>代码的层次、段落划分、逻辑</strong></em>。代码中的空行或空格是帮助我们表达代码逻辑的，并非可有可无。好的代码可以使人在观看时做过一眼明了。</p><h6 id="8-关于命名"><a href="#8-关于命名" class="headerlink" title="8. 关于命名"></a>8. 关于命名</h6><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280053731.png"></p><p>命名包括系统命名、子系统命名、模块命名、函数命名、变量命名、常量命名等。</p><p>我们要清楚命名的重要性。<strong>命名重要的主要原因为：</strong></p><p>一是“望名生义”是人的自然反应。不准确的命名会使人产生误导。</p><p>二是概念是建立模型的出发点。好的命名是系统设计的基础。</p><p>命名中普遍存在的问题有：</p><p>一是名字中不携带任何信息。</p><p>二是名字携带的信息是错误的。</p><p>命名<strong><em>关系着代码的可读性</em>，</strong>需要仔细思考。<em><strong>命名的基本要求是准确、易懂。</strong></em>提高代码命名可读性的方式之一是：<em><strong>在名字的格式中加入下划线、驼峰等。</strong></em></p><h6 id="9-关于系统的运营"><a href="#9-关于系统的运营" class="headerlink" title="9. 关于系统的运营"></a>9. 关于系统的运营</h6><p>在互联网时代，系统非常依赖运营。并不是我们把代码写完调试通了就可以。</p><p>在系统运营过程中，<strong><em>代码的可监测性非常重要</em>。</strong>很多程序都是通过线上的不断运行、不断监测、不断优化而迭代完善的，所以我们在编写代码的过程中，要注意尽可能多地暴露出可监控接口。</p><p>对于一个系统来说，<strong><em>数据和功能同等重要</em>。</strong></p><p>数据收集很重要，数据量够大才能知道这个项目或这个系统的具体收益。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280056080.png"></p><p>关于系统的运营，我们在设计和编码阶段就需要考虑。即：在设计和编码阶段，提供足够的状态记录，提供方便的对外接口。</p><h3 id="1-5-怎样修炼成为优秀的软件工程师"><a href="#1-5-怎样修炼成为优秀的软件工程师" class="headerlink" title="1.5 怎样修炼成为优秀的软件工程师"></a>1.5 怎样修炼成为优秀的软件工程师</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280057161.png"></p><p>通常人们在判断一名软件工程师的水平时，都会用工作时间、代码量、学历、曾就职的公司等等这类外部因素作为评判标准。</p><p>修炼成为优秀的软件工程师，<strong>重要的因素有三点：</strong></p><ol><li>学习-思考-实践</li><li>知识-方法-精神</li><li>基础知识是根本</li></ol><h4 id="1-5-1-学习-思考-实践"><a href="#1-5-1-学习-思考-实践" class="headerlink" title="1.5.1 学习-思考-实践"></a>1.5.1 <strong>学习-思考-实践</strong></h4><h5 id="（1）多学习"><a href="#（1）多学习" class="headerlink" title="（1）多学习"></a><strong>（1）多学习</strong></h5><p>软件编写的历史已经超过半个世纪，有太多的经验可以借鉴学习。要不断的学习进步。</p><h5 id="（2）多思考"><a href="#（2）多思考" class="headerlink" title="（2）多思考"></a><strong>（2）多思考</strong></h5><p>学而不思则罔，思而不学则殆。对于做过的项目要去深入思考，复盘写心得。</p><h5 id="（3）多实践"><a href="#（3）多实践" class="headerlink" title="（3）多实践"></a><strong>（3）多实践</strong></h5><p>要做到知行合一，我们大部分的心得和成长其实是来自于实践中的经历。在学习和思考的基础之上，要多做项目，把学到的理论运用到真正的工作中。</p><h4 id="1-5-2-知识-方法-精神"><a href="#1-5-2-知识-方法-精神" class="headerlink" title="1.5.2 知识-方法-精神"></a>1.5.2 知识-方法-精神</h4><p>互联网的发展日新月异，对于软件开发来说，知识永远在增加，所以在变化快速的知识世界中，<strong><em>最好的方式是找到方法</em>。</strong></p><p>方法就是用来分析问题和解决问题的。虽然说起来简单，但是适合每个人的方法都需要自己去寻找和总结。</p><p>在大多数人的成长过程中，并不单单只是鲜花和掌声，更多的时候是在和困难荆棘做斗争。而真正能做出成就的人，都有着远大理想和宏伟志向。所以，光有知识和方法往往是不够的，还需要有精神作为支撑。</p><p>几个精神理念：</p><ol><li><strong>自由精神、独立思想。</strong></li></ol><p>人一定要有自己的思考。不要人云亦云，不要随波逐流。</p><ol start="2"><li><strong>对完美的不懈追求。</strong></li></ol><p>不要做到一定程度就满意了，而是要去不断的追求一个更好的结果。</p><h4 id="1-5-3-基础知识是根本"><a href="#1-5-3-基础知识是根本" class="headerlink" title="1.5.3 基础知识是根本"></a>1.5.3 基础知识是根本</h4><p>唐朝著名宰相魏征曾经对唐太宗说过：“求木之长者，必固其根本；欲流之远者，必浚其泉源”，充分表达了基础乃治学之根本。</p><p>对于一个软件工程师来说，需要掌握的基础是非常全面的。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280058449.png"></p><p>包括数据结构、算法、操作系统、系统结构、计算机网络。包括软件工程、编程思想。包括逻辑思维能力、归纳总结能力、表达能力。还包括研究能力、分析问题、解决问题的能力等。这些基础的建立，至少也要5~8年的时间。</p><h2 id="2-Mini-Spider实践"><a href="#2-Mini-Spider实践" class="headerlink" title="2 Mini-Spider实践"></a>2 Mini-Spider实践</h2><h3 id="2-1-多线程编程"><a href="#2-1-多线程编程" class="headerlink" title="2.1 多线程编程"></a>2.1 多线程编程</h3><h4 id="2-1-1-数据互斥访问"><a href="#2-1-1-数据互斥访问" class="headerlink" title="2.1.1 数据互斥访问"></a>2.1.1 数据互斥访问</h4><p>多线程中数据互斥访问的情况非常常见，在真实生产的环境中，经常有开发人员会将一张表的“添加”和“判断是否存在”分为两个接口，这是一种非常常见的错误。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281424954.png"></p><p>以图中的代码为例，左边的代码是正确的写法，<strong>将添加和判断写进一个函数中</strong>。右边的代码是典型的错误代码，编写了两个函数，分别是添加和判断函数。</p><p>事实上，这种将添加和判断写进一个函数并且运行的实现机制是同8086的底层指令集支持密不可分的。</p><h4 id="2-1-2-临界区的注意事项"><a href="#2-1-2-临界区的注意事项" class="headerlink" title="2.1.2 临界区的注意事项"></a>2.1.2 临界区的注意事项</h4><p>在代码中，<strong>有锁来保护的区域被称为临界区</strong>。以图中代码为例，临界区为self.lock.acquire()和self.lock.release()两句话之间的区域。在使用临界区的时候要注意，不要把耗费时间的操作放在临界区内执行。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281429165.png"></p><p>很多开发人员在编写多线程的时候会将耗费时间很多的逻辑放入临界区内，这样会导致无法发挥多线程对于硬件资源最大化利用的优势。</p><h4 id="2-1-3-I-O操作的处理"><a href="#2-1-3-I-O操作的处理" class="headerlink" title="2.1.3 I/O操作的处理"></a>2.1.3 I/O操作的处理</h4><p>在多线程编程中还要注意对于I/O操作的处理。首先在编写代码的时候要注意不能出现无捕捉的exception，以图中最左边的代码为例，如果不对异常进行捕捉，那么一旦出现问题就不会执行self.lock.release()语句，进而导致死锁的发生。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281444010.png"></p><p>其次，因为异常处理是非常消耗资源的，所以我们也不能像图中中间的代码一样，将异常放在临界区内，要像最右边的代码一样处理。</p><h3 id="2-2-细节处理"><a href="#2-2-细节处理" class="headerlink" title="2.2 细节处理"></a>2.2 细节处理</h3><h4 id="2-2-1-种子信息的读取"><a href="#2-2-1-种子信息的读取" class="headerlink" title="2.2.1 种子信息的读取"></a>2.2.1 种子信息的读取</h4><p>很多开发人员会将种子信息读取的逻辑和其他逻辑耦合在一起，这样是错误的。以图中代码为例，虽然通过_get_seeds函数直接读取文件中的信息并没有书写错误，但是如果后续的开发中文件的格式发生了变化，那就需要重新回来修改这部分的代码。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281445680.png"></p><p>通过上述代码可以发现，模块划分和逻辑的复杂程度是没有关系的。即使是逻辑简单的代码，如果没有做好模块划分，也会变得难于维护。</p><h4 id="2-2-2-程序优雅退出"><a href="#2-2-2-程序优雅退出" class="headerlink" title="2.2.2 程序优雅退出"></a>2.2.2 程序优雅退出</h4><p>在真实应用中，很多开发人员在实现程序退出功能的时候使用了非常复杂的机制，导致后期维护难度较高。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281446653.png"></p><p>在实际应用中可以使用python系统库中关于队列的task_done()和join()的机制。</p><p>以图中代码为例，左边的代码就是使用了task_done()，中间的代码是主程序中的一种常规逻辑使用。右边是对中间主程序的一种优化，增加了spider.wait()，让整个逻辑可读性更强，更容易被理解。</p><h4 id="2-2-3-爬虫的主逻辑编码"><a href="#2-2-3-爬虫的主逻辑编码" class="headerlink" title="2.2.3 爬虫的主逻辑编码"></a>2.2.3 爬虫的主逻辑编码</h4><p>很多开发人员编写的主逻辑非常的复杂且难懂。事实上，图中的代码就是一个爬虫的主逻辑的所有代码。可以看到，里面包含了六个步骤。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281448571.png"></p><p>第一步，从队列中拿到任务。</p><p>第二步，读取内容。如果读取失败，则重新读取。如果读取成功，则执行第三步。</p><p>第三步，存储数据。</p><p>第四步，检查数据深度。</p><p>第五步，如果数据深度不足，就进一步解析，并且放到队列中。</p><p>第六步，结束任务。</p><h2 id="3-代码检查规则背景及总体介绍"><a href="#3-代码检查规则背景及总体介绍" class="headerlink" title="3 代码检查规则背景及总体介绍"></a>3 代码检查规则背景及总体介绍</h2><h3 id="3-1-代码检查的意义"><a href="#3-1-代码检查的意义" class="headerlink" title="3.1 代码检查的意义"></a>3.1 代码检查的意义</h3><ol><li>提高代码可读性，统一规范，方便他人维护，长远来看符合公司内部开源战略。</li><li>帮助发现代码缺陷，弥补人工代码评审的疏漏，节省代码评审的时间与成本。</li><li>有助于提前发现问题，节约时间成本，降低缺陷修复成本。</li><li>促进公司编码规范的落地，在规范制定后借助工具进行准入检查。</li><li>提升编码规范的可运营性，针对反馈较多的不合理规范进行调整更新。</li></ol><h3 id="3-2-代码检查场景及工具"><a href="#3-2-代码检查场景及工具" class="headerlink" title="3.2 代码检查场景及工具"></a>3.2 代码检查场景及工具</h3><h4 id="3-2-1-代码检查场景"><a href="#3-2-1-代码检查场景" class="headerlink" title="3.2.1 代码检查场景"></a>3.2.1 代码检查场景</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281541973.png"></p><p>首先是<strong>本地研发环节</strong>，借助客户端工具，在push发起评审之前进行检查。</p><p>若本地代码扫描没有出现问题，就进入第二个环节：<strong>代码准入环节，即Code Review</strong>，这一环节进行增量检查，属于公司强制要求。</p><p>第三个环节：<strong>持续集成环节</strong>，当代码合入到代码库之后，进行全量检查，业务线根据自身需求来配置。</p><h4 id="3-2-2-代码检查工具与服务"><a href="#3-2-2-代码检查工具与服务" class="headerlink" title="3.2.2 代码检查工具与服务"></a>3.2.2 代码检查工具与服务</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281543538.png"></p><p>代码检查的产品，客户端、SCM(icode)、CI(Agile)之间具有交互性，共同构成整个代码检查环节。</p><h4 id="3-2-3-代码检查覆盖范围"><a href="#3-2-3-代码检查覆盖范围" class="headerlink" title="3.2.3 代码检查覆盖范围"></a>3.2.3 代码检查覆盖范围</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281544909.png"></p><p>在<strong>覆盖语言</strong>方面，代码检查目前已经覆盖了包括C++，Java/android, PHP, Python, Go, JS, OC, Kotlin在内的几乎所有主流语言。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281544915.png"></p><p>在<strong>检查维度</strong>方面，代码检查包括编码规范 代码缺陷，开源框架引用安全检查，可维护性(MI)。</p><h4 id="3-2-4-代码检查速度"><a href="#3-2-4-代码检查速度" class="headerlink" title="3.2.4 代码检查速度"></a>3.2.4 代码检查速度</h4><p>编码规范：只扫描变更文件，检查代码变更行是否符合规范，速度较快。</p><p>缺陷检查：需考虑文件依赖、函数调用关系、代码上下文等，相对耗时。</p><h3 id="3-3-代码检查规则分级"><a href="#3-3-代码检查规则分级" class="headerlink" title="3.3 代码检查规则分级"></a>3.3 代码检查规则分级</h3><h4 id="3-3-1-规则等级梳理"><a href="#3-3-1-规则等级梳理" class="headerlink" title="3.3.1 规则等级梳理"></a>3.3.1 规则等级梳理</h4><p>Code Review阶段，所有维度扫描出的问题可以分为以下3个等级：</p><ol><li><p>Error：属于需要强制解决的类型，影响代码合入，应视具体情况不同采取修复、临时豁免、标记误报等措施及时处理；</p></li><li><p>Warning：非强制解决类型，不影响代码含入，很可能存在风险，应尽量修复；</p></li><li><p>Advice：非强制解决类型，级别相对较低，不影响代码含入，可以选择性修复。</p></li></ol><h4 id="3-3-2-机检任务统一"><a href="#3-3-2-机检任务统一" class="headerlink" title="3.3.2 机检任务统一"></a>3.3.2 机检任务统一</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281548620.png"></p><h4 id="3-3-3-评审页行间提示"><a href="#3-3-3-评审页行间提示" class="headerlink" title="3.3.3 评审页行间提示"></a>3.3.3 评审页行间提示</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550018.png"></p><h4 id="3-3-4-针对豁免、误报、咨询的说明"><a href="#3-3-4-针对豁免、误报、咨询的说明" class="headerlink" title="3.3.4 针对豁免、误报、咨询的说明"></a>3.3.4 针对豁免、误报、咨询的说明</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550799.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550899.png"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550116.png"></p><h2 id="4-代码检查规则：Python语言案例详解"><a href="#4-代码检查规则：Python语言案例详解" class="headerlink" title="4 代码检查规则：Python语言案例详解"></a>4 代码检查规则：Python语言案例详解</h2><h3 id="4-1-Python的代码检查规则"><a href="#4-1-Python的代码检查规则" class="headerlink" title="4.1 Python的代码检查规则"></a>4.1 Python的代码检查规则</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281552034.png"></p><p>Python代码检查规则主要分为四个大类，分别是<strong>代码风格规范、引用规范、定义规范和异常处理规范</strong>。</p><h4 id="4-1-1-代码风格规范"><a href="#4-1-1-代码风格规范" class="headerlink" title="4.1.1 代码风格规范"></a>4.1.1 代码风格规范</h4><h5 id="（1）程序规模规范："><a href="#（1）程序规模规范：" class="headerlink" title="（1）程序规模规范："></a><strong>（1）程序规模规范：</strong></h5><ol><li><p>每行不得超过 120 个字符。</p></li><li><p>定义的函数长度不得超过 120 行。</p></li></ol><p>这意味着，在编写代码时，需要时刻注意自己的程序规模，避免冗余，确保写出简洁而高效的代码。</p><h5 id="（2）语句规范"><a href="#（2）语句规范" class="headerlink" title="（2）语句规范"></a><strong>（2）语句规范</strong></h5><p>因为Python与其他语言不同，可以不需要明确的标识符表示语句的结尾，所以规定：</p><ol start="3"><li><p>禁止以分号结束语句。</p></li><li><p>在任何情况下，一行只能写一条语句。</p></li></ol><h5 id="（3）括号使用规范"><a href="#（3）括号使用规范" class="headerlink" title="（3）括号使用规范"></a><strong>（3）括号使用规范</strong></h5><ol start="5"><li>除非用于明确算术表达式优先级、元组或者隐式行连接，否则尽量避免冗余的括号。</li></ol><h5 id="（4）缩进规范"><a href="#（4）缩进规范" class="headerlink" title="（4）缩进规范"></a><strong>（4）缩进规范</strong></h5><ol start="6"><li>禁止使用Tab进行缩进，而统一使用4个空格进行缩进</li></ol><p>需要将单行内容拆成多行写时规定：</p><ol start="7"><li>与首行保持对齐；或者首行留空，从第二行起统一缩进4个空格。</li></ol><h5 id="（5）空行规范"><a href="#（5）空行规范" class="headerlink" title="（5）空行规范"></a><strong>（5）空行规范</strong></h5><ol start="8"><li>文件级定义（类或全局函数）之间，相隔两个空行；类方法之间，相隔一个空行。</li></ol><h5 id="（6）空格规范"><a href="#（6）空格规范" class="headerlink" title="（6）空格规范"></a><strong>（6）空格规范</strong></h5><ol start="9"><li><p>括号之内均不添加空格。</p></li><li><p>参数列表、索引或切片的左括号前不应加空格。</p></li><li><p>逗号、分号、冒号之前均不添加空格，而是在它们之后添加一个空格。</p></li><li><p>所有二元运算符前后各加一个空格。</p></li><li><p>关键字参数或参数默认值的等号前后不加空格。</p></li></ol><h5 id="（7）注释规范"><a href="#（7）注释规范" class="headerlink" title="（7）注释规范"></a><strong>（7）注释规范</strong></h5><ol start="14"><li>每个文件都必须有文件声明，每个文件声明至少必须包括以下三个方面的信息：版权声明、功能和用途介绍、修改人及联系方式。</li></ol><p>另外在使用文档字符串（docstirng）进行注释时，规定：</p><ol start="15"><li><p>使用docstring描述模块、函数、类和类方法接口时，docstring必须用三个双引号括起来。</p></li><li><p>对外接口部分必须使用docstring描述，内部接口视情况自行决定是否写docstring。</p></li><li><p>接口的docstring描述内容至少包括以下三个方面的信息：功能简介、参数、返回值。如果可能抛出异常，必须特别注明。</p></li></ol><h4 id="4-1-2-引用规范"><a href="#4-1-2-引用规范" class="headerlink" title="4.1.2 引用规范"></a>4.1.2 引用规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281600533.png"></p><p><strong>严格而具体的规定：</strong></p><ol><li>禁止使用 from……import…… 句式直接导入类或函数，而应在导入库后再行调用。</li><li>每行只导入一个库。</li><li>按标准库、第三方库、应用程序自有库的顺序排列import，三个部分之间分别留一个空行。</li></ol><h4 id="4-1-3-定义规范"><a href="#4-1-3-定义规范" class="headerlink" title="4.1.3 定义规范"></a>4.1.3 定义规范</h4><p><strong>（1）在变量定义方面，我们有强制的规范规定：</strong></p><ol><li>局部变量使用全小写字母，单词间使用下划线分隔。</li><li>定义的全局变量必须写在文件头部。</li><li>常量使用全大写字母，单词间使用下划线分隔</li></ol><p><strong>（2）函数的定义规范主要体现在函数的返回值以及默认参数的定义上。</strong></p><p>为提高代码可读性，对于函数的返回值，规范要求为：</p><ol><li>函数返回值必须小于或等于3个。若返回值大于3个，则必须通过各种具名的形式进行包装。</li></ol><p>为了保障函数的运行效率以及降低后期维护和纠错的成本，对于函数默认参数的定义有如下要求：</p><ol start="2"><li>仅可使用以下基本类型的常量或字面常量作为默认参数：整数、bool、浮点数、字符串、None。</li></ol><p><strong>（3）类定义的规范包括了四个方面的内容：</strong></p><ol><li>类的命名使用首字母大写的驼峰式命名法。</li><li>对于类定义的成员：protected成员使用单下划线前缀；private成员使用双下划线前缀。</li><li>如果一个类没有基类，必须继承自object类。</li><li>类构造函数应尽量简单，不能包含可能失败或过于复杂的操作。</li></ol><h4 id="4-1-4-异常处理规范"><a href="#4-1-4-异常处理规范" class="headerlink" title="4.1.4 异常处理规范"></a>4.1.4 异常处理规范</h4><p>在代码编写中应该<strong>尽量避免出现代码异常状态</strong>，然而错误有时在所难免，对于这些异常状态的处理，有着明确的规范要求：</p><ol><li>禁止使用双参数形式或字符串形式的语法抛出异常。</li><li>如需自定义异常，应在模块内定义名为 Error 的异常基类。并且，该基类必须继承自 Exception 。其他异常均由该基类派生而来。</li><li>除非重新抛出异常，禁止使用 except：语句捕获所有异常， 一般情况下，应使except……：语句捕获具体的异常。</li><li>捕捉异常时，应当使用 as 语法，禁止使用逗号语法。</li></ol><h3 id="4-2-Python编码惯例"><a href="#4-2-Python编码惯例" class="headerlink" title="4.2 Python编码惯例"></a>4.2 Python编码惯例</h3><h4 id="4-2-1-让模块既可被导入又可被执行"><a href="#4-2-1-让模块既可被导入又可被执行" class="headerlink" title="4.2.1 让模块既可被导入又可被执行"></a>4.2.1 让模块既可被导入又可被执行</h4><p>python不同于编译型语言，而<strong>属于脚本语言</strong>，是动态的逐行解释运行，没有统一的程序入口。所以，为了方便模块之间的相互导入，我们通常<strong>自定义一个 main 函数，并使用一个if 语句</strong>， if 内置变量 <strong>name</strong> == ‘__main__’ ，在这个if 条件下，再去执行 main函数。这样，我们就能够实现，让模块既可被导入又可执行。</p><h4 id="4-2-2-in运算符的使用"><a href="#4-2-2-in运算符的使用" class="headerlink" title="4.2.2 in运算符的使用"></a>4.2.2 in运算符的使用</h4><p>in一种简洁而高效的运算符，很多时候，合理的使用in运算符，可以<strong>代替大量的重复判断过程</strong>，降低时间复杂度，提高代码的运行效率。</p><h4 id="4-2-3-不使用临时变量交换两个值"><a href="#4-2-3-不使用临时变量交换两个值" class="headerlink" title="4.2.3 不使用临时变量交换两个值"></a>4.2.3 不使用临时变量交换两个值</h4><p>Python有更简洁而高效的语句可以实现交换两个值的操作，并<strong>无必要引入临时变量</strong>来交换两个值。</p><h4 id="4-2-4-用序列构建字符串"><a href="#4-2-4-用序列构建字符串" class="headerlink" title="4.2.4 用序列构建字符串"></a>4.2.4 用序列构建字符串</h4><p>对于一个字符串列表、元组等，可以用序列来构建字符串，<strong>利用一个空字符串和join函数</strong>，就可以避免重复，高效完成相应字符串的构建。</p><!-- flag of hidden posts -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度高效研发实战训练营Step2&quot;&gt;&lt;a href=&quot;#百度高效研发实战训练营Step2&quot; class=&quot;headerlink&quot; title=&quot;百度高效研发实战训练营Step2&quot;&gt;&lt;/a&gt;百度高效研发实战训练营Step2&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http:</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="百度高效研发实战训练营" scheme="https://www.ckxgzxa.top/tags/%E7%99%BE%E5%BA%A6%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>百度高效研发实战训练营Step1</title>
    <link href="https://www.ckxgzxa.top/bitTraingClub1.html"/>
    <id>https://www.ckxgzxa.top/bitTraingClub1.html</id>
    <published>2021-11-23T15:10:12.000Z</published>
    <updated>2021-12-08T08:16:37.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度高效研发实战训练营Step1"><a href="#百度高效研发实战训练营Step1" class="headerlink" title="百度高效研发实战训练营Step1"></a>百度高效研发实战训练营Step1</h1><p><a href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p><h2 id="1-设计方法与实践"><a href="#1-设计方法与实践" class="headerlink" title="1 设计方法与实践"></a>1 设计方法与实践</h2><h3 id="1-1-软件设计原则"><a href="#1-1-软件设计原则" class="headerlink" title="1.1 软件设计原则"></a>1.1 软件设计原则</h3><ol><li><p>软件设计的目的</p><blockquote><p>软件设计是为了使软件在长期范围内能够容易的进行变化。我们从下面这三个点来理解这句话。</p><blockquote><ol><li><p>变化：<em>软件不是一成不变的</em>，无论是软件本身的需求、软件依赖的其他软件资源都是一直在发生变化的，唯一不变的就是变化。</p></li><li><p>容易：任何一个软件的变化都需要成本，要尽可能的降低变化的成本，使得软件可以很容易应对软件的变化。</p></li><li><p>长期：事实上需要长期进行维护的软件更应该做好软件设计，因为软件长期的变化非常多，难以提前作出预测，需要良好的软件设计来应对。</p></li></ol></blockquote></blockquote></li><li><p>软件设计原则</p></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111232319206.png"></p><blockquote><p>软件设计有着很多的原则，<em>最基本的原则是高内聚低耦合，它也是软件设计追求的最高目标</em>。 <em><strong>内聚</strong></em> 指的是一个软件内部间元素相关联的程度。</p><p><em><strong>高内聚</strong></em>追求的是紧密相关联的元素要放在一起。</p><p><em><strong>低耦合</strong></em>指的是单位之间尽可能少地关联，依赖。</p></blockquote><blockquote><p>在高内聚低耦合之上有很多其他的原则：如SOLID原则、简单设计、正交设计，在这之上还会有设计模式作为最高层的软件设计原则。</p></blockquote><h3 id="1-2-clean-code"><a href="#1-2-clean-code" class="headerlink" title="1.2 clean code"></a>1.2 clean code</h3><ol><li><p>clean code的概念</p><blockquote><p>clean code中文解释为<em>整洁代码</em>，是指写的代码能够在尽可能短的时间内被别人读懂，且代码看上去排版整洁、逻辑清晰、扩展性好。</p></blockquote></li><li><p>命名规则</p><blockquote><p>代码中命名需要遵循以下的几个规则：</p><blockquote><ol><li><p>表达它是什么，不要表达怎么做。</p></li><li><p>代码要做到自注释。</p></li><li><p>使用有意义的循环迭代变量。</p></li><li><p>避免缩写，尤其拼音缩写。</p></li><li><p>不要使用非约定俗成的缩写。</p></li><li><p>避免使用魔法数。</p></li><li><p>不要害怕长变量名。</p></li></ol></blockquote></blockquote></li><li><p>注释</p><blockquote><p>注释对于代码来说是必不可少的。通常情况下，<em>好的注释包含：版权信息，设计意图，警示信息。</em></p><p>不好的注释则具有以下一个或几个特点：同义反复、隐晦关联关系、套用模板、提供历史修改记录以及注释掉的代码。</p></blockquote></li><li><p>函数</p><blockquote><p>在写函数时，应当注意，<em>每个函数只做一件事</em>，每个函数应是单一职责。</p><p>函数分为骨架函数和步骤函数。</p><ul><li><em>骨架函数</em> 是业务逻辑和算法是在高层次上的抽象描述。</li><li><em>步骤函数</em> 是业务逻辑和算法的一些实现细节，是被隐藏起来的。</li></ul></blockquote></li><li><p>编码细节</p><blockquote><p>在编码细节方面，需要遵循以下几点规则：</p><blockquote><ol><li>使用自然的比较顺序。</li><li>简化逻辑层次，避免多层嵌套。</li><li>在写三元表达式时不要出现复杂的逻辑和过长的条件。</li><li>需要控制变量的作用域，也就是缩小变量作用域的范围，越小越好。</li></ol></blockquote></blockquote></li></ol><h3 id="1-3-单元测试"><a href="#1-3-单元测试" class="headerlink" title="1.3 单元测试"></a>1.3 单元测试</h3><ol><li><p>为什么进行单元测试</p><blockquote><p>测试是分为不同层次的：最底层是单元测试，中间是基于模块级、组件级的测试，再往上则是系统级别的测试。</p><p><em>越底层的测试，越能够快速地发现问题。</em>底层的测试集成性更好，能够安全的进行代码修改。上层的测试一般情况下获得反馈的速度比较慢，测试过程也比较笨重。</p><p>所以单元测试具有<em>更早发现问题，更容易集成，更安全地代码修改的优点</em>。</p></blockquote></li><li><p>写好单元测试的重要性</p><blockquote><p>写好单元很费时。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111232334866.webp"></p><p><em>好的单元测试能够降低产品开发的成本。</em> 然而单元测试写得不好的话，不但会增加产品开发的成本，而且还会增加单元测试成本。</p></blockquote></li><li><p>单元测试原则与模式</p><p><strong>第一个原则：Tests As Documentation</strong></p><p>将测试当成一个文档工作，也就是说我们需要把测试写得像文档一样简洁，通过一些描述，可以清晰地知道这个测试的作用。在之后对项目修改时，只需要查看单元测试即可。</p><p><strong>第二个原则：Fully Automated and Self-Checking</strong></p><p>单元测试都是可以进行自我检查、自我校验的，通过代码的编写，能够知道测试是否成功，不需要人为判定。</p><p><strong>第三个原则：Do No Harm，不可破坏性。</strong></p><p>部分开发人员在进行测试时，为了完成目的，会基于测试代码创立一些逻辑，这种做法是错误的。在写测试时不能单独为测试创建特别的逻辑，更不能破坏原有代码的逻辑。</p><p><strong>第四个原则：Keep tests as simple as possible，简洁性。</strong></p><p>单元测试虽然是用来保证代码的正确性，但单元测试也是一份代码，为了避免过多的测试代码相覆盖，要尽可能地把单元测试的代码写得简单，保证其不会出错。</p></li></ol><h3 id="1-4-重构"><a href="#1-4-重构" class="headerlink" title="1.4 重构"></a>1.4 重构</h3><p>​    重构时需要遵循的规则如下:</p><blockquote><ol><li><strong>业务导向</strong></li></ol><p>重构一定是要解决实际的业务问题的，而不是为了重构去重构。</p><ol start="2"><li><strong>小步快跑</strong></li></ol><p>​        通常重构是需要多人同时参与，重构过程中开发人员要随时对比主干与分支的情况。当某一个开发人员在分支上进行了大量改动并准备将其合并到主干时，有可能主干和分支的代码有很大的差异。所以进行重构时，要<em>将问题拆分成多个小的单元进行修改，并且每修改一个就进行一次分支合并</em>。这种小步快跑的模式可以随时同步主干上的代码，减少出错的可能。</p><ol start="3"><li><strong>演进式设计</strong></li></ol><p>​        在进行代码重构之前，我们不可能知道重构的最终结果是什么。为了保证能够得到一个比较好的结果，我们采用演进式设计方法。在重构过程中<em>遵循包括高内聚低耦合、正交设计原则、SOLID原则等软件设计原则，不断地用小步快跑的方式去重构</em>，只有这样结果才能令人满意。</p><ol start="4"><li><p><strong>正交设计原则</strong></p><p>分离关注点、消除重复、缩小依赖范围、向着稳定的方向依赖。</p></li></ol></blockquote><p>​        在代码中，根据功能的不同，将其分为不同的变化方向。每个变化方向都是一个职责，我们把每一个不同的变化方向称作关注点，根据它的变化方向来进行相应的处理。</p><h3 id="1-5-配置化架构"><a href="#1-5-配置化架构" class="headerlink" title="1.5 配置化架构"></a>1.5 配置化架构</h3><ol><li><strong>配置化架构的定义：</strong></li></ol><p>以可配置的方式构建软件的方法。它是在领域建模的基础上，以配置表述业务，以配置组织架构元素，比如服务、组件、数据等，并对配置进行规范化、自动化的管理。</p><p>定义的原因：</p><blockquote><ol><li><p>通常情况下配置指的是对数据的抽象，需要架构上的描述；</p></li><li><p>架构上描述的配置指的是对架构元素的抽象，描述配置化不完整；</p></li><li><p>配置化包括对业务的抽象，尤其是逻辑；</p></li><li><p>配置化还包括对配置的管理以及分支。</p></li></ol></blockquote><ol start="2"><li><strong>如何应用配置化架构</strong></li></ol><p>应用配置化架构包括三方面：从业务上改造，提高配置本身的开发效率，降低配置的维护成本。</p><blockquote><ol><li><strong>业务配置化改造</strong></li></ol><blockquote><ol><li>组件配置化</li></ol><p>组件配置化表达<em>是业务层面上非常重要的一环</em>，组件是一个独立升级发布的单元，这样的单元关联了很多配置，可将这些配置分为两类。一类是<em>组件内部的配置</em>，另二类是<em>描述组件与组件间关系的配置</em>。只有组件配置化是不够的，往往还需要构建DSL来帮助。</p><ol start="2"><li>构建DSL：</li></ol><p>DSL是工程师针对不同的领域创建的语言。具有很强的针对性，在专业领域有时很长的代码只需要将其改为一行配置就足够了。</p></blockquote><ol start="2"><li><strong>提高配置的开发效率</strong></li></ol><p>通过下面的持续发布的系统，能够很好地提高配置的开发效率。它只针对配置，可以独立的发布配置。在系统中：需要配置前端编辑逻辑，后端校验逻辑，当存储发生变更时，触发测试流水线，当测试流水线无异常后，才会借用部署的工具，将配置分发到线上去。</p><ol start="3"><li><strong>降低配置的维护成本</strong></li></ol><p>通常来说，代码数量很大的项目，配置也会很多。这样的配置在维护起来需要花费大量的成本。所以在设计配置的时候，要满足以下这些规则：</p><blockquote><ol><li><p>让配置尽可能地在部署、数据版本、业务属性和架构描述这四个不同维度间参数能够共用。把部署的配置和策略的配置分离开来。</p></li><li><p>针对配置本身的语法，让配置支持合并.</p></li><li><p>减少冗余信。</p></li><li><p>消除信息重复。</p></li><li><p>使用配置的默认值。</p></li></ol></blockquote></blockquote><h2 id="2-高效研发流程脚本"><a href="#2-高效研发流程脚本" class="headerlink" title="2. 高效研发流程脚本"></a>2. 高效研发流程脚本</h2><h3 id="2-1-从产品目标到产品路线图"><a href="#2-1-从产品目标到产品路线图" class="headerlink" title="2.1 从产品目标到产品路线图"></a><strong>2.1 从产品目标到产品路线图</strong></h3><blockquote><p>满足用户诉求是产品的基础功能，在此之上还有一个更高的期望，即产品的目标。通常情况下产品目标与产品的收益、市场份额、流水有关。在制定具体产品目标时，需要考虑产品的商业模式以及产品所处的阶段。<em>好的产品目标是具体的、可衡量的、相对稳定的。</em></p><p>在进行产品目标阶段性地拆解时，需要考虑拆解的维度与方法。除了根据阶段性的时间维度进行拆分外，还可以根据产品的里程碑进行拆分。</p></blockquote><h3 id="2-2-从产品路线图到发布计划"><a href="#2-2-从产品路线图到发布计划" class="headerlink" title="2.2 从产品路线图到发布计划"></a>2.2 <strong>从产品路线图到发布计划</strong></h3><p>在了解如何制定产品发布计划之前，我们需要先了解一个工具：<em>用户故事地图</em>。用户故事地图实际上是一个完整的用户故事。它可以帮助我们增强团队协作、洞察真实需求、打磨优良产品。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242041157.png" alt="image-20211124204157089"></p><p>想要创建用户故事地图，首先要有用户故事地图的框架。它的核心是一条从左到右的时间线，然后从上到下按照归纳结构分为三个层级。这一条时间线上方的一级粒度的功能需求，在工作中，我们称之为Epic，也就是橙色卡片。这条时间线下方的第一行为二级粒度的功能需求，在工作中，称之为Feature，是黄色卡片。在二级粒度功能下，蓝色的卡片为三级粒度的需求，工作中，称之为Story，是蓝色卡片。</p><p>用户故事地图创建中五个重要的步骤：</p><blockquote><ol><li><p>一步一步写出你的故事</p></li><li><p>组织情节</p></li><li><p>探索替代故事</p></li><li><p>提取故事地图的主干</p></li><li><p>切分出能帮你达成特定目标的任务</p></li></ol></blockquote><p><strong>“训练智能机器人小A从起床到出门”</strong>的简单例子</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242043740.png" alt="image-20211124204337683"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242053569.png"></p><p><em>首先我们使用蓝色卡片</em> 按照步骤写出每个任务，每张卡片只写一个任务，任务以动词开头，如“睁眼”、“关闹钟”、“穿拖鞋”、“叠被子”等等。然后按照任务的发生顺序从左到右的组织卡片摆放。</p><p>接下来第二步，对所有的任务进行提取，得到概括性的行为，把这些<em>行为放到黄色卡片</em>上，也就是feature。如：“睁眼”、“关闹钟”这些行为可以归为“醒来”后要做的事情；“穿拖鞋”、“叠被子”这两个行为可以归为“起来”后要做的事情。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242055033.png"></p><p>接下来进入第三步：探索替代故事。细节、替代、变化和异常构成故事地图的主题。比如：时间充裕可以睡个回笼觉，楼上装修被提前吵醒等等可能发生的变化和异常。我们需要将这些任务补充进地图。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242057602.png"></p><p>然后进入第四步：将一系列类似的任务提取出来，形成更大的目标。在类似任务的上方，放一张<em>橙色的卡片,也就是之前提到的Epic,卡片贴上一个动词短语</em>，使其足以覆盖其下方所有任务卡片所要表达的意思。例如：“起床”可以概括“醒来”和“起来”；“如厕”可以概括“如厕”和“刷牙”。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242058456.png"></p><p>此时已经完成了较为完整的故事地图。然后进入第五步，切分出能达成特定目标的任务。先确定本次迭代需要完成的特性/目标，使用切分来识别和特定相关的所有任务和细节。</p><p>在“训练智能机器人小A从起床到出门”这个例子中，分为了三个版本。在第一个版本15分钟起床，回笼觉这张卡片明显是不需要放到其中的。在这些的story中选出满足15分钟起床的事务并将其放入都第一个版本中。至此我们也就完成了一个简单的用户故事地图的创建。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242002082.webp"></p><p>上面这张图片是实际工作中对用户故事地图的应用，可以看到在实际工作中完整的用户故事地图所包含的内容非常庞杂。</p><p>完成用户故事地图之后，就需要制订发布计划。在创建用户故事地图的第五步中，我们切分出了达成特定功能的任务目标，每一个发布计划都对应着一个版本。具体的步骤如下：</p><blockquote><ol><li><p>Big Story进行细化讨论</p></li><li><p>按照价值和重要程度进行版本规划</p></li><li><p>确定每个版本的期望达成目标</p></li><li><p>确定每个版本的内容</p></li><li><p>团队达成共识</p></li></ol></blockquote><p>通过以上步骤，就基本确定了用户故事地图的发布计划。</p><h3 id="2-3-从发布计划到迭代计划"><a href="#2-3-从发布计划到迭代计划" class="headerlink" title="2.3 从发布计划到迭代计划"></a>2.3 <strong>从发布计划到迭代计划</strong></h3><p>第三部分主要讲解 <em>集中发布式模式</em> 这一常用的模式，在集中发布式模式中<em>，一次发布包含多次迭代</em>；在迭代发布模式中，一次发布等于一次迭代。</p><p>很多大型项目都在使用这一模式，通常是每月发布一次，<em>一次发布包含四个迭代</em>，四个迭代之后，发布一次版本。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242101886.png"></p><p>从发布计划到迭代计划共包括四个内容。</p><ol><li><strong>用户故事拆分</strong></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242101974.png"></p><p>​        用户故事的拆分<em>对迭代速率有一定影响</em>。对用户故事的拆分要做到拆分出的故事尽量小，但是要适当，并不是越小越好。避免出现一个迭代内无法完成的故事。</p><ol start="2"><li><strong>用户故事优先级</strong></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242104291.webp"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242006342.webp"></p><p>​        在完成用户故事拆分后，需要对用户故事的优先级进行排序。用户故事的排序其实是对需求的一个排序，优先级排序有许多方法，如高中低、数字排序、衣服尺码L、XL等方式。<em>优先级决定排入迭代的顺序。</em></p><p>​        以一个两周的迭代时间为例，假设我们有这样一个需求，前面的数字是需求卡片的序号，后面的数字从100到45，这是项目优先级排序的一个方式。每一次迭代能做4个卡片时，我们就会<em>把优先级最高的卡片放入迭代池</em>。</p><p>​        而当第二次迭代时，需求发生了变化，出现了x和y两个新的需求，x和y有着较高的优先级，那么我们仍然将优先级最高的四个卡片放入迭代池中。</p><p>​        第三次迭代中又插入了新需求z，需求z也有较高的优先级，那么当我们进行迭代的时候，需求z就会顶替另一个需求被放入迭代池中。</p><p>​        通过以上的例子可以看到，在原本的迭代计划中，12张卡片会被按顺序放入迭代池中，而真实情况是插入了更高优先级的需求，替换了低优先级的需求，把低优先级的需求放入了下一次迭代中。这就是优先级排序对迭代计划的影响。</p><ol start="3"><li><strong>用户故事估算</strong></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242105269.png"></p><p>​        在迭代之前，需要对用户故事进行估算，<em>用户故事估算实际上是对工作量的估算</em>。这个工作量体现的是团队均值能力。</p><p>​        通常在公司内有不同级别的员工，高级别的员工和低级别的员工完成同一任务所需的时间是不同的。所以在进行用户故事估算时就需要规避掉技能的差异，根据团队的均值能力来进行估算。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242106613.png"></p><ol start="4"><li><strong>迭代计划制定</strong></li></ol><p>当前面三步全部完成后，才能开始指定迭代计划。</p><p>将已拆分好的用户故事按照优先级依次放入迭代池中，对每个要进行迭代的用户故事进行估算，确定好迭代的时间期限。所以我们就制定出了迭代计划。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242107859.png"></p><p><em>推荐采用范围调整、需求置换</em>方式，即插入高优先级用户故事，顺延低优先级故事到下一次迭代。</p><h3 id="2-4-从迭代计划到迭代的落地执行"><a href="#2-4-从迭代计划到迭代的落地执行" class="headerlink" title="2.4 从迭代计划到迭代的落地执行"></a>2.4 <strong>从迭代计划到迭代的落地执行</strong></h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242108710.png" alt="迭代计划会、站会、需求评审会、迭代回顾会"></p><p>在整个过程中开发和测试以story的力度进行。<em>分析、开发与测试三个步骤并行。</em></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242110996.png" alt="卡片墙"></p><p>团队可以使用卡片墙标注完成的任务和未完成的任务以及遇到的bug等。通过这种方式，能够对执行情况有清晰的认知，对执行过程产生积极的影响。</p><h2 id="3-研发工具链介绍"><a href="#3-研发工具链介绍" class="headerlink" title="3 研发工具链介绍"></a>3 研发工具链介绍</h2><h3 id="3-1-项目管理工具-iCafe"><a href="#3-1-项目管理工具-iCafe" class="headerlink" title="3.1 项目管理工具: iCafe"></a>3.1 项目管理工具: iCafe</h3><h4 id="3-1-1-需求管理"><a href="#3-1-1-需求管理" class="headerlink" title="3.1.1 需求管理"></a>3.1.1 需求管理</h4><p><strong>需求管理是一个项目的基石。</strong>在互联网行业中，因为产品需求迭代快速这一特点，需求管理一直非常令人头疼。所以如何对需求进行更好的管理，更好的做出产品规划对互联网行业的项目来说是一个重要的问题。</p><blockquote><p>传统的需求管理方法有以下几种：</p><ol><li><p>直接将需求写在文档上面，</p></li><li><p>将需求制作成需求卡片，通过这样的方式让研发人员与需求人员保持信息的一致。</p></li><li><p>使用Excel进行需求管理和排序。</p></li></ol></blockquote><p>这三种方法都存在很多的缺点，如撰写文档耗时长、文档编写需求较多人力、文档维护成本高、文档使用过程中沟通不畅等等。文字因为其阅读特性，不方便对任务进行直观的展现。所以在很多项目开发过程中，经常会出现文档交给研发人员后，开发出的产品与文档设计不一致的问题。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111250059343.png"></p><p>互联网的需求管理需要具有<strong>需求完整性、沟通高效性、表达准确性，沟通便捷性</strong>等特点。</p><p>研究表明，不同的沟通方式产生的沟通效果各有不同。在所有的沟通方式中，文档沟通是最低效的沟通方式，而面对面使用白板沟通是最高效的沟通方式。结合多种高效沟通方式，就产生了用户故事地图这种新颖的需求管理、排序的方式。</p><p><strong>用户故事地图是敏捷项目管理中一种重要的管理方式。</strong></p><p>首先<strong>使用卡片在白板上将所有的需求列出来，</strong>这样有助于展现产品全貌，而且将需求转化为可视的卡片能更好的根据用户反馈对任务需求进行排序；</p><p>然后<strong>使用不同的颜色对卡片进行分层。</strong>蓝色卡片是第一层，黄色卡片是第二层，白色卡片是第三层。将颗粒度最小的需求放在白色卡片这一层，低颗粒度的需求更容易被研发人员接受。</p><p>最后通过横向的分组，把迭代计划每一期的每一版本的<strong>需求进行归类分组。</strong>这样有利于打通产品视图和研发计划视图。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292215228.png"></p><p>通过以上步骤可以得到一个较为完整的用户故事地图。</p><h4 id="3-1-2-迭代计划"><a href="#3-1-2-迭代计划" class="headerlink" title="3.1.2 迭代计划"></a>3.1.2 迭代计划</h4><p>在完成产品的版本规划后，研发团队需要制定相应的迭代计划。敏捷、快速、合理地迭代计划能够更高效地促进项目的迭代。</p><p>基于用户故事地图，可以在制定迭代计划的过程中中直接对需求进行<strong>上下拖拽修改优先级，左右拖拽更改计划。</strong>这样可以更清晰的展现迭代计划，使开发团队更好定位到的里程碑，完善整个迭代计划。</p><h4 id="3-1-3-进度追踪"><a href="#3-1-3-进度追踪" class="headerlink" title="3.1.3 进度追踪"></a>3.1.3 进度追踪</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111250103932.png"></p><p>进度跟踪的三大法宝：<strong>站会、卡片墙、燃尽图。</strong></p><p>站会同卡片墙相结合，在站会过程中可以直接通过电子看板共享项目进度和项目问题，提升站会沟通效率。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270116972.png"></p><p><strong>用户故事地图是一种非常高效需求管理方式，</strong>目前所有的研发团队都可以在效率云上不受物理条件限制的直接使用它进行需求管理和追踪。</p><h4 id="3-1-4-持续改进"><a href="#3-1-4-持续改进" class="headerlink" title="3.1.4 持续改进"></a>3.1.4 持续改进</h4><p>针对持续改进，有卡片状态时长散点图和卡片状态累积流图这两种工具。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270127171.png"></p><p><strong>卡片状态时长散点图</strong>能够精确展示团队工作速率，从需求提出到需求上线的单个周期时长和平均周期时长，精确的展示团队在每一个状态的工作速率及工作速率的变化。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270128848.png"></p><p><strong>卡片状态累积流图</strong>能够宏观展示项目各流程效率趋势，颜色的色块宽表示该流程积压的需求和任务比较多，色条变窄表明团队状态流动速率提高。</p><p>基于这两幅图工具，研发团队可以周期性地进行自检，对过去一段时间的工作进行自我审视，然后持续改进。</p><h3 id="3-2-代码管理工具-iCode"><a href="#3-2-代码管理工具-iCode" class="headerlink" title="3.2 代码管理工具:iCode"></a>3.2 代码管理工具:iCode</h3><h4 id="3-2-1-工作流"><a href="#3-2-1-工作流" class="headerlink" title="3.2.1 工作流"></a>3.2.1 工作流</h4><p>运转无序，开发混乱是困扰很多团队的一个问题，严重影响产品的交付。</p><p>典型的问题有：代码处理随意、bug重复发生、测试不完善、发布版本混乱等。</p><p>支持以下两种标准的工作流，用来保障团队有序协作。</p><h5 id="1-基于主干的工作流"><a href="#1-基于主干的工作流" class="headerlink" title="1.  基于主干的工作流"></a>1.  基于主干的工作流</h5><p>​            在基于主干的工作流中，整个团队维护一条主干分支。为了保证主干分支的质量，需要配套严    格的准入机制，变更点在合入前需要经过机器、人工的双重评审，通过后才能合入主干。</p><p>​            需要发布的时候，会基于主干拉取发布分支，这个分支其实是主干特定点的快照，单纯用于发        布，如果发布问题过程中发现问题，回到主干修复Bug或进行功能增强，必要时再将主干提交拣        选到相应的发布分支上。</p><p>​            分支发布和主干并行不悖，不用担心开发中的功能被带到线上，发布完成后恢复到一条主干的        简明模式。</p><blockquote><p>  基于主干的工作流<strong>优点</strong>有：</p><ol><li>主干质量高，随时可以发布。</li><li>模型简单，只有一条主干，节省分支合并的成本。</li></ol></blockquote><p>​    缺点: 在开发高质量的工程项目时，团队需要建设完备的测试用例，在提交环节要求提交人保持原子提交，即功能和提交一一对应。</p><h5 id="2-基于分支的工作流"><a href="#2-基于分支的工作流" class="headerlink" title="2. 基于分支的工作流"></a>2. 基于分支的工作流</h5><p>在基于分支的工作流中，<strong>主干用于存储线上代码</strong>，需要变更时，基于主干最新代码开分支完成功能的开发、测试和发布；分支发布前，需要先同步主干的更新；上线之后，需要将分支合并回主干。</p><blockquote><p>基于分支的工作流的<strong>优点</strong>有：</p><ol><li>分支并行，独立开发，分支不会相互影响；</li><li>对团队而言，使用门槛低，分支贯穿一个独立功能开发、测试、发布的整个过程，给予团队充分的时间完善测试用例及完成人工测试；</li><li>容易上手，系统会引导开发人员完成新建分支、同步主干、合会主干等全部操作。</li></ol></blockquote><p>缺点：需要花费分支合并的成本、需要不断地同步主干，来发现分支的冲突风险点并提前解决。</p><h3 id="3-2-2-评审"><a href="#3-2-2-评审" class="headerlink" title="3.2.2 评审"></a>3.2.2 评审</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270327159.png"></p><p>评审是<strong>保证团队工程质量</strong>的一个重要的过程。如果不经过评审直接提交代码，可能会污染代码历史，增加后期维护成本，严重时可能还会产生代码质量问题。</p><p>在项目开发过程中，可能会出现本地运行正常的代码，在测试环境或者线上环境突然崩溃的情况。针对这样的问题，可以使用<strong>质量防护网</strong>。质量防护网包括代码扫描、持续集成、人工评审三个层次。</p><p><strong>代码扫描</strong>能够找出不符合代码规范的地方，在行间距中插入代码评论，同时出具一个风格报告，方便工程师对代码风格问题进行修改。</p><p><strong>持续集成</strong>会配置一个云端构建，通过云端构建，快速探测出代码初期Bug，帮助开发人员提早修复。</p><p>在前两步做好后，团队的资深成员就可以就架构、逻辑、设计等问题进行深入评审。</p><p>通过这三步，实现了机器、人工双重评审，层层递进，确保团队的工程质量。</p><h3 id="3-3-交付平台-iPipe"><a href="#3-3-交付平台-iPipe" class="headerlink" title="3.3 交付平台:iPipe"></a>3.3 交付平台:iPipe</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270329017.png"></p><h4 id="3-3-1-固化端到端的交付流程"><a href="#3-3-1-固化端到端的交付流程" class="headerlink" title="3.3.1 固化端到端的交付流程"></a>3.3.1 固化端到端的交付流程</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270333279.png"></p><p>标准的软件交付的过程包括以下几点：</p><blockquote><ol><li><p>会有一个明确的发布版本的输入，</p></li><li><p>基于这个发布版本，会进行代码提交。</p></li><li><p>代码提交之后会进行编译、测试。其中测试环节可能包含模块级的测试和系统级的测试。</p></li><li><p>进行发布。发布上线的过程可能会分为预上线、生产灰度、生产全量几个环节。</p></li></ol></blockquote><p>为了使代码变更流程标准化，需要<strong>使用交付流水线的方式来落地</strong>。通过标准化交付过程从而达到可靠、可重复的作用。交付流水线是<strong>串行执行</strong>的，上一个阶段成功执行后，就会触发下一个阶段。执行阶段由任务组成，这些任务可以是穿行的也可是并行的。任务的执行状态决定阶段执行状态。</p><p><strong>iPipe这一工具目前包含了标准的交付流水线</strong>，用户可以在iPipe中看到流水线的构建情况。在使用交付流水线的过程中，如果当前阶段失败，后面的阶段就不会继续进行，这样可以节省资源并且快速的发现问题，及时修复问题。</p><h4 id="3-3-2-插件化现有工具和服务"><a href="#3-3-2-插件化现有工具和服务" class="headerlink" title="3.3.2 插件化现有工具和服务"></a>3.3.2 插件化现有工具和服务</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292215685.png"></p><p>在交付流水线中执行各种任务时需要依赖很多工具和服务，比如maven，docker、jenkins、git等工具和服务。</p><p>我们通过一套<strong>标准的插件化开发规范</strong>将这些工具和服务集成到了流水线中，用户在使用流水线的过程中就可以很方便的使用这些插件和服务。如果流水线中没有想使用的插件、服务或工具，可以根据效率云提供的插件规范，自行扩展以满足项目需求。</p><h4 id="3-3-3-数据度量驱动过程改进"><a href="#3-3-3-数据度量驱动过程改进" class="headerlink" title="3.3.3 数据度量驱动过程改进"></a>3.3.3 数据度量驱动过程改进</h4><p>通过交付流水线，可以快速获取项目所有的数据和信息，如：一个版本从代码提交到交付上线的周期或者一个项目各个阶段发现的缺陷数量等等。</p><p>用户可以通过调用API获取数据来进行数据的度量，从而推动交付过程的改进。在后续的发展中，平台会识别项目中关键的数据指标并且自动化的形成更加鲜明的数据报表。这样就可以持续的进行数据度量，给个人及团队提供一个维度丰富的平台。</p><h2 id="4-持续交付方法与实践"><a href="#4-持续交付方法与实践" class="headerlink" title="4 持续交付方法与实践"></a>4 持续交付方法与实践</h2><h3 id="4-1-为什么要做持续交付"><a href="#4-1-为什么要做持续交付" class="headerlink" title="4.1 为什么要做持续交付"></a>4.1 为什么要做持续交付</h3><h4 id="4-1-1-软件交付流程"><a href="#4-1-1-软件交付流程" class="headerlink" title="4.1.1 软件交付流程"></a>4.1.1 软件交付流程</h4><p>传统软件交付流程通常包括四个步骤：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271338880.png"></p><ol><li><p>首先业务人员会诞生一个软件的想法；</p></li><li><p>然后开发人员将这个想法变为一个产品或者功能；</p></li><li><p>经过测试人员的测试之后提交给用户使用并产生收益；</p></li><li><p>最后运维人员参与产品或功能的后期运维。</p></li></ol><h4 id="4-1-2-传统软件交付的问题和困境"><a href="#4-1-2-传统软件交付的问题和困境" class="headerlink" title="4.1.2 传统软件交付的问题和困境"></a>4.1.2 传统软件交付的问题和困境</h4><p>通过分析以上流程，可以发现一些传统软件交付流程<strong>存在的问题</strong>。</p><ol><li><p><strong>业务人员产生的需求文档沟通效率较低</strong>，有时会产生需求文档描述不明确、需求文档变更频繁等问题。</p></li><li><p>随着开发进度的推进，测试人员的工作量会逐步增加，测试工作的比重会越来越大。而且由于测试方法和测试工具有限，自动化测试程度低，<strong>无法很好地把控软件质量</strong>。</p></li><li><p>真实项目中运维的排期经常会被挤占，又因为手工运维繁琐复杂，<strong>时间和技术上的双重压迫</strong>会导致运维质量难以保证。</p></li></ol><p>因为存在以上问题，所以传统的软件交付经常会出现开发团队花费大量成本开发出的功能或产品并不能满足客户需求这一双输的局面。由此可以总结出传统的软件交付存在<strong>两个层面的困境：</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271339450.png"></p><p>从<strong>表现层</strong>来看，传统软件交付存在进度不可控；流程不可靠；环境不稳定；协作不顺畅等困境。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271339695.png"></p><p>表现层的问题其实都是由<strong>底层问题</strong>引起的，从根源上来说，存在分支冗余导致合并困难；缺陷过多导致阻塞测试；开发环境、测试环境、部署环境不统一导致的未知错误；代码提交版本混乱无法回溯；等待上线周期过长；项目部署操作复杂经常失败；上线之后出现问题需要紧急回滚；架构设计不合理导致发生错误之后无法准确定位等困境。</p><h4 id="4-1-3-持续交付的流程与优势"><a href="#4-1-3-持续交付的流程与优势" class="headerlink" title="4.1.3 持续交付的流程与优势"></a>4.1.3 持续交付的流程与优势</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271340504.png"></p><p>经过对传统软件交付问题的分析和总结，持续交付应运而生，持续交付是一系列开发实践方法，用来确保让代码能够快速、安全的部署到生产环境中。持续交付是一个完全自动化的过程，当业务开发完成的时候，可以做到一键部署。持续交付提供了一套更为完善的解决传统软件开发流程的方案。</p><ol><li><p>在需求阶段，抛弃了传统的需求文档的方式，使用便于开发人员理解的用户故事。</p></li><li><p>在开发测试阶段，做到持续集成，让测试人员尽早进入项目开始测试。</p></li><li><p>在运维阶段，打通开发和运维之间的通路，保持开发环境和运维环境的统一。</p></li></ol><p><strong>持续交付具备以下几个优势：</strong></p><blockquote><ol><li>持续交付能够有效缩短提交代码到正式部署上线的时间，降低部署风险。</li><li>持续交付能够自动的、快速的提供反馈，及时发现和修复缺陷。</li><li>持续交付让软件在整个生命周期内都处于可部署的状态。</li><li>持续交付能够简化部署步骤，使软件版本更加清晰。</li><li>持续交付能够让交付过程成为一种可靠的、可预期的、可视化的过程。</li></ol></blockquote><h4 id="4-1-4-敏捷开发与Devops"><a href="#4-1-4-敏捷开发与Devops" class="headerlink" title="4.1.4 敏捷开发与Devops"></a>4.1.4 敏捷开发与Devops</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271341155.png"></p><p>持续交付依靠<strong>敏捷开发（Agile）</strong>和<strong>Devops</strong>两个组件的支撑可以更好地发挥作用。</p><p>敏捷开发（Agile）主要作用于需求阶段和研发阶段。</p><p>Devops主要作用于开发测试和运维部署阶段。</p><blockquote><p>了解Devops的相关知识。</p><blockquote><ol><li><p>Devops的趋势</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271341165.png"></p><p>根据最近的一项集体研究，DevOps的市场在2020年创造了约50亿美元的产值，预计到2022年，这个数字将达到约66亿美元。随着Devops的影响力不断扩大，目前DevOps已经成为软件工程的主流模式。</p></li></ol></blockquote><blockquote><ol start="2"><li><p>Devops效能</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271342341.png"></p><p>Devops的效能跟发布频率、部署时间、平均修复故障的时间点、部署变更的失败率四个因素紧密相关。通常在高效的团队内，发布频率会达到每天多次发布、部署时间和平均修复故障时间都小于一小时，部署变更的失败率也能维持在15%以下。</p></li></ol></blockquote></blockquote><h4 id="4-1-5-软件交付能力指标"><a href="#4-1-5-软件交付能力指标" class="headerlink" title="4.1.5 软件交付能力指标"></a>4.1.5 软件交付能力指标</h4><p>在评价互联网公司的软件交付能力的时候，通常会使用两个指标：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271343658.png"></p><ol><li><p>仅涉及一行代码的改动需要花费多少时间才能部署上线，这也是<strong>核心指标</strong>。</p></li><li><p>开发团队是否在以一种可重复、可靠的方式在执行软件交付。</p></li></ol><p>目前，国外的主流互联网企业部署周期都以分钟为单位， Amazon、Google这些头部互联网企业单日的部署频率都在20000次以上。国内以百度、阿里、腾讯三大互联网巨头的数据来看，单日部署的频率也达到了单日8000次以上。高频率的部署代表着能够更快更好的响应客户的需求。</p><h3 id="4-2-如何做到高效的持续交付"><a href="#4-2-如何做到高效的持续交付" class="headerlink" title="4.2 如何做到高效的持续交付"></a>4.2 如何做到高效的持续交付</h3><h4 id="4-2-1-持续交付方法"><a href="#4-2-1-持续交付方法" class="headerlink" title="4.2.1 持续交付方法"></a>4.2.1 持续交付方法</h4><p>为了能更好的做到高效的持续交付。在此我们提供了一个<strong>三层叠加的持续交付方法</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271345629.png"></p><p>首先最上层，持续交付的<strong>总目标是价值交付</strong>，要为用户交付有价值的内容。</p><p>然后第二层包含了业务、流程、组织三个维度。</p><p>在业务这一维度，主要通过精益、用户故事地图、看板三种方式来减少业务部门与开发部门的沟通困难。</p><p>在流程这一维度，主要集中于创建一个供开发、测试、运维人员使用的可靠、可重复的流水线，将这种流水线应用于项目的流程中。</p><p>在组织这一维度，要求加强团队协作，提高项目质量和项目改进能力，并且引入了成熟度模型用于评估团队的能力层级。</p><p>如果没有技术能力的支撑，仅依靠方法和指导思想不足以做到高效持续交付。所以<strong>第三层也是最重要的底层是技术层</strong>。技术层包括了基础架构和应用架构。<strong>基础架构</strong>引入了容器集群管理、研发工具平台、持续交付工具链。<strong>应用框架</strong>引入了浮现式设计、微服务框架还有能够抽离出来的配置化架构。</p><h4 id="4-2-2-持续交付、持续集成、持续部署的关系"><a href="#4-2-2-持续交付、持续集成、持续部署的关系" class="headerlink" title="4.2.2 持续交付、持续集成、持续部署的关系"></a>4.2.2 持续交付、持续集成、持续部署的关系</h4><p>要进一步构建可靠可重复的流水线，首先就是要理清持续交付、持续集成和持续部署三者之间的关系。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271348755.png"></p><p>简单来说<strong>持续集成和持续部署是持续交付的基础，持续交付包括但不限于持续集成和持续部署。</strong></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271350656.png"></p><p>持续集成是包含了代码的编译、近代检查、单元测试任务的集成，虽然持续集成也能构成一条流水线，但是这条流水线并不完整，而且集成并没有明确的目标。</p><p>近几年得益于虚拟机技术和容器技术的迅速发展，持续部署也逐渐变得简单高效，能够运用这些工具快速将项目部署到例如准入环境、预生产环境等等各种环境中。</p><h4 id="4-2-3-如何构建一个可靠可重复的流水线"><a href="#4-2-3-如何构建一个可靠可重复的流水线" class="headerlink" title="4.2.3 如何构建一个可靠可重复的流水线"></a>4.2.3 如何构建一个可靠可重复的流水线</h4><p>在理清持续交付的关系后，需要通过持续交付来构建一条可靠可重复的流水线，构建这条流水线的目的是为了让开发人员、测试人员、运维人员能更好的协作完成整个项目并上线到生产环境。</p><p>通过对比传统流水线和持续交付流水线，能更加清晰地展现出持续交付流水线的强大。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271351747.png"></p><p>在传统流水线中，首先代码提交要用过填写表单的形式进行版本申请，然后开发人员在离线环境上手工进行代码编译和单元测试，单元测试完成后需要撰写对应的测试报告文档并且向上提测，在系统测试环节需要测试人员手动构建和部署测试环境，完成测试之后再次撰写测试报告，并且申请上线，在通过上线审批之后，在线上生产环境需要再次手动构建环境以及进行生产环境的测试，最终完成整体的开发。</p><p>在持续交付流水线中，代码合入到主干之后会直接触发自动编译，自动编译完成之后会进行初步的自动化单元测试、模块测试和系统测试，在测试过程中持续交付可以自动构建和部署环境。完成系统测试之后会将问题抛出来，解决完成后再次提测，会自动化的再次进行系统测试，通过系统测试之后可以一键操作进行项目发布，并进行预上线，在完成预上线后，可以再次进行一键操作完成正式生产环境的上线。</p><p>通过两种流水线的对比，可以看出来，持续交付的流水线有显著的优势。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271352109.png"></p><p>实际生产中的产品级流水线，可以视为多个模块级流水线的组合，多个模块级流水线组合成为复杂的多线并发的产品级流水线，最终可以完成整个项目的持续交付。</p><h4 id="4-2-4-交付流水线落地工具"><a href="#4-2-4-交付流水线落地工具" class="headerlink" title="4.2.4 交付流水线落地工具"></a>4.2.4 交付流水线落地工具</h4><p>交付流水线的落地需要依靠<strong>落地方案</strong>和<strong>落地工具</strong>，目前常用的落地方案有GoCD，这是thoughtworks的一个产品。还有目前广泛应用的Jenkins和Spinnakeer。</p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271354818.png" style="zoom:50%;" /><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271354355.png" style="zoom:50%;" /><p>常用的交付流水线落地工具有效率云平台中的iPipe工具，在这个工具中可以根据需求创建流水线，并且将相关内容全都关联到流水线中，这样可以让开发人员、测试人员和运维人员在这个工具中直观的看到产品的状态以及质量情况。</p><h3 id="4-3-持续部署"><a href="#4-3-持续部署" class="headerlink" title="4.3 持续部署"></a>4.3 持续部署</h3><p>对于持续交付整体来说，持续部署非常重要。</p><h4 id="4-3-1-持续部署方案"><a href="#4-3-1-持续部署方案" class="headerlink" title="4.3.1 持续部署方案"></a>4.3.1 持续部署方案</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292215446.png"></p><p>容器技术目前是部署中最流行的技术，常用的持续部署方案有Kubernetes+Docker和Matrix系统两种。容器技术一经推出就被广泛的接受和应用，主要原因是对比传统的虚拟机技术有以下几个<strong>优点</strong>：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292215715.png"></p><ol><li>容器技术上手简单，轻量级架构，体积很小。</li><li>容器技术的集合性更好，能更容易对环境和软件进行打包复制和发布。</li></ol><p>容器技术的引入为软件的部署带来了前所未有的改进，不但<strong>解决了复制和部署麻烦</strong>的问题，还能<strong>更精准的将环境中的各种依赖进行完整的打包。</strong></p><h4 id="4-3-2-部署原则"><a href="#4-3-2-部署原则" class="headerlink" title="4.3.2 部署原则"></a>4.3.2 部署原则</h4><p><strong>在持续部署管理的时候，需要遵循一定的原则，内容包括以下几点：</strong></p><ol><li>部署包全部来自统一的存储库。</li><li>所有的环境使用相同的部署方式。</li><li>所有的环境使用相同的部署脚本。</li><li>部署流程编排阶梯式晋级，即在部署过程中需要设置多个检查点，一旦发生问题可以有序的进行回滚操作。</li><li>整体部署由运维人员执行。</li><li>仅通过流水线改变生产环境，防止配置漂移。</li><li>不可变服务器。部署方式采用蓝绿部署或金丝雀部署。</li></ol><h4 id="4-3-3-部署层次"><a href="#4-3-3-部署层次" class="headerlink" title="4.3.3 部署层次"></a>4.3.3 部署层次</h4><p>部署层次的设置对于部署管理来说也是非常重要的。首先要明确部署的目的并不是部署一个可工作的软件，而是<strong>部署一套可正常运行的环境</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271634406.png"></p><p><strong>完整的镜像部署包括三个环节：Build – Ship – Run。</strong></p><p>Build跟传统的编译类似，将软件编译形成RPM包或者Jar包。</p><p>Ship则是将所需的第三方依赖和第三方插件安装到环境中。</p><p>Run就是在不同的地方启动整套环境。</p><p>制作完成部署包之后，每次需要变更软件或者第三方依赖、插件升级的时候，不需要重新打包，直接更新部署包即可。</p><h4 id="4-3-4-不可变服务器"><a href="#4-3-4-不可变服务器" class="headerlink" title="4.3.4 不可变服务器"></a>4.3.4 不可变服务器</h4><p>在部署原则中提到的不可变服务器原则对于部署管理来说非常重要。不可变服务器<strong>是技术逐步演化的结果。</strong></p><p>在早期阶段，软件的部署是在物理机上进行的，每一台服务器的网络、存储、软件环境都是不同的，物理机的不稳定让环境重构变得异常困难。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271635334.png"></p><p>后来逐渐发展为虚拟机部署，在虚拟机上借助流程化的部署能较好的构建软件环境，但是第三方依赖库的重构不稳定为整体部署带来了困难。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292216469.png"></p><p>现阶段使用容器部署不但继承和优化了虚拟机部署的优点，而且很好的解决了第三方依赖库的重构问题，容器部署就像一个集装箱，直接把所有需要的内容全部打包进行复制和部署。</p><h4 id="4-3-5-蓝绿部署和金丝雀部署"><a href="#4-3-5-蓝绿部署和金丝雀部署" class="headerlink" title="4.3.5 蓝绿部署和金丝雀部署"></a>4.3.5 蓝绿部署和金丝雀部署</h4><p>在部署原则中提到两大部署方式分别为蓝绿部署和金丝雀部署。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271635700.png"></p><p><strong>蓝绿部署</strong>是指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速的将用户环境切回旧版本，并对新版本进行修复和调整。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271636728.png"></p><p><strong>金丝雀部署</strong>是指当有新版本发布的时候，先让少量的用户使用新版本并且观察新版本是否存在问题，如果出现问题，就及时处理并重新发布，如果一切正常，就稳步的将新版本适配给所有的用户。</p><h4 id="4-3-6-服务描述"><a href="#4-3-6-服务描述" class="headerlink" title="4.3.6 服务描述"></a>4.3.6 服务描述</h4><p>服务描述要实现的目标是当软件部署到不同的环境中时，通过服务描述来<strong>规避环境配置的差异</strong>。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637518.png"></p><p>在服务描述中，通常会对不同的环境下所需的配置进行描述，例如所需要的CPU、内存、网络等。当实际部署的时候，如果出现环境差异，调度工具就可以按照服务描述的配置发放资源，使环境能够正常运行。</p><h4 id="4-3-7-流程控制"><a href="#4-3-7-流程控制" class="headerlink" title="4.3.7 流程控制"></a>4.3.7 流程控制</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637506.png"></p><p>在部署阶段，为了防止意外问题的发生，会在一些环节<strong>加入人工审核</strong>。例如在灰度发布工具中，就会先对线上机器进行分组部署，然后由人工去分组检查，如果没有问题，就进行下一组的部署，如果出现问题，人工就可以及时的进行回滚操作，避免问题扩大到更多地线上环境中。</p><h4 id="4-3-8-数据度量和分析"><a href="#4-3-8-数据度量和分析" class="headerlink" title="4.3.8 数据度量和分析"></a>4.3.8 数据度量和分析</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637498.png"></p><p>在完成持续部署或持续交付之后，需要结合多个维度的数据对项目整体的<strong>研发效率和部署效率进行分析</strong>。例如通过交付时间周期的长短变化来反映流水线为团队带来的价值。再比如通过筛选和展示团队的相关数据，方便团队来进行决策。还有通过环比汇总数据来分析变化的趋势。系统也会通过数据的自动分析和异常报表监控一些关键指标，一旦关键数据出现问题，系统能够及时联系关键人员关注。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271640201.png"></p><p>通过以上的例子能够发现，<strong>持续交付与量化驱动改进是密不可分的</strong>，团队能够在度量中发现问题，在度量中看到进步。持续交付就是这样一个不断改进不断优化的过程，通过数据可以量化产出并且指引团队找到痛点并且进一步的深化改进。</p><!-- flag of hidden posts -->]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;百度高效研发实战训练营Step1&quot;&gt;&lt;a href=&quot;#百度高效研发实战训练营Step1&quot; class=&quot;headerlink&quot; title=&quot;百度高效研发实战训练营Step1&quot;&gt;&lt;/a&gt;百度高效研发实战训练营Step1&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http:</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="百度高效研发实战训练营" scheme="https://www.ckxgzxa.top/tags/%E7%99%BE%E5%BA%A6%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/"/>
    
  </entry>
  
  <entry>
    <title>在服务器上搭建jupyter notebook</title>
    <link href="https://www.ckxgzxa.top/buildJupyterOnServer.html"/>
    <id>https://www.ckxgzxa.top/buildJupyterOnServer.html</id>
    <published>2021-11-08T13:46:21.000Z</published>
    <updated>2021-12-05T05:42:21.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何在服务器上搭建jupyter-notebook"><a href="#如何在服务器上搭建jupyter-notebook" class="headerlink" title="如何在服务器上搭建jupyter notebook"></a>如何在服务器上搭建jupyter notebook</h1><h2 id="1-准备一台Linux云服务器"><a href="#1-准备一台Linux云服务器" class="headerlink" title="1. 准备一台Linux云服务器"></a>1. 准备一台Linux云服务器</h2><h2 id="2-新建一个用户"><a href="#2-新建一个用户" class="headerlink" title="2. 新建一个用户"></a>2. 新建一个用户</h2><p>我的习惯是是不在root用户下运行 jupyter notebook 服务,</p><p>因此我建议新建一个<code>jupyter</code>的用户:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adduser jupyter</span><br></code></pre></td></tr></table></figure><p>然后切换到此用户</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su jupyter</span><br></code></pre></td></tr></table></figure><h2 id="3-安装-Anaconda"><a href="#3-安装-Anaconda" class="headerlink" title="3. 安装 Anaconda"></a>3. 安装 Anaconda</h2><p>下载Anaconda最新安装程序 <a href="https://www.anaconda.com/products/individual#Downloads">https://www.anaconda.com/products/individual#Downloads</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>运行安装程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh Anaconda3-2021.05-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>安装过程中敲回车和输入yes同意许可即可</p><p>安装完成重新登录即可</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111082211398.png" alt="image-20211108221130339"></p><h2 id="4-搭建-Jupyter-Notebook-环境"><a href="#4-搭建-Jupyter-Notebook-环境" class="headerlink" title="4. 搭建 Jupyter Notebook 环境"></a>4. 搭建 Jupyter Notebook 环境</h2><ul><li>安装jupyter包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install jupyter <br></code></pre></td></tr></table></figure><ul><li>生成默认配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook --generate-config<br></code></pre></td></tr></table></figure><ul><li>随后我们往配置文件写入一些内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置可以访问的ip, 默认是localhost, 将其改为 &#x27;*&#x27;</span><br>c.NotebookApp.ip = <span class="hljs-string">&#x27;*&#x27;</span><br><br><span class="hljs-comment"># 笔记本的默认打开目录, 自己设置</span><br>c.NotebookApp.notebook_dir = <span class="hljs-string">&#x27;/home/jupyter/documents/jupyter_notebook&#x27;</span><br><br><span class="hljs-comment"># 笔记本启动后是否打开浏览器, 设为 False即可</span><br>c.NotebookApp.open_browser = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 默认访问端口, 可自己修改</span><br>c.NotebookApp.port = <span class="hljs-number">8888</span><br><br><span class="hljs-comment"># jupyterlab是否显示quit按钮,我设为false以免自己不小心按到把服务停了</span><br>c.NotebookApp.quit_button = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 如果使用root用户运行,将下列值改为True即可, 运行时也可加参数将其改为True</span><br>c.NotebookApp.allow_root = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><ul><li>修改好配置文件之后, 运行如下命令启动笔记本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook<br></code></pre></td></tr></table></figure><ul><li>第一次运行会给出带token的链接, 复制到浏览器中打开, 点击登出</li></ul><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111082241916.png" alt="image-20211108224139818"></p><ul><li><p>随后进入login界面, 输入刚刚链接中的 token值和新密码即可修改密码:</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111082243891.png" alt="image-20211108224309795"></p></li><li><p>设置好密码之后我们重启jupyter服务, 再次进入,发现就能用我们刚刚设置的密码登录了</p></li></ul><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111082245031.png" alt="image-20211108224540995"></p><ul><li>随便上传一个笔记本试试</li></ul><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111082326683.png" alt="image-20211108232637635"></p><ul><li>发现已经ok了</li></ul><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111082327360.png" alt="image-20211108232733266"></p><h2 id="5-让-jupyter-在服务器上持久运行"><a href="#5-让-jupyter-在服务器上持久运行" class="headerlink" title="5. 让 jupyter 在服务器上持久运行"></a>5. 让 jupyter 在服务器上持久运行</h2><ul><li>发现断开 SSH 连接之后, jupyter服务就会停止运行,我们利用<code>screen</code> 命令让jupyter服务一直运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S notebook<br></code></pre></td></tr></table></figure><ul><li>然后启动jupyter服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook<br></code></pre></td></tr></table></figure><ul><li>随后按 <code>Ctrl + A + D </code>将服务挂到后台即可</li></ul><h2 id="6-End"><a href="#6-End" class="headerlink" title="6. End"></a>6. End</h2><p>本次教程简单记录而已, 如有帮助,本人不胜感激.</p><blockquote><p>如有错误或不当之处, 请在下方评论, 我看到将对其进行修改和改进</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何在服务器上搭建jupyter-notebook&quot;&gt;&lt;a href=&quot;#如何在服务器上搭建jupyter-notebook&quot; class=&quot;headerlink&quot; title=&quot;如何在服务器上搭建jupyter notebook&quot;&gt;&lt;/a&gt;如何在服务器上搭建ju</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="https://www.ckxgzxa.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ModelArts平台花卉分类识别实验报告</title>
    <link href="https://www.ckxgzxa.top/FlowerIdentificationByModelarts.html"/>
    <id>https://www.ckxgzxa.top/FlowerIdentificationByModelarts.html</id>
    <published>2021-11-05T06:45:43.000Z</published>
    <updated>2021-12-05T05:42:21.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="华为云ModelArts平台花卉分类识别实验报告"><a href="#华为云ModelArts平台花卉分类识别实验报告" class="headerlink" title="华为云ModelArts平台花卉分类识别实验报告"></a>华为云ModelArts平台花卉分类识别实验报告</h1><blockquote><p><a href="https://activity.huaweicloud.com/discount_area_v5/index.html?fromacct=5a4cbb43-f85f-4427-ba12-3630ac71d4fe&utm_source=Y2t4Z3p4YWJlc3Q==&utm_medium=cps&utm_campaign=201905">【华为云11.11上云嘉年华，注册领10000元上云礼包，满额送华为X2折叠屏】</a></p></blockquote><h2 id="1-准备数据集"><a href="#1-准备数据集" class="headerlink" title="1. 准备数据集"></a>1. 准备数据集</h2><p>​        我们在官网下载好TensorFlow官网提供的[花卉数据集](<a href="https://www.tensorflow.org/datasets/catalog/tf_flowers">tf_flowers  | TensorFlow Datasets</a>)并在我们电脑上解压, </p><p>发现 文件的结构如下所示:</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111051955239.png" alt="image-20211105195521063"></p><p>flower_photos内共有5个文件夹,分别是雏菊(daisy)，dandelion(蒲公英)， roses(玫瑰)， sunflowers(向日葵)， tulips(郁金香)， 每个文件夹中存放有若干张该分类的图片。</p><h2 id="2-创建OBS桶"><a href="#2-创建OBS桶" class="headerlink" title="2. 创建OBS桶"></a>2. 创建OBS桶</h2><p>用ModelArts训练需要华为的对象存储服务OBS来保存我们的数据，</p><ul><li><p>首先在华为云搜索obs服务，然后点击进入</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052031054.png" alt="image-20211105203119822"></p></li><li><p>进入之后点击创建桶</p></li></ul><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052030323.png" alt="image-20211105203016075"></p><ul><li><p>然后选择单AZ存储，地区选择离你最近的地区即可，选择好之后点击立即创建：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052036482.png" alt="image-20211105203646291"></p></li><li><p>这样我们的OBS桶就创建好了</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052041210.png" alt="image-20211105204107093"></p></li></ul><h2 id="3-获取访问密钥"><a href="#3-获取访问密钥" class="headerlink" title="3. 获取访问密钥"></a>3. 获取访问密钥</h2><p>需要获取访问密钥然后用访问密钥登录obs-brower来方便的将我们的训练数据上传到OBS桶</p><ul><li><p>获取OBS密钥</p><ol><li><p>点击我的凭证</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052113742.png" alt="image-20211105211345664"></p></li><li><p>点击新增访问密钥</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052114923.png" alt="image-20211105211453706"></p></li><li><p>输入密钥名称就可以下载一个名为credentials.csv的文件，里面存放的就是访问密钥，请不要泄露</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052117971.png"></p></li></ol><h2 id="4-获取OBS-Browser-工具"><a href="#4-获取OBS-Browser-工具" class="headerlink" title="4. 获取OBS Browser+ 工具"></a>4. 获取OBS Browser+ 工具</h2><ol><li><p>随后我们进入如下的网址下载 obs browser+ 工具</p><p>下载OBS Browser+：<a href="https://support.huaweicloud.com/browsertg-obs/obs_03_1003.html">https://support.huaweicloud.com/browsertg-obs/obs_03_1003.html</a></p><p>下载安装好之后我们打开它之后使用上一步获取到的密钥登录：</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052121218.png" alt="image-20211105212127102"></p></li><li><p>随后我们在桶内新建4个文件夹(flower_photos, flower_input, flower_output, train_output)用于接下来的实验</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052122159.png" alt="image-20211105212256032"></p></li></ol></li></ul><h2 id="5-上传数据集"><a href="#5-上传数据集" class="headerlink" title="5. 上传数据集"></a>5. 上传数据集</h2><p>在flower_photos中上传我们解压出来的花卉数据集</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052128053.png" alt="image-20211105212805937"></p><p>​     </p><h2 id="6-创建数据集"><a href="#6-创建数据集" class="headerlink" title="6. 创建数据集"></a>6. 创建数据集</h2><ul><li><p>进入ModelArts控制台界面，进入数据集管理，然后点击创建数据集</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052131676.png" alt="image-20211105213120461"></p></li><li><p>选择图像分类标注类型，输入为止和输出位置选择我们刚刚在 obs browser中新建的两个空文件夹</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052133067.png" alt="image-20211105213303824"></p></li><li><p>随后点击创建数据集即可</p></li><li><p>返回进入此数据集管理界面，点击导入，由于我已经创建过数据集了，因此里面是有标记数据的</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052135413.png" alt="image-20211105213510211"></p></li><li><p>点击我们刚开始上传花卉数据集的位置确定即可</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052136171.png" alt="image-20211105213608064"></p></li><li><p>导入完成之后，我们点击发布，设置数据切分训练集比例为0.8即可</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052137278.png" alt="image-20211105213729194"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052138484.png" alt="image-20211105213811387"></p></li></ul><h2 id="7-使用算法进行模型训练"><a href="#7-使用算法进行模型训练" class="headerlink" title="7. 使用算法进行模型训练"></a>7. 使用算法进行模型训练</h2><ul><li><p>首先进入如下的网址订阅图像分类算法</p><p><a href="https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0">图像分类-MobileNet_v2链接</a>：<a href="https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0)">https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0)</a></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052139825.png" alt="image-20211105213954489"></p></li><li><p>订阅完成之后我们返回ModelArts控制台的训练管理界面，点击创建训练作业</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052143872.png" alt="image-20211105214329543"></p></li><li><p>算法选择刚刚我们刚刚订阅的算法，训练输入选择我们刚刚创建的数据集，训练输出选择我们刚开始创建的输出文件夹即可，下面有免费的GPU资源可以供我们选择。点击提交并等待训练完成。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052145627.png" alt="image-20211105214541511"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052147929.png" alt="image-20211105214734741"></p></li><li><p>模型训练完成大概需要二十多分钟</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052211783.png" alt="image-20211105221118637"></p></li></ul><h2 id="8-模型的部署和验证"><a href="#8-模型的部署和验证" class="headerlink" title="8. 模型的部署和验证"></a>8. 模型的部署和验证</h2><ul><li><p>点击模型管理，然后进行在线服务的部署，选择免费资源即可</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052153987.png" alt="image-20211105215342790"></p></li><li><p>部署完成之后点击在线服务的预测</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052156506.png" alt="image-20211105215616340"></p><p>在这里可以对应用接口进行调试，同样地你也可以利用POSTMAN等工具对它进行调试，官网有详细的文档可以查看</p></li><li><p>我们上传一些花卉图片对它进行测试</p><ol><li><p>这张图片的结果是玫瑰的可能性是1，识别正确。<img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052159806.png" alt="image-20211105215908408"></p></li><li><p>这张蒲公英的图片也是识别正确的。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052202530.png" alt="image-20211105220235211"></p></li><li><p>这张图片是向日葵的概率也是100%</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111052206769.png"></p></li></ol></li><li><p>我们发现这个训练出来的95.87%准确率的花卉分类模型还是能准确分辨这五种花卉图片的，结果不错。</p></li></ul><h2 id="9-注意事项"><a href="#9-注意事项" class="headerlink" title="9. 注意事项"></a>9. 注意事项</h2><ul><li>华为的OBS对象存储服务是要花钱的，不过训练完成之后也只扣了1分钱，其他的服务都是免费的，充值的费用如果没用完也是能提现的，所以不用担心，这点还是非常不错的。</li></ul><h2 id="10-心得和体会"><a href="#10-心得和体会" class="headerlink" title="10. 心得和体会"></a>10. 心得和体会</h2><p>通过这次利用华为云ModelArts平台进行的花卉识别实验，我发现华为ModelArts平台为机器学习与深度学习提供海量数据预处理及交互式智能标注、大规模分布式训练、自动化模型生成等等一些功能，这些功能全是华为云线上帮你完成的，我们用户根本不用编写一些复杂的代码，从而可以帮助用户快速创建和部署模型，即使你毫无编码基础，也能通过这些图形化的界面进行模型的搭建和训练并快速的部署发布到实际应用当中，推进了人工智能和机器学习的普及和大众化，并使用场景化的AI案例，使得AI落地零门槛，这样的话普通人也能利用华为的这个平台使用人工智能技术改变世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;华为云ModelArts平台花卉分类识别实验报告&quot;&gt;&lt;a href=&quot;#华为云ModelArts平台花卉分类识别实验报告&quot; class=&quot;headerlink&quot; title=&quot;华为云ModelArts平台花卉分类识别实验报告&quot;&gt;&lt;/a&gt;华为云ModelArts平台</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="人工智能" scheme="https://www.ckxgzxa.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>第1章 什么是对象?</title>
    <link href="https://www.ckxgzxa.top/3-WhatIsAnObject.html"/>
    <id>https://www.ckxgzxa.top/3-WhatIsAnObject.html</id>
    <published>2021-10-28T07:02:17.000Z</published>
    <updated>2021-12-05T05:42:21.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-什么是对象"><a href="#第-1-章-什么是对象" class="headerlink" title="第 1 章　什么是对象"></a>第 1 章　什么是对象</h1><blockquote><p>“我们并未意识到惯用语言结构的强大之处。甚至可以毫不夸张地说，惯用语言通过语义反应机制奴役了我们。而一门语言所展现出的结构，潜移默化地影响着我们，并自动映射至我们所生活的世界。”</p><p>——Alfred Korzybski（1930）</p></blockquote><p>计算机革命起源于一台机器，而编程语言就好比是那台机器。</p><p>然而计算机并不只是机器而已，它们还是扩展思维的工具（就像乔布斯喜欢说的一句话：计算机是“思维的自行车”），也是一种与众不同的表达媒介。结果就是，工具已经越来越不像机器，而是越来越像思维的一部分。</p><p>编程语言是用于创建应用程序的思维模式。语言本身可以从写作、绘画、雕塑、动画、电影制作等表达方式中获取灵感，而<strong>面向对象编程</strong>（Object-Oriented Programming, OOP）则是用计算机作为表达媒介的一种尝试。</p><p>许多人并不了解面向对象编程的思想框架，他们在进行编程时会感到举步维艰。因此，本章会简要的介绍一些面向对象编程的基础概念。还有一些人在接触相关机制之前可能无法理解这些概念，在看不到代码的情况下就会迷失。如果你属于后者并且渴望尽早接触到具体的语言特性，你完全可以跳过这一章，这样做并不会影响你学习编程语言或者写代码。不过，之后你可以再回到这里补充相关知识，这样有助于你理解对象如此重要的原因，以及如何利用对象做程序设计。</p><p>本章的内容假设你具有一定的编程基础，但不一定是C语言的经验。在全面学习本书之前，如果你需要补充一些基础的编程知识，可以在 On Java 8 网站下载多媒体课程“Thinking in C”来学习。</p><h2 id="1-1-抽象的历程"><a href="#1-1-抽象的历程" class="headerlink" title="1.1　抽象的历程"></a>1.1　抽象的历程</h2><p>所有编程语言都是一种抽象。甚至可以说，我们能够解决的问题的复杂程度直接取决于抽象的类型和质量。这里提到的“类型”的含义是“你要抽象的是什么”。比如，汇编语言是对计算机底层的一个极简化的抽象。还有许多所谓的命令式编程语言（比如 FORTRAN、BASIC 和 C 语言等）都是各自对汇编语言的抽象。虽然这些语言已经取得了长足的进步，但它们主要的抽象方式依然要求你根据计算机的结构而非问题的结构来思考。于是，程序员必须在机器模型（也叫作“解决方案空间”，即实际解决问题的方式，比如计算机）和实际解决的问题模型（也叫作“问题空间”，即问题实际存在之处，比如来源于某个业务）之间建立关联。建立这种关联需要耗费很大的精力，而且它是与编程语言无关的，这一切都导致程序难以编写且不易维护。</p><p>构建机器模型的一种代替方案是针对需要解决的问题构建问题模型。早期的一些编程语言（比如 LISP 和 APL）会采取特定的视角看待周遭问题（例如，“所有问题最终都可以用列表呈现”或者“所有问题都是算法问题”），Prolog 语言则会将所有问题都转换为决策链。这些语言要么是基于约束性的编程语言，要么是专门用来操作图形符号的编程语言。这些编程语言都能够出色地解决一些特定的问题，因为它们正是为此而生的。然而，一旦遇到它们专属领域以外的问题，它们就显得无能为力了。</p><p>面向对象编程则更进一步，它为程序员提供了一些能够呈现问题空间元素的工具。这种呈现方式具备足够的通用性，使得程序员不再局限于特定的问题。而这些问题空间中的元素及其解决方案空间中的具体呈现，我们称其为“对象”（需要注意的是，有些对象并不支持问题空间的类比）。其背后的理念则是，通过添加各种新的对象，程序可以将自己改编为一种描述问题的语言。于是，你阅读的既是解决方案的代码，也是表述问题的文字。这种灵活且强大的语言抽象能力是前所未有的。因此，面向对象编程描述问题的依据是实际的问题，而非用于执行解决方案的计算机。不过，它们之间依然存在联系，这是因为从某种意义上来说，对象也类似于一台小型计算机——每一个对象都具有状态，并且可以执行一些特定的操作。这一特点与现实中的事物极为相似，它们都具有各自的行为和特征。</p><p>SmallTalk 是历史上第一门获得成功的面向对象语言，并且为后续出现的 Java 语言提供了灵感。Alan Kay 总结了 SmallTalk 语言的 5 个基本特征，这些特征代表了纯粹的面向对象编程的方式。</p><ol><li><strong>万物皆对象。</strong>你可以把对象想象为一种神奇的变量，它可以存储数据，同时你可以“发出请求”，让它执行一些操作。对于你想要解决的问题中的任何元素，你都可以在程序中用对象来呈现（比如狗、建筑、服务等）。</li><li><strong>一段程序实际上就是多个对象通过发送消息来通知彼此要干什么。</strong>当你向一个对象“发送消息”时，实际情况是你发送了一个请求去调用该对象的某个方法。</li><li><strong>从内存角度而言，每一个对象都是由其他更为基础的对象组成的。</strong>换句话说，通过将现有的几个对象打包在一起，你就创建了一种新的对象。这种做法展现了对象的简单性，同时隐藏了程序的复杂性。</li><li><strong>每一个对象都有类型。</strong>具体而言，每一个对象都是通过某个<strong>类</strong>生成的<strong>实例</strong>，这里说的“类”就（几乎）等同于“类型”。一个类最为显著的特性是“你可以发送什么消息给它”。</li><li><strong>同一类型的对象可以接收相同的消息。</strong>稍后你就会意识到这句话的丰富含义。举例来说，因为一个“圆形”对象同样也是一个“形状”对象，所以“圆形”也可以接收“形状”类型的消息。这就意味着，你为“形状”对象编写的代码<strong>自然</strong>可以适用于任何的“形状”子类对象。这种可替换性是面向对象编程的一个基石。</li></ol><p>Grady Booch 对对象做了一种更为简洁的描述：</p><blockquote><p>对象具有状态、行为及标识。</p></blockquote><p>这意味着对象可以拥有属于自己的内部数据（赋予其状态）、方法（用于产生行为），同时每一个对象都有别于其他对象。也就是说，每一个对象在内存中都有唯一的地址。**$^1$**</p><blockquote><p>**$^1$**这个说法实际上不太全面。这是因为对象可以保存在不同的机器或内存地址中，甚至还可以保存在磁盘上。在上述情况中，对象的标识（identity）就需要用其他方式而非内存地址来表示。</p></blockquote><h2 id="1-2-对象具有接口"><a href="#1-2-对象具有接口" class="headerlink" title="1.2　对象具有接口"></a>1.2　对象具有接口</h2><p>亚里士多德可能是第一个仔细研究<strong>类型</strong>这一概念的人，他曾经提出过“鱼的类别和鸟的类别”。所有的对象，哪怕是相当独特的对象，都能够被归为某一类，并且同一类对象拥有一些共同的行为和特征。作为有史以来第一门面向对象编程语言，Simula-67 引入了上述的“类别”概念，并且允许通过关键字 <code>class</code> 在程序中创建新的类型。</p><p>Simula 语言恰如其名，其诞生的目的是用于“模拟”，比如模拟经典的“银行出纳问题”。这个问题的元素包括大量的出纳员、顾客、账户、交易，以及各种货币单位等，这些都是“对象”。而那些状态不同但结构相同的对象汇聚在一起，就变成了“同一类对象”（classes of objects），这就是关键字<code>class</code>的由来。</p><p>创建抽象数据类型（即“类”）是面向对象编程的一个基本概念。抽象数据类型的工作原理和内置类型几乎一样：你可以创建某种类型的变量（在面向对象领域，这些变量叫作“对象”或“实例”），随后你就可以操作这些变量（叫作“发送消息”或“发送请求”，即你发送指令给对象，然后对象自行决定怎么处理）。同一类型的所有成员（或元素）都具有一些共性，比如：每一个账户都有余额，每一位出纳员都能处理存款业务。同时，每一个成员都具有自己的专属状态，比如：每一个账户的余额都是不同的，每一位出纳员都有名字。因此，对于所有这些成员，包括每一位出纳员、每一位顾客、每一个账户，以及每一笔交易等，我们都能够在程序中用一个唯一的实体来表示。这种实体就是对象，同时每一个对象所归属的类决定了对象具有何种行为特征。</p><p>虽然我们在面向对象编程中会创建新的数据类型，但实际上所有面向对象编程语言都会使用 <code>class</code> 这个关键字。所以当你看到“类型”（type）这个词的时候，请第一时间想到“类”（class），反之亦然。**$^2$**</p><blockquote><p>**$^2$**有时候我们会将两者加以区分，将类型（type）定义为接口，而类（class）则是接口的具体实现。</p></blockquote><p>因为类描述了一系列具有相同特征（即数据元素）和行为（即功能方法）的对象，而即便是浮点数这种内置数据类型也具有一系列的行为和特征，所以类其实就是数据类型。抽象数据类型和内置数据类型的区别是，程序员可以通过定义一个新的类来解决问题，而非受限于已有的数据类型。这些已有的数据类型其设计本意是为了呈现机器内的存储单元，你可以根据实际的需求创建新的数据类型，同时扩展编程语言的能力。此外，编程系统对于新的类十分友好，比如也会为新的类提供类型检查等功能，就像对待内置数据类型一样。</p><p>面向对象编程的作用并不局限于模拟。无论你是否同意“任何程序都是对系统的一种模拟”，面向对象编程技巧都可以帮你将众多复杂的问题简化。</p><p>一旦创建了一个类，就可以用它创建任意多个对象，然后在操作这些对象时，可以把它们视为存在于问题空间的元素。实话实说，面向对象编程的一大挑战就是，如何在问题空间的元素和解决方案空间的对象之间建立一对一的关联。</p><p>那么，如何能让一个对象真正发挥其作用呢？答案是向对象发送请求，比如让它完成一次交易、在屏幕上画个图形或者打开一个开关等。对象能够接受什么请求，是由它的“接口”（interface）决定的，而对象所归属的类定义了这些接口。接下来以电灯泡为例，如下图所示。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281506403.png"></p><hr><blockquote><p>插图翻译:<br>Type Name：类型名<br>Interface：接口</p></blockquote><hr><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Light <span class="hljs-literal">lt</span> = <span class="hljs-literal">new</span> Light();<br><span class="hljs-literal">lt</span>.<span class="hljs-keyword">on</span>();<br></code></pre></td></tr></table></figure><p>图中的接口定义了你能够向这个对象发送的请求。此外，也必然存在一些代码用于响应这些请求。这些代码再加上隐藏的数据，叫作“实现”（implementation）。对于每一个请求，类都有一个方法与之对应。当你向一个对象发送特定的请求时，对应的方法就会被调用。我们通常会这样描述该过程：向对象“发送消息”（即发出请求），然后由对象决定如何处理（即运行对应的代码）。</p><p>在上面的例子中，类的名字是 <code>Light</code>，<code>Light</code> 所生成的对象的名字是 <code>lt</code>，我们能够对 <code>Light</code> 对象发出的请求是开灯（<code>on()</code>）、关灯（<code>off()</code>）、灯光变亮（<code>brighten()</code>）以及灯光变暗（<code>dim()</code>）。通过定义一个“引用”即 <code>lt</code>，以及用 <code>new</code> 关键字生成一个新对象，我们就创建了一个 <code>Light</code> 对象。此外，如果你需要向对象发送消息，可以用一个英文句号（<code>.</code>）将对象名和请求（即方法）连接起来。如果我们只是使用内置类，那么基本上关于对象编程的内容就是以上了。</p><p>此外，前面的图示遵循了<strong>统一建模语言</strong>（Unified Modeling Language, UML）的规范。在此规范下，每一个类都表示为一个方块，方块头部是类名，方块中部是你想要描述的<strong>数据成员</strong>，而<strong>方法</strong>（即该对象的函数，负责接收发送至对象的请求）则位居方块的底部。通常，UML 图中只会展示类名和公有方法，所以在上图的例子中，方块中部的内容并没有展示出来。如果你只关心类名，方块底部的内容也可以不显示。</p><h2 id="1-3-对象可以提供服务"><a href="#1-3-对象可以提供服务" class="headerlink" title="1.3　对象可以提供服务"></a>1.3　对象可以提供服务</h2><p>当你开发一个面向对象程序或理解其设计时，一个上佳的方法是将对象想象成“服务提供者”。你的程序本身也是为用户提供服务的，它通过使用其他对象提供的服务来做到这一点。所以，你的任务是创建（更好的情况是，从已有的库中找到）一些提供对应服务以解决问题的对象。</p><p>可以先从一个问题开始：“如果我能从魔术帽里变出一些对象，究竟什么对象才能解决我的问题呢？”比如，你要创建一个记账系统，于是你可能会需要一些预设的输入页面对象、负责计算的对象，以及连接各种打印机以打印支票和发票的对象。其中有些对象也许已经存在，那么其他不存在的对象应该是什么样的呢？它们应该提供哪些服务，同时它们还需要哪些其他对象的支持呢？如果继续深入的话，到了最后，你要么会说“编写这个对象的代码应该很简单”，要么会说“我确信这个对象早已存在”。这种将问题拆解为一系列对象的方法确实行之有效。</p><p>把对象视为服务提供商还有一个额外的好处，即提升了对象的聚合程度。说到这里，就需要提到软件设计领域中一个体现基础品质的术语——“高内聚性”（high cohesion），这指的是设计的组件（比如对象、方法或者对象库等）无论从哪个方面看都整合得很好。人们在设计对象时很容易犯的一个错误就是为对象添加太多的功能。例如，在一个打印支票的程序里，你一开始可能会认为需要一个既能排版又能打印的对象。然后，你发现这些功能对于一个对象而言太多了，其实你需要 3 个或者更多对象来负责这些功能。比如，一个对象包含了所有可能的打印布局，通过查找它可以知道如何打印一张支票。另一个或一组对象则作为通用打印接口，负责连接所有不同型号的打印机（但不负责记账，也许你需要购买该功能而非自行创建）。还有一个对象负责整合前两个对象提供的服务以完成打印任务。因此，每一个对象都提供了一种配套服务。在面向对象领域，出色的设计往往意味着一个对象只做好一件事，绝不贪多。这条原则不只适用于那些从外部购买的对象（比如打印接口对象），也适用于那些可复用的对象（比如支票排版对象）。</p><p>把对象视为服务提供商，不仅对你设计对象的过程有所帮助，也有利于他人阅读你的代码或复用这些对象。换句话说，如果别人因为对象提供的服务而认识到它的价值，那么他就会更加轻松地在自己的设计中使用这个对象。</p><h2 id="1-4-隐藏的实现"><a href="#1-4-隐藏的实现" class="headerlink" title="1.4　隐藏的实现"></a>1.4　隐藏的实现</h2><p>我们可以把程序员划分为两大阵营：一是“类的创建者”（负责创建新数据类型的人），二是“客户程序员” **$^3$**（在自己的应用程序里使用现有数据类型的人）。客户程序员的诉求是收集一个装满了各种类的工具箱，以便自己能够快速开发应用程序。而类的创建者则负责在创建新的类时，只暴露必要的接口给客户程序员，同时隐藏其他所有不必要的信息。为什么要这么做呢？这是因为，如果这些信息对于客户程序员而言是不可见的，那么类的创建者就可以任意修改隐藏的信息，而无须担心对其他任何人造成影响。隐藏的代码通常代表着一个对象内部脆弱的部分，如果轻易暴露给粗心或经验不足的客户程序员，就可能在顷刻之间被破坏殆尽。所以，隐藏代码的具体实现可以有效减少程序 bug。</p><blockquote><p>**$^3$**关于这个称谓，我需要感谢我的老朋友 Scott Meyers。</p></blockquote><p>所有的关系都需要被相关各方一致遵守的边界。当你创建了一个库，那么你就和使用它的客户程序员建立了一种关系。该客户程序员通过使用你的代码来构建一个应用，也可能将其用于构建成一个更大的库。如果一个类的所有成员都对所有人可见，那么客户程序员就可以恣意妄为，而且我们无法强制他遵守规定。也许你的预期是客户程序员不会直接操作任何类的成员，但是如果没有访问控制的话，你就无法实现这一点，因为所有的一切都暴露在对方面前了。</p><p>所以我们设置访问控制的首要原因就是防止客户程序员接触到他们本不该触碰的内容，即那些用于数据类型内部运转的代码，而非那些用于解决特定问题的接口部分。这种做法实际上为客户程序员提供了一种服务，因为他们很容易就可以知道哪些信息对他们来说是重要的，哪些则是无须关心的（请注意这也是一个富有哲理的决策。比如有些编程语言认为，如果程序员希望访问底层信息，就应该允许他们访问）。</p><p>设置访问控制的第二个原因则是，让类库的设计者在改变类的内部工作机制时，不用担心影响到使用该类的客户程序员。例如，你为了开发方便而创建了一个简单的类，之后你发现必须重写这个类以提升它的运行效率。如果接口部分和实现部分已经被分离和保护起来了，那么你就可以轻松地重写它。</p><p>Java 提供了 3 个显式关键字来设置这种访问控制，即 <code>public</code>、<code>private</code> 以及 <code>protected</code>。这些关键字叫作“访问修饰符”（access specifier），它们决定了谁可以使用修饰符之后的内容。<code>public</code>表示定义的内容可以被所有人访问。<code>private</code> 表示定义的内容只能被类的创建者通过该类自身的方法访问，而其他任何人都无法访问。所以，<code>private</code> 就是一道横亘在你和客户程序员之间的高墙，任何人从外部访问 <code>private</code> 数据都会得到一个编译时报错。最后，<code>protected</code> 类似于 <code>private</code>，两者的区别是继承的子类可以访问 <code>protected</code> 成员，但不可以访问 <code>private</code> 成员。至于继承的概念，本书稍后会讲述。</p><p>如果你不使用上述任意一种访问修饰符，Java 会提供一种“默认”访问权限，通常叫作“包访问”（package access），意思是一个类可以访问同一个包（库组件）里的其他类，但是如果从外部访问这些类的话，它们就像 <code>private</code> 内容一样不可访问了。</p><h2 id="1-5-复用实现"><a href="#1-5-复用实现" class="headerlink" title="1.5　复用实现"></a>1.5　复用实现</h2><p>如果一个类经过了充分测试，其代码就应该是有效且可复用的（理想情况）。不过，要实现这种复用性并不像想象的那么简单。创建可复用的对象设计需要大量的经验和洞见。然而，一旦你拥有了可复用的设计，不复用就可惜了。代码复用是我们使用面向对象编程的理由之一。</p><p>复用一个类最简单的方法是直接使用这个类所生成的对象，不过你也可以把这个对象放到另一个新类里面。新创建的类可以由任意数量和类型的对象组成，也可以任意组合这些对象，以满足想要的功能。因为利用已有的类组合成一个新的类，所以这个概念叫作“组合”（composition）。如果组合是动态的，通常叫作“聚合”（aggregation）。组合通常代表一种“有”（has-a）的关系，比如“汽车有发动机”（见下图）。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281506039.png"></p><blockquote><p>图中文字：<br>Car 汽车<br>Engine 发动机</p></blockquote><p>上图中用箭头表示了一辆汽车的组合关系。而我习惯用一种更简单的方式，即一条没有箭头的直线来表达两者之间的关联。**$^4$**</p><blockquote><p>**$^4$**这些信息对于大多数图来说已经足够了，也无须特别说明使用的是聚合还是组合。</p></blockquote><p>组合为我们提供了极大的灵活性。这些在你的类内部创建的对象通常具有 <code>private</code> 属性，所以其他使用这个类的客户程序员无法访问它们。这也意味着，就算我们修改了这些内部对象，也不会影响外部已有的代码。此外，你还可以在运行时改变这些内部对象，从而动态调整程序的行为。下一节要讲述的继承机制则不具备这种灵活性，因为编译器对使用继承创建的类设置了一些编译时的限制。</p><p>继承常被视为面向对象编程的重中之重，因此容易给新手程序员留下这样的印象：处处都应该使用继承。而实际上，这种全盘继承的做法会导致设计变得十分别扭和过于复杂。所以相比之下，在创建新类时应该首先考虑组合，因为使用组合更为简单灵活，设计也更为清晰简洁。一旦你拥有了足够的经验，何时使用继承就会变得非常清晰了。</p><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6　继承"></a>1.6　继承</h2><p>对象本身的理念是提供一种便捷的工具。对象可以根据定义的概念来封装数据和功能，从而展现给人们对应的问题空间的概念，而不是强迫程序员操作机器底层。在编程语言里，这些基础概念通过关键字 <code>class</code> 得以呈现。</p><p>然而，当我们大费周折才创建了一个类之后，如果不得不再创建一个与之前功能极为相近的类，这种滋味一定不太好受。如果我们能够复制现有的类，并且在该复制类的基础上再做一些增补的话，那就太妙了。实际上，这就是继承给我们带来的好处，除了一点：如果最初的类（叫作“基类”“超类”或“父类”）发生了变化，那么被修改的“复制”类（叫作“衍生类”“继承类”或“子类”）同样会发生变化（见下图）。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281506157.png"></p><blockquote><p>图字翻译：<br>Base 基类<br>Derived 子类</p></blockquote><p>上图中的箭头从子类指向其基类。之后你将看到，子类通常会有多个。</p><p>一个类呈现的内容不只是对象能做什么、不能做什么，它还可以关联其他的类。两个类可以拥有相同的行为和特征，但一个类可以比另一个类拥有更多的特征，以及处理更多的消息（或者用不同的方式处理消息）。继承通过基类和子类的概念来表述这种相似性，即基类拥有的所有特征和行为都可以与子类共享。也就是说，你可以通过基类呈现核心思想，从基类所派生出的众多子类则为其核心思想提供了不同的实现方式。</p><p>举个例子。一个垃圾收集器需要对垃圾进行分类。我们创建的基类是“垃圾”，具体的每一件垃圾都有各自不同的重量、价值，并且可以被切碎、溶解或者分解等。于是，更为具体的垃圾子类就出现了，并且带有额外的特征（比如，一个瓶子有颜色，一块金属有磁性等）和行为（比如你可以压扁一个铝罐）。此外，有些行为还可以产生不同的效果（比如纸质垃圾的价值取决于它的类型和状态）。通过继承，我们创建了一种“类型层次”（type hierarchy）以表述那些需要根据具体类型来解决的问题。</p><p>还有一个常见的例子是形状，你可能在计算机辅助设计系统或模拟游戏中碰过到。具体来说，基类就是“形状”（<code>Shape</code>），而每一个具体的形状都具有大小、颜色、位置等信息，并且可以被绘制（<code>draw()</code>）、清除（<code>erase()</code>）、移动（<code>move()</code>）、着色（<code>getColor</code> 或 <code>setColor</code>）等。接下来，基类 <code>Shape</code> 可以派生出特定类型的形状，比如圆形（<code>Circle</code>）、矩形（<code>Square</code>）、三角形（<code>Triangle</code>）等，每一个具体形状都可以拥有额外的行为和特征，比如某些形状可以被翻转（见下图）。有些行为背后的逻辑是不同的，比如计算不同形状的面积的方法就各不相同。所以，类型层次既体现了不同类之间的相似性，又展现了它们之间的差异。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281505322.png"></p><p>问题和解决方案都使用相同的表达方式是非常有用的，因为这样就不再需要一个中间模型将问题翻译为解决方案。在面向对象领域，类型层次是该模型的一个重要特征，它让你可以方便地从现实世界中的系统转换到代码世界的系统。不过现实情况是，有些人由于习惯了复杂的解决方案，因此对于面向对象的简约性反而会有些不适应。</p><p>继承已有的类将产生新类。这个新的子类不但会继承其基类的所有成员（虽然 <code>private</code> 成员是隐藏且不可访问的），而且更重要的是，子类也会继承基类的接口。也就是说，所有基类对象能够接收的消息，子类对象也一样能够接收。我们可以通过一个类所接收的消息来确定其类型，所以从这一点来说，子类和基类拥有相同的类型。引用之前的例子，就是“圆形是一个形状”。所以，掌握这种通过继承表现出来的类型相同的特性，是理解面向对象编程的基础方法之一。</p><p>既然基类和子类拥有相同的基础接口，就必然存在接口的具体实现。这意味着，当一个对象接收到特定的消息时，就会执行对应的代码。如果你继承了一个类并且不做任何修改的话，这个基类的方法就会原封不动地被子类所继承。也就是说，子类的对象不但和基类具有相同的类型，而且不出所料的是，它们的行为也是相同的。</p><p>有两种方法可以区分子类和基类。第一种方法非常简单直接：为子类添加新的方法（见下图）。因为这些方法并非来自基类，所以背后的逻辑可能是，基类的行为和你的预期不符，于是你添加了新的方法以满足自己的需求。有时候，继承的这种基础用法能够完美地解决你面临的问题。不过，你需要慎重考虑是否基类也需要这些新的方法（还有一个替代方案是考虑使用“组合”）。在面向对象编程领域里，这种对设计进行发现和迭代的情况非常普遍。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281505835.png"></p><p>虽然有时候继承意味着需要为子类添加新的方法[Java 尤其如此，其用于继承的关键字就是“扩展”（<code>extends</code>）]，但这不是必需的。还有一种让新类产生差异化的方法更为重要，即修改基类已有方法的行为，我们称之为“重写”该方法（见下图）。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281505375.png"></p><p>如果想要重写一个方法，你可以在子类中对其进行重新定义。也就是说，你的预期是“我想通过相同的接口调用该方法，但是我希望它可以在新的类中实现不同的效果”。</p><h3 id="is-a关系与is-like-a关系"><a href="#is-a关系与is-like-a关系" class="headerlink" title="is-a关系与is-like-a关系"></a>is-a关系与is-like-a关系</h3><p>继承机制存在一个有待商榷的问题：<strong>只应该</strong>重写基类中定义的方法吗？（并且不能添加基类中不存在的新方法）如果是，就意味着子类和基类的类型是<strong>完全</strong>相同的，因为它们的接口一模一样。结果就是，你可以直接用子类的对象代替基类的对象。这种<strong>纯替换关系</strong>通常叫作“替换原则” **$^5$**。从某种意义上说，这是一种理想的继承方式。这种情况下基类和子类之间的关系通常叫作“is-a”关系，意思是“A 是 B”，比如“圆形是一个形状”。甚至有一种测试是否是继承关系的方法是，判断你的类之间是否满足这种“is-a”关系。</p><blockquote><p>**$^5$**也叫作“里氏替换原则”（Liskov Substitution Principle），这一理论最初由 Barbara Liskov 提出。</p></blockquote><p>有时候，你会为子类的接口添加新的内容，从而扩展了原有的接口。在这种情况下，子类的对象依然可以代替基类的对象，但是这种代替方案并不完美，因为不能通过基类的接口获取子类的新方法。我将这种关系描述为“is-like-a”关系（这是我自创的词），意思是“A 像 B”，即子类在拥有基类接口的同时，也拥有一些新的接口，所以不能说两者是完全等同的。以空调为例，假设你的房间里已经安装了空调，也就是拥有能够降低温度的接口。现在发挥一下想象力，万一空调坏了，你还可以用热泵作为替代品，因为热泵既可以制冷也可以制热（见下图）。在这种情况下，热泵“就像是”空调，只不过热泵能做的事情更多而已。此外，由于设计房间的温度控制系统时，功能仅限于制冷，所以系统和新对象交互时也只有制冷的功能。虽然新对象的接口有所扩展，但现有系统也只能识别原有的接口。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281505457.png"></p><blockquote><p>图字翻译<br>Thermostat 恒温器<br>Controls 控制<br>Cooling System 制冷系统<br>Air conditioner 空调<br>Heat Pump 热泵</p></blockquote><p>观察上图你就能知道，基类“制冷系统”通用性并不高，最好可以将其改名为“温度调节系统”，使其同时包含制热功能。这样一来，之前提及的替换原则就可以派上用场了。不过话说回来，这张图也反映了真实世界中的设计方式。</p><p>当你充分理解了替换原则之后，可能会认为这种纯替换方式才是唯一正确的方式。如果你的设计能够应用纯替换原则，那就<strong>太棒了</strong>。然而实际情况是，你会发现经常需要为子类的接口添加新方法。只要稍加观察，就很容易分辨出这两种情况的应用场合。</p><h2 id="1-7-多态"><a href="#1-7-多态" class="headerlink" title="1.7　多态"></a>1.7　多态</h2><p>在编程中涉及类型层次时，我们通常会将一个对象视为其基类的一个实例，而不是对象实际的类。这种方式可以让你在编写代码时不依赖于具体的类。在形状的例子中，方法都是作用于通用的形状，而不需要关心该形状具体是圆形、矩形、三角形，还是一个没有明确定义的形状。因为所有的形状都可以被绘制、清除、移动，所以当这些方法发送消息至对象的时候，就无须关注对象是如何处理这条消息的。</p><p>当我们添加新的类时，这些代码是不受影响的，添加新的类可以扩展面向对象程序的能力，从而能够处理一些新的情况。比如，你为基类“形状”创建了一个子类“五边形”，并且不改变那些基于通用形状的方法。这种通过派生子类就可以轻松扩展程序设计的能力，是封装变化的一种基础方式。这种方式在改善设计的同时，也降低了软件维护的成本。</p><p>当你尝试用派生的子类替代通用基类（比如，把圆形当作形状，把自行车当作交通工具，把鸬鹚当作鸟等）时会发现一个问题，即调用方法来绘制这个通用的形状、驾驶这辆通用的交通工具或者让这只鸟飞翔时，编译器并不知道在编译时具体需要执行哪一段代码。那么重点来了，当消息被发送时，程序员并不<strong>关心</strong>具体执行的是哪一段代码。也就是说，当负责绘制的方法应用于圆形、矩形或者三角形时，这些对象将能够根据其类型执行对应的正确代码。</p><p>如果你并不关心具体执行的是哪一段代码，那么当你添加新的子类时，即使不对其基类的代码做任何修改，该子类实际执行的代码可能也会有所不同。但如果编译器无法得知应该具体执行哪一段代码，它会怎么做呢？比如下图中的 <code>BirdController</code> 对象，它可以和通用的 <code>Bird</code> 对象协同工作，同时它并不知道这些对象具体是什么类型的鸟。对于 <code>BirdController</code> 来说，这种方式非常方便，因为它无须额外编写代码来确定这些对象的具体类型和行为。那么问题来了，当一个 <code>Bird</code> 对象的 <code>move()</code> 方法被调用时，如果我们并不清楚其具体的类型，该如何确保最终执行的是符合预期的正确行为呢[比如 <code>Goose</code> 对象执行的是行走、飞翔或游泳，<code>Penguin</code> 对象则是移动或游泳；见下图]？</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281505516.png"></p><hr><blockquote><p>图字翻译<br>What happens when move() is called？<br>如果move()被调用，究竟会发生什么呢？</p></blockquote><hr><p>答案来自继承机制的一种重要技巧：编译器并非通过传统方式来调用方法。对于非面向对象编译器而言，其生成的函数调用会触发“前期绑定”（early binding），这是一个你可能从来都没听说过的词，因为你从未考虑过使用这种方式。前期绑定意味着编译器会生成对一个具体方法名的调用，该方法名决定了被执行代码的绝对地址。但是对于继承而言，程序直到运行时才能明确代码的地址，所以就需要引入其他可行的方案以确保消息可以顺利发送至对象。</p><p>为了解决上面提及的问题，面向对象语言使用的机制是“后期绑定”（late binding）。也就是说，当你向某个对象发送消息时，直到运行时才会确定哪一段代码会被调用。编译器会确保被调用的方法是真实存在的，并对该方法的参数和返回值进行类型检查，但是它并不知道具体执行的是哪一段代码。</p><p>为了实现后期绑定，Java 使用了一些极为特殊的代码以代替直接的函数调用，这段代码使用存储在对象中的信息来计算方法体的地址（第 9 章会详细地描述这个过程）。其结果就是，在这些特殊代码的作用下，每一个对象会有不同的表现。通俗地讲，当你向一个对象发送消息时，该对象自己会找到解决之道。</p><p>顺便一提，在某些编程语言里，你必须显式地为方法赋予这种后期绑定特性。比如，C++ 使用 <code>virtual</code> 关键字来达到此目的。在这些编程语言中，方法<strong>并不</strong>默认具备动态绑定特性。不过，Java 默认具备动态绑定特性，所以你无须借助于其他关键字或代码来实现多态。</p><p>我们再来看一下形状的例子。之前的图中展示了一些形状的类（这些类都基于统一的接口），为了更好地描述多态，我们编写一小段只关注基类而不关注具体子类的代码。由于这段代码<strong>不关注</strong>类的细节，因此非常简单易懂。此外，如果我们通过继承添加了一个新的子类“六边形”，我们的代码仍然适用于这个新的 <code>Shape</code> 类，就像适用于其他已有子类一样。因此可以说，这段程序具备<strong>扩展性</strong>。</p><p>如果你用 Java 编写一个方法（你马上就会学到具体应该怎么做）：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">void</span> doSomething(Shape <span class="hljs-built_in">shape</span>) &#123;<br>  <span class="hljs-built_in">shape</span>.erase();<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">shape</span>.<span class="hljs-title">draw</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法适用于任何 <code>Shape</code> 对象，所以它不关心进行绘制和清除的对象具体是什么类型。如果程序的其他地方调用了 <code>doSomething()</code> 方法，比如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Circle circle = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Circle()</span>;<br>Triangle triangle = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Triangle()</span>;<br>Line line = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Line()</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">circle</span>)</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">triangle</span>)</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">line</span>)</span>;<br></code></pre></td></tr></table></figure><p>不管对象具体属于哪个类，<code>doSomething()</code> 方法都可以正常运行。</p><p>简直妙不可言。我们再看这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">doSomething(circle);<br></code></pre></td></tr></table></figure><p>在这段代码里，原本我们需要传递一个 <code>Shape</code> 对象作为参数，而实际传递的参数却是一个 <code>Circle</code> 类的对象。因为 <code>Circle</code> 也是一个 <code>Shape</code>，所以 <code>doSomething()</code> 也可以接受 <code>Circle</code>。也就是说，<code>doSomething()</code> 发送给 <code>Shape</code> 对象的任何消息也可以发送给 <code>Circle</code> 对象。这是一种非常安全且逻辑清晰的做法。</p><p>这种将子类视为基类的过程叫作“向上转型”（upcasting）。这里的“转型”指的是转变对象的类型，而“向上”沿用的是继承图的常规构图，即基类位于图的顶部，数个子类则扇形分布于下方。因此，转变为基类在继承图中的路径就是一路向上，也就叫作“向上转型”。</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202110281505699.png"></p><hr><blockquote><p>图字翻译：<br>“Upcasting”：“向上转型”</p></blockquote><hr><p>面向对象程序总会包含一些向上转型的代码，因为这样就可以让我们无须关心对象具体的类是什么。再看一下 <code>doSomething()</code> 方法中包含的代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">shape</span>.erase();<br><span class="hljs-comment">// ...</span><br><span class="hljs-built_in">shape</span>.<span class="hljs-title">draw</span>();<br></code></pre></td></tr></table></figure><p>需要注意的是，代码并没有告诉我们，“如果是一个 <code>Circle</code> 请这样做，如果是一个 <code>Square</code> 请那样做，诸如此类”。如果你真的编写了一段代码用于检查所有可能出现的形状，那么这段代码必然是一团糟，并且每当你为 <code>Shape</code> 添加一个新的子类时，都必须修改这段代码。所以，上面的代码实际上做的是：“这是一个 <code>Shape</code>，我知道它可以进行绘制和清除，那就这么干吧，具体细节交给形状自己处理就好”。</p><p><code>doSomething()</code> 方法的神奇之处在于，代码运行的结果是符合预期的。如果直接通过 <code>Circle</code>、<code>Square</code> 或者 <code>Line</code> 对象调用 <code>draw()</code> 方法，运行的代码自然是不同的。如果调用 <code>draw()</code> 方法时并不知道 <code>Shape</code> 对象的具体类型，它也能正常工作，即执行其实际子类的代码。这一点十分了不起，因为当 Java 编译器编译 <code>doSomething()</code> 的代码时，它并不知道对象的类型是什么。通常来说，你可能会想当然地认为被调用的是基类 <code>Shape</code> 的 <code>erase()</code> 和 <code>draw()</code> 方法，而非具体的 <code>Circle</code>、<code>Square</code> 或者 <code>Line</code> 子类，然而实际情况是，确实是具体的子类被调用了，这就是多态。编译器和运行时系统负责处理各种细节，你需要了解的就是多态机制的存在，更重要的是要知道如何利用多态进行设计。当你向一个对象发送消息时，哪怕需要用到向上转型，该对象也能够正确地处理该消息。</p><h2 id="1-8-单根层次结构"><a href="#1-8-单根层次结构" class="headerlink" title="1.8　单根层次结构"></a>1.8　单根层次结构</h2><p>自从 C++ 语言出现以来，面向对象中是否所有的类都应该默认继承自某个基类的问题变得尤为突出。Java 则给出了肯定的答案（<strong>除了</strong> C++ 以外，实际上几乎所有动态面向对象编程语言都是如此），这个终极基类的名字是 <code>Object</code>。</p><p>这种“单根层次结构”（singly-rooted hierarchy）具备很多明显的优势。由于所有对象都具有共同的接口，因此它们都属于同一个终极基类。另一种方案（来自 C++）则无法确保所有对象都属于同一个基类。从向后兼容的角度来看，这种限制性较小的设计方式对C语言更为友好，但是从完全的面向对象编程的角度来看，你就必须自己手动构建类的层次，这样才能拥有其他面向对象编程语言默认提供的便捷性。此外，你在使用任何新的库时，都有可能遇到一些不兼容的接口。如果你希望这些接口为你所用，就必须额外花费一些精力来改造它们。所以，C++ 这种额外的“灵活性”真的物有所值吗？如果需要的话，比如你已经花费了大量心血编写C语言代码，那么答案就是肯定的。而如果你是从头开始，那么使用 Java 或者其他替代方案则会高效许多。</p><p>单根层次结构有利于实现垃圾收集器（garbage collector），这也是 Java 对比 C++ 的一个重要改进。既然所有对象都拥有类型信息，你就再也不用发愁不知道某个对象具体是什么类型了。这一特性对于系统级别的操作而言尤为重要，比如异常处理（exception handling，一种用于处理错误的语言机制）等，同时也极大地提升了编程时的灵活性。</p><h2 id="1-9-集合"><a href="#1-9-集合" class="headerlink" title="1.9　集合"></a>1.9　集合</h2><p>一般来说，你并不知道解决一个特定的问题需要用到多少个对象，也不知道这些对象会存在多久，你甚至不知道该如何保存这些对象。问题是，如果你无法在程序运行前确切地知道这些信息，那你应该申请多少内存空间呢？</p><p>在面向对象设计领域，大多数问题的解决方案看似极为简单粗暴：创建一种新类型的对象，这种对象通过保存其他对象的引用来解决这个问题。而在大多数编程语言里，你也可以用<strong>数组</strong>（array）做到这一点。</p><p>这种新对象通常叫作<strong>集合</strong>（也可以叫做“容器”，不过 Java 的库普遍使用的是“集合”），它会根据你放入其中的内容自行调整空间。也就是说，你无须关注集合里会有多少对象，直接创建集合就好了，剩下的细节交给它自己处理就可以。</p><p>幸运的是，优秀的面向对象语言都会提供一些集合作为语言的基础功能。在 C++ 里，集合是 C++ 标准库的一部分，通常叫作“标准模板库”（Standard Template Library, STL）。SmallTalk 提供了一系列完整的集合。Java 在其标准库中也提供了大量的集合。在有些语言的库中，通常会有一两个集合能够适用于所有需求。而在另外一些语言（比如 Java）的库中，不同的集合具有不同的用途。比如，有几个不同的 <code>List</code> 类（用于保存序列），几个 <code>Map</code> 类（也叫“关联数组”，用于关联对象），几个 <code>Set</code> 类（用于保存不同类型的对象），以及一些队列（queue）、树（tree）、栈（stack）等。</p><p>从程序设计的角度而言，你真正需要的是能够解决实际问题的集合。一旦某种集合能够满足你的需求，你就不再需要其他集合了。之所以需要选择集合，可能有以下两个原因。</p><ol><li>不同的集合提供了不同类型的接口和行为。比如，栈和队列的用途就与 <code>Set</code> 以及 <code>List</code> 完全不同。针对你的问题，其中的某个集合也许可以提供比另一个集合更灵活的解决方案。</li><li>不同的集合在特定操作的执行效率方面也会有差异。比如，<code>List</code> 有两种基础类型的集合：<code>ArrayList</code> 和 <code>LinkedList</code>。虽然两者可以具有相同的接口和行为，但是某些操作的执行效率却存在明显的差异。比如用 <code>ArrayList</code> 随机获取元素是一种耗费固定时间的操作，意思是不管你选择获取哪个元素，耗费的时间都是相同的。但是对于 <code>LinkedList</code> 来说，在列表中随机选择元素是一种代价很大的操作，查找列表更深处的元素也会耗费更多的时间。另外，如果需要在列表中插入元素，<code>LinkedList</code> 耗费的时间会比 <code>ArrayList</code> 更少。取决于两者底层架构的不同实现方式，其他一些操作的执行效率也各有不同。你也可以先用 <code>LinkedList</code> 编写代码，然后为了追求效率而转投 <code>ArrayList</code> 的怀抱。由于两者都是基于 <code>List</code> 接口的子类，因此只需要改动少量代码就可以切换集合。</li></ol><h3 id="参数化类型（泛型）"><a href="#参数化类型（泛型）" class="headerlink" title="参数化类型（泛型）"></a>参数化类型（泛型）</h3><p>在 Java 5 之前，Java 语言的集合所支持的是通用类型 <code>Object</code>。因为单根层次结构决定了所有对象都属于 <code>Object</code> 类型，所以一个持有 <code>Object</code> 的集合就可以持有任何对象**$^6$**，这就使得集合十分易于复用。</p><p><strong>6</strong>其实并不能保存原始类型，不过“自动装箱”（autoboxing）机制从某种程度上缓解了这个问题。相关细节将在后续章节介绍。</p><p>为了使用这样一个集合，你要将对象引用添加到集合中，然后再将其取出。但由于该集合只能持有 <code>Object</code> 类型，因此当你添加一个对象引用到集合时，该对象会向上转型为 <code>Object</code>，从而失去了其原本的特征。当你需要将其取出时，会获得一个 <code>Object</code> 类型的对象引用，这就不是当初的类型了。那么问题来了，当初被放入集合中的对象如何才能转换回原来的类型呢？</p><p>这里需要再一次用到转型，只不过这次不是向上转为更通用的类型，而是向下转为更具体的类型，这种转型叫作“向下转型”（downcasting）。当使用向上转型时，我们知道 <code>Circle</code> 对象属于 <code>Shape</code> 类型，所以这种向上转型是安全的。但是反过来，我们并不知道一个 <code>Object</code> 对象实际上是 <code>Circle</code> 还是 <code>Shape</code> 类型，所以除非你明确知道对象的具体类型是什么，否则向下转型是不安全的。</p><p>不过，也不是说向下转型一定是危险的。如果向下转型失败，你会得到一个运行时的错误提示，这叫作“异常”（exception），后面你很快就会看到相关的介绍。不过话说回来，当你从集合中获取对象引用时，需要通过一些方法明确对象的类型，这样的话才能正确的向下转型。</p><p>当一段程序在运行时，向下转型和与其关联的运行时检查都会耗费额外的时间，同时程序员也需要关注这种向下转型。为什么我们创建的集合就不能明确地知道所包含的对象类型呢？如果知道的话，我们就不再需要向下转型，也避免了在此期间可能出现的报错。这个问题的解决方案就是“参数化类型”（parameterized type）机制。一个被参数化的类型是一种特殊的类，可以让编译器自动适配特定的类型。比如，对于参数化的集合而言，编译器可以将集合定义为只接受放入 <code>Shape</code> 的对象，因此从集合也只能取出 <code>Shape</code> 对象。</p><p>Java 5 新增的主要特性之一是支持参数化类型，也叫作“泛型”（generics）。你可以通过在一对尖括号中间加上类名来定义泛型，比如，你可以这样创建一个放置 <code>Shape</code> 对象的 <code>ArrayList</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ArrayList<span class="hljs-tag">&lt;<span class="hljs-name">Shape</span>&gt;</span> shapes = new ArrayList<span class="hljs-tag">&lt;&gt;</span>();<br></code></pre></td></tr></table></figure><p>泛型带来的好处促使许多标准库组件都进行了相应的调整。此外，你在本书所列举的许多代码示例中都会看到泛型的作用。</p><h2 id="1-10-对象的创建和生命周期"><a href="#1-10-对象的创建和生命周期" class="headerlink" title="1.10　对象的创建和生命周期"></a>1.10　对象的创建和生命周期</h2><p>和对象打交道时有一个至关重要的问题，那就是它们的创建和销毁方式。每个对象的创建都要消耗一些资源，尤其是内存资源。当我们不再需要一个对象时，就要及时清理它，这样它占用的资源才能被释放并重复使用。在一些环境简单的场景下，清理对象似乎不是一个难题：你创建了一个对象，根据自己的需要使用，不再使用的时候就将其销毁。然而不幸的是，我们经常会遇到更为复杂的情况。</p><p>假设你需要为某个机场设计一个航空管制系统（你也可以用同样的方式管理仓库中的箱子、录像带租赁系统，甚至还有装宠物的笼子）。刚开始的时候，一切都是如此简单：新建一个用于保存飞机对象的集合，然后每当有飞机需要进入航空管制区域的时候，就新建一个飞机对象并将其放入集合中。而每当有飞机离开航空管制区域时，就清理对应的飞机对象。</p><p>再做一个假设：还有其他系统也会记录飞机的数据，而这些数据不需要像主控制程序那样及时更新，比如只会对离开机场的小型飞机做记录。于是，你需要创建一个新的集合用于保存小飞机对象，并且每当新建的飞机对象是小型飞机时，需要将其放入这个新的集合中。当有后台进程处于空闲状态时，就会操作这些对象。</p><p>现在问题变得更加棘手了，你怎么判断什么时候需要清理对象？当你不再需要一个对象时，系统的其他部分也许还在使用该对象。更糟糕的是，在许多其他情况下也会遇到同样的问题。而对于诸如 C++ 这样需要显式删除对象的编程语言来说，这绝对是一个相当让人头疼的问题。</p><p>对象的数据保存在哪里，系统又是如何控制对象的生命周期的呢？C++ 语言的宗旨是效率优先，所以它交给程序员来选择。如果要最大化运行时效率，可以通过栈区（也叫作“自动变量”或“局部变量”）保存对象，或者将对象保存在静态存储区里，这样在编写程序时就可以明确地知道对象的内存分配和生命周期。这种做法会优先考虑分配和释放内存的速度，在有些情况下是极为有利的。但是，代价就是牺牲了灵活性，因为你必须在编写代码时就明确对象的数量、生命周期以及类型。如果你希望解决一个更为普遍的问题，比如计算机辅助设计、仓库管理或者航空管制等，这种做法的限制性就太大了。</p><p>还有一种方案是在内存池里动态创建对象，这个内存池叫作“堆”（heap）。如果使用这个方案，直到运行时你才能知道需要多少对象，以及它们的生命周期和确切的类型是什么。也就是说，这些信息要等到程序运行时才能确定。如果你需要创建一个新对象，可以直接通过堆来创建。因为堆是在运行时动态管理内存的，所以堆分配内存所花费的时间通常会比栈多一些（不过也不一定）。栈通常利用汇编指令向下或向上移动栈指针（stack pointer）来管理内存，而堆何时分配内存则取决于内存机制的实现方式。</p><p>动态创建对象的方案基于一个普遍接受的逻辑假设，即对象往往是复杂的。所以在创建对象时，查找和释放内存空间所带来的额外开销不会造成严重的影响。此外，更大的灵活性才是解决常规编程问题的关键。</p><p>Java 只允许动态分配内存<strong>7</strong>。每当你创建一个对象时，都需要使用 <code>new</code> 操作符创建一个对象的动态实例。</p><p><strong>7</strong>你之后将学习到的原始类型（primitive type）是一个特例。</p><p>然而还有另一个问题——对象的生命周期。对于那些允许在栈上创建对象的编程语言，编译器会判断对象将会存在多久以及负责自动销毁该对象。但是如果你是在堆上创建对象，编译器就无从得知对象的生命周期了。对于像 C++ 这样的语言来说，你必须在编码时就明确何时销毁对象，否则万一你的代码出了差错，就会造成内存泄漏。而 Java 语言的底层支持<strong>垃圾收集器</strong>（garbage collector）机制，它会自动找到无用的对象并将其销毁。垃圾收集器带来了很大的便利性，因为它显著减少了你必须关注的问题数量以及需要编写的代码。因此，垃圾收集器提供了一种更高级的保障以防止潜在的内存泄漏，而正是内存泄漏导致了许多 C++ 项目的失败。</p><p>Java 设计垃圾收集器的意图就是处理内存释放的相关问题（虽然不包括清理对象所涉及的其他内容）。垃圾收集器“知道”一个对象何时不再有用，并且会自动释放该对象占用的内存。再加上所有对象都继承自顶层基类 <code>Object</code>，以及只能在堆上创建对象等特点，使得 Java 编程比 C++ 简单了不少。一言以蔽之，需要你介入的决策和阻碍都大大减少了。</p><h2 id="1-11-异常处理"><a href="#1-11-异常处理" class="headerlink" title="1.11　异常处理"></a>1.11　异常处理</h2><p>自从有编程语言起，错误处理就是一项极为困难的工作。设计一个优秀的错误处理系统是如此困难，以至于许多编程语言忽视了这个问题，而将问题抛给库的设计者。这些设计者只能采取一些折中措施来填补漏洞，这些举措虽然在有很多场景中都有效，但很容易通过忽略提示的错误而轻易绕过。大多数错误处理方案存在的一个显著的问题是，这些方案并非编程语言强制要求的，而是依赖于程序员同意并遵守相关约定。如果遇到警惕性不高的程序员（通常都是因为需要赶进度而放松了警惕），这些方案就形同虚设了。</p><p><strong>异常处理</strong>则是将编程语言甚至是操作系统和错误处理机制直接捆绑在一起。异常是从错误发生之处“抛出”的对象，而根据错误类型，它可以被对应的异常处理程序所“捕获”。而每当代码出现错误时，似乎异常处理机制会使用一条特殊的、并行的执行路径来处理这些错误。这是因为它确实采取了一条单独的运行路径，所以不影响正常执行的代码。同时这一点也降低了你编写代码的成本，因为你不用经常反复检查各种错误了。此外，抛出的异常也不同于方法返回的错误值或者方法设置的错误标识，因为这两者是可以被忽略的，但是异常不允许被忽略，所以这就确保了异常一定会在必要的时候被处理。最后，异常为我们提供了一种可以让程序从糟糕的情况中恢复过来的方法。即便发生了意外，我们也还有机会修正问题以及让程序重新恢复运行，而不是只能结束程序了事，而这一点无疑会增强许多程序的稳健性。</p><p>Java 的异常处理机制在众多编程语言之中几乎可以说是鹤立鸡群，这是因为 Java 从一开始就内置了异常处理，并且强制你必须使用它，这一点没有任何商量的余地，同时这也是Java唯一允许的报错方式。如果你的代码没有正确地处理各种异常，就会得到一条编译时的报错消息。这种有保障的一致性使得错误处理的工作简单了许多。</p><p>值得我们留意的是，虽然面向对象语言里的异常一般用对象的形式来呈现，异常处理却并不是面向对象语言的特性。其实，异常处理远在面向对象语言诞生之前就已经存在了。</p><h2 id="1-12-总结"><a href="#1-12-总结" class="headerlink" title="1.12　总结"></a>1.12　总结</h2><p>一段过程式程序（procedural program）包含了数据定义和函数调用。如果你想要搞清楚这种程序究竟做了什么，就必须仔细研究，比如查看它的函数调用以及底层代码等，以便在你的脑海中勾勒出一幅完整的蓝图。而这就解释了在设计过程式程序时，为什么还需要中间表示（intermediate representation, IR）。实话实说，过程式程序的理解成本确实很高，因其设计的表达方式更多是面向计算机，而不是你要解决的问题。</p><p>因为面向对象编程在过程式编程语言的基础上增加了许多新特性，所以你可能会想当然地认为同等效果的 Java 程序会远比过程式程序复杂。然而你会惊喜地发现，编写良好的 Java 程序通常比过程式程序更简单，也更易于理解。这是因为在 Java 中，对象的定义所呈现的是问题空间（而非计算机式的呈现）的概念，而发送至对象的消息则代表问题空间的具体活动。面向对象编程的一个令人愉悦之处在于，那些设计良好的程序，其代码总是易于阅读的。另外，因为许多问题都能够通过复用已有的库来解决，所以通常来说代码行数也不会太多。</p><p>面向对象编程和 Java 不一定适合所有人。有一点非常重要，那就是你必须仔细评估自己的需求，然后再判断 Java 是不是满足这些需求的最佳方案，也许使用其他编程语言是更好的选择（说不定就是你现在使用的编程语言）。如果在可预见的将来，你的需求非常专业并且具有一些 Java 无法满足的特殊条件，那么你就有必要研究一下其他可代替的编程语言（我尤其推荐 Python）。这样一来，就算你依然选择 Java 作为你的编程语言，至少你清楚还有哪些可选项，以及为什么选择它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第-1-章-什么是对象&quot;&gt;&lt;a href=&quot;#第-1-章-什么是对象&quot; class=&quot;headerlink&quot; title=&quot;第 1 章　什么是对象&quot;&gt;&lt;/a&gt;第 1 章　什么是对象&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“我们并未意识到惯用语言结构的强大之处。甚</summary>
      
    
    
    
    <category term="Books" scheme="https://www.ckxgzxa.top/categories/Books/"/>
    
    
    <category term="OnJava8" scheme="https://www.ckxgzxa.top/tags/OnJava8/"/>
    
  </entry>
  
  <entry>
    <title>本书导读</title>
    <link href="https://www.ckxgzxa.top/2-Introduction.html"/>
    <id>https://www.ckxgzxa.top/2-Introduction.html</id>
    <published>2021-10-28T06:53:31.000Z</published>
    <updated>2021-10-28T06:58:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本书导读"><a href="#本书导读" class="headerlink" title="本书导读"></a>本书导读</h1><blockquote><p>“我的语言之局限，即我的世界之局限。”</p><p>​                                                   ——Ludwig Wittgenstein（1889—1951）</p></blockquote><p>这句话不仅适用于我们日常读写的语言，也适用于编程语言。很微妙的一件事是，一门语言会悄然无息地引导你进入某种思维模式，同时远离其他思维模式。Java尤其如此。</p><p>Java是一门派生语言。当时的情况是，早期的语言设计师不想用C++来开发项目，于是创建了一门和C++极为相似的新编程语言，不过也做出了一些改进（遗憾的是，他们的项目最终没有上线）。这种新编程语言最主要的改动是加入了<strong>虚拟机</strong>和<strong>垃圾收集</strong>机制，本书后续章节会对这两点进行详细介绍。此外，Java还在其他方面推动着行业的持续发展，比如现在大多数语言应该支持文档标记语法，以及生成HTML文档的工具。</p><p>Java最主要的概念之一来自SmallTalk，这门语言强调“对象”（详细内容请见第1章）是编程的基本单位，所以任何一个东西都必须是对象。经历过长时间的洗礼之后，这个概念被证明是有些激进的，有些人甚至断定对象的概念是彻头彻尾的失败，应该果断丢弃。我个人认为，把所有内容都封装为对象不仅是一种负担，而且还会将许多程序设计推向错误的方向。然而不可否认的是，在一些情况下对象依然十分有用。所以，将一切都封装为对象（尤其是深入到最底层的时候）是一种设计失误，而完全抛弃对象同样太过极端。</p><p>Java还有一些决策也没有达成预期目标。关于这一点，本书中会陆续加以说明，以确保你不但可以理解这些语言特性，还能明白为什么你会觉得如鲠在喉。我并不是要将Java盖棺定论为一门优秀或拙劣的语言，我想表达的是，当了解了一门语言的不足之处和局限性之后，你将能够做到以下两点。</p><ol><li>当遇到某个语言特性不可用时，不会被卡住以致无法继续。</li><li>因为了解局限性所在，所以可以更好地进行程序设计和编程。</li></ol><p>编程是一门管理复杂性的艺术，而问题的复杂程度取决于机器的复杂程度。由于这种复杂性的存在，导致了大多数编程项目的失败。</p><p>许多编程语言在设计时充分考虑了复杂性的问题，然而有时候，其他问题才是更为本质的问题。几乎不可避免的是，那些“其他问题”才是让使用该语言的程序员最终碰壁的原因。例如，C++语言不得不向后兼容C语言（这是为了让C语言程序员更容易上手），同时还要保证运行效率。不可否认的是，这两者都是非常实用的设计目标，并且成了C++语言获得成功的功臣。但是随之也带来了大量额外的复杂性，使得许多项目因此而失败。当然，你可以责备程序员技艺不精或者管理方式有问题，但是如果一门语言可以协助你捕获程序中的错误，那么何乐而不为呢？</p><p>Visual Basic（VB）语言依赖于BASIC语言，而BASIC语言本身并不是一种扩展性良好的语言。这导致VB在扩展时经常出现各种非常难以维护的语法。Perl语言能够向后兼容<code>awk</code>、<code>sed</code>、<code>grep</code>以及其他UNIX工具，然而这些旧时代的工具本身就是需要被替换和更新的。结果就是，Perl程序里面充斥着大量的“只读代码”（意思是你自己都搞不懂自己写的代码是什么意思）。不过话说回来，C++、VB、Perl以及其他一些语言（比如SmallTalk）都提供了一些能够处理复杂性的设计方案，并且从解决特定问题的角度来看，它们做得还相当不错。</p><p>信息革命让我们所有人可以更为便捷地交流，不管是一对一、群组对群组还是星球对星球。我听说下一次革命将促生一个由足够多的人和连接组合而成的全球化的大脑。Java会不会成为这种革命所需的工具之一呢？一切皆有可能。</p><h2 id="阅读前提"><a href="#阅读前提" class="headerlink" title="阅读前提"></a>阅读前提</h2><p>本书假设你有一定的编程基础，即你应该了解以下内容。</p><ul><li>程序是一些计算机语句的集合。</li><li>子程序、函数、宏的概念。</li><li>了解<code>if</code>等控制语句，以及<code>while</code>等循环结构的用法。</li><li>其他相关知识点。</li></ul><p>也许你已经通过学校、图书或者互联网掌握了以上知识点。只要你能够理解编程的基本概念，就可以顺畅地阅读本书了。</p><p>如果你对以上基本概念不甚了解的话，可以通过On Java 8网站上的免费多媒体课程“Thinking in C”获取学习Java语言所需的基础知识。本书会重点介绍面向对象编程（Object-Oriented Programming, OOP）的概念，以及Java语言的基本控制机制。</p><p>我偶尔会提及一些C和C++的语言特性（有时也会提及其他语言），但是并不代表你必须熟悉C/C++语言，其目的是帮助大家理解和对比Java与两者的异同，毕竟Java是在它们的基础上发展而来的。我会尽量用简单的方式来引用这些概念，同时也会对非C/C++程序员所不熟悉的概念进行讲解。</p><h2 id="JDK-HTML文档"><a href="#JDK-HTML文档" class="headerlink" title="JDK HTML文档"></a>JDK HTML文档</h2><p>Oracle公司为Java开发工具集（Java Development Kit, JDK）提供了电子文档，你用Web浏览器就可以查看。除非必要，本书不会重复文档的内容，因为你用浏览器查看一个类的详细说明要比在本书中查找快得多（此外，在线文档的内容还是即时更新的）。所以在本书中，通常我只会提及需要参考“JDK文档”。除非需要补充文档内容才能让你理解某个特定的示例，否则一般情况下我不会提供额外的说明。</p><h2 id="“Thinking-in-C”课程"><a href="#“Thinking-in-C”课程" class="headerlink" title="“Thinking in C”课程"></a>“Thinking in C”课程</h2><p>“Thinking in C”课程介绍了C语言的一些基础知识，如语法、运算符、函数等，而这些内容同样也是Java语言的基础知识。此外，该课程还提供了一些编程的入门级知识，这些知识点适用于编程经验甚至比本书读者还要少的学生。</p><p>我委托Chuck Allison开发了“Thinking in C”这门独立的课程，之后将其收录在光碟里，再后来它变成了免费下载的形式。通过在网络上免费提供该课程，我可以确保所有人都具备阅读本书的知识基础。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>本书所有源代码都属于受版权保护的自由软件，并且都可以在GitHub网站上获取：<a href="https://github.com/BruceEckel/Onjava8-examples%E3%80%82%E4%B8%BA%E4%BA%86%E7%A1%AE%E4%BF%9D%E4%BD%A0%E4%BD%BF%E7%94%A8%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E6%98%AF%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E8%AF%B7%E8%AE%A4%E5%87%86%E8%BF%99%E4%B8%AA%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E3%80%82%E8%BF%99%E4%BA%9B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E5%9C%A8%E6%A0%A1%E5%AD%A6%E4%B9%A0%E6%88%96%E8%80%85%E6%95%99%E8%82%B2%E7%94%A8%E9%80%94%E3%80%82">https://github.com/BruceEckel/Onjava8-examples。为了确保你使用的源代码是最新版本，请认准这个官方下载地址。这些源代码可以用于在校学习或者教育用途。</a></p><p>源代码的版权保护主要是为了确保这些源代码可以被正确地引用，以及防止在未经授权的情况下被随意发布。（只要是本书中引用了版权信息的源代码，在大多数情况下，使用是没有问题的。）</p><p>在所有源代码文件里，你都会发现类似以下的版权信息说明：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>P14-P16代码<br></code></pre></td></tr></table></figure><p>在编程过程中，只要你在每一个源代码文件里都保留了上面提及的版权信息，这些源代码就可以用于在校学习或者教育用途（包括幻灯片演示等文件）。</p><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>在本书中，各种标识符（关键字、方法名、变量名、类名等）会以等宽字体显示。</p><p>本书示例会采用一种特定的编程风格。在尽可能满足本书格式要求的前提下，这种编程风格和Oracle网站上提供的编程风格几乎完全一致，同时能够兼容大多数Java开发环境。鉴于编程风格这个话题足以引发长达数小时的激烈争论，我需要在此澄清的是，我并没有试图通过我的代码示例来指导何为正确的编程风格，我使用的编程风格完全只是根据自己的意愿而为之。Java是一种形态自由的编程语言，所以你可以按照自己的喜好选择编程风格。此外，在使用诸如IntelliJ IDEA、Eclipse或者NetBeans等IDE（Integrated Development Environment，集成开发环境）时，你可以设置自己熟悉的编程风格，以此解决编程风格不一致的问题。</p><p>本书的源代码都通过了自动化测试，最新版本的Java应该可以正常运行这些源代码（除了被特别标识的内容以外）。</p><p>本书的内容聚焦于Java 8，并且所有源代码都在Java 8环境下测试通过。如果你一心想要学习本书未曾提及的Java早期版本的内容，也可以在On Java 8网站下载《Java编程思想》（第4版）。</p><h2 id="bug反馈"><a href="#bug反馈" class="headerlink" title="bug反馈"></a>bug反馈</h2><p>就算作者本人用尽各种办法来检测编程错误，依然可能会有漏网之鱼，通常新的读者可能会有所发现。在阅读本书的过程中，只要你确信自己发现了某处错误，不管是文字还是代码示例问题，请第一时间将该错误以及你修正后的内容提交到：<a href="https://github.com/BruceEckel/Onjava8-examples/issues%E3%80%82%E6%84%9F%E8%B0%A2%E4%BD%A0%E7%9A%84%E5%B8%AE%E5%8A%A9%EF%BC%81">https://github.com/BruceEckel/Onjava8-examples/issues。感谢你的帮助！</a></p><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>如果你希望获取相关新闻和通知，可以在On Java 8网站上订阅一个只包含少量内容的邮件列表。我不会发送任何广告，并且我会尽我所能保持其内容的正确性。</p><h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><p>对于Java而言，图形用户界面（GUI）和桌面编程代表着一段动荡甚至有些悲惨的历史。</p><p>在Java 1.0时代，GUI库最初的设计目的是让程序员可以创建一种在所有平台上看起来都光鲜亮丽的GUI。遗憾的是，这个目标并没有达成。取而代之的是，Java 1.0通过<strong>抽象窗口工具集</strong>（Abstract Windowing Toolkit, AWT）创建了一种在所有平台上都表现平平的GUI。不仅如此，这套GUI还有一些局限性。比如，你最多只能使用4种字体，而且你不能调用操作系统中任何成熟的GUI组件。此外，Java 1.0 AWT的编程模式最令人尴尬的是，它甚至不支持面向对象编程。我的研讨班中的一名学生（他曾经在Sun公司经历过最初创造Java语言的那段时光）曾经对此情况做出过解释：最初的AWT是在一个月之内构想、设计和实现出来的。这样的产能效率纵然让人称奇，却也是体现框架设计重要性的一份反面教材。</p><p>随后发展到Java 1.1 AWT事件模型的时期，情况终于有所改善。这次的AWT使用一种更为清晰且面向对象的编程方式，同时添加了一种名为JavaBeans的组件编程模式（现在已经不复存在），其目的是可以轻松创建可视化的编程环境。到了Java 2（也叫Java 1.2）时代，Java不再继续改进Java 1.0 AWT，而是用<strong>Java基础类</strong>（Java Foundation Classes, JFC）重写了一切，其中GUI部分称为“Swing”。通过JavaBeans及其丰富的代码库，用户可以创建出效果不错的GUI。只不过这一次，软件产业的“三个版本定律”（只有改良到第三个版本的才是好产品）似乎在编程语言领域也适用了。</p><p>Swing看起来似乎是Java语言GUI库的最终解决方案，然而这个假设最终也不攻自破了。随后，Sun公司又做出了最后一次努力，推出了JavaFX。当Oracle公司收购Sun公司后，Java的设计者们将这个野心勃勃的项目（其中甚至还包含了一种脚本语言）调整为Java的一个库，现在它似乎是唯一一个得以继续开发的UI工具包（详细请参考维基百科关于JavaFX的文章）。然而即便是这种程度的开发力度也难以为继，于是JavaFX和它的几个前辈一样，最终也难逃覆灭的命运。</p><p>现如今，Swing依然是Java的一部分（不过只是维护而没有再开发新内容）。由于Java现在已经是开源项目，所以也可以轻松获取到Swing。此外，Swing和JavaFX之间有一些有限的交互，其原本的目的是将Swing的功能移植到JavaFX中。</p><p>归根结底，Java在桌面领域从未真正强大过，甚至从未触及设计师的雄心壮志。至于其他，比如JavaBeans，也总是雷声大雨点小（不幸的是，有不少作者花费了大量心血来编写关于Swing的书，甚至是仅仅关于JavaBeans的书），始终没有获得大众的青睐。结果就是，Java在桌面领域的大多数应用场景是IDE以及一些企业内部的应用程序。虽然人们确实也会用Java开发用户界面，但是你要清楚地意识到这只是Java语言的一个小众需求。</p><p>如果你一定要学习Swing，可以在On Java 8网站上免费下载《Java编程思想》（第4版）并学习相关内容，或者参考其他专门讲解Swing的图书。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本书导读&quot;&gt;&lt;a href=&quot;#本书导读&quot; class=&quot;headerlink&quot; title=&quot;本书导读&quot;&gt;&lt;/a&gt;本书导读&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“我的语言之局限，即我的世界之局限。”&lt;/p&gt;
&lt;p&gt;​                     </summary>
      
    
    
    
    <category term="Books" scheme="https://www.ckxgzxa.top/categories/Books/"/>
    
    
    <category term="OnJava8" scheme="https://www.ckxgzxa.top/tags/OnJava8/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云新号注册教程</title>
    <link href="https://www.ckxgzxa.top/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%96%B0%E5%8F%B7%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B.html"/>
    <id>https://www.ckxgzxa.top/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%96%B0%E5%8F%B7%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B.html</id>
    <published>2021-10-27T11:30:06.000Z</published>
    <updated>2021-10-27T12:27:08.233Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/TencentCloudNewAccount.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/TencentCloudNewAccount.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络习题第一章(网络体系结构)</title>
    <link href="https://www.ckxgzxa.top/ComputerNetworkingProblem1.html"/>
    <id>https://www.ckxgzxa.top/ComputerNetworkingProblem1.html</id>
    <published>2021-10-27T06:28:56.000Z</published>
    <updated>2021-12-05T05:42:21.975Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假定有一个通信协议，每个分组都引入100字节的开销用于头和成帧。现在使用这个协议发送 $10^6$ 字节的数据，然而在传送的过程中有一个字节被破坏了，因而包含该字节的那个分组被丢弃。试对于1000字节和20000字节的分组的有效数据大小分别计算“开销+丢失”字节的总数目。分组数据大小的最佳值是多少?</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/IMG_20211027_144348.png"></p></li><li><p>考虑一个最大距离为2km的局域网，当带宽等于多大时 传播延时（传播速度为$2\times10^8m/s$ )等于100B分组的发送延时?对于512B分组结果又当如何?</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/0571ddc1c8ecc9360933b1968027a05.jpg"></p></li><li><p>在两台计算机之间传输一个文件有两种可行的确认策略。第一种策略把文件截成分组，接收方逐个地确认分组，但就整体而言，文件没有得到确认。第二种策略不确认单个分组，但当文件全部收到后，对整个文件予以确认。请讨论这两种方式的优缺点。</p><blockquote><table><thead><tr><th><strong>方案1</strong></th><th>出错后不必从头开始，只传出错的分组</th><th>速度慢,需要分割和拼接</th></tr></thead><tbody><tr><td><strong>方案2</strong></td><td><strong>速度较快，不用分割和拼接分组</strong></td><td><strong>出错后整个文件重传</strong></td></tr></tbody></table><p>如果网络容易丢失分组，选方案一，此时仅重传丢失的分组。<br>如果网络高度可靠，那么在不发生差错的情况下，选方案二.从而减少了确认次数，节省了带宽。不过,即使只有单个分组丢失也要重传整个文件,因此更适用于小文件。</p></blockquote></li><li><p>试在下列条件下比较电路交换和分组交换。要传送的报文共x比特。从源点到终点共经过k段链路，每段链路的传播时延为d秒，数据传输速率为b比特每秒。在电路交换时电路的建立时间为s秒。在分组交换时分组长度为p比特，且各结点的排队等待时间可忽略不计。问在怎样的条件下，分组交换的时延比电路交换的要小?(提示:画一下草图观察k段链路共有几个结点。)</p><blockquote><p>电路交换时延:  $s + \frac{x}{b} + k \cdot d$</p><p>分组交换时延: $\frac{p}{b}\cdot k + \frac{p}{b} (\frac{x}{p} - 1) + k \cdot d$</p><p>由 $$ \frac{p}{b}\cdot k + \frac{p}{b} (\frac{x}{p} - 1) + k \cdot d &lt; s + \frac{x}{b} + k \cdot d $$可得:<br>$$<br>k &lt; \frac {\frac{p}{b}+s}{\frac{p}{b}+d-1}<br>$$</p></blockquote></li><li><p>在上题的分组交换网中，设报文长度和分组长度分别为x和( p+h )比特，其中p为分组的数据部分的长度，而h为每个分组所带的控制信息固定长度，与p的大小无关。通信的两端共经过k段链路。链路的数据传输速率为b比特每秒，但传播时延、结点的排队时延和处理时延均可忽略不计。若打算使总的时延为最小，问分组的数据部分长度p应取为多大?</p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/f165ba22bc8debf251158a105358b4d.jpg"></p></li><li><p>在下列情况下，计算传送1000KB文件所需要的总时间，即从开始传送时起直到文件的最后一位到达目的地为止的时间。假定往返时间RTT为100ms，一个分组是1KB(即1024B)的数据，在开始传送整个文件数据之前进行的起始握手过程需要2RTT的时间。<br>1）带宽是1.5Mb/s，数据分组可连续发送。<br>2）带宽是1.5Mb/s，但在发送完每一个数据分组后，必须等待一个RTT （等待来自接收方的确认）才能发送下一个数据分组。<br>3 )假设带宽是无限大的值，即我们取发送时间为0，并且在等待每个RTT后可以发送多达20个分组。</p></li></ol><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/a25cf59fb4897e1480ab29929476142.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;假定有一个通信协议，每个分组都引入100字节的开销用于头和成帧。现在使用这个协议发送 $10^6$ 字节的数据，然而在传送的过程中有一个字节被破坏了，因而包含该字节的那个分组被丢弃。试对于1000字节和20000字节的分组的有效数据大小分别计算“开销+丢失</summary>
      
    
    
    
    <category term="习题" scheme="https://www.ckxgzxa.top/categories/%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="计算机网络" scheme="https://www.ckxgzxa.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>传输延迟和传播延迟的区别</title>
    <link href="https://www.ckxgzxa.top/TransmissionDelayandProgationDelay.html"/>
    <id>https://www.ckxgzxa.top/TransmissionDelayandProgationDelay.html</id>
    <published>2021-10-26T15:19:23.000Z</published>
    <updated>2021-12-05T05:42:21.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输延迟和传播延迟的区别"><a href="#传输延迟和传播延迟的区别" class="headerlink" title="传输延迟和传播延迟的区别"></a>传输延迟和传播延迟的区别</h1><blockquote><p>类比: 车队</p></blockquote><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/20211026232700.png"></p><ul><li>车速为 100 km/hr ~ 信号传播速度</li><li>收费站放行一台车用时 12 秒 ~ 比特传输时间</li><li>车 ~ 比特；车队 ~ 分组</li><li>车队通过收费站时间 ~ <strong>传输延迟</strong> （120秒）</li><li>每台车从第一个收费站跑到第二个收费站用时 ~ <strong>传播延迟</strong> （1小时）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传输延迟和传播延迟的区别&quot;&gt;&lt;a href=&quot;#传输延迟和传播延迟的区别&quot; class=&quot;headerlink&quot; title=&quot;传输延迟和传播延迟的区别&quot;&gt;&lt;/a&gt;传输延迟和传播延迟的区别&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;类比: 车队&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="学习笔记" scheme="https://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="https://www.ckxgzxa.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>中秋之行_下午_故宫博物院</title>
    <link href="https://www.ckxgzxa.top/2021MidAutumnFestival2.html"/>
    <id>https://www.ckxgzxa.top/2021MidAutumnFestival2.html</id>
    <published>2021-09-22T08:51:32.000Z</published>
    <updated>2021-12-05T05:42:21.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中秋之行-下午-故宫博物院"><a href="#中秋之行-下午-故宫博物院" class="headerlink" title="中秋之行_下午_故宫博物院"></a>中秋之行_下午_故宫博物院</h1><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zAqLaebNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="西华门"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zAqLaefNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="西华门"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9WF6evNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="午门"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxp2lafHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="午门"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_je6fXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRUJr6frNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="太和殿"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSq9R6f7NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="太和殿"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSq9R6gLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://static.dingtalk.com/media/lADPDhmOw-dNZ4nNA8DNBQA_1280_960.jpg_720x720q90g.jpg?bizType=im" alt="太和殿"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zAqmZ5HNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTDaZ5zNA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9Wg56bNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQowT563NA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="中和殿"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTDaZ73NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="保和殿"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zAqmZ8zNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="皇建有极"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_j559nNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQow41HjNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="乾清门"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9XF1H3NA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="乾清宫"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zArLVIbNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="正大光明"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQow41R_NA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_ke1SPNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="乾清宫介绍"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRUKr1SXNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="无为"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSq-R1SfNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="无为"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRUKr1SnNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="坤宁宫"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRUKr1SzNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="体和殿介绍"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zArcE-_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="翔凤为林"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9XWk_LNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSq-ik_jNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="钟表馆"><a href="#钟表馆" class="headerlink" title="钟表馆"></a>钟表馆</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxqIq6jDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="钟表馆"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9XWk__NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金奖杯式寒暑三面表_19世纪末_法国"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9XWlAPNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜轮船模型表_19世纪末_法国"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-eDFAfNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜灯塔式座钟_19世纪_法国"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zArcFA7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金珐琅座钟_19世纪末_法国慕让制造"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-eDFBLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜热气球式钟_19世纪末_法国"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zArcFBfNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9X3V3vNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9X3V4LNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-ej13bNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxp4W14nNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金饰蓝瓷瓶式钟_19世纪末_法国巴黎"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_lQV4_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金珐琅围屏式钟_19世纪末_法国马蒂公司制造)"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zAr815rNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金石座水法穹式钟_19世纪末_法国"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-ej16PNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鸟音山石钟_19世纪_瑞士"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoxqV6nNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSq_DV7HNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金转花自鸣过枝雀笼钟"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zAsreLjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTFfeL3NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金园于莳花钟"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoyY-NbNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTFfeOLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金人指时刻分钟"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-fSeO3NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://static.dingtalk.com/media/lADPDiQ3P9Yl-PvNBQDNA8A_960_1280.jpg_720x720q90g.jpg?bizType=im"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyVS4eQXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRUML-RHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-f-llTNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTGLlljNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9ZSFl7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-f-lmLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_mrFoDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金七政仪表"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_mrFmzNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9ZSFnTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金象拉战车钟"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxp5xlo_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_mxVEHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-u36hXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9oLahjNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金写字人钟_1780年_英国伦敦威廉森制造"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyVid6hnNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="铜镀金写字人钟"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTVE6hrNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyVid6hvNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="彩漆描金自开门群仙祝寿楼阁式钟"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxqIq6hzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyVid6h3NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSrPXah7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSrPXah_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTVE6i_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="珍宝馆"><a href="#珍宝馆" class="headerlink" title="珍宝馆"></a>珍宝馆</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9oLajLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="珍宝馆入口"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyVid6jTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="九龙壁介绍"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyVid6jXNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="九龙壁1"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpB-ajbNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="九龙壁2"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTVE6jrNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="皇极殿介绍"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyVid6jfNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="皇极殿"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxqIq6jvNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="仁德大隆"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-vRLo_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="门"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSrPwro7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="门特写"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRUcKrpHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRUcKrpLNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCX_aDNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="大肥猫"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCXrpXNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxqJELpjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9okrpnNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-vRLprNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCXOlLNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSrPwOlTNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-vQulXNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw-vQulfNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSrPwOlnNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxqJDulrNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="御花园"><a href="#御花园" class="headerlink" title="御花园"></a>御花园</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCXOrrNA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zA8purvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCXOrzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCXOr7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鱼"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9okOr_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鱼"></p><hr><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCYQ8HNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxqJEw8LNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="神武门"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9olQ8TNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="神武门"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9olQ8XNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="刘老板"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9olQ8fNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="神武门_全"></p><hr><p><img src="https://static.dingtalk.com/media/lADPDg7mR_2CJ1zNA8DNBQA_1280_960.jpg_720x720q90g.jpg?bizType=im" alt="明思宗殉国处"></p><hr><h2 id="夜景"><a href="#夜景" class="headerlink" title="夜景"></a>夜景</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSrP1J8zNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwTVip83NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCcJ87NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="月"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQpCcJ9DNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zA8up9LNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P9olQ8nNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="晚饭,比中饭好吃,还有一个菜没拍"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zA8qw8vNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="wow"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中秋之行-下午-故宫博物院&quot;&gt;&lt;a href=&quot;#中秋之行-下午-故宫博物院&quot; class=&quot;headerlink&quot; title=&quot;中秋之行_下午_故宫博物院&quot;&gt;&lt;/a&gt;中秋之行_下午_故宫博物院&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://git</summary>
      
    
    
    
    <category term="个人记实" scheme="https://www.ckxgzxa.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%AE%9E/"/>
    
    
    <category term="2021中秋节" scheme="https://www.ckxgzxa.top/tags/2021%E4%B8%AD%E7%A7%8B%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>中秋之行_上午_中国地质博物馆</title>
    <link href="https://www.ckxgzxa.top/2021MidAutumnFestival1.html"/>
    <id>https://www.ckxgzxa.top/2021MidAutumnFestival1.html</id>
    <published>2021-09-21T14:19:40.000Z</published>
    <updated>2021-12-05T05:42:21.975Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中秋之行-上午-中国地质博物馆"><a href="#中秋之行-上午-中国地质博物馆" class="headerlink" title="中秋之行_上午_中国地质博物馆"></a>中秋之行_上午_中国地质博物馆</h1><h2 id="参观指南"><a href="#参观指南" class="headerlink" title="参观指南"></a>参观指南</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/ea272b7e29ac1914605940da8f4b2f3.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/3c8f10fd9d5673c3391c4fcdd13db42.jpg"></p><h2 id="2F矿物岩石厅"><a href="#2F矿物岩石厅" class="headerlink" title="2F矿物岩石厅"></a>2F矿物岩石厅</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9-baoXNEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P83u6oHNEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P83u6n_NEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwSkoanrNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRTrU6nXNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9-banHNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRTrU6m3NFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9-bamvNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P830x6rNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxpYdUPzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxpYdUP7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRTrj0QLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwSk3UQPNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSqfJ0QfNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyUyQUQnNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwSk3UQvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zAMDUQ3NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P8390Q7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSqfJ0R7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><h2 id="3F史前生物厅"><a href="#3F史前生物厅" class="headerlink" title="3F史前生物厅"></a>3F史前生物厅</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxpYgID7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_FZoD_NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoRzoEHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoRzoELNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P84AoETNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxpYgIEbNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgQ9zAMGIEjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyUyTIEvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P84AoE7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><h5 id="鹦鹉嘴龙"><a href="#鹦鹉嘴龙" class="headerlink" title="鹦鹉嘴龙"></a>鹦鹉嘴龙</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwSk989nNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRTrmhd7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxpYgBd_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwSk6BeHNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9-tBeLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="中国鹦鹉嘴龙"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSqfMhePNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_FZheTNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="翼龙"></p><h5 id="三里庙树枝蛋"><a href="#三里庙树枝蛋" class="headerlink" title="三里庙树枝蛋"></a>三里庙树枝蛋</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9-tBebNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="三里庙树枝蛋"></p><h5 id="满洲满洲龟"><a href="#满洲满洲龟" class="headerlink" title="满洲满洲龟"></a>满洲满洲龟</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRTrmhefNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="满洲满洲龟"></p><h5 id="猛犸象"><a href="#猛犸象" class="headerlink" title="猛犸象"></a>猛犸象</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwSlBdr7NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="猛犸象"></p><h5 id="柄杯鹿"><a href="#柄杯鹿" class="headerlink" title="柄杯鹿"></a>柄杯鹿</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoR69r_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="柄杯鹿"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_Fg9sDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="一些哺乳动物的牙齿"></p><h5 id="西峡巨型长型蛋"><a href="#西峡巨型长型蛋" class="headerlink" title="西峡巨型长型蛋"></a>西峡巨型长型蛋</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyUyZ_tLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="西峡巨型长型蛋"></p><h5 id="披毛犀"><a href="#披毛犀" class="headerlink" title="披毛犀"></a>披毛犀</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P84H9sHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="披毛犀"></p><h5 id="头骨"><a href="#头骨" class="headerlink" title="头骨"></a>头骨</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9-0dsPNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="头骨"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRTrt9sTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="头骨"></p><h5 id="巨型禄丰龙骨架模型"><a href="#巨型禄丰龙骨架模型" class="headerlink" title="巨型禄丰龙骨架模型"></a>巨型禄丰龙骨架模型</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwSlBdsfNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="巨型禄丰龙骨架模型"></p><h2 id="3F临时展厅"><a href="#3F临时展厅" class="headerlink" title="3F临时展厅"></a>3F临时展厅</h2><h5 id="徐悲鸿-愚公移山"><a href="#徐悲鸿-愚公移山" class="headerlink" title="徐悲鸿_愚公移山"></a>徐悲鸿_愚公移山</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoR69snNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="徐悲鸿_愚公移山"></p><h5 id="铁工厂锻压插件-水彩-1951-孙宗慰"><a href="#铁工厂锻压插件-水彩-1951-孙宗慰" class="headerlink" title="铁工厂锻压插件_水彩_1951_孙宗慰"></a>铁工厂锻压插件_水彩_1951_孙宗慰</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9-5MoHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="铁工厂锻压插件\_水彩\_1951_孙宗慰"></p><h5 id="愚公移山单人-1940-徐悲鸿"><a href="#愚公移山单人-1940-徐悲鸿" class="headerlink" title="愚公移山单人_1940_徐悲鸿"></a>愚公移山单人_1940_徐悲鸿</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSqfYsoLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山单人_1940_徐悲鸿"></p><h5 id="愚公移山手稿-1940-徐悲鸿"><a href="#愚公移山手稿-1940-徐悲鸿" class="headerlink" title="愚公移山手稿_1940_徐悲鸿"></a>愚公移山手稿_1940_徐悲鸿</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSqfYsoTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山手稿_1940_徐悲鸿"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgfLSqfYsoXNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山手稿_徐悲鸿"></p><h2 id="4F临时展厅"><a href="#4F临时展厅" class="headerlink" title="4F临时展厅"></a>4F临时展厅</h2><h5 id="柴达木之宝"><a href="#柴达木之宝" class="headerlink" title="柴达木之宝"></a>柴达木之宝</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxpYsMobNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="柴达木之宝"></p><h5 id="朱德收藏标本"><a href="#朱德收藏标本" class="headerlink" title="朱德收藏标本"></a>朱德收藏标本</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyUyfMofNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="朱德收藏标本"></p><h5 id="原油"><a href="#原油" class="headerlink" title="原油"></a>原油</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhYBRTrysojNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="原油"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiQ3P84MsonNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="原油"></p><h5 id="雌黄"><a href="#雌黄" class="headerlink" title="雌黄"></a>雌黄</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoR_sovNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="雌黄"></p><h5 id="萤石、白云石、水晶"><a href="#萤石、白云石、水晶" class="headerlink" title="萤石、白云石、水晶"></a>萤石、白云石、水晶</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9_BF7LNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="萤石、白云石、水晶"></p><h5 id="石英、白钨矿、云母"><a href="#石英、白钨矿、云母" class="headerlink" title="石英、白钨矿、云母"></a>石英、白钨矿、云母</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoSHl7PNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="石英、白钨矿、云母"></p><h5 id="石膏"><a href="#石膏" class="headerlink" title="石膏"></a>石膏</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDiCpwSlOF7bNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="石膏"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDg7mR_Ftl7jNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhmOw9_BF7rNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><h5 id="石油书籍"><a href="#石油书籍" class="headerlink" title="石油书籍"></a>石油书籍</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDgtYyUynF73NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="石油书籍"></p><h2 id="出馆与李四光像合影"><a href="#出馆与李四光像合影" class="headerlink" title="出馆与李四光像合影"></a>出馆与李四光像合影</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDh0cQoSHl77NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="照片"></p><h2 id="中饭"><a href="#中饭" class="headerlink" title="中饭"></a>中饭</h2><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/lADPDhJzxpY0F8DNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="中饭,这面太难吃了"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中秋之行-上午-中国地质博物馆&quot;&gt;&lt;a href=&quot;#中秋之行-上午-中国地质博物馆&quot; class=&quot;headerlink&quot; title=&quot;中秋之行_上午_中国地质博物馆&quot;&gt;&lt;/a&gt;中秋之行_上午_中国地质博物馆&lt;/h1&gt;&lt;h2 id=&quot;参观指南&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="个人记实" scheme="https://www.ckxgzxa.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%AE%9E/"/>
    
    
    <category term="2021中秋节" scheme="https://www.ckxgzxa.top/tags/2021%E4%B8%AD%E7%A7%8B%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>一些绕口令</title>
    <link href="https://www.ckxgzxa.top/%E4%B8%80%E4%BA%9B%E7%BB%95%E5%8F%A3%E4%BB%A4.html"/>
    <id>https://www.ckxgzxa.top/%E4%B8%80%E4%BA%9B%E7%BB%95%E5%8F%A3%E4%BB%A4.html</id>
    <published>2021-09-19T10:49:35.000Z</published>
    <updated>2021-09-19T10:58:54.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些绕口令"><a href="#一些绕口令" class="headerlink" title="一些绕口令"></a>一些绕口令</h1><ol><li><p>==八了百了标了兵了奔了北了坡，炮了兵了并了排了北了边了跑， 炮了兵了怕了把了标了兵了碰，标了兵了怕了碰了炮了兵了炮。（双唇及舌）==</p></li><li><p>==巴老爷有八十八棵芭蕉树，来了八十八个把式要在巴老爷八十八棵芭蕉树下住。巴老爷拔了八十八棵芭蕉树，不让八十八个把式在八十八棵芭蕉树下住。八十八个把式烧了八十八棵芭蕉树，巴老爷在八十八棵树边哭。（锻炼唇力）==</p></li><li><p>==门口吊刀，刀倒吊着。……（反复说，锻炼舌的顶力）==</p></li><li><p>==山前有个催粗腿，山后有个催腿粗，俩人山前来比腿，不知是催粗腿比催腿粗的腿粗，还是催腿粗比催粗腿的腿粗。==</p></li><li><p>==粉红墙上画凤凰，凤凰画在粉红墙。红凤凰、粉凤凰，红粉凤凰花凤凰。==</p></li></ol><h3 id="主持人播音员专业八级绕口令考试试卷"><a href="#主持人播音员专业八级绕口令考试试卷" class="headerlink" title="主持人播音员专业八级绕口令考试试卷"></a>主持人播音员专业八级绕口令考试试卷</h3><h4 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h4><p>老龙恼怒闹老农，老农恼怒闹老龙。农怒龙恼农更怒，龙恼农怒龙怕农。</p><h4 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h4><p>牛郎恋刘娘，刘娘念牛郞，牛郎年年念刘娘，刘娘牛年恋牛郎，郎念娘来娘恋娘</p><h4 id="第三题："><a href="#第三题：" class="headerlink" title="第三题："></a>第三题：</h4><p>七巷一个漆匠，西巷一个锡匠。七巷漆匠用了西巷锡匠的锡，西巷锡匠拿了七巷漆匠的漆，七巷漆匠气西巷锡匠用了漆，西巷锡匠讥七巷漆匠拿了锡。</p><h4 id="第四题："><a href="#第四题：" class="headerlink" title="第四题："></a>第四题：</h4><p>初级 大声说20遍(红凤凰)<br>中级 大声说20遍(粉红凤凰)<br>高级 大声说10遍(红凤凰，黄凤凰，粉红凤凰花凤凰)</p><hr><p>丝瓜藤上绕满绳，<br>瓜藤绕着绳架伸。<br>绳长藤伸瓜儿长，<br>绳粗藤壮瓜儿沉。</p><p>风吹银铃叮铃铃<br>小琳琳，爱银铃，<br>琳琳用劲摇银铃，<br>银铃的铃声真好听。<br>风吹银铃叮铃铃，<br>小琳以为铃失灵，<br>银铃笑琳琳真是不机灵！</p><p>蓝教练是女教练，吕教练是男教练<br>蓝教练不是男教练，吕教练不是男教练<br>蓝南是男篮主力，吕楠是女篮主力。吕教练在男篮训练蓝南，蓝教练在女篮训练吕楠。</p><p>小盈林，爱银铃，<br>盈林用劲摇银铃，<br>银铃声音真动听。<br>风吹银铃叮铃铃，<br>盈林心中喜盈盈，<br>笑声尽情赛银玲。</p><hr><ol><li>初入江湖：化肥会挥发</li><li>小有名气：黑化肥发灰，灰化肥发黑</li><li>名动一方：黑化肥发灰会挥发；灰化肥挥发会发黑</li><li>天下闻名：黑化肥挥发发灰会花飞；灰化肥挥发发黑会飞花</li><li>一代宗师：黑灰化肥会挥发发灰黑讳为花飞；灰黑化肥会挥发发黑灰为讳飞花</li><li>超凡入圣：黑灰化肥灰会挥发发灰黑讳为黑灰花会飞；灰黑化肥会会挥发发黑灰为讳飞花化为灰</li><li>天外飞仙：黑化黑灰化肥灰会挥发发灰黑讳为黑灰花会回飞；灰化灰黑化肥会会挥发发黑灰为讳飞花回化为灰</li></ol><h3 id="绕口令"><a href="#绕口令" class="headerlink" title="绕口令"></a>绕口令</h3><h4 id="单韵母练习"><a href="#单韵母练习" class="headerlink" title="单韵母练习"></a>单韵母练习</h4><ol><li>坡上立着一只鹅，坡下就是一条河。宽宽的河，肥肥的鹅，鹅要过河，河要渡鹅，不知是鹅过河，还是河渡鹅？</li><li>山上五棵树，架上五壶醋，林中五只鹿，箱里五条裤。伐了山上树，搬下架上的醋，射死林中的鹿，取出箱中的裤。</li></ol><h4 id="鼻韵母练习"><a href="#鼻韵母练习" class="headerlink" title="鼻韵母练习"></a>鼻韵母练习</h4><ol><li>扁担长，板凳宽，扁担没有板凳宽，板凳没有扁担长，扁担想绑在板凳上，板凳不让扁担绑在板凳上，扁担偏偏绑在板凳上，到底是板凳宽还是扁担长。</li><li>一平盆面，烙一平盆饼，饼碰盆，盆碰饼。</li><li>山前有个严圆眼，山后有个严眼圆，二人山前来比眼，不知是严圆眼的眼圆，还是严眼圆比严圆眼的眼圆？</li></ol><h4 id="复韵母练习"><a href="#复韵母练习" class="headerlink" title="复韵母练习"></a>复韵母练习</h4><ol><li>出南门，走六步，见着六叔和六舅，叫声六叔和六舅，借我六斗六升好绿豆；过了秋，打了豆，还我六叔六舅六十六斗六升好绿豆。</li><li>哥挎瓜筐过宽沟，过沟筐漏瓜滚沟。隔沟挎筐瓜筐扣，瓜滚筐空哥怪沟。</li></ol><h4 id="唇音练习"><a href="#唇音练习" class="headerlink" title="唇音练习"></a>唇音练习</h4><ol><li>老方扛着黄幌子，老黄扛着方幌子。老方要拿老黄的方幌子，老黄要拿老方的黄幌子，末了儿方幌子碰破了黄幌子，黄幌子碰破了方幌子。</li></ol><h4 id="舌尖中音练习"><a href="#舌尖中音练习" class="headerlink" title="舌尖中音练习"></a>舌尖中音练习</h4><ol><li>你会炖炖冻豆腐，你来炖我的炖冻豆腐；你不会炖炖冻豆腐，别胡炖乱炖炖坏了我的炖冻豆腐。</li><li>老罗拉了一车梨，老李拉了一车栗。老罗人称大力罗，老李人称李大力。老罗拉梨做梨酒，老李拉栗去换梨。</li><li>有个面铺门朝南，门上挂着蓝布棉门帘，摘了蓝布棉门帘，面铺门朝南；挂上蓝布棉门帘，面铺还是门朝南。</li><li>大刀对单刀，单刀对大刀，大刀斗单刀，单刀夺大刀。</li></ol><h4 id="舌根音、舌面音练习"><a href="#舌根音、舌面音练习" class="headerlink" title="舌根音、舌面音练习"></a>舌根音、舌面音练习</h4><ol><li>一班有个黄贺，二班有个王克，黄贺、王克二人搞创作，黄贺搞木刻，王克写诗歌。黄贺帮助王克写诗歌，王克帮助黄贺搞木刻。由于二人搞协作，黄贺完成了木刻，王克写好了诗歌。<br>翘舌音、平舌音、练习</li><li>天上有个日头，地下有块石头，嘴里有个舌头，手上有五个手指头。不管是天上的热日头，地下的硬石头，嘴里的软舌头，手上的手指头，还是热日头，硬石头，软舌头，手指头，反正都是练舌头。</li><li>师部司令部指示：四团十连石连长带四十人在十日四时四十四分按时到达师部司令部，师长召开誓师大会。</li><li>早招租，晚招租，总找周邹郑曾朱。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些绕口令&quot;&gt;&lt;a href=&quot;#一些绕口令&quot; class=&quot;headerlink&quot; title=&quot;一些绕口令&quot;&gt;&lt;/a&gt;一些绕口令&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;==八了百了标了兵了奔了北了坡，炮了兵了并了排了北了边了跑， 炮了兵了怕了把了标了兵了碰，标了兵了</summary>
      
    
    
    
    <category term="其他" scheme="https://www.ckxgzxa.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
</feed>
