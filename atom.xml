<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>残魁斜罡的空间</title>
  
  
  <link href="http://www.ckxgzxa.top/atom.xml" rel="self"/>
  
  <link href="http://www.ckxgzxa.top/"/>
  <updated>2021-11-08T15:40:18.611Z</updated>
  <id>http://www.ckxgzxa.top/</id>
  
  <author>
    <name>残魁斜罡</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在服务器上搭建jupyter notebook</title>
    <link href="http://www.ckxgzxa.top/buildJupyterOnServer"/>
    <id>http://www.ckxgzxa.top/buildJupyterOnServer</id>
    <published>2021-11-08T13:46:21.000Z</published>
    <updated>2021-11-08T15:40:18.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何在服务器上搭建jupyter-notebook"><a href="#如何在服务器上搭建jupyter-notebook" class="headerlink" title="如何在服务器上搭建jupyter notebook"></a>如何在服务器上搭建jupyter notebook</h1><h2 id="1-准备一台Linux云服务器"><a href="#1-准备一台Linux云服务器" class="headerlink" title="1. 准备一台Linux云服务器"></a>1. 准备一台Linux云服务器</h2><h2 id="2-新建一个用户"><a href="#2-新建一个用户" class="headerlink" title="2. 新建一个用户"></a>2. 新建一个用户</h2><p>我的习惯是是不在root用户下运行 jupyter notebook 服务,</p><p>因此我建议新建一个<code>jupyter</code>的用户:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">adduser jupyter</span><br></code></pre></td></tr></table></figure><p>然后切换到此用户</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">su jupyter</span><br></code></pre></td></tr></table></figure><h2 id="3-安装-Anaconda"><a href="#3-安装-Anaconda" class="headerlink" title="3. 安装 Anaconda"></a>3. 安装 Anaconda</h2><p>下载Anaconda最新安装程序 <a href="https://www.anaconda.com/products/individual#Downloads">https://www.anaconda.com/products/individual#Downloads</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>运行安装程序:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh Anaconda3-2021.05-Linux-x86_64.sh<br></code></pre></td></tr></table></figure><p>安装过程中敲回车和输入yes同意许可即可</p><p>安装完成重新登录即可</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111082211398.png" alt="image-20211108221130339"></p><h2 id="4-搭建-Jupyter-Notebook-环境"><a href="#4-搭建-Jupyter-Notebook-环境" class="headerlink" title="4. 搭建 Jupyter Notebook 环境"></a>4. 搭建 Jupyter Notebook 环境</h2><ul><li>安装jupyter包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda install jupyter <br></code></pre></td></tr></table></figure><ul><li>生成默认配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook --generate-config<br></code></pre></td></tr></table></figure><ul><li>随后我们往配置文件写入一些内容</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置可以访问的ip, 默认是localhost, 将其改为 &#x27;*&#x27;</span><br>c.NotebookApp.ip = <span class="hljs-string">&#x27;*&#x27;</span><br><br><span class="hljs-comment"># 笔记本的默认打开目录, 自己设置</span><br>c.NotebookApp.notebook_dir = <span class="hljs-string">&#x27;/home/jupyter/documents/jupyter_notebook&#x27;</span><br><br><span class="hljs-comment"># 笔记本启动后是否打开浏览器, 设为 False即可</span><br>c.NotebookApp.open_browser = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 默认访问端口, 可自己修改</span><br>c.NotebookApp.port = <span class="hljs-number">8888</span><br><br><span class="hljs-comment"># jupyterlab是否显示quit按钮,我设为false以免自己不小心按到把服务停了</span><br>c.NotebookApp.quit_button = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 如果使用root用户运行,将下列值改为True即可, 运行时也可加参数将其改为True</span><br>c.NotebookApp.allow_root = <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><ul><li>修改好配置文件之后, 运行如下命令启动笔记本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook<br></code></pre></td></tr></table></figure><ul><li>第一次运行会给出带token的链接, 复制到浏览器中打开, 点击登出</li></ul><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111082241916.png" alt="image-20211108224139818"></p><ul><li><p>随后进入login界面, 输入刚刚链接中的 token值和新密码即可修改密码:</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111082243891.png" alt="image-20211108224309795"></p></li><li><p>设置好密码之后我们重启jupyter服务, 再次进入,发现就能用我们刚刚设置的密码登录了</p></li></ul><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111082245031.png" alt="image-20211108224540995"></p><ul><li>随便上传一个笔记本试试</li></ul><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111082326683.png" alt="image-20211108232637635"></p><ul><li>发现已经ok了</li></ul><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111082327360.png" alt="image-20211108232733266"></p><h2 id="5-让-jupyter-在服务器上持久运行"><a href="#5-让-jupyter-在服务器上持久运行" class="headerlink" title="5. 让 jupyter 在服务器上持久运行"></a>5. 让 jupyter 在服务器上持久运行</h2><ul><li>发现断开 SSH 连接之后, jupyter服务就会停止运行,我们利用<code>screen</code> 命令让jupyter服务一直运行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">screen -S notebook<br></code></pre></td></tr></table></figure><ul><li>然后启动jupyter服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jupyter notebook<br></code></pre></td></tr></table></figure><ul><li>随后按 <code>Ctrl + A + D </code>将服务挂到后台即可</li></ul><h2 id="6-End"><a href="#6-End" class="headerlink" title="6. End"></a>6. End</h2><p>本次教程简单记录而已, 如有帮助,本人不胜感激.</p><blockquote><p>如有错误或不当之处, 请在下方评论, 我看到将对其进行修改和改进</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;如何在服务器上搭建jupyter-notebook&quot;&gt;&lt;a href=&quot;#如何在服务器上搭建jupyter-notebook&quot; class=&quot;headerlink&quot; title=&quot;如何在服务器上搭建jupyter notebook&quot;&gt;&lt;/a&gt;如何在服务器上搭建ju</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="机器学习" scheme="http://www.ckxgzxa.top/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>ModelArts平台花卉分类识别实验报告</title>
    <link href="http://www.ckxgzxa.top/FlowerIdentificationByModelarts"/>
    <id>http://www.ckxgzxa.top/FlowerIdentificationByModelarts</id>
    <published>2021-11-05T06:45:43.000Z</published>
    <updated>2021-11-05T15:02:46.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="华为云ModelArts平台花卉分类识别实验报告"><a href="#华为云ModelArts平台花卉分类识别实验报告" class="headerlink" title="华为云ModelArts平台花卉分类识别实验报告"></a>华为云ModelArts平台花卉分类识别实验报告</h1><blockquote><p><a href="https://activity.huaweicloud.com/discount_area_v5/index.html?fromacct=5a4cbb43-f85f-4427-ba12-3630ac71d4fe&utm_source=Y2t4Z3p4YWJlc3Q==&utm_medium=cps&utm_campaign=201905">【华为云11.11上云嘉年华，注册领10000元上云礼包，满额送华为X2折叠屏】</a></p></blockquote><h2 id="1-准备数据集"><a href="#1-准备数据集" class="headerlink" title="1. 准备数据集"></a>1. 准备数据集</h2><p>​        我们在官网下载好TensorFlow官网提供的[花卉数据集](<a href="https://www.tensorflow.org/datasets/catalog/tf_flowers">tf_flowers  | TensorFlow Datasets</a>)并在我们电脑上解压, </p><p>发现 文件的结构如下所示:</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111051955239.png" alt="image-20211105195521063"></p><p>flower_photos内共有5个文件夹,分别是雏菊(daisy)，dandelion(蒲公英)， roses(玫瑰)， sunflowers(向日葵)， tulips(郁金香)， 每个文件夹中存放有若干张该分类的图片。</p><h2 id="2-创建OBS桶"><a href="#2-创建OBS桶" class="headerlink" title="2. 创建OBS桶"></a>2. 创建OBS桶</h2><p>用ModelArts训练需要华为的对象存储服务OBS来保存我们的数据，</p><ul><li><p>首先在华为云搜索obs服务，然后点击进入</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052031054.png" alt="image-20211105203119822"></p></li><li><p>进入之后点击创建桶</p></li></ul><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052030323.png" alt="image-20211105203016075"></p><ul><li><p>然后选择单AZ存储，地区选择离你最近的地区即可，选择好之后点击立即创建：</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052036482.png" alt="image-20211105203646291"></p></li><li><p>这样我们的OBS桶就创建好了</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052041210.png" alt="image-20211105204107093"></p></li></ul><h2 id="3-获取访问密钥"><a href="#3-获取访问密钥" class="headerlink" title="3. 获取访问密钥"></a>3. 获取访问密钥</h2><p>需要获取访问密钥然后用访问密钥登录obs-brower来方便的将我们的训练数据上传到OBS桶</p><ul><li><p>获取OBS密钥</p><ol><li><p>点击我的凭证</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052113742.png" alt="image-20211105211345664"></p></li><li><p>点击新增访问密钥</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052114923.png" alt="image-20211105211453706"></p></li><li><p>输入密钥名称就可以下载一个名为credentials.csv的文件，里面存放的就是访问密钥，请不要泄露</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052117971.png"></p></li></ol><h2 id="4-获取OBS-Browser-工具"><a href="#4-获取OBS-Browser-工具" class="headerlink" title="4. 获取OBS Browser+ 工具"></a>4. 获取OBS Browser+ 工具</h2><ol><li><p>随后我们进入如下的网址下载 obs browser+ 工具</p><p>下载OBS Browser+：<a href="https://support.huaweicloud.com/browsertg-obs/obs_03_1003.html">https://support.huaweicloud.com/browsertg-obs/obs_03_1003.html</a></p><p>下载安装好之后我们打开它之后使用上一步获取到的密钥登录：</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052121218.png" alt="image-20211105212127102"></p></li><li><p>随后我们在桶内新建4个文件夹(flower_photos, flower_input, flower_output, train_output)用于接下来的实验</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052122159.png" alt="image-20211105212256032"></p></li></ol></li></ul><h2 id="5-上传数据集"><a href="#5-上传数据集" class="headerlink" title="5. 上传数据集"></a>5. 上传数据集</h2><p>在flower_photos中上传我们解压出来的花卉数据集</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052128053.png" alt="image-20211105212805937"></p><p>​     </p><h2 id="6-创建数据集"><a href="#6-创建数据集" class="headerlink" title="6. 创建数据集"></a>6. 创建数据集</h2><ul><li><p>进入ModelArts控制台界面，进入数据集管理，然后点击创建数据集</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052131676.png" alt="image-20211105213120461"></p></li><li><p>选择图像分类标注类型，输入为止和输出位置选择我们刚刚在 obs browser中新建的两个空文件夹</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052133067.png" alt="image-20211105213303824"></p></li><li><p>随后点击创建数据集即可</p></li><li><p>返回进入此数据集管理界面，点击导入，由于我已经创建过数据集了，因此里面是有标记数据的</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052135413.png" alt="image-20211105213510211"></p></li><li><p>点击我们刚开始上传花卉数据集的位置确定即可</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052136171.png" alt="image-20211105213608064"></p></li><li><p>导入完成之后，我们点击发布，设置数据切分训练集比例为0.8即可</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052137278.png" alt="image-20211105213729194"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052138484.png" alt="image-20211105213811387"></p></li></ul><h2 id="7-使用算法进行模型训练"><a href="#7-使用算法进行模型训练" class="headerlink" title="7. 使用算法进行模型训练"></a>7. 使用算法进行模型训练</h2><ul><li><p>首先进入如下的网址订阅图像分类算法</p><p><a href="https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0">图像分类-MobileNet_v2链接</a>：<a href="https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0)">https://marketplace.huaweicloud.com/markets/aihub/modelhub/detail/?id=0470e6b1-923b-47a8-ba3e-fe93de5ae2a0)</a></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052139825.png" alt="image-20211105213954489"></p></li><li><p>订阅完成之后我们返回ModelArts控制台的训练管理界面，点击创建训练作业</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052143872.png" alt="image-20211105214329543"></p></li><li><p>算法选择刚刚我们刚刚订阅的算法，训练输入选择我们刚刚创建的数据集，训练输出选择我们刚开始创建的输出文件夹即可，下面有免费的GPU资源可以供我们选择。点击提交并等待训练完成。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052145627.png" alt="image-20211105214541511"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052147929.png" alt="image-20211105214734741"></p></li><li><p>模型训练完成大概需要二十多分钟</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052211783.png" alt="image-20211105221118637"></p></li></ul><h2 id="8-模型的部署和验证"><a href="#8-模型的部署和验证" class="headerlink" title="8. 模型的部署和验证"></a>8. 模型的部署和验证</h2><ul><li><p>点击模型管理，然后进行在线服务的部署，选择免费资源即可</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052153987.png" alt="image-20211105215342790"></p></li><li><p>部署完成之后点击在线服务的预测</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052156506.png" alt="image-20211105215616340"></p><p>在这里可以对应用接口进行调试，同样地你也可以利用POSTMAN等工具对它进行调试，官网有详细的文档可以查看</p></li><li><p>我们上传一些花卉图片对它进行测试</p><ol><li><p>这张图片的结果是玫瑰的可能性是1，识别正确。<img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052159806.png" alt="image-20211105215908408"></p></li><li><p>这张蒲公英的图片也是识别正确的。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052202530.png" alt="image-20211105220235211"></p></li><li><p>这张图片是向日葵的概率也是100%</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202111052206769.png"></p></li></ol></li><li><p>我们发现这个训练出来的95.87%准确率的花卉分类模型还是能准确分辨这五种花卉图片的，结果不错。</p></li></ul><h2 id="9-注意事项"><a href="#9-注意事项" class="headerlink" title="9. 注意事项"></a>9. 注意事项</h2><ul><li>华为的OBS对象存储服务是要花钱的，不过训练完成之后也只扣了1分钱，其他的服务都是免费的，充值的费用如果没用完也是能提现的，所以不用担心，这点还是非常不错的。</li></ul><h2 id="10-心得和体会"><a href="#10-心得和体会" class="headerlink" title="10. 心得和体会"></a>10. 心得和体会</h2><p>通过这次利用华为云ModelArts平台进行的花卉识别实验，我发现华为ModelArts平台为机器学习与深度学习提供海量数据预处理及交互式智能标注、大规模分布式训练、自动化模型生成等等一些功能，这些功能全是华为云线上帮你完成的，我们用户根本不用编写一些复杂的代码，从而可以帮助用户快速创建和部署模型，即使你毫无编码基础，也能通过这些图形化的界面进行模型的搭建和训练并快速的部署发布到实际应用当中，推进了人工智能和机器学习的普及和大众化，并使用场景化的AI案例，使得AI落地零门槛，这样的话普通人也能利用华为的这个平台使用人工智能技术改变世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;华为云ModelArts平台花卉分类识别实验报告&quot;&gt;&lt;a href=&quot;#华为云ModelArts平台花卉分类识别实验报告&quot; class=&quot;headerlink&quot; title=&quot;华为云ModelArts平台花卉分类识别实验报告&quot;&gt;&lt;/a&gt;华为云ModelArts平台</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="人工智能" scheme="http://www.ckxgzxa.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>第1章 什么是对象?</title>
    <link href="http://www.ckxgzxa.top/3-WhatIsAnObject"/>
    <id>http://www.ckxgzxa.top/3-WhatIsAnObject</id>
    <published>2021-10-28T07:02:17.000Z</published>
    <updated>2021-10-28T07:23:09.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-什么是对象"><a href="#第-1-章-什么是对象" class="headerlink" title="第 1 章　什么是对象"></a>第 1 章　什么是对象</h1><blockquote><p>“我们并未意识到惯用语言结构的强大之处。甚至可以毫不夸张地说，惯用语言通过语义反应机制奴役了我们。而一门语言所展现出的结构，潜移默化地影响着我们，并自动映射至我们所生活的世界。”</p><p>——Alfred Korzybski（1930）</p></blockquote><p>计算机革命起源于一台机器，而编程语言就好比是那台机器。</p><p>然而计算机并不只是机器而已，它们还是扩展思维的工具（就像乔布斯喜欢说的一句话：计算机是“思维的自行车”），也是一种与众不同的表达媒介。结果就是，工具已经越来越不像机器，而是越来越像思维的一部分。</p><p>编程语言是用于创建应用程序的思维模式。语言本身可以从写作、绘画、雕塑、动画、电影制作等表达方式中获取灵感，而<strong>面向对象编程</strong>（Object-Oriented Programming, OOP）则是用计算机作为表达媒介的一种尝试。</p><p>许多人并不了解面向对象编程的思想框架，他们在进行编程时会感到举步维艰。因此，本章会简要的介绍一些面向对象编程的基础概念。还有一些人在接触相关机制之前可能无法理解这些概念，在看不到代码的情况下就会迷失。如果你属于后者并且渴望尽早接触到具体的语言特性，你完全可以跳过这一章，这样做并不会影响你学习编程语言或者写代码。不过，之后你可以再回到这里补充相关知识，这样有助于你理解对象如此重要的原因，以及如何利用对象做程序设计。</p><p>本章的内容假设你具有一定的编程基础，但不一定是C语言的经验。在全面学习本书之前，如果你需要补充一些基础的编程知识，可以在 On Java 8 网站下载多媒体课程“Thinking in C”来学习。</p><h2 id="1-1-抽象的历程"><a href="#1-1-抽象的历程" class="headerlink" title="1.1　抽象的历程"></a>1.1　抽象的历程</h2><p>所有编程语言都是一种抽象。甚至可以说，我们能够解决的问题的复杂程度直接取决于抽象的类型和质量。这里提到的“类型”的含义是“你要抽象的是什么”。比如，汇编语言是对计算机底层的一个极简化的抽象。还有许多所谓的命令式编程语言（比如 FORTRAN、BASIC 和 C 语言等）都是各自对汇编语言的抽象。虽然这些语言已经取得了长足的进步，但它们主要的抽象方式依然要求你根据计算机的结构而非问题的结构来思考。于是，程序员必须在机器模型（也叫作“解决方案空间”，即实际解决问题的方式，比如计算机）和实际解决的问题模型（也叫作“问题空间”，即问题实际存在之处，比如来源于某个业务）之间建立关联。建立这种关联需要耗费很大的精力，而且它是与编程语言无关的，这一切都导致程序难以编写且不易维护。</p><p>构建机器模型的一种代替方案是针对需要解决的问题构建问题模型。早期的一些编程语言（比如 LISP 和 APL）会采取特定的视角看待周遭问题（例如，“所有问题最终都可以用列表呈现”或者“所有问题都是算法问题”），Prolog 语言则会将所有问题都转换为决策链。这些语言要么是基于约束性的编程语言，要么是专门用来操作图形符号的编程语言。这些编程语言都能够出色地解决一些特定的问题，因为它们正是为此而生的。然而，一旦遇到它们专属领域以外的问题，它们就显得无能为力了。</p><p>面向对象编程则更进一步，它为程序员提供了一些能够呈现问题空间元素的工具。这种呈现方式具备足够的通用性，使得程序员不再局限于特定的问题。而这些问题空间中的元素及其解决方案空间中的具体呈现，我们称其为“对象”（需要注意的是，有些对象并不支持问题空间的类比）。其背后的理念则是，通过添加各种新的对象，程序可以将自己改编为一种描述问题的语言。于是，你阅读的既是解决方案的代码，也是表述问题的文字。这种灵活且强大的语言抽象能力是前所未有的。因此，面向对象编程描述问题的依据是实际的问题，而非用于执行解决方案的计算机。不过，它们之间依然存在联系，这是因为从某种意义上来说，对象也类似于一台小型计算机——每一个对象都具有状态，并且可以执行一些特定的操作。这一特点与现实中的事物极为相似，它们都具有各自的行为和特征。</p><p>SmallTalk 是历史上第一门获得成功的面向对象语言，并且为后续出现的 Java 语言提供了灵感。Alan Kay 总结了 SmallTalk 语言的 5 个基本特征，这些特征代表了纯粹的面向对象编程的方式。</p><ol><li><strong>万物皆对象。</strong>你可以把对象想象为一种神奇的变量，它可以存储数据，同时你可以“发出请求”，让它执行一些操作。对于你想要解决的问题中的任何元素，你都可以在程序中用对象来呈现（比如狗、建筑、服务等）。</li><li><strong>一段程序实际上就是多个对象通过发送消息来通知彼此要干什么。</strong>当你向一个对象“发送消息”时，实际情况是你发送了一个请求去调用该对象的某个方法。</li><li><strong>从内存角度而言，每一个对象都是由其他更为基础的对象组成的。</strong>换句话说，通过将现有的几个对象打包在一起，你就创建了一种新的对象。这种做法展现了对象的简单性，同时隐藏了程序的复杂性。</li><li><strong>每一个对象都有类型。</strong>具体而言，每一个对象都是通过某个<strong>类</strong>生成的<strong>实例</strong>，这里说的“类”就（几乎）等同于“类型”。一个类最为显著的特性是“你可以发送什么消息给它”。</li><li><strong>同一类型的对象可以接收相同的消息。</strong>稍后你就会意识到这句话的丰富含义。举例来说，因为一个“圆形”对象同样也是一个“形状”对象，所以“圆形”也可以接收“形状”类型的消息。这就意味着，你为“形状”对象编写的代码<strong>自然</strong>可以适用于任何的“形状”子类对象。这种可替换性是面向对象编程的一个基石。</li></ol><p>Grady Booch 对对象做了一种更为简洁的描述：</p><blockquote><p>对象具有状态、行为及标识。</p></blockquote><p>这意味着对象可以拥有属于自己的内部数据（赋予其状态）、方法（用于产生行为），同时每一个对象都有别于其他对象。也就是说，每一个对象在内存中都有唯一的地址。**$^1$**</p><blockquote><p>**$^1$**这个说法实际上不太全面。这是因为对象可以保存在不同的机器或内存地址中，甚至还可以保存在磁盘上。在上述情况中，对象的标识（identity）就需要用其他方式而非内存地址来表示。</p></blockquote><h2 id="1-2-对象具有接口"><a href="#1-2-对象具有接口" class="headerlink" title="1.2　对象具有接口"></a>1.2　对象具有接口</h2><p>亚里士多德可能是第一个仔细研究<strong>类型</strong>这一概念的人，他曾经提出过“鱼的类别和鸟的类别”。所有的对象，哪怕是相当独特的对象，都能够被归为某一类，并且同一类对象拥有一些共同的行为和特征。作为有史以来第一门面向对象编程语言，Simula-67 引入了上述的“类别”概念，并且允许通过关键字 <code>class</code> 在程序中创建新的类型。</p><p>Simula 语言恰如其名，其诞生的目的是用于“模拟”，比如模拟经典的“银行出纳问题”。这个问题的元素包括大量的出纳员、顾客、账户、交易，以及各种货币单位等，这些都是“对象”。而那些状态不同但结构相同的对象汇聚在一起，就变成了“同一类对象”（classes of objects），这就是关键字<code>class</code>的由来。</p><p>创建抽象数据类型（即“类”）是面向对象编程的一个基本概念。抽象数据类型的工作原理和内置类型几乎一样：你可以创建某种类型的变量（在面向对象领域，这些变量叫作“对象”或“实例”），随后你就可以操作这些变量（叫作“发送消息”或“发送请求”，即你发送指令给对象，然后对象自行决定怎么处理）。同一类型的所有成员（或元素）都具有一些共性，比如：每一个账户都有余额，每一位出纳员都能处理存款业务。同时，每一个成员都具有自己的专属状态，比如：每一个账户的余额都是不同的，每一位出纳员都有名字。因此，对于所有这些成员，包括每一位出纳员、每一位顾客、每一个账户，以及每一笔交易等，我们都能够在程序中用一个唯一的实体来表示。这种实体就是对象，同时每一个对象所归属的类决定了对象具有何种行为特征。</p><p>虽然我们在面向对象编程中会创建新的数据类型，但实际上所有面向对象编程语言都会使用 <code>class</code> 这个关键字。所以当你看到“类型”（type）这个词的时候，请第一时间想到“类”（class），反之亦然。**$^2$**</p><blockquote><p>**$^2$**有时候我们会将两者加以区分，将类型（type）定义为接口，而类（class）则是接口的具体实现。</p></blockquote><p>因为类描述了一系列具有相同特征（即数据元素）和行为（即功能方法）的对象，而即便是浮点数这种内置数据类型也具有一系列的行为和特征，所以类其实就是数据类型。抽象数据类型和内置数据类型的区别是，程序员可以通过定义一个新的类来解决问题，而非受限于已有的数据类型。这些已有的数据类型其设计本意是为了呈现机器内的存储单元，你可以根据实际的需求创建新的数据类型，同时扩展编程语言的能力。此外，编程系统对于新的类十分友好，比如也会为新的类提供类型检查等功能，就像对待内置数据类型一样。</p><p>面向对象编程的作用并不局限于模拟。无论你是否同意“任何程序都是对系统的一种模拟”，面向对象编程技巧都可以帮你将众多复杂的问题简化。</p><p>一旦创建了一个类，就可以用它创建任意多个对象，然后在操作这些对象时，可以把它们视为存在于问题空间的元素。实话实说，面向对象编程的一大挑战就是，如何在问题空间的元素和解决方案空间的对象之间建立一对一的关联。</p><p>那么，如何能让一个对象真正发挥其作用呢？答案是向对象发送请求，比如让它完成一次交易、在屏幕上画个图形或者打开一个开关等。对象能够接受什么请求，是由它的“接口”（interface）决定的，而对象所归属的类定义了这些接口。接下来以电灯泡为例，如下图所示。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281506403.png"></p><hr><blockquote><p>插图翻译:<br>Type Name：类型名<br>Interface：接口</p></blockquote><hr><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lasso">Light <span class="hljs-literal">lt</span> = <span class="hljs-literal">new</span> Light();<br><span class="hljs-literal">lt</span>.<span class="hljs-keyword">on</span>();<br></code></pre></td></tr></table></figure><p>图中的接口定义了你能够向这个对象发送的请求。此外，也必然存在一些代码用于响应这些请求。这些代码再加上隐藏的数据，叫作“实现”（implementation）。对于每一个请求，类都有一个方法与之对应。当你向一个对象发送特定的请求时，对应的方法就会被调用。我们通常会这样描述该过程：向对象“发送消息”（即发出请求），然后由对象决定如何处理（即运行对应的代码）。</p><p>在上面的例子中，类的名字是 <code>Light</code>，<code>Light</code> 所生成的对象的名字是 <code>lt</code>，我们能够对 <code>Light</code> 对象发出的请求是开灯（<code>on()</code>）、关灯（<code>off()</code>）、灯光变亮（<code>brighten()</code>）以及灯光变暗（<code>dim()</code>）。通过定义一个“引用”即 <code>lt</code>，以及用 <code>new</code> 关键字生成一个新对象，我们就创建了一个 <code>Light</code> 对象。此外，如果你需要向对象发送消息，可以用一个英文句号（<code>.</code>）将对象名和请求（即方法）连接起来。如果我们只是使用内置类，那么基本上关于对象编程的内容就是以上了。</p><p>此外，前面的图示遵循了<strong>统一建模语言</strong>（Unified Modeling Language, UML）的规范。在此规范下，每一个类都表示为一个方块，方块头部是类名，方块中部是你想要描述的<strong>数据成员</strong>，而<strong>方法</strong>（即该对象的函数，负责接收发送至对象的请求）则位居方块的底部。通常，UML 图中只会展示类名和公有方法，所以在上图的例子中，方块中部的内容并没有展示出来。如果你只关心类名，方块底部的内容也可以不显示。</p><h2 id="1-3-对象可以提供服务"><a href="#1-3-对象可以提供服务" class="headerlink" title="1.3　对象可以提供服务"></a>1.3　对象可以提供服务</h2><p>当你开发一个面向对象程序或理解其设计时，一个上佳的方法是将对象想象成“服务提供者”。你的程序本身也是为用户提供服务的，它通过使用其他对象提供的服务来做到这一点。所以，你的任务是创建（更好的情况是，从已有的库中找到）一些提供对应服务以解决问题的对象。</p><p>可以先从一个问题开始：“如果我能从魔术帽里变出一些对象，究竟什么对象才能解决我的问题呢？”比如，你要创建一个记账系统，于是你可能会需要一些预设的输入页面对象、负责计算的对象，以及连接各种打印机以打印支票和发票的对象。其中有些对象也许已经存在，那么其他不存在的对象应该是什么样的呢？它们应该提供哪些服务，同时它们还需要哪些其他对象的支持呢？如果继续深入的话，到了最后，你要么会说“编写这个对象的代码应该很简单”，要么会说“我确信这个对象早已存在”。这种将问题拆解为一系列对象的方法确实行之有效。</p><p>把对象视为服务提供商还有一个额外的好处，即提升了对象的聚合程度。说到这里，就需要提到软件设计领域中一个体现基础品质的术语——“高内聚性”（high cohesion），这指的是设计的组件（比如对象、方法或者对象库等）无论从哪个方面看都整合得很好。人们在设计对象时很容易犯的一个错误就是为对象添加太多的功能。例如，在一个打印支票的程序里，你一开始可能会认为需要一个既能排版又能打印的对象。然后，你发现这些功能对于一个对象而言太多了，其实你需要 3 个或者更多对象来负责这些功能。比如，一个对象包含了所有可能的打印布局，通过查找它可以知道如何打印一张支票。另一个或一组对象则作为通用打印接口，负责连接所有不同型号的打印机（但不负责记账，也许你需要购买该功能而非自行创建）。还有一个对象负责整合前两个对象提供的服务以完成打印任务。因此，每一个对象都提供了一种配套服务。在面向对象领域，出色的设计往往意味着一个对象只做好一件事，绝不贪多。这条原则不只适用于那些从外部购买的对象（比如打印接口对象），也适用于那些可复用的对象（比如支票排版对象）。</p><p>把对象视为服务提供商，不仅对你设计对象的过程有所帮助，也有利于他人阅读你的代码或复用这些对象。换句话说，如果别人因为对象提供的服务而认识到它的价值，那么他就会更加轻松地在自己的设计中使用这个对象。</p><h2 id="1-4-隐藏的实现"><a href="#1-4-隐藏的实现" class="headerlink" title="1.4　隐藏的实现"></a>1.4　隐藏的实现</h2><p>我们可以把程序员划分为两大阵营：一是“类的创建者”（负责创建新数据类型的人），二是“客户程序员” **$^3$**（在自己的应用程序里使用现有数据类型的人）。客户程序员的诉求是收集一个装满了各种类的工具箱，以便自己能够快速开发应用程序。而类的创建者则负责在创建新的类时，只暴露必要的接口给客户程序员，同时隐藏其他所有不必要的信息。为什么要这么做呢？这是因为，如果这些信息对于客户程序员而言是不可见的，那么类的创建者就可以任意修改隐藏的信息，而无须担心对其他任何人造成影响。隐藏的代码通常代表着一个对象内部脆弱的部分，如果轻易暴露给粗心或经验不足的客户程序员，就可能在顷刻之间被破坏殆尽。所以，隐藏代码的具体实现可以有效减少程序 bug。</p><blockquote><p>**$^3$**关于这个称谓，我需要感谢我的老朋友 Scott Meyers。</p></blockquote><p>所有的关系都需要被相关各方一致遵守的边界。当你创建了一个库，那么你就和使用它的客户程序员建立了一种关系。该客户程序员通过使用你的代码来构建一个应用，也可能将其用于构建成一个更大的库。如果一个类的所有成员都对所有人可见，那么客户程序员就可以恣意妄为，而且我们无法强制他遵守规定。也许你的预期是客户程序员不会直接操作任何类的成员，但是如果没有访问控制的话，你就无法实现这一点，因为所有的一切都暴露在对方面前了。</p><p>所以我们设置访问控制的首要原因就是防止客户程序员接触到他们本不该触碰的内容，即那些用于数据类型内部运转的代码，而非那些用于解决特定问题的接口部分。这种做法实际上为客户程序员提供了一种服务，因为他们很容易就可以知道哪些信息对他们来说是重要的，哪些则是无须关心的（请注意这也是一个富有哲理的决策。比如有些编程语言认为，如果程序员希望访问底层信息，就应该允许他们访问）。</p><p>设置访问控制的第二个原因则是，让类库的设计者在改变类的内部工作机制时，不用担心影响到使用该类的客户程序员。例如，你为了开发方便而创建了一个简单的类，之后你发现必须重写这个类以提升它的运行效率。如果接口部分和实现部分已经被分离和保护起来了，那么你就可以轻松地重写它。</p><p>Java 提供了 3 个显式关键字来设置这种访问控制，即 <code>public</code>、<code>private</code> 以及 <code>protected</code>。这些关键字叫作“访问修饰符”（access specifier），它们决定了谁可以使用修饰符之后的内容。<code>public</code>表示定义的内容可以被所有人访问。<code>private</code> 表示定义的内容只能被类的创建者通过该类自身的方法访问，而其他任何人都无法访问。所以，<code>private</code> 就是一道横亘在你和客户程序员之间的高墙，任何人从外部访问 <code>private</code> 数据都会得到一个编译时报错。最后，<code>protected</code> 类似于 <code>private</code>，两者的区别是继承的子类可以访问 <code>protected</code> 成员，但不可以访问 <code>private</code> 成员。至于继承的概念，本书稍后会讲述。</p><p>如果你不使用上述任意一种访问修饰符，Java 会提供一种“默认”访问权限，通常叫作“包访问”（package access），意思是一个类可以访问同一个包（库组件）里的其他类，但是如果从外部访问这些类的话，它们就像 <code>private</code> 内容一样不可访问了。</p><h2 id="1-5-复用实现"><a href="#1-5-复用实现" class="headerlink" title="1.5　复用实现"></a>1.5　复用实现</h2><p>如果一个类经过了充分测试，其代码就应该是有效且可复用的（理想情况）。不过，要实现这种复用性并不像想象的那么简单。创建可复用的对象设计需要大量的经验和洞见。然而，一旦你拥有了可复用的设计，不复用就可惜了。代码复用是我们使用面向对象编程的理由之一。</p><p>复用一个类最简单的方法是直接使用这个类所生成的对象，不过你也可以把这个对象放到另一个新类里面。新创建的类可以由任意数量和类型的对象组成，也可以任意组合这些对象，以满足想要的功能。因为利用已有的类组合成一个新的类，所以这个概念叫作“组合”（composition）。如果组合是动态的，通常叫作“聚合”（aggregation）。组合通常代表一种“有”（has-a）的关系，比如“汽车有发动机”（见下图）。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281506039.png"></p><blockquote><p>图中文字：<br>Car 汽车<br>Engine 发动机</p></blockquote><p>上图中用箭头表示了一辆汽车的组合关系。而我习惯用一种更简单的方式，即一条没有箭头的直线来表达两者之间的关联。**$^4$**</p><blockquote><p>**$^4$**这些信息对于大多数图来说已经足够了，也无须特别说明使用的是聚合还是组合。</p></blockquote><p>组合为我们提供了极大的灵活性。这些在你的类内部创建的对象通常具有 <code>private</code> 属性，所以其他使用这个类的客户程序员无法访问它们。这也意味着，就算我们修改了这些内部对象，也不会影响外部已有的代码。此外，你还可以在运行时改变这些内部对象，从而动态调整程序的行为。下一节要讲述的继承机制则不具备这种灵活性，因为编译器对使用继承创建的类设置了一些编译时的限制。</p><p>继承常被视为面向对象编程的重中之重，因此容易给新手程序员留下这样的印象：处处都应该使用继承。而实际上，这种全盘继承的做法会导致设计变得十分别扭和过于复杂。所以相比之下，在创建新类时应该首先考虑组合，因为使用组合更为简单灵活，设计也更为清晰简洁。一旦你拥有了足够的经验，何时使用继承就会变得非常清晰了。</p><h2 id="1-6-继承"><a href="#1-6-继承" class="headerlink" title="1.6　继承"></a>1.6　继承</h2><p>对象本身的理念是提供一种便捷的工具。对象可以根据定义的概念来封装数据和功能，从而展现给人们对应的问题空间的概念，而不是强迫程序员操作机器底层。在编程语言里，这些基础概念通过关键字 <code>class</code> 得以呈现。</p><p>然而，当我们大费周折才创建了一个类之后，如果不得不再创建一个与之前功能极为相近的类，这种滋味一定不太好受。如果我们能够复制现有的类，并且在该复制类的基础上再做一些增补的话，那就太妙了。实际上，这就是继承给我们带来的好处，除了一点：如果最初的类（叫作“基类”“超类”或“父类”）发生了变化，那么被修改的“复制”类（叫作“衍生类”“继承类”或“子类”）同样会发生变化（见下图）。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281506157.png"></p><blockquote><p>图字翻译：<br>Base 基类<br>Derived 子类</p></blockquote><p>上图中的箭头从子类指向其基类。之后你将看到，子类通常会有多个。</p><p>一个类呈现的内容不只是对象能做什么、不能做什么，它还可以关联其他的类。两个类可以拥有相同的行为和特征，但一个类可以比另一个类拥有更多的特征，以及处理更多的消息（或者用不同的方式处理消息）。继承通过基类和子类的概念来表述这种相似性，即基类拥有的所有特征和行为都可以与子类共享。也就是说，你可以通过基类呈现核心思想，从基类所派生出的众多子类则为其核心思想提供了不同的实现方式。</p><p>举个例子。一个垃圾收集器需要对垃圾进行分类。我们创建的基类是“垃圾”，具体的每一件垃圾都有各自不同的重量、价值，并且可以被切碎、溶解或者分解等。于是，更为具体的垃圾子类就出现了，并且带有额外的特征（比如，一个瓶子有颜色，一块金属有磁性等）和行为（比如你可以压扁一个铝罐）。此外，有些行为还可以产生不同的效果（比如纸质垃圾的价值取决于它的类型和状态）。通过继承，我们创建了一种“类型层次”（type hierarchy）以表述那些需要根据具体类型来解决的问题。</p><p>还有一个常见的例子是形状，你可能在计算机辅助设计系统或模拟游戏中碰过到。具体来说，基类就是“形状”（<code>Shape</code>），而每一个具体的形状都具有大小、颜色、位置等信息，并且可以被绘制（<code>draw()</code>）、清除（<code>erase()</code>）、移动（<code>move()</code>）、着色（<code>getColor</code> 或 <code>setColor</code>）等。接下来，基类 <code>Shape</code> 可以派生出特定类型的形状，比如圆形（<code>Circle</code>）、矩形（<code>Square</code>）、三角形（<code>Triangle</code>）等，每一个具体形状都可以拥有额外的行为和特征，比如某些形状可以被翻转（见下图）。有些行为背后的逻辑是不同的，比如计算不同形状的面积的方法就各不相同。所以，类型层次既体现了不同类之间的相似性，又展现了它们之间的差异。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281505322.png"></p><p>问题和解决方案都使用相同的表达方式是非常有用的，因为这样就不再需要一个中间模型将问题翻译为解决方案。在面向对象领域，类型层次是该模型的一个重要特征，它让你可以方便地从现实世界中的系统转换到代码世界的系统。不过现实情况是，有些人由于习惯了复杂的解决方案，因此对于面向对象的简约性反而会有些不适应。</p><p>继承已有的类将产生新类。这个新的子类不但会继承其基类的所有成员（虽然 <code>private</code> 成员是隐藏且不可访问的），而且更重要的是，子类也会继承基类的接口。也就是说，所有基类对象能够接收的消息，子类对象也一样能够接收。我们可以通过一个类所接收的消息来确定其类型，所以从这一点来说，子类和基类拥有相同的类型。引用之前的例子，就是“圆形是一个形状”。所以，掌握这种通过继承表现出来的类型相同的特性，是理解面向对象编程的基础方法之一。</p><p>既然基类和子类拥有相同的基础接口，就必然存在接口的具体实现。这意味着，当一个对象接收到特定的消息时，就会执行对应的代码。如果你继承了一个类并且不做任何修改的话，这个基类的方法就会原封不动地被子类所继承。也就是说，子类的对象不但和基类具有相同的类型，而且不出所料的是，它们的行为也是相同的。</p><p>有两种方法可以区分子类和基类。第一种方法非常简单直接：为子类添加新的方法（见下图）。因为这些方法并非来自基类，所以背后的逻辑可能是，基类的行为和你的预期不符，于是你添加了新的方法以满足自己的需求。有时候，继承的这种基础用法能够完美地解决你面临的问题。不过，你需要慎重考虑是否基类也需要这些新的方法（还有一个替代方案是考虑使用“组合”）。在面向对象编程领域里，这种对设计进行发现和迭代的情况非常普遍。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281505835.png"></p><p>虽然有时候继承意味着需要为子类添加新的方法[Java 尤其如此，其用于继承的关键字就是“扩展”（<code>extends</code>）]，但这不是必需的。还有一种让新类产生差异化的方法更为重要，即修改基类已有方法的行为，我们称之为“重写”该方法（见下图）。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281505375.png"></p><p>如果想要重写一个方法，你可以在子类中对其进行重新定义。也就是说，你的预期是“我想通过相同的接口调用该方法，但是我希望它可以在新的类中实现不同的效果”。</p><h3 id="is-a关系与is-like-a关系"><a href="#is-a关系与is-like-a关系" class="headerlink" title="is-a关系与is-like-a关系"></a>is-a关系与is-like-a关系</h3><p>继承机制存在一个有待商榷的问题：<strong>只应该</strong>重写基类中定义的方法吗？（并且不能添加基类中不存在的新方法）如果是，就意味着子类和基类的类型是<strong>完全</strong>相同的，因为它们的接口一模一样。结果就是，你可以直接用子类的对象代替基类的对象。这种<strong>纯替换关系</strong>通常叫作“替换原则” **$^5$**。从某种意义上说，这是一种理想的继承方式。这种情况下基类和子类之间的关系通常叫作“is-a”关系，意思是“A 是 B”，比如“圆形是一个形状”。甚至有一种测试是否是继承关系的方法是，判断你的类之间是否满足这种“is-a”关系。</p><blockquote><p>**$^5$**也叫作“里氏替换原则”（Liskov Substitution Principle），这一理论最初由 Barbara Liskov 提出。</p></blockquote><p>有时候，你会为子类的接口添加新的内容，从而扩展了原有的接口。在这种情况下，子类的对象依然可以代替基类的对象，但是这种代替方案并不完美，因为不能通过基类的接口获取子类的新方法。我将这种关系描述为“is-like-a”关系（这是我自创的词），意思是“A 像 B”，即子类在拥有基类接口的同时，也拥有一些新的接口，所以不能说两者是完全等同的。以空调为例，假设你的房间里已经安装了空调，也就是拥有能够降低温度的接口。现在发挥一下想象力，万一空调坏了，你还可以用热泵作为替代品，因为热泵既可以制冷也可以制热（见下图）。在这种情况下，热泵“就像是”空调，只不过热泵能做的事情更多而已。此外，由于设计房间的温度控制系统时，功能仅限于制冷，所以系统和新对象交互时也只有制冷的功能。虽然新对象的接口有所扩展，但现有系统也只能识别原有的接口。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281505457.png"></p><blockquote><p>图字翻译<br>Thermostat 恒温器<br>Controls 控制<br>Cooling System 制冷系统<br>Air conditioner 空调<br>Heat Pump 热泵</p></blockquote><p>观察上图你就能知道，基类“制冷系统”通用性并不高，最好可以将其改名为“温度调节系统”，使其同时包含制热功能。这样一来，之前提及的替换原则就可以派上用场了。不过话说回来，这张图也反映了真实世界中的设计方式。</p><p>当你充分理解了替换原则之后，可能会认为这种纯替换方式才是唯一正确的方式。如果你的设计能够应用纯替换原则，那就<strong>太棒了</strong>。然而实际情况是，你会发现经常需要为子类的接口添加新方法。只要稍加观察，就很容易分辨出这两种情况的应用场合。</p><h2 id="1-7-多态"><a href="#1-7-多态" class="headerlink" title="1.7　多态"></a>1.7　多态</h2><p>在编程中涉及类型层次时，我们通常会将一个对象视为其基类的一个实例，而不是对象实际的类。这种方式可以让你在编写代码时不依赖于具体的类。在形状的例子中，方法都是作用于通用的形状，而不需要关心该形状具体是圆形、矩形、三角形，还是一个没有明确定义的形状。因为所有的形状都可以被绘制、清除、移动，所以当这些方法发送消息至对象的时候，就无须关注对象是如何处理这条消息的。</p><p>当我们添加新的类时，这些代码是不受影响的，添加新的类可以扩展面向对象程序的能力，从而能够处理一些新的情况。比如，你为基类“形状”创建了一个子类“五边形”，并且不改变那些基于通用形状的方法。这种通过派生子类就可以轻松扩展程序设计的能力，是封装变化的一种基础方式。这种方式在改善设计的同时，也降低了软件维护的成本。</p><p>当你尝试用派生的子类替代通用基类（比如，把圆形当作形状，把自行车当作交通工具，把鸬鹚当作鸟等）时会发现一个问题，即调用方法来绘制这个通用的形状、驾驶这辆通用的交通工具或者让这只鸟飞翔时，编译器并不知道在编译时具体需要执行哪一段代码。那么重点来了，当消息被发送时，程序员并不<strong>关心</strong>具体执行的是哪一段代码。也就是说，当负责绘制的方法应用于圆形、矩形或者三角形时，这些对象将能够根据其类型执行对应的正确代码。</p><p>如果你并不关心具体执行的是哪一段代码，那么当你添加新的子类时，即使不对其基类的代码做任何修改，该子类实际执行的代码可能也会有所不同。但如果编译器无法得知应该具体执行哪一段代码，它会怎么做呢？比如下图中的 <code>BirdController</code> 对象，它可以和通用的 <code>Bird</code> 对象协同工作，同时它并不知道这些对象具体是什么类型的鸟。对于 <code>BirdController</code> 来说，这种方式非常方便，因为它无须额外编写代码来确定这些对象的具体类型和行为。那么问题来了，当一个 <code>Bird</code> 对象的 <code>move()</code> 方法被调用时，如果我们并不清楚其具体的类型，该如何确保最终执行的是符合预期的正确行为呢[比如 <code>Goose</code> 对象执行的是行走、飞翔或游泳，<code>Penguin</code> 对象则是移动或游泳；见下图]？</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281505516.png"></p><hr><blockquote><p>图字翻译<br>What happens when move() is called？<br>如果move()被调用，究竟会发生什么呢？</p></blockquote><hr><p>答案来自继承机制的一种重要技巧：编译器并非通过传统方式来调用方法。对于非面向对象编译器而言，其生成的函数调用会触发“前期绑定”（early binding），这是一个你可能从来都没听说过的词，因为你从未考虑过使用这种方式。前期绑定意味着编译器会生成对一个具体方法名的调用，该方法名决定了被执行代码的绝对地址。但是对于继承而言，程序直到运行时才能明确代码的地址，所以就需要引入其他可行的方案以确保消息可以顺利发送至对象。</p><p>为了解决上面提及的问题，面向对象语言使用的机制是“后期绑定”（late binding）。也就是说，当你向某个对象发送消息时，直到运行时才会确定哪一段代码会被调用。编译器会确保被调用的方法是真实存在的，并对该方法的参数和返回值进行类型检查，但是它并不知道具体执行的是哪一段代码。</p><p>为了实现后期绑定，Java 使用了一些极为特殊的代码以代替直接的函数调用，这段代码使用存储在对象中的信息来计算方法体的地址（第 9 章会详细地描述这个过程）。其结果就是，在这些特殊代码的作用下，每一个对象会有不同的表现。通俗地讲，当你向一个对象发送消息时，该对象自己会找到解决之道。</p><p>顺便一提，在某些编程语言里，你必须显式地为方法赋予这种后期绑定特性。比如，C++ 使用 <code>virtual</code> 关键字来达到此目的。在这些编程语言中，方法<strong>并不</strong>默认具备动态绑定特性。不过，Java 默认具备动态绑定特性，所以你无须借助于其他关键字或代码来实现多态。</p><p>我们再来看一下形状的例子。之前的图中展示了一些形状的类（这些类都基于统一的接口），为了更好地描述多态，我们编写一小段只关注基类而不关注具体子类的代码。由于这段代码<strong>不关注</strong>类的细节，因此非常简单易懂。此外，如果我们通过继承添加了一个新的子类“六边形”，我们的代码仍然适用于这个新的 <code>Shape</code> 类，就像适用于其他已有子类一样。因此可以说，这段程序具备<strong>扩展性</strong>。</p><p>如果你用 Java 编写一个方法（你马上就会学到具体应该怎么做）：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">void</span> doSomething(Shape <span class="hljs-built_in">shape</span>) &#123;<br>  <span class="hljs-built_in">shape</span>.erase();<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">shape</span>.<span class="hljs-title">draw</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法适用于任何 <code>Shape</code> 对象，所以它不关心进行绘制和清除的对象具体是什么类型。如果程序的其他地方调用了 <code>doSomething()</code> 方法，比如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Circle circle = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Circle()</span>;<br>Triangle triangle = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Triangle()</span>;<br>Line line = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Line()</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">circle</span>)</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">triangle</span>)</span>;<br><span class="hljs-keyword">do</span><span class="hljs-constructor">Something(<span class="hljs-params">line</span>)</span>;<br></code></pre></td></tr></table></figure><p>不管对象具体属于哪个类，<code>doSomething()</code> 方法都可以正常运行。</p><p>简直妙不可言。我们再看这一行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">doSomething(circle);<br></code></pre></td></tr></table></figure><p>在这段代码里，原本我们需要传递一个 <code>Shape</code> 对象作为参数，而实际传递的参数却是一个 <code>Circle</code> 类的对象。因为 <code>Circle</code> 也是一个 <code>Shape</code>，所以 <code>doSomething()</code> 也可以接受 <code>Circle</code>。也就是说，<code>doSomething()</code> 发送给 <code>Shape</code> 对象的任何消息也可以发送给 <code>Circle</code> 对象。这是一种非常安全且逻辑清晰的做法。</p><p>这种将子类视为基类的过程叫作“向上转型”（upcasting）。这里的“转型”指的是转变对象的类型，而“向上”沿用的是继承图的常规构图，即基类位于图的顶部，数个子类则扇形分布于下方。因此，转变为基类在继承图中的路径就是一路向上，也就叫作“向上转型”。</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/202110281505699.png"></p><hr><blockquote><p>图字翻译：<br>“Upcasting”：“向上转型”</p></blockquote><hr><p>面向对象程序总会包含一些向上转型的代码，因为这样就可以让我们无须关心对象具体的类是什么。再看一下 <code>doSomething()</code> 方法中包含的代码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">shape</span>.erase();<br><span class="hljs-comment">// ...</span><br><span class="hljs-built_in">shape</span>.<span class="hljs-title">draw</span>();<br></code></pre></td></tr></table></figure><p>需要注意的是，代码并没有告诉我们，“如果是一个 <code>Circle</code> 请这样做，如果是一个 <code>Square</code> 请那样做，诸如此类”。如果你真的编写了一段代码用于检查所有可能出现的形状，那么这段代码必然是一团糟，并且每当你为 <code>Shape</code> 添加一个新的子类时，都必须修改这段代码。所以，上面的代码实际上做的是：“这是一个 <code>Shape</code>，我知道它可以进行绘制和清除，那就这么干吧，具体细节交给形状自己处理就好”。</p><p><code>doSomething()</code> 方法的神奇之处在于，代码运行的结果是符合预期的。如果直接通过 <code>Circle</code>、<code>Square</code> 或者 <code>Line</code> 对象调用 <code>draw()</code> 方法，运行的代码自然是不同的。如果调用 <code>draw()</code> 方法时并不知道 <code>Shape</code> 对象的具体类型，它也能正常工作，即执行其实际子类的代码。这一点十分了不起，因为当 Java 编译器编译 <code>doSomething()</code> 的代码时，它并不知道对象的类型是什么。通常来说，你可能会想当然地认为被调用的是基类 <code>Shape</code> 的 <code>erase()</code> 和 <code>draw()</code> 方法，而非具体的 <code>Circle</code>、<code>Square</code> 或者 <code>Line</code> 子类，然而实际情况是，确实是具体的子类被调用了，这就是多态。编译器和运行时系统负责处理各种细节，你需要了解的就是多态机制的存在，更重要的是要知道如何利用多态进行设计。当你向一个对象发送消息时，哪怕需要用到向上转型，该对象也能够正确地处理该消息。</p><h2 id="1-8-单根层次结构"><a href="#1-8-单根层次结构" class="headerlink" title="1.8　单根层次结构"></a>1.8　单根层次结构</h2><p>自从 C++ 语言出现以来，面向对象中是否所有的类都应该默认继承自某个基类的问题变得尤为突出。Java 则给出了肯定的答案（<strong>除了</strong> C++ 以外，实际上几乎所有动态面向对象编程语言都是如此），这个终极基类的名字是 <code>Object</code>。</p><p>这种“单根层次结构”（singly-rooted hierarchy）具备很多明显的优势。由于所有对象都具有共同的接口，因此它们都属于同一个终极基类。另一种方案（来自 C++）则无法确保所有对象都属于同一个基类。从向后兼容的角度来看，这种限制性较小的设计方式对C语言更为友好，但是从完全的面向对象编程的角度来看，你就必须自己手动构建类的层次，这样才能拥有其他面向对象编程语言默认提供的便捷性。此外，你在使用任何新的库时，都有可能遇到一些不兼容的接口。如果你希望这些接口为你所用，就必须额外花费一些精力来改造它们。所以，C++ 这种额外的“灵活性”真的物有所值吗？如果需要的话，比如你已经花费了大量心血编写C语言代码，那么答案就是肯定的。而如果你是从头开始，那么使用 Java 或者其他替代方案则会高效许多。</p><p>单根层次结构有利于实现垃圾收集器（garbage collector），这也是 Java 对比 C++ 的一个重要改进。既然所有对象都拥有类型信息，你就再也不用发愁不知道某个对象具体是什么类型了。这一特性对于系统级别的操作而言尤为重要，比如异常处理（exception handling，一种用于处理错误的语言机制）等，同时也极大地提升了编程时的灵活性。</p><h2 id="1-9-集合"><a href="#1-9-集合" class="headerlink" title="1.9　集合"></a>1.9　集合</h2><p>一般来说，你并不知道解决一个特定的问题需要用到多少个对象，也不知道这些对象会存在多久，你甚至不知道该如何保存这些对象。问题是，如果你无法在程序运行前确切地知道这些信息，那你应该申请多少内存空间呢？</p><p>在面向对象设计领域，大多数问题的解决方案看似极为简单粗暴：创建一种新类型的对象，这种对象通过保存其他对象的引用来解决这个问题。而在大多数编程语言里，你也可以用<strong>数组</strong>（array）做到这一点。</p><p>这种新对象通常叫作<strong>集合</strong>（也可以叫做“容器”，不过 Java 的库普遍使用的是“集合”），它会根据你放入其中的内容自行调整空间。也就是说，你无须关注集合里会有多少对象，直接创建集合就好了，剩下的细节交给它自己处理就可以。</p><p>幸运的是，优秀的面向对象语言都会提供一些集合作为语言的基础功能。在 C++ 里，集合是 C++ 标准库的一部分，通常叫作“标准模板库”（Standard Template Library, STL）。SmallTalk 提供了一系列完整的集合。Java 在其标准库中也提供了大量的集合。在有些语言的库中，通常会有一两个集合能够适用于所有需求。而在另外一些语言（比如 Java）的库中，不同的集合具有不同的用途。比如，有几个不同的 <code>List</code> 类（用于保存序列），几个 <code>Map</code> 类（也叫“关联数组”，用于关联对象），几个 <code>Set</code> 类（用于保存不同类型的对象），以及一些队列（queue）、树（tree）、栈（stack）等。</p><p>从程序设计的角度而言，你真正需要的是能够解决实际问题的集合。一旦某种集合能够满足你的需求，你就不再需要其他集合了。之所以需要选择集合，可能有以下两个原因。</p><ol><li>不同的集合提供了不同类型的接口和行为。比如，栈和队列的用途就与 <code>Set</code> 以及 <code>List</code> 完全不同。针对你的问题，其中的某个集合也许可以提供比另一个集合更灵活的解决方案。</li><li>不同的集合在特定操作的执行效率方面也会有差异。比如，<code>List</code> 有两种基础类型的集合：<code>ArrayList</code> 和 <code>LinkedList</code>。虽然两者可以具有相同的接口和行为，但是某些操作的执行效率却存在明显的差异。比如用 <code>ArrayList</code> 随机获取元素是一种耗费固定时间的操作，意思是不管你选择获取哪个元素，耗费的时间都是相同的。但是对于 <code>LinkedList</code> 来说，在列表中随机选择元素是一种代价很大的操作，查找列表更深处的元素也会耗费更多的时间。另外，如果需要在列表中插入元素，<code>LinkedList</code> 耗费的时间会比 <code>ArrayList</code> 更少。取决于两者底层架构的不同实现方式，其他一些操作的执行效率也各有不同。你也可以先用 <code>LinkedList</code> 编写代码，然后为了追求效率而转投 <code>ArrayList</code> 的怀抱。由于两者都是基于 <code>List</code> 接口的子类，因此只需要改动少量代码就可以切换集合。</li></ol><h3 id="参数化类型（泛型）"><a href="#参数化类型（泛型）" class="headerlink" title="参数化类型（泛型）"></a>参数化类型（泛型）</h3><p>在 Java 5 之前，Java 语言的集合所支持的是通用类型 <code>Object</code>。因为单根层次结构决定了所有对象都属于 <code>Object</code> 类型，所以一个持有 <code>Object</code> 的集合就可以持有任何对象**$^6$**，这就使得集合十分易于复用。</p><p><strong>6</strong>其实并不能保存原始类型，不过“自动装箱”（autoboxing）机制从某种程度上缓解了这个问题。相关细节将在后续章节介绍。</p><p>为了使用这样一个集合，你要将对象引用添加到集合中，然后再将其取出。但由于该集合只能持有 <code>Object</code> 类型，因此当你添加一个对象引用到集合时，该对象会向上转型为 <code>Object</code>，从而失去了其原本的特征。当你需要将其取出时，会获得一个 <code>Object</code> 类型的对象引用，这就不是当初的类型了。那么问题来了，当初被放入集合中的对象如何才能转换回原来的类型呢？</p><p>这里需要再一次用到转型，只不过这次不是向上转为更通用的类型，而是向下转为更具体的类型，这种转型叫作“向下转型”（downcasting）。当使用向上转型时，我们知道 <code>Circle</code> 对象属于 <code>Shape</code> 类型，所以这种向上转型是安全的。但是反过来，我们并不知道一个 <code>Object</code> 对象实际上是 <code>Circle</code> 还是 <code>Shape</code> 类型，所以除非你明确知道对象的具体类型是什么，否则向下转型是不安全的。</p><p>不过，也不是说向下转型一定是危险的。如果向下转型失败，你会得到一个运行时的错误提示，这叫作“异常”（exception），后面你很快就会看到相关的介绍。不过话说回来，当你从集合中获取对象引用时，需要通过一些方法明确对象的类型，这样的话才能正确的向下转型。</p><p>当一段程序在运行时，向下转型和与其关联的运行时检查都会耗费额外的时间，同时程序员也需要关注这种向下转型。为什么我们创建的集合就不能明确地知道所包含的对象类型呢？如果知道的话，我们就不再需要向下转型，也避免了在此期间可能出现的报错。这个问题的解决方案就是“参数化类型”（parameterized type）机制。一个被参数化的类型是一种特殊的类，可以让编译器自动适配特定的类型。比如，对于参数化的集合而言，编译器可以将集合定义为只接受放入 <code>Shape</code> 的对象，因此从集合也只能取出 <code>Shape</code> 对象。</p><p>Java 5 新增的主要特性之一是支持参数化类型，也叫作“泛型”（generics）。你可以通过在一对尖括号中间加上类名来定义泛型，比如，你可以这样创建一个放置 <code>Shape</code> 对象的 <code>ArrayList</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">ArrayList<span class="hljs-tag">&lt;<span class="hljs-name">Shape</span>&gt;</span> shapes = new ArrayList<span class="hljs-tag">&lt;&gt;</span>();<br></code></pre></td></tr></table></figure><p>泛型带来的好处促使许多标准库组件都进行了相应的调整。此外，你在本书所列举的许多代码示例中都会看到泛型的作用。</p><h2 id="1-10-对象的创建和生命周期"><a href="#1-10-对象的创建和生命周期" class="headerlink" title="1.10　对象的创建和生命周期"></a>1.10　对象的创建和生命周期</h2><p>和对象打交道时有一个至关重要的问题，那就是它们的创建和销毁方式。每个对象的创建都要消耗一些资源，尤其是内存资源。当我们不再需要一个对象时，就要及时清理它，这样它占用的资源才能被释放并重复使用。在一些环境简单的场景下，清理对象似乎不是一个难题：你创建了一个对象，根据自己的需要使用，不再使用的时候就将其销毁。然而不幸的是，我们经常会遇到更为复杂的情况。</p><p>假设你需要为某个机场设计一个航空管制系统（你也可以用同样的方式管理仓库中的箱子、录像带租赁系统，甚至还有装宠物的笼子）。刚开始的时候，一切都是如此简单：新建一个用于保存飞机对象的集合，然后每当有飞机需要进入航空管制区域的时候，就新建一个飞机对象并将其放入集合中。而每当有飞机离开航空管制区域时，就清理对应的飞机对象。</p><p>再做一个假设：还有其他系统也会记录飞机的数据，而这些数据不需要像主控制程序那样及时更新，比如只会对离开机场的小型飞机做记录。于是，你需要创建一个新的集合用于保存小飞机对象，并且每当新建的飞机对象是小型飞机时，需要将其放入这个新的集合中。当有后台进程处于空闲状态时，就会操作这些对象。</p><p>现在问题变得更加棘手了，你怎么判断什么时候需要清理对象？当你不再需要一个对象时，系统的其他部分也许还在使用该对象。更糟糕的是，在许多其他情况下也会遇到同样的问题。而对于诸如 C++ 这样需要显式删除对象的编程语言来说，这绝对是一个相当让人头疼的问题。</p><p>对象的数据保存在哪里，系统又是如何控制对象的生命周期的呢？C++ 语言的宗旨是效率优先，所以它交给程序员来选择。如果要最大化运行时效率，可以通过栈区（也叫作“自动变量”或“局部变量”）保存对象，或者将对象保存在静态存储区里，这样在编写程序时就可以明确地知道对象的内存分配和生命周期。这种做法会优先考虑分配和释放内存的速度，在有些情况下是极为有利的。但是，代价就是牺牲了灵活性，因为你必须在编写代码时就明确对象的数量、生命周期以及类型。如果你希望解决一个更为普遍的问题，比如计算机辅助设计、仓库管理或者航空管制等，这种做法的限制性就太大了。</p><p>还有一种方案是在内存池里动态创建对象，这个内存池叫作“堆”（heap）。如果使用这个方案，直到运行时你才能知道需要多少对象，以及它们的生命周期和确切的类型是什么。也就是说，这些信息要等到程序运行时才能确定。如果你需要创建一个新对象，可以直接通过堆来创建。因为堆是在运行时动态管理内存的，所以堆分配内存所花费的时间通常会比栈多一些（不过也不一定）。栈通常利用汇编指令向下或向上移动栈指针（stack pointer）来管理内存，而堆何时分配内存则取决于内存机制的实现方式。</p><p>动态创建对象的方案基于一个普遍接受的逻辑假设，即对象往往是复杂的。所以在创建对象时，查找和释放内存空间所带来的额外开销不会造成严重的影响。此外，更大的灵活性才是解决常规编程问题的关键。</p><p>Java 只允许动态分配内存<strong>7</strong>。每当你创建一个对象时，都需要使用 <code>new</code> 操作符创建一个对象的动态实例。</p><p><strong>7</strong>你之后将学习到的原始类型（primitive type）是一个特例。</p><p>然而还有另一个问题——对象的生命周期。对于那些允许在栈上创建对象的编程语言，编译器会判断对象将会存在多久以及负责自动销毁该对象。但是如果你是在堆上创建对象，编译器就无从得知对象的生命周期了。对于像 C++ 这样的语言来说，你必须在编码时就明确何时销毁对象，否则万一你的代码出了差错，就会造成内存泄漏。而 Java 语言的底层支持<strong>垃圾收集器</strong>（garbage collector）机制，它会自动找到无用的对象并将其销毁。垃圾收集器带来了很大的便利性，因为它显著减少了你必须关注的问题数量以及需要编写的代码。因此，垃圾收集器提供了一种更高级的保障以防止潜在的内存泄漏，而正是内存泄漏导致了许多 C++ 项目的失败。</p><p>Java 设计垃圾收集器的意图就是处理内存释放的相关问题（虽然不包括清理对象所涉及的其他内容）。垃圾收集器“知道”一个对象何时不再有用，并且会自动释放该对象占用的内存。再加上所有对象都继承自顶层基类 <code>Object</code>，以及只能在堆上创建对象等特点，使得 Java 编程比 C++ 简单了不少。一言以蔽之，需要你介入的决策和阻碍都大大减少了。</p><h2 id="1-11-异常处理"><a href="#1-11-异常处理" class="headerlink" title="1.11　异常处理"></a>1.11　异常处理</h2><p>自从有编程语言起，错误处理就是一项极为困难的工作。设计一个优秀的错误处理系统是如此困难，以至于许多编程语言忽视了这个问题，而将问题抛给库的设计者。这些设计者只能采取一些折中措施来填补漏洞，这些举措虽然在有很多场景中都有效，但很容易通过忽略提示的错误而轻易绕过。大多数错误处理方案存在的一个显著的问题是，这些方案并非编程语言强制要求的，而是依赖于程序员同意并遵守相关约定。如果遇到警惕性不高的程序员（通常都是因为需要赶进度而放松了警惕），这些方案就形同虚设了。</p><p><strong>异常处理</strong>则是将编程语言甚至是操作系统和错误处理机制直接捆绑在一起。异常是从错误发生之处“抛出”的对象，而根据错误类型，它可以被对应的异常处理程序所“捕获”。而每当代码出现错误时，似乎异常处理机制会使用一条特殊的、并行的执行路径来处理这些错误。这是因为它确实采取了一条单独的运行路径，所以不影响正常执行的代码。同时这一点也降低了你编写代码的成本，因为你不用经常反复检查各种错误了。此外，抛出的异常也不同于方法返回的错误值或者方法设置的错误标识，因为这两者是可以被忽略的，但是异常不允许被忽略，所以这就确保了异常一定会在必要的时候被处理。最后，异常为我们提供了一种可以让程序从糟糕的情况中恢复过来的方法。即便发生了意外，我们也还有机会修正问题以及让程序重新恢复运行，而不是只能结束程序了事，而这一点无疑会增强许多程序的稳健性。</p><p>Java 的异常处理机制在众多编程语言之中几乎可以说是鹤立鸡群，这是因为 Java 从一开始就内置了异常处理，并且强制你必须使用它，这一点没有任何商量的余地，同时这也是Java唯一允许的报错方式。如果你的代码没有正确地处理各种异常，就会得到一条编译时的报错消息。这种有保障的一致性使得错误处理的工作简单了许多。</p><p>值得我们留意的是，虽然面向对象语言里的异常一般用对象的形式来呈现，异常处理却并不是面向对象语言的特性。其实，异常处理远在面向对象语言诞生之前就已经存在了。</p><h2 id="1-12-总结"><a href="#1-12-总结" class="headerlink" title="1.12　总结"></a>1.12　总结</h2><p>一段过程式程序（procedural program）包含了数据定义和函数调用。如果你想要搞清楚这种程序究竟做了什么，就必须仔细研究，比如查看它的函数调用以及底层代码等，以便在你的脑海中勾勒出一幅完整的蓝图。而这就解释了在设计过程式程序时，为什么还需要中间表示（intermediate representation, IR）。实话实说，过程式程序的理解成本确实很高，因其设计的表达方式更多是面向计算机，而不是你要解决的问题。</p><p>因为面向对象编程在过程式编程语言的基础上增加了许多新特性，所以你可能会想当然地认为同等效果的 Java 程序会远比过程式程序复杂。然而你会惊喜地发现，编写良好的 Java 程序通常比过程式程序更简单，也更易于理解。这是因为在 Java 中，对象的定义所呈现的是问题空间（而非计算机式的呈现）的概念，而发送至对象的消息则代表问题空间的具体活动。面向对象编程的一个令人愉悦之处在于，那些设计良好的程序，其代码总是易于阅读的。另外，因为许多问题都能够通过复用已有的库来解决，所以通常来说代码行数也不会太多。</p><p>面向对象编程和 Java 不一定适合所有人。有一点非常重要，那就是你必须仔细评估自己的需求，然后再判断 Java 是不是满足这些需求的最佳方案，也许使用其他编程语言是更好的选择（说不定就是你现在使用的编程语言）。如果在可预见的将来，你的需求非常专业并且具有一些 Java 无法满足的特殊条件，那么你就有必要研究一下其他可代替的编程语言（我尤其推荐 Python）。这样一来，就算你依然选择 Java 作为你的编程语言，至少你清楚还有哪些可选项，以及为什么选择它。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第-1-章-什么是对象&quot;&gt;&lt;a href=&quot;#第-1-章-什么是对象&quot; class=&quot;headerlink&quot; title=&quot;第 1 章　什么是对象&quot;&gt;&lt;/a&gt;第 1 章　什么是对象&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“我们并未意识到惯用语言结构的强大之处。甚</summary>
      
    
    
    
    <category term="Books" scheme="http://www.ckxgzxa.top/categories/Books/"/>
    
    
    <category term="OnJava8" scheme="http://www.ckxgzxa.top/tags/OnJava8/"/>
    
  </entry>
  
  <entry>
    <title>本书导读</title>
    <link href="http://www.ckxgzxa.top/2-Introduction"/>
    <id>http://www.ckxgzxa.top/2-Introduction</id>
    <published>2021-10-28T06:53:31.000Z</published>
    <updated>2021-10-28T06:58:01.954Z</updated>
    
    <content type="html"><![CDATA[<h1 id="本书导读"><a href="#本书导读" class="headerlink" title="本书导读"></a>本书导读</h1><blockquote><p>“我的语言之局限，即我的世界之局限。”</p><p>​                                                   ——Ludwig Wittgenstein（1889—1951）</p></blockquote><p>这句话不仅适用于我们日常读写的语言，也适用于编程语言。很微妙的一件事是，一门语言会悄然无息地引导你进入某种思维模式，同时远离其他思维模式。Java尤其如此。</p><p>Java是一门派生语言。当时的情况是，早期的语言设计师不想用C++来开发项目，于是创建了一门和C++极为相似的新编程语言，不过也做出了一些改进（遗憾的是，他们的项目最终没有上线）。这种新编程语言最主要的改动是加入了<strong>虚拟机</strong>和<strong>垃圾收集</strong>机制，本书后续章节会对这两点进行详细介绍。此外，Java还在其他方面推动着行业的持续发展，比如现在大多数语言应该支持文档标记语法，以及生成HTML文档的工具。</p><p>Java最主要的概念之一来自SmallTalk，这门语言强调“对象”（详细内容请见第1章）是编程的基本单位，所以任何一个东西都必须是对象。经历过长时间的洗礼之后，这个概念被证明是有些激进的，有些人甚至断定对象的概念是彻头彻尾的失败，应该果断丢弃。我个人认为，把所有内容都封装为对象不仅是一种负担，而且还会将许多程序设计推向错误的方向。然而不可否认的是，在一些情况下对象依然十分有用。所以，将一切都封装为对象（尤其是深入到最底层的时候）是一种设计失误，而完全抛弃对象同样太过极端。</p><p>Java还有一些决策也没有达成预期目标。关于这一点，本书中会陆续加以说明，以确保你不但可以理解这些语言特性，还能明白为什么你会觉得如鲠在喉。我并不是要将Java盖棺定论为一门优秀或拙劣的语言，我想表达的是，当了解了一门语言的不足之处和局限性之后，你将能够做到以下两点。</p><ol><li>当遇到某个语言特性不可用时，不会被卡住以致无法继续。</li><li>因为了解局限性所在，所以可以更好地进行程序设计和编程。</li></ol><p>编程是一门管理复杂性的艺术，而问题的复杂程度取决于机器的复杂程度。由于这种复杂性的存在，导致了大多数编程项目的失败。</p><p>许多编程语言在设计时充分考虑了复杂性的问题，然而有时候，其他问题才是更为本质的问题。几乎不可避免的是，那些“其他问题”才是让使用该语言的程序员最终碰壁的原因。例如，C++语言不得不向后兼容C语言（这是为了让C语言程序员更容易上手），同时还要保证运行效率。不可否认的是，这两者都是非常实用的设计目标，并且成了C++语言获得成功的功臣。但是随之也带来了大量额外的复杂性，使得许多项目因此而失败。当然，你可以责备程序员技艺不精或者管理方式有问题，但是如果一门语言可以协助你捕获程序中的错误，那么何乐而不为呢？</p><p>Visual Basic（VB）语言依赖于BASIC语言，而BASIC语言本身并不是一种扩展性良好的语言。这导致VB在扩展时经常出现各种非常难以维护的语法。Perl语言能够向后兼容<code>awk</code>、<code>sed</code>、<code>grep</code>以及其他UNIX工具，然而这些旧时代的工具本身就是需要被替换和更新的。结果就是，Perl程序里面充斥着大量的“只读代码”（意思是你自己都搞不懂自己写的代码是什么意思）。不过话说回来，C++、VB、Perl以及其他一些语言（比如SmallTalk）都提供了一些能够处理复杂性的设计方案，并且从解决特定问题的角度来看，它们做得还相当不错。</p><p>信息革命让我们所有人可以更为便捷地交流，不管是一对一、群组对群组还是星球对星球。我听说下一次革命将促生一个由足够多的人和连接组合而成的全球化的大脑。Java会不会成为这种革命所需的工具之一呢？一切皆有可能。</p><h2 id="阅读前提"><a href="#阅读前提" class="headerlink" title="阅读前提"></a>阅读前提</h2><p>本书假设你有一定的编程基础，即你应该了解以下内容。</p><ul><li>程序是一些计算机语句的集合。</li><li>子程序、函数、宏的概念。</li><li>了解<code>if</code>等控制语句，以及<code>while</code>等循环结构的用法。</li><li>其他相关知识点。</li></ul><p>也许你已经通过学校、图书或者互联网掌握了以上知识点。只要你能够理解编程的基本概念，就可以顺畅地阅读本书了。</p><p>如果你对以上基本概念不甚了解的话，可以通过On Java 8网站上的免费多媒体课程“Thinking in C”获取学习Java语言所需的基础知识。本书会重点介绍面向对象编程（Object-Oriented Programming, OOP）的概念，以及Java语言的基本控制机制。</p><p>我偶尔会提及一些C和C++的语言特性（有时也会提及其他语言），但是并不代表你必须熟悉C/C++语言，其目的是帮助大家理解和对比Java与两者的异同，毕竟Java是在它们的基础上发展而来的。我会尽量用简单的方式来引用这些概念，同时也会对非C/C++程序员所不熟悉的概念进行讲解。</p><h2 id="JDK-HTML文档"><a href="#JDK-HTML文档" class="headerlink" title="JDK HTML文档"></a>JDK HTML文档</h2><p>Oracle公司为Java开发工具集（Java Development Kit, JDK）提供了电子文档，你用Web浏览器就可以查看。除非必要，本书不会重复文档的内容，因为你用浏览器查看一个类的详细说明要比在本书中查找快得多（此外，在线文档的内容还是即时更新的）。所以在本书中，通常我只会提及需要参考“JDK文档”。除非需要补充文档内容才能让你理解某个特定的示例，否则一般情况下我不会提供额外的说明。</p><h2 id="“Thinking-in-C”课程"><a href="#“Thinking-in-C”课程" class="headerlink" title="“Thinking in C”课程"></a>“Thinking in C”课程</h2><p>“Thinking in C”课程介绍了C语言的一些基础知识，如语法、运算符、函数等，而这些内容同样也是Java语言的基础知识。此外，该课程还提供了一些编程的入门级知识，这些知识点适用于编程经验甚至比本书读者还要少的学生。</p><p>我委托Chuck Allison开发了“Thinking in C”这门独立的课程，之后将其收录在光碟里，再后来它变成了免费下载的形式。通过在网络上免费提供该课程，我可以确保所有人都具备阅读本书的知识基础。</p><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>本书所有源代码都属于受版权保护的自由软件，并且都可以在GitHub网站上获取：<a href="https://github.com/BruceEckel/Onjava8-examples%E3%80%82%E4%B8%BA%E4%BA%86%E7%A1%AE%E4%BF%9D%E4%BD%A0%E4%BD%BF%E7%94%A8%E7%9A%84%E6%BA%90%E4%BB%A3%E7%A0%81%E6%98%AF%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%EF%BC%8C%E8%AF%B7%E8%AE%A4%E5%87%86%E8%BF%99%E4%B8%AA%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E3%80%82%E8%BF%99%E4%BA%9B%E6%BA%90%E4%BB%A3%E7%A0%81%E5%8F%AF%E4%BB%A5%E7%94%A8%E4%BA%8E%E5%9C%A8%E6%A0%A1%E5%AD%A6%E4%B9%A0%E6%88%96%E8%80%85%E6%95%99%E8%82%B2%E7%94%A8%E9%80%94%E3%80%82">https://github.com/BruceEckel/Onjava8-examples。为了确保你使用的源代码是最新版本，请认准这个官方下载地址。这些源代码可以用于在校学习或者教育用途。</a></p><p>源代码的版权保护主要是为了确保这些源代码可以被正确地引用，以及防止在未经授权的情况下被随意发布。（只要是本书中引用了版权信息的源代码，在大多数情况下，使用是没有问题的。）</p><p>在所有源代码文件里，你都会发现类似以下的版权信息说明：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>P14-P16代码<br></code></pre></td></tr></table></figure><p>在编程过程中，只要你在每一个源代码文件里都保留了上面提及的版权信息，这些源代码就可以用于在校学习或者教育用途（包括幻灯片演示等文件）。</p><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><p>在本书中，各种标识符（关键字、方法名、变量名、类名等）会以等宽字体显示。</p><p>本书示例会采用一种特定的编程风格。在尽可能满足本书格式要求的前提下，这种编程风格和Oracle网站上提供的编程风格几乎完全一致，同时能够兼容大多数Java开发环境。鉴于编程风格这个话题足以引发长达数小时的激烈争论，我需要在此澄清的是，我并没有试图通过我的代码示例来指导何为正确的编程风格，我使用的编程风格完全只是根据自己的意愿而为之。Java是一种形态自由的编程语言，所以你可以按照自己的喜好选择编程风格。此外，在使用诸如IntelliJ IDEA、Eclipse或者NetBeans等IDE（Integrated Development Environment，集成开发环境）时，你可以设置自己熟悉的编程风格，以此解决编程风格不一致的问题。</p><p>本书的源代码都通过了自动化测试，最新版本的Java应该可以正常运行这些源代码（除了被特别标识的内容以外）。</p><p>本书的内容聚焦于Java 8，并且所有源代码都在Java 8环境下测试通过。如果你一心想要学习本书未曾提及的Java早期版本的内容，也可以在On Java 8网站下载《Java编程思想》（第4版）。</p><h2 id="bug反馈"><a href="#bug反馈" class="headerlink" title="bug反馈"></a>bug反馈</h2><p>就算作者本人用尽各种办法来检测编程错误，依然可能会有漏网之鱼，通常新的读者可能会有所发现。在阅读本书的过程中，只要你确信自己发现了某处错误，不管是文字还是代码示例问题，请第一时间将该错误以及你修正后的内容提交到：<a href="https://github.com/BruceEckel/Onjava8-examples/issues%E3%80%82%E6%84%9F%E8%B0%A2%E4%BD%A0%E7%9A%84%E5%B8%AE%E5%8A%A9%EF%BC%81">https://github.com/BruceEckel/Onjava8-examples/issues。感谢你的帮助！</a></p><h2 id="邮件列表"><a href="#邮件列表" class="headerlink" title="邮件列表"></a>邮件列表</h2><p>如果你希望获取相关新闻和通知，可以在On Java 8网站上订阅一个只包含少量内容的邮件列表。我不会发送任何广告，并且我会尽我所能保持其内容的正确性。</p><h2 id="图形用户界面"><a href="#图形用户界面" class="headerlink" title="图形用户界面"></a>图形用户界面</h2><p>对于Java而言，图形用户界面（GUI）和桌面编程代表着一段动荡甚至有些悲惨的历史。</p><p>在Java 1.0时代，GUI库最初的设计目的是让程序员可以创建一种在所有平台上看起来都光鲜亮丽的GUI。遗憾的是，这个目标并没有达成。取而代之的是，Java 1.0通过<strong>抽象窗口工具集</strong>（Abstract Windowing Toolkit, AWT）创建了一种在所有平台上都表现平平的GUI。不仅如此，这套GUI还有一些局限性。比如，你最多只能使用4种字体，而且你不能调用操作系统中任何成熟的GUI组件。此外，Java 1.0 AWT的编程模式最令人尴尬的是，它甚至不支持面向对象编程。我的研讨班中的一名学生（他曾经在Sun公司经历过最初创造Java语言的那段时光）曾经对此情况做出过解释：最初的AWT是在一个月之内构想、设计和实现出来的。这样的产能效率纵然让人称奇，却也是体现框架设计重要性的一份反面教材。</p><p>随后发展到Java 1.1 AWT事件模型的时期，情况终于有所改善。这次的AWT使用一种更为清晰且面向对象的编程方式，同时添加了一种名为JavaBeans的组件编程模式（现在已经不复存在），其目的是可以轻松创建可视化的编程环境。到了Java 2（也叫Java 1.2）时代，Java不再继续改进Java 1.0 AWT，而是用<strong>Java基础类</strong>（Java Foundation Classes, JFC）重写了一切，其中GUI部分称为“Swing”。通过JavaBeans及其丰富的代码库，用户可以创建出效果不错的GUI。只不过这一次，软件产业的“三个版本定律”（只有改良到第三个版本的才是好产品）似乎在编程语言领域也适用了。</p><p>Swing看起来似乎是Java语言GUI库的最终解决方案，然而这个假设最终也不攻自破了。随后，Sun公司又做出了最后一次努力，推出了JavaFX。当Oracle公司收购Sun公司后，Java的设计者们将这个野心勃勃的项目（其中甚至还包含了一种脚本语言）调整为Java的一个库，现在它似乎是唯一一个得以继续开发的UI工具包（详细请参考维基百科关于JavaFX的文章）。然而即便是这种程度的开发力度也难以为继，于是JavaFX和它的几个前辈一样，最终也难逃覆灭的命运。</p><p>现如今，Swing依然是Java的一部分（不过只是维护而没有再开发新内容）。由于Java现在已经是开源项目，所以也可以轻松获取到Swing。此外，Swing和JavaFX之间有一些有限的交互，其原本的目的是将Swing的功能移植到JavaFX中。</p><p>归根结底，Java在桌面领域从未真正强大过，甚至从未触及设计师的雄心壮志。至于其他，比如JavaBeans，也总是雷声大雨点小（不幸的是，有不少作者花费了大量心血来编写关于Swing的书，甚至是仅仅关于JavaBeans的书），始终没有获得大众的青睐。结果就是，Java在桌面领域的大多数应用场景是IDE以及一些企业内部的应用程序。虽然人们确实也会用Java开发用户界面，但是你要清楚地意识到这只是Java语言的一个小众需求。</p><p>如果你一定要学习Swing，可以在On Java 8网站上免费下载《Java编程思想》（第4版）并学习相关内容，或者参考其他专门讲解Swing的图书。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;本书导读&quot;&gt;&lt;a href=&quot;#本书导读&quot; class=&quot;headerlink&quot; title=&quot;本书导读&quot;&gt;&lt;/a&gt;本书导读&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;“我的语言之局限，即我的世界之局限。”&lt;/p&gt;
&lt;p&gt;​                     </summary>
      
    
    
    
    <category term="Books" scheme="http://www.ckxgzxa.top/categories/Books/"/>
    
    
    <category term="OnJava8" scheme="http://www.ckxgzxa.top/tags/OnJava8/"/>
    
  </entry>
  
  <entry>
    <title>腾讯云新号注册教程</title>
    <link href="http://www.ckxgzxa.top/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%96%B0%E5%8F%B7%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B"/>
    <id>http://www.ckxgzxa.top/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%96%B0%E5%8F%B7%E6%B3%A8%E5%86%8C%E6%95%99%E7%A8%8B</id>
    <published>2021-10-27T11:30:06.000Z</published>
    <updated>2021-10-27T12:27:08.233Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/TencentCloudNewAccount.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/img/TencentCloudNewAccount.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络习题第一章(网络体系结构)</title>
    <link href="http://www.ckxgzxa.top/ComputerNetworkingProblem1"/>
    <id>http://www.ckxgzxa.top/ComputerNetworkingProblem1</id>
    <published>2021-10-27T06:28:56.000Z</published>
    <updated>2021-10-27T09:18:05.207Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>假定有一个通信协议，每个分组都引入100字节的开销用于头和成帧。现在使用这个协议发送 $10^6$ 字节的数据，然而在传送的过程中有一个字节被破坏了，因而包含该字节的那个分组被丢弃。试对于1000字节和20000字节的分组的有效数据大小分别计算“开销+丢失”字节的总数目。分组数据大小的最佳值是多少?</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/IMG_20211027_144348.png"></p></li><li><p>考虑一个最大距离为2km的局域网，当带宽等于多大时 传播延时（传播速度为$2\times10^8m/s$ )等于100B分组的发送延时?对于512B分组结果又当如何?</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/0571ddc1c8ecc9360933b1968027a05.jpg"></p></li><li><p>在两台计算机之间传输一个文件有两种可行的确认策略。第一种策略把文件截成分组，接收方逐个地确认分组，但就整体而言，文件没有得到确认。第二种策略不确认单个分组，但当文件全部收到后，对整个文件予以确认。请讨论这两种方式的优缺点。</p><blockquote><table><thead><tr><th><strong>方案1</strong></th><th>出错后不必从头开始，只传出错的分组</th><th>速度慢,需要分割和拼接</th></tr></thead><tbody><tr><td><strong>方案2</strong></td><td><strong>速度较快，不用分割和拼接分组</strong></td><td><strong>出错后整个文件重传</strong></td></tr></tbody></table><p>如果网络容易丢失分组，选方案一，此时仅重传丢失的分组。<br>如果网络高度可靠，那么在不发生差错的情况下，选方案二.从而减少了确认次数，节省了带宽。不过,即使只有单个分组丢失也要重传整个文件,因此更适用于小文件。</p></blockquote></li><li><p>试在下列条件下比较电路交换和分组交换。要传送的报文共x比特。从源点到终点共经过k段链路，每段链路的传播时延为d秒，数据传输速率为b比特每秒。在电路交换时电路的建立时间为s秒。在分组交换时分组长度为p比特，且各结点的排队等待时间可忽略不计。问在怎样的条件下，分组交换的时延比电路交换的要小?(提示:画一下草图观察k段链路共有几个结点。)</p><blockquote><p>电路交换时延:  $s + \frac{x}{b} + k \cdot d$</p><p>分组交换时延: $\frac{p}{b}\cdot k + \frac{p}{b} (\frac{x}{p} - 1) + k \cdot d$</p><p>由 $$ \frac{p}{b}\cdot k + \frac{p}{b} (\frac{x}{p} - 1) + k \cdot d &lt; s + \frac{x}{b} + k \cdot d $$可得:<br>$$<br>k &lt; \frac {\frac{p}{b}+s}{\frac{p}{b}+d-1}<br>$$</p></blockquote></li><li><p>在上题的分组交换网中，设报文长度和分组长度分别为x和( p+h )比特，其中p为分组的数据部分的长度，而h为每个分组所带的控制信息固定长度，与p的大小无关。通信的两端共经过k段链路。链路的数据传输速率为b比特每秒，但传播时延、结点的排队时延和处理时延均可忽略不计。若打算使总的时延为最小，问分组的数据部分长度p应取为多大?</p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/f165ba22bc8debf251158a105358b4d.jpg"></p></li><li><p>在下列情况下，计算传送1000KB文件所需要的总时间，即从开始传送时起直到文件的最后一位到达目的地为止的时间。假定往返时间RTT为100ms，一个分组是1KB(即1024B)的数据，在开始传送整个文件数据之前进行的起始握手过程需要2RTT的时间。<br>1）带宽是1.5Mb/s，数据分组可连续发送。<br>2）带宽是1.5Mb/s，但在发送完每一个数据分组后，必须等待一个RTT （等待来自接收方的确认）才能发送下一个数据分组。<br>3 )假设带宽是无限大的值，即我们取发送时间为0，并且在等待每个RTT后可以发送多达20个分组。</p></li></ol><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/a25cf59fb4897e1480ab29929476142.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;假定有一个通信协议，每个分组都引入100字节的开销用于头和成帧。现在使用这个协议发送 $10^6$ 字节的数据，然而在传送的过程中有一个字节被破坏了，因而包含该字节的那个分组被丢弃。试对于1000字节和20000字节的分组的有效数据大小分别计算“开销+丢失</summary>
      
    
    
    
    <category term="习题" scheme="http://www.ckxgzxa.top/categories/%E4%B9%A0%E9%A2%98/"/>
    
    
    <category term="计算机网络" scheme="http://www.ckxgzxa.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>传输延迟和传播延迟的区别</title>
    <link href="http://www.ckxgzxa.top/TransmissionDelayandProgationDelay"/>
    <id>http://www.ckxgzxa.top/TransmissionDelayandProgationDelay</id>
    <published>2021-10-26T15:19:23.000Z</published>
    <updated>2021-10-26T15:32:38.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="传输延迟和传播延迟的区别"><a href="#传输延迟和传播延迟的区别" class="headerlink" title="传输延迟和传播延迟的区别"></a>传输延迟和传播延迟的区别</h1><blockquote><p>类比: 车队</p></blockquote><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/20211026232700.png"></p><ul><li>车速为 100 km/hr ~ 信号传播速度</li><li>收费站放行一台车用时 12 秒 ~ 比特传输时间</li><li>车 ~ 比特；车队 ~ 分组</li><li>车队通过收费站时间 ~ <strong>传输延迟</strong> （120秒）</li><li>每台车从第一个收费站跑到第二个收费站用时 ~ <strong>传播延迟</strong> （1小时）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;传输延迟和传播延迟的区别&quot;&gt;&lt;a href=&quot;#传输延迟和传播延迟的区别&quot; class=&quot;headerlink&quot; title=&quot;传输延迟和传播延迟的区别&quot;&gt;&lt;/a&gt;传输延迟和传播延迟的区别&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;类比: 车队&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机网络" scheme="http://www.ckxgzxa.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>中秋之行_下午_故宫博物院</title>
    <link href="http://www.ckxgzxa.top/2021MidAutumnFestival2"/>
    <id>http://www.ckxgzxa.top/2021MidAutumnFestival2</id>
    <published>2021-09-22T08:51:32.000Z</published>
    <updated>2021-09-22T16:10:15.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中秋之行-下午-故宫博物院"><a href="#中秋之行-下午-故宫博物院" class="headerlink" title="中秋之行_下午_故宫博物院"></a>中秋之行_下午_故宫博物院</h1><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zAqLaebNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="西华门"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zAqLaefNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="西华门"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9WF6evNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="午门"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxp2lafHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="午门"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_je6fXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRUJr6frNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="太和殿"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSq9R6f7NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="太和殿"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSq9R6gLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://static.dingtalk.com/media/lADPDhmOw-dNZ4nNA8DNBQA_1280_960.jpg_720x720q90g.jpg?bizType=im" alt="太和殿"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zAqmZ5HNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTDaZ5zNA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9Wg56bNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQowT563NA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="中和殿"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTDaZ73NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="保和殿"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zAqmZ8zNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="皇建有极"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_j559nNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQow41HjNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="乾清门"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9XF1H3NA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="乾清宫"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zArLVIbNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="正大光明"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQow41R_NA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_ke1SPNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="乾清宫介绍"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRUKr1SXNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="无为"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSq-R1SfNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="无为"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRUKr1SnNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="坤宁宫"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRUKr1SzNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="体和殿介绍"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zArcE-_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="翔凤为林"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9XWk_LNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSq-ik_jNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="钟表馆"><a href="#钟表馆" class="headerlink" title="钟表馆"></a>钟表馆</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxqIq6jDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="钟表馆"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9XWk__NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金奖杯式寒暑三面表_19世纪末_法国"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9XWlAPNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜轮船模型表_19世纪末_法国"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-eDFAfNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜灯塔式座钟_19世纪_法国"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zArcFA7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金珐琅座钟_19世纪末_法国慕让制造"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-eDFBLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜热气球式钟_19世纪末_法国"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zArcFBfNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9X3V3vNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9X3V4LNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-ej13bNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxp4W14nNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金饰蓝瓷瓶式钟_19世纪末_法国巴黎"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_lQV4_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金珐琅围屏式钟_19世纪末_法国马蒂公司制造)"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zAr815rNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金石座水法穹式钟_19世纪末_法国"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-ej16PNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鸟音山石钟_19世纪_瑞士"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoxqV6nNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSq_DV7HNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金转花自鸣过枝雀笼钟"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zAsreLjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTFfeL3NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金园于莳花钟"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoyY-NbNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTFfeOLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金人指时刻分钟"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-fSeO3NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://static.dingtalk.com/media/lADPDiQ3P9Yl-PvNBQDNA8A_960_1280.jpg_720x720q90g.jpg?bizType=im"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyVS4eQXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRUML-RHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-f-llTNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTGLlljNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9ZSFl7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-f-lmLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_mrFoDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金七政仪表"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_mrFmzNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9ZSFnTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金象拉战车钟"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxp5xlo_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_mxVEHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-u36hXNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9oLahjNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="铜镀金写字人钟_1780年_英国伦敦威廉森制造"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyVid6hnNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="铜镀金写字人钟"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTVE6hrNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyVid6hvNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="彩漆描金自开门群仙祝寿楼阁式钟"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxqIq6hzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyVid6h3NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSrPXah7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSrPXah_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTVE6i_NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="珍宝馆"><a href="#珍宝馆" class="headerlink" title="珍宝馆"></a>珍宝馆</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9oLajLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="珍宝馆入口"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyVid6jTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="九龙壁介绍"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyVid6jXNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="九龙壁1"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpB-ajbNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="九龙壁2"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTVE6jrNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="皇极殿介绍"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyVid6jfNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="皇极殿"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxqIq6jvNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="仁德大隆"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-vRLo_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="门"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSrPwro7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="门特写"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRUcKrpHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRUcKrpLNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCX_aDNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="大肥猫"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCXrpXNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxqJELpjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9okrpnNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-vRLprNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCXOlLNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSrPwOlTNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-vQulXNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw-vQulfNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSrPwOlnNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxqJDulrNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><hr><h2 id="御花园"><a href="#御花园" class="headerlink" title="御花园"></a>御花园</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCXOrrNA7XNBQA_1280_949.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zA8purvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCXOrzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCXOr7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鱼"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9okOr_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鱼"></p><hr><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCYQ8HNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxqJEw8LNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="神武门"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9olQ8TNBQDNA7U_949_1280.jpg_720x720q90g.jpg" alt="神武门"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9olQ8XNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="刘老板"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9olQ8fNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="神武门_全"></p><hr><p><img src="https://static.dingtalk.com/media/lADPDg7mR_2CJ1zNA8DNBQA_1280_960.jpg_720x720q90g.jpg?bizType=im" alt="明思宗殉国处"></p><hr><h2 id="夜景"><a href="#夜景" class="headerlink" title="夜景"></a>夜景</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSrP1J8zNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwTVip83NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCcJ87NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="月"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQpCcJ9DNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zA8up9LNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><hr><h2 id="杂"><a href="#杂" class="headerlink" title="杂"></a>杂</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P9olQ8nNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="晚饭,比中饭好吃,还有一个菜没拍"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zA8qw8vNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="wow"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中秋之行-下午-故宫博物院&quot;&gt;&lt;a href=&quot;#中秋之行-下午-故宫博物院&quot; class=&quot;headerlink&quot; title=&quot;中秋之行_下午_故宫博物院&quot;&gt;&lt;/a&gt;中秋之行_下午_故宫博物院&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://git</summary>
      
    
    
    
    <category term="个人记实" scheme="http://www.ckxgzxa.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%AE%9E/"/>
    
    
    <category term="2021中秋节" scheme="http://www.ckxgzxa.top/tags/2021%E4%B8%AD%E7%A7%8B%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>中秋之行_上午_中国地质博物馆</title>
    <link href="http://www.ckxgzxa.top/2021MidAutumnFestival1"/>
    <id>http://www.ckxgzxa.top/2021MidAutumnFestival1</id>
    <published>2021-09-21T14:19:40.000Z</published>
    <updated>2021-09-22T05:54:15.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中秋之行-上午-中国地质博物馆"><a href="#中秋之行-上午-中国地质博物馆" class="headerlink" title="中秋之行_上午_中国地质博物馆"></a>中秋之行_上午_中国地质博物馆</h1><h2 id="参观指南"><a href="#参观指南" class="headerlink" title="参观指南"></a>参观指南</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/ea272b7e29ac1914605940da8f4b2f3.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/3c8f10fd9d5673c3391c4fcdd13db42.jpg"></p><h2 id="2F矿物岩石厅"><a href="#2F矿物岩石厅" class="headerlink" title="2F矿物岩石厅"></a>2F矿物岩石厅</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9-baoXNEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P83u6oHNEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P83u6n_NEPjNFqA_5792_4344.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwSkoanrNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRTrU6nXNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9-banHNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRTrU6m3NFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9-bamvNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P830x6rNFqDNEPg_4344_5792.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxpYdUPzNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxpYdUP7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRTrj0QLNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwSk3UQPNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSqfJ0QfNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyUyQUQnNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwSk3UQvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zAMDUQ3NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P8390Q7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSqfJ0R7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><h2 id="3F史前生物厅"><a href="#3F史前生物厅" class="headerlink" title="3F史前生物厅"></a>3F史前生物厅</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxpYgID7NBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_FZoD_NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoRzoEHNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoRzoELNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P84AoETNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxpYgIEbNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgQ9zAMGIEjNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyUyTIEvNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P84AoE7NA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><h5 id="鹦鹉嘴龙"><a href="#鹦鹉嘴龙" class="headerlink" title="鹦鹉嘴龙"></a>鹦鹉嘴龙</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwSk989nNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRTrmhd7NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxpYgBd_NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwSk6BeHNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9-tBeLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="中国鹦鹉嘴龙"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSqfMhePNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="鹦鹉嘴龙"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_FZheTNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="翼龙"></p><h5 id="三里庙树枝蛋"><a href="#三里庙树枝蛋" class="headerlink" title="三里庙树枝蛋"></a>三里庙树枝蛋</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9-tBebNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="三里庙树枝蛋"></p><h5 id="满洲满洲龟"><a href="#满洲满洲龟" class="headerlink" title="满洲满洲龟"></a>满洲满洲龟</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRTrmhefNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="满洲满洲龟"></p><h5 id="猛犸象"><a href="#猛犸象" class="headerlink" title="猛犸象"></a>猛犸象</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwSlBdr7NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="猛犸象"></p><h5 id="柄杯鹿"><a href="#柄杯鹿" class="headerlink" title="柄杯鹿"></a>柄杯鹿</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoR69r_NA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="柄杯鹿"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_Fg9sDNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="一些哺乳动物的牙齿"></p><h5 id="西峡巨型长型蛋"><a href="#西峡巨型长型蛋" class="headerlink" title="西峡巨型长型蛋"></a>西峡巨型长型蛋</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyUyZ_tLNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="西峡巨型长型蛋"></p><h5 id="披毛犀"><a href="#披毛犀" class="headerlink" title="披毛犀"></a>披毛犀</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P84H9sHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="披毛犀"></p><h5 id="头骨"><a href="#头骨" class="headerlink" title="头骨"></a>头骨</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9-0dsPNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="头骨"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRTrt9sTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="头骨"></p><h5 id="巨型禄丰龙骨架模型"><a href="#巨型禄丰龙骨架模型" class="headerlink" title="巨型禄丰龙骨架模型"></a>巨型禄丰龙骨架模型</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwSlBdsfNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="巨型禄丰龙骨架模型"></p><h2 id="3F临时展厅"><a href="#3F临时展厅" class="headerlink" title="3F临时展厅"></a>3F临时展厅</h2><h5 id="徐悲鸿-愚公移山"><a href="#徐悲鸿-愚公移山" class="headerlink" title="徐悲鸿_愚公移山"></a>徐悲鸿_愚公移山</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoR69snNA7XNBQA_1280_949.jpg_720x720q90g.jpg" alt="徐悲鸿_愚公移山"></p><h5 id="铁工厂锻压插件-水彩-1951-孙宗慰"><a href="#铁工厂锻压插件-水彩-1951-孙宗慰" class="headerlink" title="铁工厂锻压插件_水彩_1951_孙宗慰"></a>铁工厂锻压插件_水彩_1951_孙宗慰</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9-5MoHNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="铁工厂锻压插件\_水彩\_1951_孙宗慰"></p><h5 id="愚公移山单人-1940-徐悲鸿"><a href="#愚公移山单人-1940-徐悲鸿" class="headerlink" title="愚公移山单人_1940_徐悲鸿"></a>愚公移山单人_1940_徐悲鸿</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSqfYsoLNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山单人_1940_徐悲鸿"></p><h5 id="愚公移山手稿-1940-徐悲鸿"><a href="#愚公移山手稿-1940-徐悲鸿" class="headerlink" title="愚公移山手稿_1940_徐悲鸿"></a>愚公移山手稿_1940_徐悲鸿</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSqfYsoTNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山手稿_1940_徐悲鸿"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgfLSqfYsoXNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="愚公移山手稿_徐悲鸿"></p><h2 id="4F临时展厅"><a href="#4F临时展厅" class="headerlink" title="4F临时展厅"></a>4F临时展厅</h2><h5 id="柴达木之宝"><a href="#柴达木之宝" class="headerlink" title="柴达木之宝"></a>柴达木之宝</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxpYsMobNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="柴达木之宝"></p><h5 id="朱德收藏标本"><a href="#朱德收藏标本" class="headerlink" title="朱德收藏标本"></a>朱德收藏标本</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyUyfMofNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="朱德收藏标本"></p><h5 id="原油"><a href="#原油" class="headerlink" title="原油"></a>原油</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhYBRTrysojNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="原油"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiQ3P84MsonNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="原油"></p><h5 id="雌黄"><a href="#雌黄" class="headerlink" title="雌黄"></a>雌黄</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoR_sovNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="雌黄"></p><h5 id="萤石、白云石、水晶"><a href="#萤石、白云石、水晶" class="headerlink" title="萤石、白云石、水晶"></a>萤石、白云石、水晶</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9_BF7LNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="萤石、白云石、水晶"></p><h5 id="石英、白钨矿、云母"><a href="#石英、白钨矿、云母" class="headerlink" title="石英、白钨矿、云母"></a>石英、白钨矿、云母</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoSHl7PNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="石英、白钨矿、云母"></p><h5 id="石膏"><a href="#石膏" class="headerlink" title="石膏"></a>石膏</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDiCpwSlOF7bNBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="石膏"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDg7mR_Ftl7jNA8DNBQA_1280_960.jpg_720x720q90g.jpg"></p><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhmOw9_BF7rNBQDNA8A_960_1280.jpg_720x720q90g.jpg"></p><h5 id="石油书籍"><a href="#石油书籍" class="headerlink" title="石油书籍"></a>石油书籍</h5><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDgtYyUynF73NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="石油书籍"></p><h2 id="出馆与李四光像合影"><a href="#出馆与李四光像合影" class="headerlink" title="出馆与李四光像合影"></a>出馆与李四光像合影</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDh0cQoSHl77NBQDNA8A_960_1280.jpg_720x720q90g.jpg" alt="照片"></p><h2 id="中饭"><a href="#中饭" class="headerlink" title="中饭"></a>中饭</h2><p><img src="https://gitee.com/ZXA200009/BlogPictures/raw/master/lADPDhJzxpY0F8DNA8DNBQA_1280_960.jpg_720x720q90g.jpg" alt="中饭,这面太难吃了"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中秋之行-上午-中国地质博物馆&quot;&gt;&lt;a href=&quot;#中秋之行-上午-中国地质博物馆&quot; class=&quot;headerlink&quot; title=&quot;中秋之行_上午_中国地质博物馆&quot;&gt;&lt;/a&gt;中秋之行_上午_中国地质博物馆&lt;/h1&gt;&lt;h2 id=&quot;参观指南&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="个人记实" scheme="http://www.ckxgzxa.top/categories/%E4%B8%AA%E4%BA%BA%E8%AE%B0%E5%AE%9E/"/>
    
    
    <category term="2021中秋节" scheme="http://www.ckxgzxa.top/tags/2021%E4%B8%AD%E7%A7%8B%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>一些绕口令</title>
    <link href="http://www.ckxgzxa.top/%E4%B8%80%E4%BA%9B%E7%BB%95%E5%8F%A3%E4%BB%A4"/>
    <id>http://www.ckxgzxa.top/%E4%B8%80%E4%BA%9B%E7%BB%95%E5%8F%A3%E4%BB%A4</id>
    <published>2021-09-19T10:49:35.000Z</published>
    <updated>2021-09-19T10:58:54.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些绕口令"><a href="#一些绕口令" class="headerlink" title="一些绕口令"></a>一些绕口令</h1><ol><li><p>==八了百了标了兵了奔了北了坡，炮了兵了并了排了北了边了跑， 炮了兵了怕了把了标了兵了碰，标了兵了怕了碰了炮了兵了炮。（双唇及舌）==</p></li><li><p>==巴老爷有八十八棵芭蕉树，来了八十八个把式要在巴老爷八十八棵芭蕉树下住。巴老爷拔了八十八棵芭蕉树，不让八十八个把式在八十八棵芭蕉树下住。八十八个把式烧了八十八棵芭蕉树，巴老爷在八十八棵树边哭。（锻炼唇力）==</p></li><li><p>==门口吊刀，刀倒吊着。……（反复说，锻炼舌的顶力）==</p></li><li><p>==山前有个催粗腿，山后有个催腿粗，俩人山前来比腿，不知是催粗腿比催腿粗的腿粗，还是催腿粗比催粗腿的腿粗。==</p></li><li><p>==粉红墙上画凤凰，凤凰画在粉红墙。红凤凰、粉凤凰，红粉凤凰花凤凰。==</p></li></ol><h3 id="主持人播音员专业八级绕口令考试试卷"><a href="#主持人播音员专业八级绕口令考试试卷" class="headerlink" title="主持人播音员专业八级绕口令考试试卷"></a>主持人播音员专业八级绕口令考试试卷</h3><h4 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h4><p>老龙恼怒闹老农，老农恼怒闹老龙。农怒龙恼农更怒，龙恼农怒龙怕农。</p><h4 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h4><p>牛郎恋刘娘，刘娘念牛郞，牛郎年年念刘娘，刘娘牛年恋牛郎，郎念娘来娘恋娘</p><h4 id="第三题："><a href="#第三题：" class="headerlink" title="第三题："></a>第三题：</h4><p>七巷一个漆匠，西巷一个锡匠。七巷漆匠用了西巷锡匠的锡，西巷锡匠拿了七巷漆匠的漆，七巷漆匠气西巷锡匠用了漆，西巷锡匠讥七巷漆匠拿了锡。</p><h4 id="第四题："><a href="#第四题：" class="headerlink" title="第四题："></a>第四题：</h4><p>初级 大声说20遍(红凤凰)<br>中级 大声说20遍(粉红凤凰)<br>高级 大声说10遍(红凤凰，黄凤凰，粉红凤凰花凤凰)</p><hr><p>丝瓜藤上绕满绳，<br>瓜藤绕着绳架伸。<br>绳长藤伸瓜儿长，<br>绳粗藤壮瓜儿沉。</p><p>风吹银铃叮铃铃<br>小琳琳，爱银铃，<br>琳琳用劲摇银铃，<br>银铃的铃声真好听。<br>风吹银铃叮铃铃，<br>小琳以为铃失灵，<br>银铃笑琳琳真是不机灵！</p><p>蓝教练是女教练，吕教练是男教练<br>蓝教练不是男教练，吕教练不是男教练<br>蓝南是男篮主力，吕楠是女篮主力。吕教练在男篮训练蓝南，蓝教练在女篮训练吕楠。</p><p>小盈林，爱银铃，<br>盈林用劲摇银铃，<br>银铃声音真动听。<br>风吹银铃叮铃铃，<br>盈林心中喜盈盈，<br>笑声尽情赛银玲。</p><hr><ol><li>初入江湖：化肥会挥发</li><li>小有名气：黑化肥发灰，灰化肥发黑</li><li>名动一方：黑化肥发灰会挥发；灰化肥挥发会发黑</li><li>天下闻名：黑化肥挥发发灰会花飞；灰化肥挥发发黑会飞花</li><li>一代宗师：黑灰化肥会挥发发灰黑讳为花飞；灰黑化肥会挥发发黑灰为讳飞花</li><li>超凡入圣：黑灰化肥灰会挥发发灰黑讳为黑灰花会飞；灰黑化肥会会挥发发黑灰为讳飞花化为灰</li><li>天外飞仙：黑化黑灰化肥灰会挥发发灰黑讳为黑灰花会回飞；灰化灰黑化肥会会挥发发黑灰为讳飞花回化为灰</li></ol><h3 id="绕口令"><a href="#绕口令" class="headerlink" title="绕口令"></a>绕口令</h3><h4 id="单韵母练习"><a href="#单韵母练习" class="headerlink" title="单韵母练习"></a>单韵母练习</h4><ol><li>坡上立着一只鹅，坡下就是一条河。宽宽的河，肥肥的鹅，鹅要过河，河要渡鹅，不知是鹅过河，还是河渡鹅？</li><li>山上五棵树，架上五壶醋，林中五只鹿，箱里五条裤。伐了山上树，搬下架上的醋，射死林中的鹿，取出箱中的裤。</li></ol><h4 id="鼻韵母练习"><a href="#鼻韵母练习" class="headerlink" title="鼻韵母练习"></a>鼻韵母练习</h4><ol><li>扁担长，板凳宽，扁担没有板凳宽，板凳没有扁担长，扁担想绑在板凳上，板凳不让扁担绑在板凳上，扁担偏偏绑在板凳上，到底是板凳宽还是扁担长。</li><li>一平盆面，烙一平盆饼，饼碰盆，盆碰饼。</li><li>山前有个严圆眼，山后有个严眼圆，二人山前来比眼，不知是严圆眼的眼圆，还是严眼圆比严圆眼的眼圆？</li></ol><h4 id="复韵母练习"><a href="#复韵母练习" class="headerlink" title="复韵母练习"></a>复韵母练习</h4><ol><li>出南门，走六步，见着六叔和六舅，叫声六叔和六舅，借我六斗六升好绿豆；过了秋，打了豆，还我六叔六舅六十六斗六升好绿豆。</li><li>哥挎瓜筐过宽沟，过沟筐漏瓜滚沟。隔沟挎筐瓜筐扣，瓜滚筐空哥怪沟。</li></ol><h4 id="唇音练习"><a href="#唇音练习" class="headerlink" title="唇音练习"></a>唇音练习</h4><ol><li>老方扛着黄幌子，老黄扛着方幌子。老方要拿老黄的方幌子，老黄要拿老方的黄幌子，末了儿方幌子碰破了黄幌子，黄幌子碰破了方幌子。</li></ol><h4 id="舌尖中音练习"><a href="#舌尖中音练习" class="headerlink" title="舌尖中音练习"></a>舌尖中音练习</h4><ol><li>你会炖炖冻豆腐，你来炖我的炖冻豆腐；你不会炖炖冻豆腐，别胡炖乱炖炖坏了我的炖冻豆腐。</li><li>老罗拉了一车梨，老李拉了一车栗。老罗人称大力罗，老李人称李大力。老罗拉梨做梨酒，老李拉栗去换梨。</li><li>有个面铺门朝南，门上挂着蓝布棉门帘，摘了蓝布棉门帘，面铺门朝南；挂上蓝布棉门帘，面铺还是门朝南。</li><li>大刀对单刀，单刀对大刀，大刀斗单刀，单刀夺大刀。</li></ol><h4 id="舌根音、舌面音练习"><a href="#舌根音、舌面音练习" class="headerlink" title="舌根音、舌面音练习"></a>舌根音、舌面音练习</h4><ol><li>一班有个黄贺，二班有个王克，黄贺、王克二人搞创作，黄贺搞木刻，王克写诗歌。黄贺帮助王克写诗歌，王克帮助黄贺搞木刻。由于二人搞协作，黄贺完成了木刻，王克写好了诗歌。<br>翘舌音、平舌音、练习</li><li>天上有个日头，地下有块石头，嘴里有个舌头，手上有五个手指头。不管是天上的热日头，地下的硬石头，嘴里的软舌头，手上的手指头，还是热日头，硬石头，软舌头，手指头，反正都是练舌头。</li><li>师部司令部指示：四团十连石连长带四十人在十日四时四十四分按时到达师部司令部，师长召开誓师大会。</li><li>早招租，晚招租，总找周邹郑曾朱。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些绕口令&quot;&gt;&lt;a href=&quot;#一些绕口令&quot; class=&quot;headerlink&quot; title=&quot;一些绕口令&quot;&gt;&lt;/a&gt;一些绕口令&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;==八了百了标了兵了奔了北了坡，炮了兵了并了排了北了边了跑， 炮了兵了怕了把了标了兵了碰，标了兵了</summary>
      
    
    
    
    <category term="其他" scheme="http://www.ckxgzxa.top/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>OnJava8前言</title>
    <link href="http://www.ckxgzxa.top/1-OnJava8Preface"/>
    <id>http://www.ckxgzxa.top/1-OnJava8Preface</id>
    <published>2021-09-15T13:44:40.000Z</published>
    <updated>2021-10-28T06:54:51.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本书基于Java 8的特性进行该语言的编程教学。</p></blockquote><p>我以前的那本Java书——《Java编程思想》（第4版），对于用Java 5编程仍然很有用，Android编程用的就是这个语言版本。然而随着Java 8的到来，这门语言发生了许多显著的变化，使得编写和阅读新版本Java代码的方式都与以往有了明显的不同。于是，花费两年时间编写一本新书也就在情理之中了。</p><p>本书的读者具备基础的编程经验即可。对于经验不足的编程入门者而言，可汗学院（Khan Academy）这类网络资源提供了不少介绍编程基础知识的课程，另外也可以尝试之前提及的“Thinking in C”免费多媒体课程。当你遇到问题时，相比数年前只能依靠纸质媒体的时代，如今通过YouTube、博客、Stack Overflow等网站就可以轻松地找到所需要的答案。此外，若有坚韧不拔的毅力，你完全可以把本书当作自己的第一本编程教材。此外，本书同样适用于那些希望拓宽自己知识面的专业程序员。</p><p>《Java编程思想》一书自面世至今，让我受益匪浅，尤其是与其相关的全球范围内的演讲让我收获很多。对此，我一直心存感激。而这本书真正的无价之处在于，它让许多人和公司之间产生了关联。</p><h2 id="本书目标"><a href="#本书目标" class="headerlink" title="本书目标"></a>本书目标</h2><p>本书每一章都会介绍一个或者一组互相关联的概念，同时这些概念不依赖于当前章节没有介绍的特性。因此，你可以结合当前获取的知识来充分理解上下文，然后再阅读下一章。</p><p>我个人对本书的目标如下。</p><ol><li>循序渐进地呈现相关知识点，以便你充分理解每一个理念，之后再继续前行。同时，谨慎地安排语言特性出现的顺序，以便你先学习一个特性，然后再接触与之相关的实际应用场景。然而我并不能保证百分之百可以做到这一点，当出现意外情况时，我也会提供一些简要的相关说明。</li><li>所使用的示例尽可能地浅显易懂。有时候我会因为这一条原则而放弃引入所谓“现实世界”的问题，然而我发现对于初学者而言，相比于因为示例解决了一个范围很大的问题而惊讶，当他们理解示例中所有细节的时候会觉得更有收获。对于这一点，也许有人会批判我只热衷于“简单示例”，但是为了产生更为明显的教育成效，我依然乐于接受目前的做法。</li><li>相较传授我所了解的语言知识，我更希望传授语言的重要之处是什么。我认为信息需要根据其重要程度进行分级，而事实是，有些细节对于95%的程序员而言是无关紧要的。这些细节只会让人们感到困惑，以及增加他们对于语言复杂度的认知。如果<strong>你的</strong>代码必须考虑这些细节，切记这些内容也会困扰那些阅读和维护代码的人。所以我提倡代码使用简单的实现方式。</li><li>为你打下坚实的编程语言基础，以便你之后学习难度更高的课程和图书时，可以充分理解自己所遇到的问题。</li></ol><h2 id="语言设计缺陷"><a href="#语言设计缺陷" class="headerlink" title="语言设计缺陷"></a>语言设计缺陷</h2><p>每一种语言都存在设计缺陷。屡屡让新手程序员感到不安和挫败的是，他们必须“周旋”于各种语言特性之中，不断猜测应该用什么、不应该用什么。承认错误总是让人感到不快，但是相比承认错误所带来的不适感，这种糟糕的新手体验要严重得多。令人尴尬的是，所有失败的语言/库设计一直存在于Java的发布版本里。</p><p>诺贝尔经济学奖得主Joseph Stiglitz有一句生活哲言十分应景，也叫作“承诺升级理论”（The Theory of Escalating Commitment）：</p><blockquote><p>持续犯错的代价由别人承担，而承认错误的代价由你自己来承担。</p></blockquote><p>如果你读过我以往的文章或著作，就会知道，当发现编程语言的设计缺陷时，我倾向于指出这些问题。Java发展到今天，已拥有了许多热心的拥护者，其中有些人甚至将Java视为自家“孩子”，而非一种语言工具。因为我编写了一些关于Java的著作，所以他们以为我也会像他们一样袒护Java。于是，当我发现了某个语言缺陷并进行批判时，经常会出现以下两种情况。</p><ol><li>起初会引起一阵类似于“我的孩子无论对错”的愤怒，之后会逐渐平复，变成只有零星反抗。到了最后（也许会经过许多年），该缺陷逐渐被大家广泛承认，从此被视为Java的历史遗留问题。</li><li>更为关键的是，新手程序员并没有经历过“想不通为什么会这样”的痛苦挣扎，尤其是发现了某个看起来不对劲儿的地方之后所产生的自我怀疑，在这种情况下人们会很自然地认为<strong>要么是自己做错了，要么就是自己还没有搞明白</strong>。更糟糕的是，有些教授该语言的人会直接引用一些错误的概念，而不是对问题进行更加深入的研究和分析。而如果能够理解语言的设计缺陷，即使是新手程序员也能够理解不对劲儿的地方是一个错误，从而绕过它继续前行。</li></ol><p>我认为，理解语言和库的设计缺陷是必要的，因为它们会影响程序员的生产力。有些公司和团队会刻意规避某些语言特性，因为虽然它们看起来很有趣，但可能会在你毫无准备之时突然卡住你的工作进程。此外，设计缺陷也会影响新语言的创建和采用。探索一门语言能做什么的过程十分有趣，然而设计缺陷能够告诉你该语言<strong>不能</strong>做什么。</p><p>多年以来，我真切地感受到Java语言的设计者不够关心用户。有些语言缺陷可谓是太过明显，根本没有经过深思熟虑，看起来像是设计者的思绪早已飞到了九霄云外，对自己的用户不管不顾。因此，Java语言在相当长的一段时间里饱受争议，也许这些有争议之处正是其诱惑所在。此外，这种对程序员看似不尊重的态度，也是我当初放弃Java选择其他语言，并且在相当长的一段时间内都不想回头的主要原因。</p><p>而当我重新回过头来审视Java的时候，Java 8给我的感觉是焕然一新，就好像是该语言的设计者对于语言和用户的态度发生了180度大转变。比如，许多被用户诟病已久，甚至被视为语言毒瘤的特性和库都得到了修正。新引入的特性也让人耳目一新，就好像是设计团队中新加入了几位极其关注程序员使用体验的设计者。这些特性最终被证明是有效的，从而使得Java语言更为出众，这明显好过在没有深入探究一个理念的本质时就急不可待地把它添加进来。此外，部分新特性十分优雅（至少可以说在考虑到Java局限性的情况下，已经尽可能地优雅了）。对此我只能猜测，可能有些人离开了Java语言设计团队，因而才发生了这些变化。</p><p>得益于语言设计者的良苦用心（其实我并没有料想到这一点），编写本书的过程相比以往要顺利得多。Java 8包含了许多基础和重要的改进，而由于Java的向后兼容性一直惨不忍睹，做出这些改进无疑需要花费相当多的精力。因此可以预料的是，将来也很难再见到如此重大的改进了（关于这一点，希望我是错的）。话虽如此，我依然要为那些把Java重新带入正确航道的人献上掌声。当终于能够用Java 8编写出某段代码时，我第一次下意识地喊出：“我爱死这个了！”</p><p>最后，本书的出版时机也非常不错，这是因为Java 8提供的一些重要特性会大大影响我们编写代码的方式，而到目前为止，Java 9似乎专注于改进语言的底层，其引入的一些重要的底层特性并不会影响本书中的代码。</p><h2 id="经过测试的示例"><a href="#经过测试的示例" class="headerlink" title="经过测试的示例"></a>经过测试的示例</h2><p>本书提供的示例所使用的是Java 8环境和Gradle编译工具。虽然我也使用新版本的Java测试过这些示例，但我依然推荐你使用该语言的长期稳定（LTS）版本：在我写这本书时，对应的是Java 8或者Java 11。此外，本书所有示例都可以从GitHub仓库免费获取。</p><p>每当构建一个应用程序时，如果没有一套内置测试流程来测试你的代码，就无法判断代码是否坚实可信。因此，我为本书创建了一套测试系统，用于展示和验证大多数示例的输出结果。具体而言，运行示例代码后的输出结果会生成一段注释，附加在代码的末尾处。有时候注释并不显示全部内容，而是只显示开头的几行，或者开头和末尾的几行。这种嵌入式的输出方式提升了代码可读性，降低了学习门槛，同时也提供了一种验证代码正确性的方式。</p><h2 id="普及程度"><a href="#普及程度" class="headerlink" title="普及程度"></a>普及程度</h2><p>Java的普及具有重要意义。我的意思是，如果你学会了Java，也许找工作会容易一些，而且市面上有大量的Java培训材料、课程以及其他学习资源等。另外，如果你开一家公司并且选择Java作为工作语言，招募Java程序员时也会容易一些。Java的这一点优势确实无可争辩。</p><p>话虽如此，目光短浅总归不是好事。如果你并不是真心喜爱Java，建议你还是远离它为好。我的意思是，如果学习Java只是为了找工作，无异于选择了一种不幸福的人生。而对于公司来说，如果你选择Java只是为了降低招聘难度，请务必三思而后行。根据你的实际需求，也许采用其他语言的话，你可以雇用更少的员工，但能达到更高的生产力（比如通过我的另一本书<em>Atomic Kotlin</em>学习Kotlin语言）。此外，使用一种更新也更激动人心的编程语言也许更容易吸引有志之士的加盟。</p><p>不过，如果你<strong>真的</strong>喜爱Java这门语言，那么欢迎你加入。同时，我希望本书可以丰富你的编程经验。</p><h2 id="关于Android程序员"><a href="#关于Android程序员" class="headerlink" title="关于Android程序员"></a>关于Android程序员</h2><p>Android编程使用的环境是Java 5，而我编写本书的原则是“尽可能使用纯粹的Java 8”，所以如果你学习Java的目的是为Android系统编写应用程序，那么推荐你学习《Java编程思想》（第4版）。此外，还有许多专门针对Android的编程资源可供学习。</p><p>顺便一提，对于Android编程而言，Kotlin语言是一种更新和更好的选择，同时它也是Android的官方编程语言。</p><h2 id="出版说明"><a href="#出版说明" class="headerlink" title="出版说明"></a>出版说明</h2><p>本书使用了自动化的构建过程，同样的自动化过程还有解压、编译以及测试所有示例代码。我使用Python 3编写了大量的应用程序来处理所有的自动化过程。</p><h3 id="封面设计"><a href="#封面设计" class="headerlink" title="封面设计"></a>封面设计</h3><p>本书的封面插图来自美国公共事业振兴署（Works Progress Administration，简称WPA，是1935—1943年美国大萧条时期所创建的一个大型公共事业项目，其目标是援助失业人口重新返回工作岗位）。此外，它也让我想起了《绿野仙踪》系列丛书的插图。我的设计师朋友Daniel Will-Harris和我都十分喜爱这张图片。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p>感谢Eric Evans（《领域驱动设计》一书的作者）针对本书书名提供了宝贵意见，也感谢所有在讨论组里帮助我确定书名的人们。</p><p>感谢James Ward，他使我得以为本书使用Gradle构建工具，感谢他一直以来提供的帮助以及跟我的友谊。感谢Ben Muschko对构建文件所做的优化，同时也要感谢Hans Dockter给Ben时间来做这件事。</p><p>感谢Jeremy Cerise与Bill Frasure参与本书的开发者活动，并提供了有价值的帮助。</p><p>感谢所有抽出宝贵时间莅临科罗拉多州克雷斯特德比特市，参加我所组织的会议、研讨活动、开发者活动以及其他活动的嘉宾们。你们虽深居幕后，但所做出的贡献不可或缺。</p><h2 id="献词"><a href="#献词" class="headerlink" title="献词"></a>献词</h2><p>谨献给我敬爱的父亲E. Wayne Eckel，他生于1924年4月1日，卒于2016年11月23日。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本书基于Java 8的特性进行该语言的编程教学。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我以前的那本Java书</summary>
      
    
    
    
    <category term="Books" scheme="http://www.ckxgzxa.top/categories/Books/"/>
    
    
    <category term="OnJava8" scheme="http://www.ckxgzxa.top/tags/OnJava8/"/>
    
  </entry>
  
  <entry>
    <title>软件工程导论复习</title>
    <link href="http://www.ckxgzxa.top/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA"/>
    <id>http://www.ckxgzxa.top/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA</id>
    <published>2021-07-21T16:08:45.305Z</published>
    <updated>2021-05-14T17:06:43.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件工程导论"><a href="#软件工程导论" class="headerlink" title="软件工程导论"></a>软件工程导论</h1><h2 id="1-软件工程概论"><a href="#1-软件工程概论" class="headerlink" title="1. 软件工程概论"></a>1. 软件工程概论</h2><h3 id="1-1-软件危机-Soft-Crisis"><a href="#1-1-软件危机-Soft-Crisis" class="headerlink" title="1.1. 软件危机(Soft Crisis)"></a>1.1. 软件危机(Soft Crisis)</h3><ul><li><p>计算机软件的开发和维护过程中遇到的一系列严重问题</p></li><li><p>两方面问题</p><ul><li>如何开发软件,满足对软件日益增长的需求</li><li>如何维护数量不断膨胀的已有软件</li></ul></li><li><p>具体表现</p><ul><li><ol><li>对软件开发成本和进度的估计常常很不准确</li></ol></li><li><ol start="2"><li>用户不满意的现象经常发生</li></ol></li><li><ol start="3"><li>软件产品的质量往往靠不住</li></ol></li><li><ol start="4"><li>软件常常是不可维护的</li></ol></li><li><ol start="5"><li>软件没有适当的文档资料</li></ol></li><li><ol start="6"><li>软件成本在计算机系统总成本占比逐年上升</li></ol></li><li><ol start="7"><li>软件开发生产率提高的速度远不及计算机应用迅速普及深入的趋势</li></ol></li></ul></li><li><p>产生原因</p><ul><li><ol><li>与软件本身特点有关</li></ol><ul><li><p>逻辑部件</p><ul><li>质量难以评价, 管理、开发和维护困难</li></ul></li><li><p>规模庞大</p><ul><li>开发繁琐，多人分工协作，设计技术和管理等问题</li></ul></li></ul></li><li><ol start="2"><li>与软件开发与维护不正确有关</li></ol><ul><li>早期软件开发具有个体化特点</li><li>忽视软件需求分析的重要性</li><li>认为软件开发就是写程序并设法使之运行</li><li>轻视软件维护</li></ul></li></ul></li><li><p>消除途径</p><ul><li>对计算机软件有正确的认识, 消除”软件就是程序”的错误认识. 认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目,充分借鉴吸取已有经验</li><li>推广使用在实践中总结出的开发软件的成功技术和方法,并继续研究探索</li><li>开发和使用更好地软件工具</li></ul></li></ul><h3 id="2-1-软件工程"><a href="#2-1-软件工程" class="headerlink" title="2.1 软件工程"></a>2.1 软件工程</h3><ul><li><p>简介</p><ul><li><p>定义</p><ul><li>指导计算机软件开发和维护的一门工程学科, 该学科的目的是生产出能按期交付的、在预算范围内的、满足用户需求的、质量合格的软件产品</li></ul></li><li><p>本质特性</p><ul><li>关注于大型程序的构造</li><li>中心课题是控制复杂性</li><li>软件经常变化</li><li>开发软件效率非常重要</li><li>和谐地合作是开发软件的关键（标准和规程）</li><li>软件必须有效地支持它的用户（满足各方面需求）</li><li>在软件工程领域中通常由具有一种文化的人替具有另一种文化的人开发产品</li></ul></li></ul></li><li><p>基本原理</p><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该小而精</li></ul></li><li><p>方法学</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;软件工程导论&quot;&gt;&lt;a href=&quot;#软件工程导论&quot; class=&quot;headerlink&quot; title=&quot;软件工程导论&quot;&gt;&lt;/a&gt;软件工程导论&lt;/h1&gt;&lt;h2 id=&quot;1-软件工程概论&quot;&gt;&lt;a href=&quot;#1-软件工程概论&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="软件工程导论" scheme="http://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>摩尔庄园手游NPC喜好</title>
    <link href="http://www.ckxgzxa.top/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%AD%E6%89%8B%E6%B8%B8NPC%E5%96%9C%E5%A5%BD"/>
    <id>http://www.ckxgzxa.top/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%AD%E6%89%8B%E6%B8%B8NPC%E5%96%9C%E5%A5%BD</id>
    <published>2021-06-19T15:42:01.000Z</published>
    <updated>2021-09-19T10:51:05.142Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th align="center"><strong>NPC</strong></th><th align="center"><strong>位置</strong></th><th><strong>喜好</strong></th><th><strong>厌恶</strong></th><th><strong>好友</strong></th></tr></thead><tbody><tr><td align="center">菩提</td><td align="center">神秘湖(阳光沙滩)码头</td><td>清炒毛毛豆、奇异果、星空鱼、香蕉</td><td>荔枝、狗鱼</td><td></td></tr><tr><td align="center">艾尔</td><td align="center">警署</td><td>鸡蛋、满天星、罗汉鱼、牛奶鱼群汤</td><td>大闸蟹、小龙虾</td><td></td></tr><tr><td align="center">艾米</td><td align="center">报社门口</td><td>锦鲤、月亮海螺、棉花糖、胡萝卜盖饭</td><td>水蜘蛛、奇异果</td><td></td></tr><tr><td align="center">杰西</td><td align="center">城堡喷泉广场</td><td>茄子、小丑鱼、小麦牛奶蛋粥、牛奶</td><td>水蛇、章鱼、葡萄</td><td></td></tr><tr><td align="center">彩虹</td><td align="center">宠物店</td><td>胡萝卜、浆果烧饼、小麦牛奶蛋粥、章鱼</td><td>利齿狗鱼、鲶鱼</td><td></td></tr><tr><td align="center">丝尔特</td><td align="center">服装店门口</td><td>苹果、羊毛、甲鱼南瓜盅、蒲兰花</td><td>大闸蟹、章鱼</td><td></td></tr><tr><td align="center">埃里克斯</td><td align="center">家具店门口</td><td>金鱼、铜矿石、红木、棉花糖豆浆</td><td>南瓜、西瓜</td><td></td></tr><tr><td align="center">梅森</td><td align="center">梅森小屋门口</td><td>南瓜、草莓、向日葵、葫芦炒茄子</td><td>鲶鱼、带鱼</td><td></td></tr><tr><td align="center">克劳</td><td align="center">爱心礼堂</td><td>牛奶鱼群汤、冰激凌鼠、百合花</td><td>水蜘蛛、水蛇</td><td></td></tr><tr><td align="center">尼克</td><td align="center">城堡餐厅门口</td><td>白菜、石榴炸冰虾、鲶鱼、河豚</td><td>百合花</td><td></td></tr><tr><td align="center">汤米</td><td align="center">摩尔拉雅山脚</td><td>水蜜桃、铜矿石、解暑冲饮、茄块狗鱼片</td><td>水煮大闸蟹 、章鱼</td><td></td></tr><tr><td align="center">弗礼德</td><td align="center">游戏小屋(白熊游戏屋)</td><td>葫芦、冰川虾、鲶鱼、香煎雪鱼</td><td>鲤鱼、玉米、香蕉</td><td></td></tr><tr><td align="center">花婶</td><td align="center">淘淘乐街</td><td>毛毛花、七色花、葡萄、椰汁水果捞</td><td>金鱼</td><td></td></tr><tr><td align="center">瑞琪</td><td align="center">前哨站</td><td>小丑鱼、抱抱熊、毛毛爆囧菇</td><td>怪怪鱼</td><td></td></tr><tr><td align="center">凯文</td><td align="center">摩尔拉雅山顶</td><td>小丑鱼、抱抱熊、葫芦烧茄子</td><td>水蛇、水蜘蛛、章鱼</td><td></td></tr><tr><td align="center">洛克</td><td align="center">摩尔城堡大门处</td><td>向日葵、星空鱼、浆果浓汤、椰子</td><td>毛毛豆、怪怪鱼、茄块狗鱼片、麻辣小龙虾</td><td></td></tr><tr><td align="center">琦琦</td><td align="center">派对广场</td><td>南瓜、初恋海星、麻辣小龙虾、水蜜桃</td><td>水蛇、水蜘蛛</td><td></td></tr><tr><td align="center">茜茜</td><td align="center">摩尔拉雅山腰</td><td>水蜘蛛、樱花蛇、麻辣小龙虾</td><td>带鱼、苹果</td><td></td></tr><tr><td align="center">尤尤</td><td align="center">阳光牧场</td><td>毛毛花、向日葵，玫瑰海星、奶油玉米浓汤</td><td>蒜头蛙、粑粑海肠、水蜘蛛</td><td></td></tr><tr><td align="center">贝琪</td><td align="center">摩尔拉雅山顶</td><td>玉米、绿鲤鱼、河童、花香金鱼</td><td>胡萝卜盖饭、胡萝卜、奇异果</td><td></td></tr></tbody></table><p><img src="/img/others/%E6%91%A9%E5%B0%94%E5%BA%84%E5%9B%ADNPC.jpg" alt="摩尔庄园NPC"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;NPC&lt;/strong&gt;&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;&lt;strong&gt;位置&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;喜好&lt;/strong&gt;&lt;/th&gt;
&lt;</summary>
      
    
    
    
    
    <category term="游戏" scheme="http://www.ckxgzxa.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>第七章 实现</title>
    <link href="http://www.ckxgzxa.top/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AE%9E%E7%8E%B0"/>
    <id>http://www.ckxgzxa.top/%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AE%9E%E7%8E%B0</id>
    <published>2021-05-21T16:44:15.000Z</published>
    <updated>2021-05-23T12:24:10.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-实现"><a href="#第七章-实现" class="headerlink" title="第七章 实现"></a>第七章 实现</h1><hr><h2 id="实现包括：编码和测试"><a href="#实现包括：编码和测试" class="headerlink" title="实现包括：编码和测试"></a>实现包括：编码和测试</h2><blockquote><p>编码：把软件设计结果翻译成程序。<br>测试：检测程序并改正错误的过程。</p></blockquote><hr><h2 id="白盒测试和黑盒测试的定义"><a href="#白盒测试和黑盒测试的定义" class="headerlink" title="白盒测试和黑盒测试的定义"></a>白盒测试和黑盒测试的定义</h2><h3 id="白盒测试（也称结构测试）"><a href="#白盒测试（也称结构测试）" class="headerlink" title="白盒测试（也称结构测试）"></a>白盒测试（也称结构测试）</h3><blockquote><p>如果知道软件内部工作过程，可以通过测试来检验软件内部动作是否按照规格说明书的规定正常进行，这种测试称为白盒测试。</p></blockquote><h3 id="黑盒测试（也称功能测试）"><a href="#黑盒测试（也称功能测试）" class="headerlink" title="黑盒测试（也称功能测试）"></a>黑盒测试（也称功能测试）</h3><blockquote><p>如果已经知道软件应该具有的功能，可以通过测试来检验是否每个功能都能正常使用，这种测试称黑盒测试。也称功能测试。</p></blockquote><hr><h2 id="软件测试的步骤"><a href="#软件测试的步骤" class="headerlink" title="软件测试的步骤"></a>软件测试的步骤</h2><h3 id="1-模块测试（测试编码和详细设计的错误）"><a href="#1-模块测试（测试编码和详细设计的错误）" class="headerlink" title="1. 模块测试（测试编码和详细设计的错误）"></a>1. 模块测试（测试编码和详细设计的错误）</h3><blockquote><p>模块测试又称单元测试，它把每个模块作为单独的实体来测试。</p></blockquote><h3 id="2-子系统测试（测试模块接口）"><a href="#2-子系统测试（测试模块接口）" class="headerlink" title="2. 子系统测试（测试模块接口）"></a>2. 子系统测试（测试模块接口）</h3><blockquote><p>子系统测试是把警告单元测试的模块放在一起形成一个子系统来测试。</p></blockquote><h3 id="3-系统测试"><a href="#3-系统测试" class="headerlink" title="3. 系统测试"></a>3. 系统测试</h3><blockquote><p>系统测试是把经过测试的子系统装配成一个完整的系统来测试。<br>子系统测试测试和系统测试，通常称为集成测试。</p></blockquote><h3 id="4-验收测试"><a href="#4-验收测试" class="headerlink" title="4. 验收测试"></a>4. 验收测试</h3><blockquote><p>验收测试把软件系统作为单一的实体进行测试（利用用户的实际数据测试）。</p></blockquote><h3 id="5-平行运行"><a href="#5-平行运行" class="headerlink" title="5.平行运行"></a>5.平行运行</h3><blockquote><p>平行运行是同时运行新开发出来的系统和将被它取代的旧系统，以便比较新旧两个系统的处理结果。</p></blockquote><hr><h2 id="单元测试-计算机测试（驱动程序和存根程序）"><a href="#单元测试-计算机测试（驱动程序和存根程序）" class="headerlink" title="单元测试-计算机测试（驱动程序和存根程序）"></a>单元测试-计算机测试（驱动程序和存根程序）</h2><blockquote><p>单元测试集中检测软件的设计的最小单元—模块。单元测试和编码属于软件工程的同一阶段。一般方法是：</p><ul><li>首先通过编译系统检查并改正程序中所有的语法错误；</li><li>然后用详细设计模块说明为指南，对重要的控制路径进行测试，以便发现模块内部的错误。</li><li>通常，单元测试使用白盒测试技术。</li></ul></blockquote><h3 id="测试重点"><a href="#测试重点" class="headerlink" title="测试重点"></a>测试重点</h3><ol><li>模块接口</li></ol><blockquote><p>应该对穿过模块接口的数据流进行检测，以保证正确的输入和输出。</p></blockquote><ol start="2"><li>局部数据结构</li></ol><blockquote><p>这是错误的主要来源，应该设计相应的测试用例，以便发现数据结构方面的错误。</p></blockquote><ol start="3"><li>重要的执行路径</li></ol><blockquote><p>由于不可能进行穷尽测试，因此选择测试路径是非常关键的。</p></blockquote><ol start="4"><li>出错处理通路和边界条件</li></ol><h3 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h3><h3 id="计算机测试"><a href="#计算机测试" class="headerlink" title="计算机测试"></a>计算机测试</h3><blockquote><p>由于软件模块不是一个独立的系统，不能独立运行，要依靠其他模块调用，或需要调用其他模块。因此，必须要为测试的单元开发驱动程序或存根程序。</p><p>1.驱动程序</p><blockquote><p>相当于一个“主程序”，用来把测试数据传送给被测试的模块，并打印有关结果。</p></blockquote><ol start="2"><li>存根程序</li></ol><blockquote><p>用来代替被测试模块所调用的模块，相当于“虚拟子程序”。</p></blockquote></blockquote><hr><h2 id="集成测试：非渐增测试和渐增式测试"><a href="#集成测试：非渐增测试和渐增式测试" class="headerlink" title="集成测试：非渐增测试和渐增式测试"></a>集成测试：非渐增测试和渐增式测试</h2><blockquote><p>集成测试是组装软件的系统化技术，它将经过单元测试的模块联系在一起进行测试。</p></blockquote><p>由模块组装成程序时有两种方法：</p><h3 id="1-非渐增式测试方法"><a href="#1-非渐增式测试方法" class="headerlink" title="1. 非渐增式测试方法"></a>1. 非渐增式测试方法</h3><blockquote><p>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序。</p></blockquote><h3 id="2-渐增式测试方法"><a href="#2-渐增式测试方法" class="headerlink" title="2. 渐增式测试方法"></a>2. 渐增式测试方法</h3><blockquote><p>每次增加一个待测试模块，把它同已经测试好的那些模块结合起来进行测试，反复进行直到完成所有模块测试的方法。<br>使用渐增式测试方法把模块结合到软件系统中去时，有自顶向下和自底向上两种集成方法。  </p></blockquote><hr><h2 id="确认测试：Alpha和Beta测试"><a href="#确认测试：Alpha和Beta测试" class="headerlink" title="确认测试：Alpha和Beta测试"></a>确认测试：Alpha和Beta测试</h2><h3 id="Alpha测试"><a href="#Alpha测试" class="headerlink" title="Alpha测试"></a>Alpha测试</h3><blockquote><p>用户在开发者的场所进行测试，并且在开发者的指导下进行，测试在受控环境中进行，开发者记录发现的错误和问题；</p></blockquote><h3 id="Beta测试"><a href="#Beta测试" class="headerlink" title="Beta测试"></a>Beta测试</h3><blockquote><p>用户在一个或多个客户场所进行测试，不受开发者控制，测试者记录发现的问题和错误，定期将问题报告发送给开发者。</p></blockquote><hr><h2 id="白盒测试技术"><a href="#白盒测试技术" class="headerlink" title="白盒测试技术"></a>白盒测试技术</h2><h3 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1. 语句覆盖"></a>1. 语句覆盖</h3><blockquote><p>设计的测试用例能使程序中每条语句至少执行一次。</p></blockquote><h3 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2. 判定覆盖"></a>2. 判定覆盖</h3><blockquote><p>判定覆盖是指：选取足够的测试用例，使得程序中每个判断的可能结果都至少执行一次，也就是说使程序的每个判断分支至少通过一次。</p></blockquote><h3 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3. 条件覆盖"></a>3. 条件覆盖</h3><blockquote><p>条件覆盖是指：选择足够的测试用例，使得程序中每个判定表达式的每个条件都取到各种可能的结果。</p></blockquote><blockquote><p>条件覆盖通常比判定覆盖强，但是条件覆盖不一定包含判定覆盖。</p></blockquote><h3 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4. 判定/条件覆盖"></a>4. 判定/条件覆盖</h3><blockquote><p>选取足够的测试用例使得同时满足判定覆盖和条件覆盖的要求。</p></blockquote><h3 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5. 条件组合覆盖"></a>5. 条件组合覆盖</h3><blockquote><p>选取足够的测试用例，使得每个判定表达式中条件的各种可能的组合都至少出现一次。</p></blockquote><p>如果从对程序路径的覆盖程度分析，可以提出下面一些逻辑覆盖标准：</p><h3 id="6-点覆盖"><a href="#6-点覆盖" class="headerlink" title="6. 点覆盖"></a>6. 点覆盖</h3><blockquote><p>选取足够多的测试用例，使得程序执行路径至少经过程序图中每个节点一次。</p></blockquote><h3 id="7-边覆盖"><a href="#7-边覆盖" class="headerlink" title="7.  边覆盖"></a>7.  边覆盖</h3><blockquote><p>边覆盖是指：选取足够多的测试用例，使得程序执行路径至少经过程序图中每条边一次。</p></blockquote><h3 id="8-路径覆盖"><a href="#8-路径覆盖" class="headerlink" title="8. 路径覆盖"></a>8. 路径覆盖</h3><blockquote><p>路径覆盖是指：选取足够多的测试用例，使得程序的每条可能路径都至少执行一次。</p></blockquote><hr><h2 id="黑盒测试：等价划分、边界值检测和错误推测"><a href="#黑盒测试：等价划分、边界值检测和错误推测" class="headerlink" title="黑盒测试：等价划分、边界值检测和错误推测"></a>黑盒测试：等价划分、边界值检测和错误推测</h2><hr><h2 id="调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）"><a href="#调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）" class="headerlink" title="调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）"></a>调试：蛮干法、回溯法和原因排除法（对分查找、归纳和演绎法）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-实现&quot;&gt;&lt;a href=&quot;#第七章-实现&quot; class=&quot;headerlink&quot; title=&quot;第七章 实现&quot;&gt;&lt;/a&gt;第七章 实现&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;实现包括：编码和测试&quot;&gt;&lt;a href=&quot;#实现包括：编码和测试&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第六章 详细设计</title>
    <link href="http://www.ckxgzxa.top/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1"/>
    <id>http://www.ckxgzxa.top/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1</id>
    <published>2021-05-20T17:36:06.000Z</published>
    <updated>2021-09-15T09:22:23.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-详细设计"><a href="#第六章-详细设计" class="headerlink" title="第六章_详细设计"></a>第六章_详细设计</h1><hr><blockquote><p><strong>概要设计说明书</strong><br>该说明书是概要实际阶段的工作成果，它应说明功能分配、模块划分、程序的总体结构、输入输出以及接口设计、运行设计、数据结构设计和出错处理设计等，为详细设计提供基础。</p></blockquote><hr><h2 id="什么是结构化程序设计？经典、扩展和修正的控制结构；"><a href="#什么是结构化程序设计？经典、扩展和修正的控制结构；" class="headerlink" title="什么是结构化程序设计？经典、扩展和修正的控制结构；"></a>什么是结构化程序设计？经典、扩展和修正的控制结构；</h2><h3 id="经典定义"><a href="#经典定义" class="headerlink" title="经典定义"></a>经典定义</h3><blockquote><p>如果一个程序的代码块仅仅通过<strong>顺序、选择和循环</strong>这三种基本控制结构进行链接，并且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。<br><img src="/img/soft_intro_c6/3%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="3种基本的控制结构"></p></blockquote><h3 id="更全面定义"><a href="#更全面定义" class="headerlink" title="更全面定义"></a>更全面定义</h3><blockquote><p>结构程序设计是尽可能少用 GOTO 语句的程序设计方法。最好仅在检测出错误时才使用 GOTO 语句，而且应该总是使用前向 GOTO 语句。</p></blockquote><blockquote><ul><li>为了实际使用方便起见，常常还允许使用 DO-UNTIL 和 DO-CASE 两种控制结构。<br><img src="/img/soft_intro_c6/%E5%85%B6%E4%BB%96%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84.png" alt="其他常用的控制结构"></li><li>有时需要立即从循环（甚至嵌套的循环）中转移出来，允许使用 LEAVE（或 BREAK）结构。LEAVE 或 BREAK 结构实质上是受限制的 GOTO 语句，用于转移到循环结构后面</li></ul></blockquote><h3 id="经典的结构程序设计"><a href="#经典的结构程序设计" class="headerlink" title="经典的结构程序设计"></a>经典的结构程序设计</h3><blockquote><p>只允许使用顺序、IF-THEN-ELSE型分支和DO-WHILE型循环这三种基本控制结构；</p></blockquote><h3 id="扩展的结构程序设计"><a href="#扩展的结构程序设计" class="headerlink" title="扩展的结构程序设计"></a>扩展的结构程序设计</h3><blockquote><p>如果除了上述3中基本控制结构之外，还允许使用DO-CASE型多分支结构和DO-UNTIL型循环结构；</p></blockquote><h3 id="修正的结构程序设计"><a href="#修正的结构程序设计" class="headerlink" title="修正的结构程序设计"></a>修正的结构程序设计</h3><blockquote><p>再加上允许使用LEAVE（或BREAK）结构。</p></blockquote><hr><h2 id="人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；"><a href="#人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；" class="headerlink" title="人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；"></a>人机界面设计遇到的4个问题：系统响应时间（长度和易变性）、用户帮助设施、出错信息处理、命令交互；</h2><blockquote><ul><li>人机界面设计是接口设计的重要组成部分。对于交互式系统来说，人机界面设计和数据设计、体系结构设计及过程设计一样重要。</li><li>人机界面的设计质量，直接影响用户对软件产品的评价，从而影响软件产品的竞争力和寿命，必须对人机界面设计给予足够重视。</li></ul></blockquote><h3 id="设计人机界面过程中会遇到的4个问题"><a href="#设计人机界面过程中会遇到的4个问题" class="headerlink" title="设计人机界面过程中会遇到的4个问题:"></a>设计人机界面过程中会遇到的4个问题:</h3><h4 id="1-系统响应时间"><a href="#1-系统响应时间" class="headerlink" title="1. 系统响应时间:"></a>1. 系统响应时间:</h4><blockquote><p>系统相应时间指从用户完成某个控制动作，到软件给出预期的相应之间的这段时间。系统响应时间有两个重要属性：长度和易变性。</p><ul><li><strong>长度：</strong> 如果系统响应时间过长，用户就会感到紧张</li><li><strong>易变性：</strong> 指系统响应时间相对于平均相应时间的偏差，即使系统响应时间较长，响应时间易变性低也有助于用户建立起稳定的工作节奏。</li></ul></blockquote><h4 id="2-用户帮助设施"><a href="#2-用户帮助设施" class="headerlink" title="2. 用户帮助设施"></a>2. 用户帮助设施</h4><blockquote><p>大多数现代软件都提供联机帮助设施，用户无须离开用户界面就能解决自己的问题。常见的帮助设施可分为集成的和附加的两类。</p><ul><li><strong>集成的帮助设施</strong> 设计在软件里面，它对用户工作内容是敏感的，用户可以从与刚刚完成的操作有关的主题中选择一个请求帮助。</li><li><strong>附加的帮助设施</strong> 是在系统建成后再添加到软件中的，它实际上是一种查询能力有限的联机用户手册。</li></ul><p>集成的帮助设施优于附加的帮助设施。</p></blockquote><h4 id="3-出错信息处理"><a href="#3-出错信息处理" class="headerlink" title="3. 出错信息处理"></a>3. 出错信息处理</h4><blockquote><p>出错信息和警告信息，是出现问题时交互式系统给出的“坏消息”。</p></blockquote><h4 id="4-命令交互"><a href="#4-命令交互" class="headerlink" title="4. 命令交互"></a>4. 命令交互</h4><blockquote><p>多数情况下，用户既可以从菜单中选择软件功能，也可以通过键盘命令序列调用软件功能。<br>在理想的情况下，所有应用软件都有一致的命令使用方法。</p></blockquote><hr><h2 id="过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树"><a href="#过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树" class="headerlink" title="过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树"></a>过程设计的工具：图形、表格和语言。程序流程图、盒图（N-S图）、PAD图、判定表、判定树</h2><blockquote><ul><li>定义：描述程序处理工程的工具</li><li>分类：图形、表格和语言</li><li>基本要求：不论是哪类工具，<strong>对它们的基本要求都是能提供对设计的无歧义的描述，</strong> 也就是应该指明控制流程、处理功能、数据组织以及其他方面的实现细节，从而在编码阶段能把对设计的描述直接翻译成程序代码。</li></ul></blockquote><h3 id="1-程序流程图"><a href="#1-程序流程图" class="headerlink" title="1. 程序流程图"></a>1. 程序流程图</h3><blockquote><ul><li>程序流程图又称为程序框图，它是历史最悠久、使用最广泛的描述过程设计的方法。</li><li>它的主要优点是对控制流程的描绘很直观，便于初学者掌握。</li><li>程序流程图历史悠久，至今仍在广泛使用着。</li></ul></blockquote><h4 id="程序流程图的符号"><a href="#程序流程图的符号" class="headerlink" title="程序流程图的符号"></a>程序流程图的符号</h4><blockquote><p><img src="/img/soft_intro_c6/%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE%E7%AC%A6%E5%8F%B7.png" alt="程序流程图符号"></p></blockquote><h4 id="程序流程图的主要缺点："><a href="#程序流程图的主要缺点：" class="headerlink" title="程序流程图的主要缺点："></a>程序流程图的主要缺点：</h4><blockquote><ul><li>程序流程图本质上不是逐步求精的好工具，它诱使程序员过早地考虑程序的控制流程，而不去考虑程序的全局结构。</li><li>程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以完全不顾结构程序设计的精神，随意转移控制。</li><li>程序流程图不易表示数据结构。</li></ul></blockquote><h3 id="2-盒图（N-S图）"><a href="#2-盒图（N-S图）" class="headerlink" title="2. 盒图（N-S图）"></a>2. 盒图（N-S图）</h3><h4 id="盒图的特点："><a href="#盒图的特点：" class="headerlink" title="盒图的特点："></a>盒图的特点：</h4><blockquote><ul><li>功能域明确。</li><li>不可能任意转移控制。</li><li>很容易确定局部和全称数据的作用域。</li><li>很容易表示嵌套关系，也可以表示模块的层次结构。</li></ul></blockquote><h4 id="盒图的基本符号"><a href="#盒图的基本符号" class="headerlink" title="盒图的基本符号:"></a>盒图的基本符号:</h4><blockquote><p><img src="/img/soft_intro_c6/%E7%9B%92%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7.png" alt="盒图的基本符号"><br>(a) 顺序；(b) IF_THEN_ELSE型分支；(c) CASE型多分支；(d) 循环；(e) 调用子程序 A</p></blockquote><h3 id="3-PAD图"><a href="#3-PAD图" class="headerlink" title="3. PAD图"></a>3. PAD图</h3><blockquote><ul><li>PAD是问题分析图(problem analysis diagram)的英文缩写，自1973年由日本日立公司发明以后，已得到一定程度的推广。</li><li>它用二维树形结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易。</li></ul></blockquote><h4 id="PAD图的基本符号："><a href="#PAD图的基本符号：" class="headerlink" title="PAD图的基本符号："></a>PAD图的基本符号：</h4><blockquote><p><img src="/img/soft_intro_c6/PAD%E5%9B%BE%E7%AC%A6%E5%8F%B7.png" alt="PAD图的基本符号"><br>(a)顺序（先执行P1后执行P2）；(b)选择（IF C THEN P1 ELSE P2）；(c)CASE型多分支(d)WHILE型循环（WHILE C DO P）；(e)UNTIL型循环（REPEAT P UNTIL C）;(f)语句标号；(g)定义</p></blockquote><h4 id="PAD图的主要优点："><a href="#PAD图的主要优点：" class="headerlink" title="PAD图的主要优点："></a>PAD图的主要优点：</h4><blockquote><ul><li>使用表示结构化控制结构的PAD符号设计出来的程序必然是结构化程序。</li><li>PAD图所描绘的程序结构十分清晰。</li><li>PAD图表现程序逻辑易读、易懂、易记。</li><li>容易将PAD图转换成高级语言源程序，这种转换可用软件工具自动完成。</li><li>既可表示程序逻辑，也可描绘数据结构。</li><li>PAD图的符号支持自顶向下、逐步求精方法的使用。</li></ul></blockquote><blockquote><p>使用PAD提供的定义功能来逐步求精的例子<br><img src="/img/soft_intro_c6/PAD_%E9%80%90%E6%AD%A5%E6%B1%82%E7%B2%BE.png" alt="使用PAD提供的定义功能逐步求精_例"></p></blockquote><h3 id="4-判定表"><a href="#4-判定表" class="headerlink" title="4. 判定表"></a>4. 判定表</h3><blockquote><ul><li>当算法中包含 <strong>多重嵌套的条件选择</strong> 时，用程序流程图、盒图、PAD图或后面即将介绍的过程设计语言（PDL）都不易清楚地描述。</li><li>判定表能够清晰地表示复杂的条件组合与应做的动作之间的对应关系。</li></ul></blockquote><h4 id="判定表组成（4部分）"><a href="#判定表组成（4部分）" class="headerlink" title="判定表组成（4部分）"></a>判定表组成（4部分）</h4><blockquote><ul><li>左上部列出所有条件；</li><li>左下部是所有可能做的动作；</li><li>右上部是表示各种条件组合的一个矩阵；</li><li>右下部是和每种条件组合相对应的动作。</li></ul><p><img src="/img/soft_intro_c6/%E5%88%A4%E5%AE%9A%E8%A1%A8%E7%BB%84%E6%88%90.png" alt="判定表组成"></p></blockquote><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><blockquote><p>能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</p></blockquote><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><ul><li>判定表的含义不是一眼就能看出来的，初次接触这种工具的人理解它需要有一个简短的学习过程。</li><li>当数据元素的值多于两个时，判定表的简洁程度也将下降。</li></ul></blockquote><h3 id="5-判定树"><a href="#5-判定树" class="headerlink" title="5. 判定树"></a>5. 判定树</h3><blockquote><ul><li>判定树是判定表的变种，也能清晰地表示复杂的条件组合与应做的动作之间的对应关系。</li><li>多年来判定树一直受到人们的重视，是一种比较常用的系统分析和设计的工具。</li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c6/%E5%88%A4%E5%AE%9A%E6%A0%91%E4%BE%8B%E5%AD%90.png" alt="判定树例子"></p></blockquote><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h4><blockquote><p>形式简单，一眼就可以看出其含义，因此易于掌握和使用。</p></blockquote><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><ul><li>简洁性不如判定表，数据元素的同一个值往往要重复写多遍，而且越接近树的叶端重复次数越多。</li><li>画判定树时分枝的次序可能对最终画出的判定树的简洁程度有较大影响。</li></ul></blockquote><h3 id="6-过程设计语言"><a href="#6-过程设计语言" class="headerlink" title="6. 过程设计语言"></a>6. 过程设计语言</h3><hr><h2 id="过程设计语言（PDL）：伪码"><a href="#过程设计语言（PDL）：伪码" class="headerlink" title="过程设计语言（PDL）：伪码"></a>过程设计语言（PDL）：伪码</h2><blockquote><ul><li>过程设计语言(PDL)也称为伪码，它是用正文形式表示数据和处理过程的设计工具。</li><li>PDL具有严格的关键字外部语法，用于定义控制结构和数据结构；另一方面，PDL表示实际操作和条件的内部语法通常又是灵活自由的，可以适应各种工程项目的需要。</li><li>PDL是一种“混杂”语言，它使用一种语言的词汇，同时却使用另一种语言的语法。 </li></ul></blockquote><h3 id="伪代码的基本控制结构："><a href="#伪代码的基本控制结构：" class="headerlink" title="伪代码的基本控制结构："></a>伪代码的基本控制结构：</h3><blockquote><ul><li>简单陈述句结构：避免复合语句。</li><li>判定结构：IF_THEN_ELSE 或 CASE_OF 结构。</li><li>选择结构：WHILE_DO或REPEAT_UNTIL 结构</li></ul></blockquote><h3 id="PDL的特点："><a href="#PDL的特点：" class="headerlink" title="PDL的特点："></a>PDL的特点：</h3><blockquote><ol><li>关键字的固定用法，它提供了结构化控制结构、数据说明和模块化的特点。</li><li>自然语言的自由语言，它描绘处理特点。</li><li>数据说明的手段。应该既包括简单的数据结构，又包括复杂的数据结构。</li><li>模块定义和调用的技术，应该提供各种接口描述模式。</li></ol></blockquote><h3 id="PDL的优点："><a href="#PDL的优点：" class="headerlink" title="PDL的优点："></a>PDL的优点：</h3><blockquote><ul><li>可以作为注释直接插在源程序中间。有助于保持文档和程序的一致性，提高了文档的质量。</li><li>可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的书写和编辑工作。</li><li>已经有自动处理程序存在，并且可以自动由PDL生成代码。</li></ul></blockquote><h3 id="PDL的缺点："><a href="#PDL的缺点：" class="headerlink" title="PDL的缺点："></a>PDL的缺点：</h3><blockquote><p>不如图形工具直观，描述复杂的条件组合与动作间的对应关系时，不如判定表清晰简单。</p></blockquote><hr><h2 id="面向数据结构的设计方法-Jackson图，和步骤"><a href="#面向数据结构的设计方法-Jackson图，和步骤" class="headerlink" title="面向数据结构的设计方法-Jackson图，和步骤"></a>面向数据结构的设计方法-Jackson图，和步骤</h2><ul><li>数据结构既影响程序的结构又影响程序的处理过程<ul><li>重复出现的数据通常由具有循环控制结构的程序来处理</li><li>选择数据要用带有分支控制结构的程序来处理</li><li>层次的数据组织通常和使用这些数据的程序的层次结构十分相似。</li></ul></li><li>面向数据结构的设计方法的最终目标是得出对程序处理过程的描述。</li></ul><h3 id="Jackson图"><a href="#Jackson图" class="headerlink" title="Jackson图"></a>Jackson图</h3><h4 id="数据结构中数据元素彼此间的逻辑关系："><a href="#数据结构中数据元素彼此间的逻辑关系：" class="headerlink" title="数据结构中数据元素彼此间的逻辑关系："></a>数据结构中数据元素彼此间的逻辑关系：</h4><blockquote><ul><li><p>顺序结构，顺序结构的数据由一个或多个数据元素组成，每个元素按确定次序出现一次。<br><img src="/img/soft_intro_c6/Jackson%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84.png" alt="顺序结构"></p></li><li><p>选择结构，选择结构的数据包含两个或多个元素，每次使用这个数据时按一定条件从这些数据元素中选择一个。<br><img src="/img/soft_intro_c6/Jackson%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84.png" alt="选择结构"></p></li><li><p>重复结构，重复结构的数据，根据使用时的条件由一个数据元素出现零次或多次构成。<br><img src="/img/soft_intro_c6/Jackson%E9%87%8D%E5%A4%8D%E7%BB%93%E6%9E%84.png" alt="重复结构"></p></li></ul></blockquote><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><blockquote><ul><li>便于表示层次结构，而且是对结构进行自顶向下分解的有力工具；</li><li>形象直观可读性好；</li><li>技能表示数据结构也能表示程序结构。</li></ul></blockquote><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><blockquote><p>表示选择或重复结构时，选择条件或循环结束条件不能直接在图上表示出来，影响了图的表达能力，也不易直接把图翻译成程序；<br>框间连线为斜线，不易在行式打印机上输出。</p></blockquote><h3 id="改进的Jackson图"><a href="#改进的Jackson图" class="headerlink" title="改进的Jackson图"></a>改进的Jackson图</h3><blockquote><p><img src="/img/soft_intro_c6/%E6%94%B9%E8%BF%9B%E7%9A%84Jackson%E5%9B%BE.png" alt="改进的Jackson图"><br>(a) 顺序结构，B、C、D中任一个都不能是选择出现或重复出现的数据元素（即不能是右上角有小圆圈或星号标记的元素；<br>(b) 选择结构，S 右面括号中的数字 i 是分支条件的编号；<br>(c) 可选结构，A 或者是元素 B 或者不出现（可选结构是选择结构的一种常见的特殊形式）；<br>(d) 重复结构，循环结束条件的编号为 i 。</p></blockquote><h3 id="Jackson程序设计方法由5个步骤组成："><a href="#Jackson程序设计方法由5个步骤组成：" class="headerlink" title="Jackson程序设计方法由5个步骤组成："></a>Jackson程序设计方法由5个步骤组成：</h3><ol><li><p>分析并确定输入数据和输出数据的逻辑结构，用 Jackson 图描绘数据结构。</p></li><li><p>找出输入数据结构和输出数据结构中有对应关系的数据单元。所谓有对应关系是指有直接的因果关系，在程序中可以同时处理的数据单元（对于重复出现的数据单元必须重复的次序和次序都相同才可能有对应关系）。</p></li><li><p>用下述规则从描绘数据结构的 Jackson 图导出描绘程序结构的 Jackson 图：</p><blockquote><ul><li>第一，为每对有对应关系的数据单元，按照它们在数据结构图中的层次在程序结构图的相应层次画一个处理框(层次不同时与图中层次低的那个对应)；</li><li>第二，根据输入数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框；</li><li>第三，根据输出数据结构中剩余的每个数据单元所处的层次，在程序结构图的相应层次分别为它们画上对应的处理框。</li><li>改进的Jackson图规定在构成顺序结构的元素中不能有重复出现或选择出现的元素，因此可能需要增加中间层次的处理框。</li></ul></blockquote></li><li><p>列出所有操作和条件（包括分支条件和循环结束条件），并且把它们分配到程序结构图的适当位置。</p></li><li><p>用伪码表示程序。</p></li></ol><blockquote><table><thead><tr><th align="center">顺序结构</th><th align="left">选择结构</th><th align="left">循环结构</th></tr></thead><tbody><tr><td align="center">A seq</br>B</br>C</br>D</br>A end</td><td align="left">A select cond1</br>$\quad$B</br>A or cond2</br>$\quad$C</br>A or cond3</br>$\quad$D</br>A end</td><td align="left">A iter until(或while) cond</br>$\quad$B</br>A end$\quad$</td></tr></tbody></table></blockquote><h3 id="设计步骤如下："><a href="#设计步骤如下：" class="headerlink" title="设计步骤如下："></a>设计步骤如下：</h3><ol><li>用Jackson图描绘的输入输出结构。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="输入输出结构"></p></blockquote><ol start="2"><li>分析确定在输入数据结构和输出数据结构中有对应关系的数据单元。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8D%95%E5%85%83.png" alt="对应关系的数据单元"></p></blockquote><ol start="3"><li>从数据结构图导出程序结构图。</li></ol><blockquote><p><img src="/img/soft_intro_c6/Jackson_%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BE%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE.png" alt="从数据结构图导出程序结构图"></p></blockquote><ol start="4"><li>列出所有操作和条件，并且把它们分配到程序结构图的适当位置。</li></ol><blockquote><p><img src="/img/soft_intro_c6/%E6%93%8D%E4%BD%9C%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%88%86%E6%95%A3%E5%88%B0%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84%E5%9B%BE%E9%80%82%E5%BD%93%E7%9A%84%E4%BD%8D%E7%BD%AE.png"></p></blockquote><ol start="5"><li>用伪码表示程序处理程序。</li></ol><hr><h2 id="Jackson、层次图和层次方框图的区别"><a href="#Jackson、层次图和层次方框图的区别" class="headerlink" title="Jackson、层次图和层次方框图的区别"></a>Jackson、层次图和层次方框图的区别</h2><blockquote><table><thead><tr><th align="center"></th><th align="center">Jackson图</th><th align="center">层次图</th><th align="center">层次方框图</th></tr></thead><tbody><tr><td align="center">作用</td><td align="center">1. 描述数据结构</br>2. 描绘程序结构</td><td align="center">描绘软件结构</td><td align="center">描绘数据结构</td></tr><tr><td align="center">矩形框</td><td align="center">1. 数据结构</br>2. 几个语句</td><td align="center">模块</td><td align="center">数据元素</td></tr><tr><td align="center">连线</td><td align="center">组成关系</td><td align="center">调用关系</td><td align="center">组成关系</td></tr></tbody></table></blockquote><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第六章-详细设计&quot;&gt;&lt;a href=&quot;#第六章-详细设计&quot; class=&quot;headerlink&quot; title=&quot;第六章_详细设计&quot;&gt;&lt;/a&gt;第六章_详细设计&lt;/h1&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;概要设计说明书&lt;/strong&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第五章_总体设计</title>
    <link href="http://www.ckxgzxa.top/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1"/>
    <id>http://www.ckxgzxa.top/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1</id>
    <published>2021-05-19T04:39:17.000Z</published>
    <updated>2021-05-23T12:32:53.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-总体设计"><a href="#第五章-总体设计" class="headerlink" title="第五章_总体设计"></a>第五章_总体设计</h1><p>总体设计/概要设计基本目的：“系统如何实现”</p><ol><li>划分组成系统的物理元素</li><li>设计软件的结构，确定模块构成和之间的联系</li></ol><hr><h3 id="1-设计过程由两个主要阶段组成（9个步骤）"><a href="#1-设计过程由两个主要阶段组成（9个步骤）" class="headerlink" title="1. 设计过程由两个主要阶段组成（9个步骤）"></a>1. 设计过程由两个主要阶段组成（9个步骤）</h3><h4 id="系统设计阶段，确定系统的具体实现方案"><a href="#系统设计阶段，确定系统的具体实现方案" class="headerlink" title="系统设计阶段，确定系统的具体实现方案"></a>系统设计阶段，确定系统的具体实现方案</h4><ol><li><p>设想供选择的方案</p><blockquote><p>根据需求分析阶段得出的数据流图考虑各种可能的实现方案，力求从中选出最佳方案。</p></blockquote></li><li><p>选取合理的方案</p><blockquote><p>从前一步得到的一系列供选择的方案中选取若干个合理的方案。对每个合理的方案分析员都应该准备下列4份资料：</p><ol><li>系统流程图；</li><li>组成系统的物理元素清单；</li><li>成本/效益分析；</li><li>实现这个系统的进度计划。</li></ol></blockquote></li><li><p>推荐最佳方案</p><blockquote><p>分析员应该综合对比各种合理方案的利弊,推荐一个最佳的方案, 并且为推荐的方案制定详细地实现计划。</p></blockquote></li></ol><h4 id="结构设计阶段，确定软件结构"><a href="#结构设计阶段，确定软件结构" class="headerlink" title="结构设计阶段，确定软件结构"></a>结构设计阶段，确定软件结构</h4><ol start="4"><li><p>功能分解</p><blockquote><p>首先进行结构设计，然后进行过程设计。</p><ul><li>结构设计确定程序由哪些模块组成, 以及这些模块之间的关系；$\quad$过程设计 确定每个模块的处理过程。</li><li>结构设计是总体设计阶段的任务,$\quad$过程设计是详细设计阶段的任务。</li></ul></blockquote></li><li><p>设计软件的结构</p><blockquote><ul><li>通常程序中的一个模块完成一个适当的子功能。应该把模块组织成良好的层次系统。软件结构可以用层次图或结构图来描绘。</li><li>如果数据流图已经细化到适当的层次，则可以直接从数据流图映射出软件结构，这就是面向数据流的设计方法。</li></ul></blockquote></li><li><p>设计数据库</p><blockquote><p>对于需要使用数据库的那些应用系统，软件工程师应该在需求分析阶段所确定的系统数据需求的基础上，进一步设计数据库。</p></blockquote></li><li><p>制定测试计划</p><blockquote><p>在软件开发的早期阶段考虑测试问题，能促使软件设计人员在设计时注意提高软件的可测试性。</p></blockquote></li><li><p>书写文档</p><blockquote><p>应该用正式的稳定记录总体设计的结果，在这个阶段应该完成的文档通常有下述几种：</p><ol><li>系统说明；</li><li>用户手册；</li><li>测试计划；</li><li>详细的实现计划；</li><li>数据库设计结果；</li></ol></blockquote></li><li><p>审查和复审</p><blockquote><p>最后应该对总体设计的结果进行严格的技术审查和管理复审。</p></blockquote></li></ol><hr><h3 id="2-设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）"><a href="#2-设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）" class="headerlink" title="2. 设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）"></a>2. 设计原理：模块化、抽象、逐步求精、信息隐藏和局部化，和模块独立（耦合和内聚）</h3><h4 id="1-模块化"><a href="#1-模块化" class="headerlink" title="1. 模块化"></a>1. 模块化</h4><blockquote><ul><li>模块：由边界元素限定的相邻程序元素的序列，还有一个总体标识符代表</li><li>模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。</li></ul></blockquote><blockquote><p>为什么要模块化?</p><ul><li>使一个复杂的大型程序能被人的智力所管理,软件应该具备的唯一属性。</li><li>如果一个大型程序仅由一个模块组成，它将很难被人所理解。</li></ul></blockquote><blockquote><p>决定模块效率化的因素:</p><ol><li>模块的数量；</li><li>模块之间的接口；</li></ol></blockquote><blockquote><p><strong>评价一种设计方法定义模块能力的五条标准:</strong></p><ul><li>模块可分解性</li><li>模块可组装性</li><li>模块可理解性</li><li>模块连续性</li><li>模块保护性</li></ul></blockquote><blockquote><p><strong>模块化的作用:</strong></p><ul><li>采用模块化原理可以使软件结构清晰,不仅容易设计也容易阅读和理解。</li><li>模块化使软件容易测试和调试, 因而有助于提高软件的可靠性。</li><li>模块化能够提高软件的可修改性。</li><li>模块化也有助于软件开发工程的组织管理。</li></ul></blockquote><h4 id="2-抽象"><a href="#2-抽象" class="headerlink" title="2. 抽象"></a>2. 抽象</h4><blockquote><ul><li><strong>抽象:</strong> 现实世界中一定事物、状态或过程之间总存在着某些相似的方面(共性)。把这些相似的方面集中和概括起来，暂时忽略它们之间的差异，这就是抽象。</li><li>抽象就是抽出事物本质特性而暂时不考虑细节。</li></ul></blockquote><blockquote><p><strong>一般抽象过程:</strong></p><ul><li>处理复杂系统的惟一有效的方法是用层次的方式构造和分析它。</li><li>一个复杂的动态系统首先可以用一些高级的抽象概念构造和理解，这些高级概念又可以用一些较低级的概念构造和理解，如此进行下去，直至最低层次的具体元素。</li><li>例：过程抽象、数据抽象</li></ul></blockquote><blockquote><p>软件工程抽象过程: 软件工程过程的每一步都是对软件解法的抽象层次的一次精化。</p><ul><li>在可行性研究阶段，软件作为系统的一个完整部件；</li><li>在需求分析期间，软件解法是使用在问题环境内熟悉的方式描述的；</li><li>当由总体设计向详细设计过渡时，抽象的程度也就随之减少了；</li><li>最后，当源程序写出来以后，也就达到了抽象的最低层。</li></ul></blockquote><h4 id="3-逐步求精"><a href="#3-逐步求精" class="headerlink" title="3. 逐步求精"></a>3. 逐步求精</h4><blockquote><p>为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。逐步求精是人类解决复杂问题时采用的基本方法，也是许多软件工程技术的基础。</p></blockquote><blockquote><p><strong>作用:</strong></p><ul><li>帮助软件工程师把精力集中在与当前开发阶段最相关的那些方面上，而忽略那些对整体解决方案来说虽然是必要的，然而目前还不需要考虑的细节。</li><li>确保每个问题都将被解决，而且每个问题都将在适当的时候被解决，但是，在任何时候一个人都不需要同时处理7个以上知识块。</li></ul></blockquote><h4 id="4-信息隐藏和局部化"><a href="#4-信息隐藏和局部化" class="headerlink" title="4. 信息隐藏和局部化"></a>4. 信息隐藏和局部化</h4><blockquote><ul><li><strong>信息隐藏:</strong> 应该这样设计和确定模块，使得一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。</li><li><strong>局部化:</strong> 局部化的概念和信息隐藏概念是密切相关的。所谓局部化是指把一些关系密切的软件元素物理地放得彼此靠近。显然，局部化有助于实现信息隐藏。</li></ul></blockquote><blockquote><p><strong>信息隐藏和局部化的作用:</strong></p><ul><li>“隐藏”意味着有效的模块化可以通过定义一组独立的模块而实现，这些独立的模块彼此间仅仅交换那些为了完成系统功能而必须交换的信息。</li><li>使用信息隐藏原理作为模块化系统设计的标准就会带来极大好处。因为绝大多数数据和过程对于软件的其他部分而言是隐藏的，在修改期间由于疏忽而引入的错误就很少可能传播到软件的其他部分。</li></ul></blockquote><h4 id="5-模块独立"><a href="#5-模块独立" class="headerlink" title="5. 模块独立"></a>5. 模块独立</h4><blockquote><p>模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果。<br>希望这样设计软件结构，使得每个模块完成一个相对独立的特定子功能，并且和其他模块之间的关系很简单。</p></blockquote><blockquote><ul><li>重要性:<ul><li>有效的模块化的软件比较容易开发出来。</li><li>独立的模块比较容易测试和维护。</li></ul></li></ul></blockquote><blockquote><ul><li><strong>模块独立程度的两个定性标准度量:</strong><ul><li><strong>耦合</strong>衡量不同模块彼此间互相依赖(连接)的紧密程度。耦合要低，即每个模块和其他模块之间的关系要简单；</li><li><strong>内聚</strong>衡量一个模块内部各个元素彼此结合的紧密程度。内聚要高，每个模块完成一个相对独立的子功能。</li></ul></li></ul></blockquote><h5 id="1-耦合"><a href="#1-耦合" class="headerlink" title="1. 耦合"></a>1. 耦合</h5><blockquote><ul><li>耦合:是对一个软件结构内不同模块之间互连程度的度量。</li><li>要求：在软件设计中应该追求尽可能松散耦合的系统。</li><li>可以研究、测试或维护任何一个模块，而不需要对系统的其他模块有很多了解；</li><li>模块间联系简单，发生在一处的错误传播到整个系统的可能性很小；</li><li>模块间的耦合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性。</li></ul></blockquote><h6 id="耦合程度的度量"><a href="#耦合程度的度量" class="headerlink" title="耦合程度的度量"></a>耦合程度的度量</h6><blockquote><ol><li>非直接耦合/完全独立(no direct coupling)</li></ol><blockquote><p>如果两个模块中的每一个都能独立地工作而不需要另一个模块的存在，那么它们完全独立。在一个软件系统中不可能所有模块之间都没有任何连接。</p></blockquote><ol start="2"><li>数据耦合(data coupling)</li></ol><blockquote><p>如果两个模块彼此间通过参数交换信息，而且交换的信息仅仅是数据，那么这种耦合称为数据耦合。</p></blockquote><blockquote><p>评价:</p><ul><li>系统中至少必须存在这种耦合。一般说来，一个系统内可以只包含数据耦合。$\qquad$数据耦合是理想的目标。</li><li>维护更容易，对一个模块的修改不会是另一个模块产生退化错误。</li></ul></blockquote><ol start="3"><li>控制耦合(control coupling)</li></ol><blockquote><p>如果两个模块彼此间传递的信息中有控制信息，这种耦合成为控制耦合。</p></blockquote><blockquote><p><strong>评价:</strong></p><ul><li>控制耦合往往是多余的,把模块适当分解之后通常可以用数据耦合代替它。</li><li>被调用的模块需知道调用模块的内部结构和逻辑，降低了重用的可能性。</li></ul></blockquote><ol start="4"><li>特征耦合(stamp coupling)</li></ol><blockquote><p>当把整个数据结构作为参数传递而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。<br>评价：</p></blockquote><blockquote><p>被调用的模块可使用的数据多于它确实需要的数据，这将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。<br>无论何时把指针作为参数进行传递，都应该仔细检查该耦合。</p></blockquote><ol start="5"><li>公共环境耦合(common coupling)<blockquote><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等等。</p></blockquote></li></ol><blockquote><p>类型:<br><img src="/img/soft_intro_c5/%E5%85%AC%E5%85%B1%E7%8E%AF%E5%A2%83%E8%80%A6%E5%90%88.png" alt="公共环境耦合的两种类型"></p><ul><li>一个模块往公告环境送数据,另一个模块从公共环境取数据。数据耦合的一种形式，是比较松散的耦合。</li><li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li></ul></blockquote><ol start="6"><li>内容耦合(content coupling)</li></ol><blockquote><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合：</p><ul><li>一个模块访问另一个模块的内部数据；</li><li>一个模块不通过正常入口转到另一个模块的内部；</li><li>两个模块有一部分程序代码重叠；</li><li>一个模块有多个入口。</li></ul></blockquote></blockquote><blockquote><p>耦合是影响软件复杂程度的一个重要因素。</p></blockquote><blockquote><p>应该采取下述设计原则:</p><ul><li><strong>尽量使用数据耦合，</strong></li><li><strong>少用控制耦合和特征耦合，</strong></li><li><strong>限制公共环境耦合的范围，</strong></li><li><strong>完全不用内容耦合。</strong></li></ul></blockquote><h5 id="2-内聚"><a href="#2-内聚" class="headerlink" title="2. 内聚"></a>2. 内聚</h5><blockquote><ul><li>内聚: 标志一个模块内各个元素彼此结合的紧密程度，它是信息隐藏和局部化概念的自然扩展。简单地说，理想内聚的模块只做一件事情。</li><li>要求:设计时应该力求做到高内聚，通常中等程度的内聚也是可以采用的，而且效果和高内聚相差不多；但是，低内聚不要使用。</li><li>内聚和耦合是密切相关的，模块内的高内聚往往意味着模块间的松耦合。实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。</li></ul></blockquote><h6 id="内聚程度的度量"><a href="#内聚程度的度量" class="headerlink" title="内聚程度的度量"></a>内聚程度的度量</h6><ol><li>偶然内聚(coincidental cohesion)————低内聚</li></ol><blockquote><p>如果一个模块完成一组任务,  这些任务彼此间即使有关系, 关系也是很松散的, 就叫做偶然内聚。<br><img src="/img/soft_intro_c5/%E5%81%B6%E7%84%B6%E5%86%85%E8%81%9A.png" alt="偶然内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>模块内各元素之间没有实质性联系，很可能在一种应用场合需要修改这个模块，在另一种应用场合又不允许这种修改，从而陷入困境；</li><li>可理解性差，可维护性产生退化；</li><li>模块是不可重用的。</li></ul></blockquote><blockquote><p>解决方案:将模块分成更小的模块, 每个小模块执行一个操作。</p></blockquote><ol start="2"><li>逻辑内聚（logical cohesion）————低内聚</li></ol><blockquote><p>如果一个模块完成的任务在逻辑上属于相同或相似的一类，则称为逻辑内聚。<br><img src="/img/soft_intro_c5/%E9%80%BB%E8%BE%91%E5%86%85%E8%81%9A.png" alt="逻辑内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>接口难以理解, 造成整体上不易理解；</li><li>完成多个操作的代码互相纠缠在一起，即使局部功能的修改有时也会影响全局，导致严重的维护问题；</li><li>难以重用。</li></ul></blockquote><blockquote><p>解决方案: 模块分解。<br><img src="/img/soft_intro_c5/%E6%A8%A1%E5%9D%97%E5%88%86%E8%A7%A3.png" alt="模块分解示意"></p></blockquote><ol start="3"><li>时间内聚(temporal cohesion)————低内聚</li></ol><blockquote><p>如果一个模块包含的任务必须在同一段时间内执行，就叫时间内聚。<br><img src="/img/soft_intro_c5/%E6%97%B6%E9%97%B4%E5%86%85%E8%81%9A.png" alt="时间内聚"></p></blockquote><blockquote><p>评价:</p><ul><li>时间关系在一定程度上反映了程序某些实质，所以时间内聚比逻辑内聚好一些。</li><li>模块内操作之间的关系很弱，与其他模块的操作却有很强的关联。</li><li>时间内聚的模块不太可能重用。</li></ul></blockquote><ol start="4"><li>过程内聚(procedural cohesion)</li></ol><blockquote><ul><li>如果一个模块内的处理元素是相关的，而且必须以特定次序执行，则称为过程内聚。</li><li>使用程序流程图作为工具设计软件时，常常通过研究流程图确定模块的划分，这样得到的往往是过程内聚的模块。</li></ul></blockquote><blockquote><p>评价:</p><ul><li>比时间内聚好，至少操作之间是过程关联的。</li><li>仍是弱连接，不太可能重用模块。</li></ul></blockquote><blockquote><p>解决方案：分割为单独的模块，每个模块执行一个操作</p></blockquote><ol start="5"><li>通信内聚（communicational cohesion）</li></ol><blockquote><p>如果模块中所有元素都使用同一个输入数据和(或)产生同一个输出数据，则称为通信内聚。即在同一个数据结构上操作。</p></blockquote><blockquote><p>评价：模块中各操作紧密相连，比过程内聚更好。不能重用。</p></blockquote><blockquote><p>解决方案：分成多个模块，每个模块执行一个操作。</p></blockquote><ol start="6"><li>顺序内聚(sequential cohesion)</li></ol><blockquote><p>如果一个模块内的处理元素和同一个功能密切相关，而且这些处理必须顺序执行，则称为顺序内聚。</p></blockquote><blockquote><p>评价：根据数据流图划分模块时，通常得到顺序内聚的模块，这种模块彼此间的连接往往比较简单。</p></blockquote><ol start="7"><li>功能内聚(functional cohesion)</li></ol><blockquote><p>如果模块内所有处理元素属于一个整体，完成一个单一的功能，则称为功能内聚。功能内聚是最高程度的内聚。</p></blockquote><blockquote><p>评价：</p><ul><li>模块可重用，应尽可能重用；</li><li>可隔离错误，维护更容易；</li><li>扩充产品功能时更容易。</li></ul></blockquote><h6 id="七种内聚的优劣评分结果"><a href="#七种内聚的优劣评分结果" class="headerlink" title="七种内聚的优劣评分结果"></a>七种内聚的优劣评分结果</h6><blockquote><table><thead><tr><th align="center"></th><th align="center">类型</th><th align="center">分数</th></tr></thead><tbody><tr><td align="center"><strong>高内聚</strong></td><td align="center"><strong>功能内聚</strong></td><td align="center"><strong>10分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>顺序内聚</strong></td><td align="center"><strong>9分</strong></td></tr><tr><td align="center"><strong>中内聚</strong></td><td align="center"><strong>通信内聚</strong></td><td align="center"><strong>7分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>过程内聚</strong></td><td align="center"><strong>5分</strong></td></tr><tr><td align="center"><strong>低内聚</strong></td><td align="center"><strong>时间内聚</strong></td><td align="center"><strong>3分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>逻辑内聚</strong></td><td align="center"><strong>1分</strong></td></tr><tr><td align="center"></td><td align="center"><strong>偶然内聚</strong></td><td align="center"><strong>0分</strong></td></tr></tbody></table><p>设计时力争做到高内聚，并且能够辨认出低内聚的模块。</p></blockquote><hr><h3 id="3-启发准则"><a href="#3-启发准则" class="headerlink" title="3. 启发准则"></a>3. 启发准则</h3><h4 id="1-改进软件结构提高模块独立性"><a href="#1-改进软件结构提高模块独立性" class="headerlink" title="1. 改进软件结构提高模块独立性"></a>1. 改进软件结构提高模块独立性</h4><blockquote><p>通过模块分解或合并，降低耦合提高内聚。<br>两个方面：</p><blockquote><ul><li>模块功能完善化。 一个完整的模块包含：<ul><li>执行规定的功能的部分</li><li>出错处理的部分</li><li>返回一个”结束标志”</li></ul></li><li>消除重复功能, 改善软件结构。</li></ul></blockquote></blockquote><h4 id="2-模块规模应该适中"><a href="#2-模块规模应该适中" class="headerlink" title="2. 模块规模应该适中"></a>2. 模块规模应该适中</h4><blockquote><ul><li>经验表明，一个模块的规模不应过大，最好能写在一页纸内。通常规定50~100行语句，最多不超过500行。数字只能作为参考，根本问题是要保证模块的独立性。</li><li>过大的模块往往是由于分解不充分，但是进一步分解必须符合问题结构，一般说来，分解后不应该降低模块独立性。</li><li>过小的模块开销大于有效操作，而且模块数目过多将使系统接口复杂。</li></ul></blockquote><h4 id="3-深度、宽度、扇出和扇入都应适当"><a href="#3-深度、宽度、扇出和扇入都应适当" class="headerlink" title="3. 深度、宽度、扇出和扇入都应适当"></a>3. 深度、宽度、扇出和扇入都应适当</h4><blockquote><p><strong>深度：</strong> 软件结构中控制的层数，它往往能粗略地标志一个系统的大小和复杂程度。<br><strong>宽度：</strong> 软件结构内同一个层次上的模块总数的最大值。<br><strong>扇出：</strong> 一个模块直接控制（调用）的模块数目。<br><strong>扇入：</strong> 有多少个上级模块直接调用它。<br><img src="/img/soft_intro_c5/%E8%BD%AF%E4%BB%B6%E7%BB%93%E6%9E%84.png" alt="软件结构"><br><img src="/img/soft_intro_c5/%E6%89%87%E5%87%BA%E6%89%87%E5%85%A5%E4%B8%8D%E5%90%88%E7%90%86%E7%9A%84%E6%83%85%E5%86%B5.png" alt="不好的情况"></p></blockquote><h4 id="4-模块的作用域应该在控制域之内"><a href="#4-模块的作用域应该在控制域之内" class="headerlink" title="4. 模块的作用域应该在控制域之内"></a>4. 模块的作用域应该在控制域之内</h4><blockquote><ul><li><strong>模块的作用域：</strong> 定义为受该模块内一个判定影响的所有模块的集合。</li><li><strong>模块的控制域：</strong> 这个模块本身以及所有直接或间接从属于它的模块的集合。</li><li>在一个设计得很好的系统中，所有受判定影响的模块应该都从属于做出判定的那个模块，最好局限于做出判定的那个模块本身及它的直属下级模块。</li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E8%BF%9D%E5%8F%8D%E8%A7%84%E5%88%99%E7%9A%84%E6%83%85%E5%86%B5.png" alt="违反规则的情况"><br><strong>解决方案:</strong></p><ul><li>把模块 A 中的判定移到模块 M 中；</li><li>把模块 G 移到模块A下面，作为它的下级模块。</li></ul><p><img src="/img/soft_intro_c5/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.png" alt="解决方案"></p></blockquote><h4 id="5-力争降低模块接口的复杂程度"><a href="#5-力争降低模块接口的复杂程度" class="headerlink" title="5. 力争降低模块接口的复杂程度"></a>5. 力争降低模块接口的复杂程度</h4><blockquote><p>模块接口复杂是软件发生错误的一个主要原因。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。</p></blockquote><p><strong>例:解一元二次方程的函数</strong></p><ul><li><input disabled="" type="checkbox"> <strong>QUAD_ROOT(TBL, X)</strong><blockquote><ul><li>其中数组 TBL 传送方程的系数</li><li>数组 X 送回求得的根  </li></ul></blockquote></li><li><input checked="" disabled="" type="checkbox"> <strong>QUAD_ROOT(A, B, C, ROOT1, ROOT2)</strong></li></ul><h4 id="6-设计单入口单出口的模块"><a href="#6-设计单入口单出口的模块" class="headerlink" title="6. 设计单入口单出口的模块"></a>6. 设计单入口单出口的模块</h4><blockquote><p>警告软件工程师不要使模块间出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。</p></blockquote><h4 id="7-模块功能应该可以预测"><a href="#7-模块功能应该可以预测" class="headerlink" title="7. 模块功能应该可以预测"></a>7. 模块功能应该可以预测</h4><blockquote><ul><li>模块的功能应该能够预测，但也要防止模块功能过分局限。</li><li>功能可预测：如果一个模块可以当做一个黑盒子，只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。</li></ul></blockquote><hr><h3 id="4-软件结构的图形工具：层次图（H图）、HIPO图、结构图"><a href="#4-软件结构的图形工具：层次图（H图）、HIPO图、结构图" class="headerlink" title="4. 软件结构的图形工具：层次图（H图）、HIPO图、结构图"></a>4. 软件结构的图形工具：层次图（H图）、HIPO图、结构图</h3><h4 id="1-层次图-H图"><a href="#1-层次图-H图" class="headerlink" title="1. 层次图(H图)"></a>1. 层次图(H图)</h4><blockquote><p>层次图用来描绘软件的层次结构。很适于在自顶向下设计软件的过程中使用。</p></blockquote><blockquote><p>层次图和层次方框图的区别：</p><table><thead><tr><th align="center"></th><th align="center">层次图</th><th align="center">层次方框图</th></tr></thead><tbody><tr><td align="center">作用</td><td align="center">描绘软件结构</td><td align="center">描绘数据结构</td></tr><tr><td align="center">矩形框</td><td align="center">模块</td><td align="center">数据元素</td></tr><tr><td align="center">连线</td><td align="center">调用关系</td><td align="center">组成关系</td></tr></tbody></table></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E6%AD%A3%E6%96%87%E5%8A%A0%E5%B7%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E5%9B%BE.png" alt="正文加工系统的层次图"></p></blockquote><h4 id="2-HIPO图"><a href="#2-HIPO图" class="headerlink" title="2. HIPO图"></a>2. HIPO图</h4><blockquote><ul><li>HIPO图是美国IBM公司发明的“层次图+输入/处理/输出图”的英文缩写。</li><li>为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。<br><img src="/img/soft_intro_c5/HIPO%E5%9B%BE.png" alt="HIPO图"><br>和H图中每个方框相对应，应该有一张IPO图描绘这个方框代表的模块的处理过程。模块在H图中的编号便于追踪了解这个模块在软件结构中的位置。</li></ul></blockquote><h4 id="3-结构图"><a href="#3-结构图" class="headerlink" title="3. 结构图"></a>3. 结构图</h4><blockquote><p><strong>基本符号:</strong></p><ul><li>方框代表一个模块；</li><li>方框之间的直线表示模块的调用关系；</li><li>尾部是空心圆箭头表示传递的是数据；</li><li>尾部是实心圆箭头表示传递的是控制信息。<br><img src="/img/soft_intro_c5/%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="结构图"></li></ul></blockquote><blockquote><p><strong>附加符号:</strong><br><img src="/img/soft_intro_c5/%E7%BB%93%E6%9E%84%E5%9B%BE%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7.png" alt="结构图附加符号"></p><ul><li>选择调用: 判定为真时调用 A，为假时调用 B。</li><li>模块 M 循环调用模块 A、B、C。</li></ul></blockquote><blockquote><p><strong>注意:</strong></p><ul><li>层次图和结构图并不严格表示模块的调用次序，多数人习惯从左到右画模块；</li><li>层次图和结构图并不指明合适调用下层模块；<br>层次图和结构图只表明一个模块调用哪些模块，没有表示模块内还有没有其他成分；<br>通常用层次图作为描绘软件结构的文档；<br>由层次图导出结构图的过程可以作为检查设计正确性和评价模块独立性的好方法。</li></ul></blockquote><hr><h3 id="5-面向数据流的设计方法：变换流和事务流"><a href="#5-面向数据流的设计方法：变换流和事务流" class="headerlink" title="5. 面向数据流的设计方法：变换流和事务流"></a>5. 面向数据流的设计方法：变换流和事务流</h3><h4 id="1-变换流"><a href="#1-变换流" class="headerlink" title="1. 变换流"></a>1. 变换流</h4><blockquote><p>信息沿输入通路进入系统，同时由外部形式变换成内部形式，进入系统的信息通过变换中心，经加工处理以后再沿输出通路变换成外部形式离开软件系统。<br><img src="/img/soft_intro_c5/%E5%8F%98%E6%8D%A2%E6%B5%81.png" alt="变换流"></p></blockquote><h4 id="2-事务流"><a href="#2-事务流" class="headerlink" title="2. 事务流"></a>2. 事务流</h4><blockquote><p>数据沿输入通路到达一个处理T，T根据输入数据的类型在若干个动作序列中选出一个来执行。处理T称为事务中心，它完成下述任务：</p><ul><li>接收输入数据</li><li>分析每个事务以确定它的类型；</li><li>根据事务类型选取一条活动通路。<br><img src="/img/soft_intro_c5/%E4%BA%8B%E5%8A%A1%E6%B5%81.png" alt="事务流"></li></ul></blockquote><blockquote><p><img src="/img/soft_intro_c5/%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png" alt="设计过程"></p></blockquote><h4 id="3-变换分析"><a href="#3-变换分析" class="headerlink" title="3. 变换分析"></a>3. 变换分析</h4><blockquote><p>变换分析是一系列设计步骤的总称，经过这些步骤把具有变换流特点的数据流图按预先确定的模式映射成软件结构。</p></blockquote><blockquote><p><strong>设计步骤:</strong></p><ol><li>复查基本系统模型</li></ol><blockquote><ul><li>确保系统的输入数据和输出数据符合实际。</li></ul></blockquote><ol start="2"><li>复查并精化数据流图</li></ol><blockquote><ul><li>对需求分析阶段得出的数据流图认真复查，并且在必要时进行精化。</li><li>不仅要确保数据流图给出了目标系统的正确逻辑模型，而且应该使数据流图中每个处理都代表一个规模适中相对独立的子功能。</li></ul></blockquote><ol start="3"><li>确定数据流图具有变换特性还是事务特性</li></ol><blockquote><ul><li>一个系统中的所有信息流都可以认为是变换流，但是，当遇到有明显事务特性的信息流时，建议采用事务分析方法进行设计。确定数据流的全局特性和局部特性。</li></ul></blockquote><ol start="4"><li>确定输入流和输出流的边界，从而孤立出变换中心</li></ol><blockquote><ul><li>输入流和输出流的边界和对它们的解释有关,不同设计人员可能会在流内选取稍微不同的点作为边界的位置。</li></ul></blockquote><ol start="5"><li>完成“第一级分解”。</li></ol><blockquote><ul><li>位于软件结构最顶层的控制模块 $C_m$ 协调下述从属的控制功能：<ul><li>输入信息处理控制模块 $C_a$ ，管理对内部形式的数据的所有操作；</li><li>变换中心控制模块 $C_t$，管理对内部形式的数据的所有操作；</li><li>输出信息处理控制模块 $C_e$，协调输出信息的产生过程。</li></ul></li></ul><p><img src="/img/soft_intro_c5/%E7%AC%AC%E4%B8%80%E7%BA%A7%E5%88%86%E8%A7%A3.png" alt="第一级分解"></p></blockquote><ol start="6"><li>完成“第二级分解”</li></ol><blockquote><ul><li>处理映射成软件结构中一个适当的模块。完成第二级分解的方法是：<ul><li>从变换中心的边界开始逆着输入通路向外移动，把输入通路中每个处理映射成软件结构中Ca控制下的一个低层模块；</li><li>然后沿输出通路向外移动，把输出通路中每个处理映射成直接或间接受模块Ce控制的一个低层模块；</li><li>最后把变换中心内的每个处理映射成受Ct控制的一个模块。</li></ul></li></ul><p><img src="/img/soft_intro_c5/%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E8%A7%A3.png" alt="第二级分解"><br><img src="/img/soft_intro_c5/%E7%AC%AC%E4%BA%8C%E7%BA%A7%E5%88%86%E8%A7%A31.png" alt="第二级分解"></p></blockquote><ol start="7"><li>使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化</li></ol><blockquote><p>为了产生合理的分解，得到尽可能高的内聚、尽可能松散的耦合，为了得到一个易于实现、易于测试和易于维护的软件结构，应该对初步分割得到的模块进行再分解或合并。 </p></blockquote></blockquote><h4 id="4-事务分析"><a href="#4-事务分析" class="headerlink" title="4. 事务分析"></a>4. 事务分析</h4><blockquote><p>虽然在任何情况下都可以使用变换分析方法设计软件结构，但是在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。</p></blockquote><blockquote><ul><li>事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于由数据流图到软件结构的映射方法不同；</li><li>由事务流映射成的软件结构包括一个接收分支和一个发送分支；</li><li>映射出接收分支结构的方法和变换分析映射出输入结构的方法很相像，即从事务中心的边界开始，把沿着接收流通路的处理映射成模块；</li><li>发送分支的结构包含一个调度模块，它控制下层的所有活动模块；然后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构<br><img src="/img/soft_intro_c5/%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E6%B3%95.png" alt="事务分析的映射方法"></li></ul></blockquote><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结:"></a>5. 总结:</h4><blockquote><ul><li>一般说来，如果数据流不具有显著的事务特点，最好使用变换分析；反之，如果具有明显的事务中心，则应该采用事务分析技术。</li><li>机械地遵循变换分析或事务分析的映射规则，可能会得到一些不必要的控制模块，如果它们确实用处不大，那么可以而且应该把它们合并。</li><li>如果一个控制模块功能过分复杂，这应该分解为两个或多个控制模块，或者增加中间层次的控制模块。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五章-总体设计&quot;&gt;&lt;a href=&quot;#第五章-总体设计&quot; class=&quot;headerlink&quot; title=&quot;第五章_总体设计&quot;&gt;&lt;/a&gt;第五章_总体设计&lt;/h1&gt;&lt;p&gt;总体设计/概要设计基本目的：“系统如何实现”&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;划分组成系统的物理元</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第三章 需求分析</title>
    <link href="http://www.ckxgzxa.top/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"/>
    <id>http://www.ckxgzxa.top/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90</id>
    <published>2021-05-17T16:22:55.000Z</published>
    <updated>2021-05-23T02:27:37.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-需求分析"><a href="#第三章-需求分析" class="headerlink" title="第三章 需求分析"></a>第三章 需求分析</h1><hr><h4 id="需求分析的任务；获取需求的方法"><a href="#需求分析的任务；获取需求的方法" class="headerlink" title="需求分析的任务；获取需求的方法"></a>需求分析的任务；获取需求的方法</h4><h5 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h5><ul><li><p><strong>确定对系统的综合要求</strong></p><blockquote><ol><li><em>功能需求</em></li><li><em>性能需求</em></li><li><em>可靠性和可用性需求</em></li><li><em>出错处理需求</em></li><li><em>接口需求</em></li><li><em>约束</em></li><li><em>逆向需求</em></li><li><em>将来可能提出的要求</em></li></ol></blockquote></li><li><p><strong>分析系统的数据要求</strong></p><blockquote><ul><li>建立数据模型——ER图 </li><li>描绘数据结构——层次方框图和Warnier图  </li><li>数据结构规范化 </li></ul></blockquote></li><li><p><strong>导出系统的逻辑模型</strong></p><blockquote><p>综合上述两项分析的结果可以导出系统的详细的逻辑模型，通常用 <strong>数据流图</strong> 、<strong>实体-联系图</strong> 、<strong>状态转换图</strong> 、<strong>数据字典</strong> 和 <strong>主要的处理算法</strong> 描述这个逻辑模型。</p></blockquote></li><li><p><strong>修正系统开发计划</strong></p><blockquote><p>根据在分析过程中获得的对系统的更深入更具体的了解，可以比较准确地估计系统的成本和进度，修正以前制定的开发计划。 </p></blockquote></li></ul><h5 id="获取需求的方法"><a href="#获取需求的方法" class="headerlink" title="获取需求的方法"></a>获取需求的方法</h5><ul><li><p><strong>访谈</strong></p><blockquote><ol><li><em>正式访谈</em> : 系统分析员将提出一些事先准备好的具体问题。</li><li><em>非正式访谈</em> : 分析员将提出一些用户可以自由回答的开放性问题，以鼓励被访问人员说出自己的想法。</li><li><em>调查表</em> : 经过仔细考虑写出的书面回答可能比被访者对问题的口头回答更准确。</li><li><em>情景分析技术</em> :<blockquote><p>对用户将来使用目标系统解决某个具体问题的方法和结果进行分析。<br><strong>情景分析技术的用处：</strong></p><ul><li>能在某种程度上演示目标系统的行为，从而便于用户理解，而且还可能进一步揭示出一些分析员目前还不知道的需求。</li><li>能保证用户在需求分析过程中始终扮演一个积极主动的角色。让用户起积极主动的作用对需求分析工作获得成功是至关重要的。</li></ul></blockquote></li></ol></blockquote></li><li><p><strong>面向数据流自顶向下求精</strong></p><blockquote><ol><li><em>分析追踪数据流图</em> : 需求分析的目标之一就是把数据流和数据存储定义到元素级，通常从数据流图的输出端着手分析。</li><li><em>用户复查</em> : <ul><li>必须请用户对上述分析过程中得出的结果仔细地复查。复查过程验证了已知的元素，补充了未知的元素，填补了文档中的空白。</li><li>随着分析过程的进展，经过问题和解答的反复循环，分析员越来越深入具体地定义了目标系统，最终得到对系统数据和功能要求的<del>满意</del>充足了解。<br><img src="/img/soft_intro_c3/%E9%9D%A2%E5%90%91%E6%95%B0%E6%8D%AE%E6%B5%81%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%B1%82%E7%B2%BE.png" alt="面向数据流自顶向下求精"></li></ul></li></ol></blockquote></li><li><p><strong>简易的应用规格说明技术</strong></p><blockquote><ul><li>简易的应用规格说明技术是一种面向团队的需求收集法。</li><li>这种方法提倡用户与开发者密切合作，共同标识问题，提出解决方案要素，商讨不同方案并指定基本需求。 </li></ul></blockquote><blockquote><p><strong>优点:</strong></p><ul><li>开发者与用户不分彼此，齐心协力，密切合作；</li><li>即时讨论并求精；</li><li>有能导出规格说明的具体步骤。 </li></ul></blockquote></li></ul><blockquote><p><strong>分析需求的典型过程如下:</strong></p><ol><li>初步访谈, 提出建议;</li><li>会前审查需求, 确定列表;</li><li>会上讨论列表, 创建组合列表;</li><li>分组制定小型规格说明;</li><li>制定确认标准, 起草需求规格说明书 </li></ol></blockquote><ul><li><p><strong>快速建立软件原型</strong></p><blockquote><ul><li>快速建立软件原型是最准确、最有效、最强大的需求分析技术。</li><li>快速原型就是快速建立起来的旨在演示目标系统主要功能的可运行的程序。</li><li>构建原型的要点是，它应该实现用户看得见的功能，省略目标系统的“隐含”功能。</li></ul></blockquote><blockquote><p><strong>特性:</strong></p><ul><li>“快速”。快速原型的目的是尽快向用户提供一个可在计算机上运行的目标系统的模型。因此，原型的某些缺陷是可以忽略的。</li><li>“容易修改”。如果原型的第一版不是用户所需要的，就必须根据用户的意见迅速地修改它，构建出原型的第二版，以更好地满足用户需求。如果修改耗时过多，势必延误软件开发时间。 </li></ul></blockquote></li></ul><blockquote><p><strong>通常使用的3种方法和工具：</strong></p><ol><li>第四代技术（4GL）</li><li>可重用的软件构建</li><li>形式化规格说明和原型环境</li></ol></blockquote><blockquote><p>第四代技术特点：<br>简单易学，用户界面良好，面向问题、非过程化程度高，用户只需告知系统做什么，而无需说明怎么做。用4GL编程使用的代码量较少，并可成数量级地提高软件生产率。</p></blockquote><blockquote><p>程序设计语言划代：<br>1GL是汇编语言；<br>2GL是高级程序设计语言，如FORTRAN，ALGOL，BASIC，LISP等；<br>3GL是增强性的高级程序设计语言，如PASCAL，ALGOL68，FORTRAN77等；<br>4GL是按计算机科学理论指导设计出来的语言，如ADA，MODULA－2，SMALLTALK－80，JAVA，VB，VC，VF等。 </p></blockquote><hr><h4 id="需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；"><a href="#需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；" class="headerlink" title="需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；"></a>需求分析阶段需要建立3个模型：数据（E-R）、功能（DFD）和行为模型（状态转换）；</h4><hr><h4 id="实体-联系图（E-R图）：三种信息、符号和应用"><a href="#实体-联系图（E-R图）：三种信息、符号和应用" class="headerlink" title="实体-联系图（E-R图）：三种信息、符号和应用"></a>实体-联系图（E-R图）：三种信息、符号和应用</h4><ul><li><p><strong>数据模型(E-R图):</strong> 描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形。</p></li><li><p><strong>三种相互关联的信息:</strong></p><ol><li><strong>数据对象</strong></li></ol><blockquote><ul><li>是对软件必须理解的复合信息的抽象。复合信息是指具有一系列不同性质或属性的事物，仅有单个值的事物不是数据对象。</li><li>数据对象可以是外部实体、事物、行为、事件、角色、单位、地点或结构等。数据对象彼此间是有关联的。</li></ul></blockquote><ol start="2"><li>数据对象的 <strong>属性</strong></li></ol><blockquote><ul><li><strong>属性</strong> 定义了数据对象的性质。必须把一个或多个属性定义为“标识符” 。</li><li>根据对问题的理解来确定特定数据对象的合适的属性。 </li></ul></blockquote><ol start="3"><li>数据对象彼此间相互连接的 <strong>关系</strong></li></ol><blockquote><ul><li><strong>联系:</strong> 数据对象彼此之间相互连接的方式称为联系，也称为关系。</li><li><strong>联系可分为以下3种类型：</strong><ol><li>一对一联系(1∶1)</li><li>一对多联系(1∶N)</li><li>多对多联系(M∶N)</li></ol></li><li><strong>联系也可能有属性。</strong></li></ul></blockquote></li><li><p><strong>E-R图的符号</strong></p><blockquote><p><img src="/img/soft_intro_c3/E-R%E5%9B%BE%E7%9A%84%E7%AC%A6%E5%8F%B7.png"></p></blockquote></li><li><p><strong>应用</strong></p></li><li><p><strong>优点</strong></p><blockquote><ul><li>比较接近人的习惯思维方式；</li><li>用简单的图形符号表达系统分析员对问题域的理解，用户也容易理解，可以作为用户与分析员之间有效的交流工具。 </li></ul></blockquote></li></ul><hr><h4 id="状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；"><a href="#状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；" class="headerlink" title="状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；"></a>状态转换图定义，状态（3种，循环运行过程时，3种变为1种）、事件和、符号和语法表达式；</h4><ul><li><p><strong>状态转换图:</strong> 通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。还指明了作为特定事件的结果系统将做哪些动作(例如，处理数据)。</p></li><li><p><strong>状态：</strong> 是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。</p><blockquote><p>状态主要有:</p><ul><li>初态(即初始状态), 只能有一个</li><li>终态(即最终状态)，可以有0至多个</li><li>中间状态</li></ul></blockquote><blockquote><p>状态图分类：</p><ul><li>表示系统循环运行过程，通常不关心循环是怎样启动的。</li><li>表示系统单程生命期，需要标明初始状态和最终状态。</li></ul></blockquote></li><li><p><strong>事件:</strong> 是在某个特定时刻发生的事情，它是对引起系统做动作或(和)从一个状态转换到另一个状态的外界事件的抽象。简而言之，事件就是引起系统做动作或(和)转换状态的控制信息。 </p></li><li><p><strong>符号:</strong></p><blockquote><ul><li>初态:用实心圆表示；</li><li>终态:用一对同心圆(内圆为实心圆)表示；</li><li>中间状态: 用圆角矩形表示, 分成上、中、下3部分。<ul><li>上面部分—–为状态的名称；</li><li>中间部分—–为状态变量的名字和值；</li><li>下面部分—–是活动表（可选）。 </li></ul></li><li>带箭头的连线: 称为状态转换, 箭头指明了传播方向。</li></ul></blockquote></li><li><p><strong>活动表的语法格式</strong></p><blockquote><p><strong>语法格式: 事件名(参数表)/动作表达式</strong></p><ul><li>entry事件指定进入该状态的动作；</li><li>exit事件指定退出该状态的动作；</li><li>do事件则指定在该状态的动作。</li></ul><p>需要时可以为事件指定参数表。活动表中的动作表达式描述应做的具体动作。</p></blockquote></li><li><p><strong>事件表达式的语法格式</strong></p><blockquote><p>状态转换: 状态图中两个状态之间带箭头的连线，箭头指明了传播方向<br>状态变迁: 通常由事件触发, 在此情况下, 应在表示状态转换的箭头线上标出触发状态转换的事件表达式。如果未标明,则表示自动触发。</p></blockquote><blockquote><p>语法: <strong>事件说明[守卫条件] / 动作表达式</strong></p><ul><li>时间说明的语法为: 事件名(参数表)。</li><li>守卫条件是一个布尔表达式。如果同时使用时间说明和守卫条件，则当且仅当事件发生且布尔表达式为真时，状态转换才会发生。如果只有守卫条件没有事件说明，则只要守卫条件为真状态转换就发生。</li><li>动作表达式是一个过程表达式,当状态转换开始时执行该表达式<br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B01.png"><br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B021.png"><br><img src="/img/soft_intro_c3/%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%E4%BE%8B022.png"></li></ul></blockquote></li></ul><hr><h4 id="其他图形工具：层次方框图、Warnier图、IPO图"><a href="#其他图形工具：层次方框图、Warnier图、IPO图" class="headerlink" title="其他图形工具：层次方框图、Warnier图、IPO图"></a>其他图形工具：层次方框图、Warnier图、IPO图</h4><ul><li><p><strong>层次方框图</strong></p><blockquote><p><strong>层次方框图:</strong> 用树形结构的一系列多层次的矩形框来描绘数据的层次结构。<br><img src="/img/soft_intro_c3/%E5%B1%82%E6%AC%A1%E6%96%B9%E6%A1%86%E5%9B%BE.png" alt="层次方框图"></p><ul><li>树形结构的顶层是一个单独的矩形框,它代表完整的数据结构；</li><li>下面的各层矩形框代表这个数据的子集；</li><li>最底层的各个框代表组成这个数据的实际数据元素(不能再分割的元素)。</li></ul></blockquote></li><li><p><strong>Warnier图</strong></p><blockquote><p><strong>Warnier图:</strong> 和层次方框图类似, Waarnier图也用树形结构描绘信息, 但是这种图形工具比层次方框图提供了更丰富的描绘手段。<br><img src="/img/soft_intro_c3/%E8%BD%AF%E4%BB%B6%E4%BA%A7%E5%93%81%E7%9A%84Warnier%E5%9B%BE.png"><br><strong>特点:</strong> 用Warnier图可以表明信息的逻辑组织，也可以表示特定信息在某一类信息中是有条件地出现的。因为重复和条件约束是说明软件处理过程的基础，所以很容易把Warnier图转变成软件设计的工具。 </p></blockquote></li><li><p><strong>IPO图</strong></p><blockquote><p>IPO图: 是输入、处理、输出图的简称，它是美国IBM公司发展完善起来的一种图形工具，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。<br>基本形式: 是在左边的框中列出有关的输入数据，在中间的框内列出主要的处理，在右边的框内列出产生的输出数据。在IPO图中还用类似向量符号的粗大箭头清楚地指出数据通信的情况。<br><img src="/img/soft_intro_c3/IPO%E5%9B%BE%E4%BE%8B%E5%AD%90.png" alt="IPO图例子"></p></blockquote><blockquote><p><strong>改进的IPO图:</strong> 这种图中包含某些附加的信息, 在软件设计过程中将比原始的IPO图更有用。<br><img src="/img/soft_intro_c3/IPO%E5%9B%BE_%E6%94%B9%E8%BF%9B.png" alt="改进的IPO图"><br>在需求分析阶段可以使用IPO图简略地描述系统的主要算法(即数据流图中各个处理的基本算法)。</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-需求分析&quot;&gt;&lt;a href=&quot;#第三章-需求分析&quot; class=&quot;headerlink&quot; title=&quot;第三章 需求分析&quot;&gt;&lt;/a&gt;第三章 需求分析&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;需求分析的任务；获取需求的方法&quot;&gt;&lt;a href=&quot;#需求分析的任务；获</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第二章 可行性研究</title>
    <link href="http://www.ckxgzxa.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6"/>
    <id>http://www.ckxgzxa.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6</id>
    <published>2021-05-16T02:46:43.000Z</published>
    <updated>2021-05-19T04:49:47.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-可行性研究"><a href="#第二章-可行性研究" class="headerlink" title="第二章 可行性研究"></a>第二章 可行性研究</h1><hr><h4 id="可行性研究的内容"><a href="#可行性研究的内容" class="headerlink" title="可行性研究的内容"></a>可行性研究的内容</h4><p><strong>1. 技术可行性:</strong></p><blockquote><p>使用现有的技术能否实现这个系统？<br>是否有胜任开发该项目的熟练技术人员？<br>能否按期得到开发该项目所需的软件、硬件资源？</p></blockquote><p><strong>2. 经济可行性:</strong></p><blockquote><p>这个系统的经济效益能否超过它的开发成本？<br>需要对项目进行价格/利益分析，即“投入/产出”分析。<br>由于利益分析取决于软件系统的特点，因此在软件开发之前，很难对新系统产生的效益作出精确的定量描述，所以往往采用一些估算方法。</p></blockquote><p><strong>3. 操作可行性:</strong></p><blockquote><p>操作可行性评价系统运行后会引起的各方面变化，如：对组织机构管理模式、用户工作环境等产生的影响。</p></blockquote><p><strong>4. 社会可行性:</strong></p><blockquote><p>社会可行性主要讨论法律方面和使用方面的可行性。<br>例如，被开发软件的权利归属问题、软件所使用的技术是否会造成侵权等问题。</p></blockquote><hr><h4 id="可行性研究过程-7步骤"><a href="#可行性研究过程-7步骤" class="headerlink" title="可行性研究过程(7步骤)"></a>可行性研究过程(7步骤)</h4><ol><li>复查定义，确定系统规模和目标；<blockquote><p>确认目标问题（用户需要的是否等于我们认为用户需要的）</p></blockquote></li><li>研究目前正在使用的系统；<blockquote><p>确认成本，缺点，流程图，接口等</p></blockquote></li><li>导出新系统的高层逻辑模型（数据流图、数据字典）；<blockquote><p>输入输出，数据格式</p></blockquote></li><li>重新定义问题；</li></ol><blockquote><p>前 4 个步骤实质上构成一个循环</p></blockquote><ol start="5"><li>导出和评价供选择的解法（物理解决方案）；<blockquote><p>技术、操作、经济和市场上接受同时满足，给出供选择的方案。</p></blockquote></li><li>推荐行动方案；<blockquote><p>哪一种方案最好，为什么，给出定论和原因。</p></blockquote></li><li>草拟开发计划（粗略）；<blockquote><ul><li>任务分解，确定负责人</li><li>大致进度规划</li><li>财务预算</li><li>风险分析及对策</li></ul></blockquote></li><li>书写文档提交审查。 （作为下一个阶段工作的基础）</li></ol><p><strong>可行性报告，必须给出明确结论：</strong></p><ul><li>行或不行。</li><li>或者给出系统开始前需要首先具备哪些条件</li><li>或系统目标需要先行修改等。</li></ul><hr><h4 id="系统流程图概念，特点、符号和应用；"><a href="#系统流程图概念，特点、符号和应用；" class="headerlink" title="系统流程图概念，特点、符号和应用；"></a>系统流程图概念，特点、符号和应用；</h4><ul><li>概念和特点:<blockquote><p>系统流程图是概括的描述物理系统的传统工具。<br>系统流程图反映的是信息在系统各部分之间流动的情况；<br>系统流程图 $\neq$ 控制、处理信息（不同于程序流程图）</p></blockquote></li><li>符号:<br><img src="/img/soft_intro_c2/%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE_%E5%9F%BA%E6%9C%AC%E7%AC%A6%E5%8F%B7.png" alt="基本符号"><br><img src="/img/soft_intro_c2/%E7%B3%BB%E7%BB%9F%E6%B5%81%E7%A8%8B%E5%9B%BE_%E7%B3%BB%E7%BB%9F%E7%AC%A6%E5%8F%B7.png" alt="系统符号"></li><li>应用</li><li>分层:<blockquote><p>面对复杂的系统时,一个比较好的方法是分层次地描绘这个系统。首先用一张高层次的系统流程图描绘系统总体概貌,表明系统的关键功能。然后分别把每个关键功能扩展到适当的详细程度,画在单独的一页纸上。这种分层次的描绘方法便于阅读者按从抽象到具体的过程逐步深入地了解一个复杂的系统。</p></blockquote></li></ul><hr><h4 id="数据流图概念、要素、特点、符号和应用；"><a href="#数据流图概念、要素、特点、符号和应用；" class="headerlink" title="数据流图概念、要素、特点、符号和应用；"></a>数据流图概念、要素、特点、符号和应用；</h4><ul><li>定义:<blockquote><p>数据流图是系统逻辑功能的图形表示, 图中没有任何具体的物理部件。<br>数据流图描绘数据在软件系统内从输入移动到输出过程中所经受的变换。通常用数据流图建立软件结构的功能模型。</p></blockquote></li><li>要素及符号:<br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E6%BA%90%E7%82%B9or%E7%BB%88%E7%82%B9.png"><br><img src="/img/soft_intro_c2/DFD_%E5%A4%84%E7%90%86.png"><br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8.png"><br><img src="/img/soft_intro_c2/DFD_%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="基本符号"><br><img src="/img/soft_intro_c2/DFD_%E9%99%84%E5%8A%A0%E7%AC%A6%E5%8F%B7.png" alt="附加符号"></li></ul><p><strong>注意:</strong></p><blockquote><ul><li>“处理”可表示：单个程序、一系列程序、程序的一个模块、人工处理过程等等；</li><li>“数据存储”可表示：一个文件、文件的一部分、数据库记录等等；</li><li>数据流图 <strong>忽略</strong> 出错处理、打开文件、关闭文件。</li></ul></blockquote><ul><li>特点:<blockquote><p>抽象性，概括性，层次性</p></blockquote></li><li>应用:<blockquote><p>见课本</p></blockquote></li></ul><p><strong>怎样画数据流图?</strong></p><blockquote><ol><li>提取数据流图的4种成分<ol><li><strong>考虑数据的源点和终点</strong></li><li><strong>考虑处理</strong></li><li><strong>考虑数据流和数据存储</strong></li></ol></li><li>画出基本系统模型并将其细化, 描绘系统的主要功能<br>   一旦把数据流程图中的四种成份都分离出来之后，就可着手绘制系统的数据流程图了。数据流程图的绘制也是采用自顶向下的方法，由粗到细，逐层细化，最后形成一套完整的拟建系统的数据流程图。 </li></ol></blockquote><p><strong>命名:</strong></p><blockquote><ol><li><strong>为数据流(或数据存储)命名</strong><ol><li>名字应该代表整个数据流(或数据存储)的内容；</li><li> 不要使用空洞的、缺乏具体含义的名字（如“数据”、“输入”）；</li><li>如果为某个数据流（或数据存储）起名字时遇到困难，则很可能是因为对数据流图的分解不恰当造成的，应该试试重新分解数据流图； </li></ol></li><li><strong>为处理命名</strong><ol><li>通常先为数据流命名，然后再为与之相关联的处理命名；</li><li>名字应该反映整个处理的功能；</li><li>应该尽量避免空洞笼统的动词做名字，如“处理”、“加工”；</li><li>通常用一个动词命名，如果必须用两个动词才能描述整个处理的功能，则可能要把这个处理分解成两个处理更恰当；</li><li>如果在为某个处理命名时遇到困难，则很可能是发现了分解不当的情况，应考虑重新分解。</li></ol></li><li><strong>数据源点/终点并不需要在开发目标系统的过程中设计和实现,它并不属于数据流图的核心内容,只不过是目标系统的外围环境部分(可能是人员、计算机外部设备或传感器装置)。通常,为数据源点/终点命名时采用它们在问题域中习惯使用的名字(如“采购员”、“仓库管理员”等)。</strong></li></ol></blockquote><blockquote><p>作用:</p><ul><li>利用它作为交流信息的工具；</li><li>作为软件分析和设计的工具。</li></ul></blockquote><hr><h4 id="数据字典定义、包含内容："><a href="#数据字典定义、包含内容：" class="headerlink" title="数据字典定义、包含内容："></a>数据字典定义、包含内容：</h4><blockquote><p>关于数据的信息的集合，也就是对数据流图中包含元素的定义的集合。<br>与数据流图共同构成系统的 <strong>逻辑模型</strong></p><p>数据字典由下列四类元素的定义组成：</p><ul><li>数据流；</li><li>数据流分量（即数据元素）</li><li>数据存储；</li><li>处理。</li></ul></blockquote><h5 id="定义数据的方法"><a href="#定义数据的方法" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h5><ol><li><strong>数据元素字典</strong> 定义基本内容:<ul><li>数据元素编号、名称及其含义；</li><li>数据类型和长度；</li><li>合理取值；</li><li>其他内容，如它和其它数据的逻辑关系等。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据元素字典定义实例"></li></ul></li><li><strong>数据流字典</strong> 定义基本内容：<ul><li>数据流编号及名称；</li><li>数据流来源；</li><li>数据流去处；</li><li>数据流的组成； </li><li>流通量；</li><li>峰值。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E6%B5%81%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据流字典定义实例"></li></ul></li><li><strong>数据存储</strong> 字典定义基本内容:<ul><li>数据存储编号及名称；</li><li>数据存储的组成；</li><li>其它要求。</li></ul></li><li><strong>数据处理</strong> 字典定义基本内容:<ul><li>数据处理编号及名称；</li><li>简单描述；</li><li>输入/输出；</li><li>功能描述；</li><li>有关数据存储。<br><img src="/img/soft_intro_c2/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E5%AD%97%E5%85%B8%E5%AE%9A%E4%B9%89%E5%AE%9E%E4%BE%8B.png" alt="数据处理字典定义实例"></li></ul></li><li>数据元素组成数据的表示方法：<ul><li>顺序：即以确定次序连接两个或多个分量。</li><li>选择：即从两个或多个可能的元素中选取一个。</li><li>重复：即把指定的分量重复零次或多次。</li><li>可选：即一个分量是可有可无的(重复零次或一次)。</li></ul></li></ol><h5 id="数据字典的用途"><a href="#数据字典的用途" class="headerlink" title="数据字典的用途:"></a>数据字典的用途:</h5><ol><li>作为分析阶段的重要工具；</li><li>数据元素的控制信息非常有用；</li><li>有助于开发数据库。</li></ol><hr><h4 id="定义数据的方法-1"><a href="#定义数据的方法-1" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h4><p><img src="/img/soft_intro_c2/%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="定义数据的方法"></p><hr><h4 id="成本估算技术"><a href="#成本估算技术" class="headerlink" title="成本估算技术"></a>成本估算技术</h4><h5 id="1-代码行技术"><a href="#1-代码行技术" class="headerlink" title="1. 代码行技术"></a>1. 代码行技术</h5><blockquote><p>软件成本 = 每行代码的平均成本×估计的源代码总行数</p></blockquote><h5 id="2-任务分解技术"><a href="#2-任务分解技术" class="headerlink" title="2. 任务分解技术"></a>2. 任务分解技术</h5><blockquote><p>软件开发项目分解为若干个相对独立的任务，分别估计每个单独任务的成本；<br>单独任务成本 = 任务所需人力估计值×每人每月平均工资；<br>软件开发项目总成本估计 = 各个单独任务成本估计值之和。<br><img src="/img/soft_intro_c2/%E4%BB%BB%E5%8A%A1%E5%88%86%E8%A7%A3%E6%8A%80%E6%9C%AF.png" alt="任务分解技术"></p></blockquote><h5 id="3-自动估计成本技术"><a href="#3-自动估计成本技术" class="headerlink" title="3. 自动估计成本技术"></a>3. 自动估计成本技术</h5><blockquote><p>采用自动估计成本的软件工具估计</p></blockquote><h5 id="成本-效应分析的方法"><a href="#成本-效应分析的方法" class="headerlink" title="成本/效应分析的方法"></a>成本/效应分析的方法</h5><p><strong>1. 货币的时间价值</strong></p><blockquote><p>假设年利率为i,如果现在存入P元钱，则n年以后可以得到的钱数为：<br>$$F = P(1+i)^n$$</p><p>反之，如果 <strong>n</strong> 年后能收入 <strong>F</strong> 元钱，那么这些钱现在的价值是：<br>$$P = F/(1+i)^n$$</p></blockquote><p><img src="/img/soft_intro_c2/%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90%E4%BE%8B01.png"><br><img src="/img/soft_intro_c2/%E6%88%90%E6%9C%AC%E6%95%88%E7%9B%8A%E5%88%86%E6%9E%90%E4%BE%8B02.png"><br><strong>2. 投资回收期</strong></p><blockquote><ul><li>第一、第二年回收：4225元</li><li>第三年回收投资要：(5000 - 4225)/1779 = 0.44 年</li><li>总的投资回收期 = 2.44 年</li></ul></blockquote><p><strong>3. 纯收入:</strong> 9011.94 - 5000 = 4011.94 (元)<br><strong>4. 投资回收率</strong><br>$$P = \frac{F_1}{(1+j)} + \frac{F_2}{(1+j)^2} +···+\frac{F_n}{(1+n)^n}$$</p><p>其中:</p><blockquote><p>P是现在的投资额；<br>Fi是第i年年底的效益（i=1,2,3,…,n）;<br>n是系统的使用寿命（一般假设n=5）；<br>j是投资回收率。</p></blockquote><p>上述修改系统的工程的投资回收率是41%-42%</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-可行性研究&quot;&gt;&lt;a href=&quot;#第二章-可行性研究&quot; class=&quot;headerlink&quot; title=&quot;第二章 可行性研究&quot;&gt;&lt;/a&gt;第二章 可行性研究&lt;/h1&gt;&lt;hr&gt;
&lt;h4 id=&quot;可行性研究的内容&quot;&gt;&lt;a href=&quot;#可行性研究的内容&quot; cl</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第一章 软件工程概述</title>
    <link href="http://www.ckxgzxa.top/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0"/>
    <id>http://www.ckxgzxa.top/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0</id>
    <published>2021-05-14T16:53:14.000Z</published>
    <updated>2021-05-19T16:00:24.002Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h1><ul><li><h4 id="软件包含几部分、软件本身特点"><a href="#软件包含几部分、软件本身特点" class="headerlink" title="软件包含几部分、软件本身特点"></a>软件包含几部分、软件本身特点</h4></li></ul><blockquote><table><thead><tr><th align="center">软件</th><th></th></tr></thead><tbody><tr><td align="center">程序(指令集)</td><td>可执行代码，由字符、数字等组成</td></tr><tr><td align="center">数据</td><td>输入输出数据</td></tr><tr><td align="center">相关文档</td><td>规格说明文档、设计文档、用户手册和其他管理文档</td></tr></tbody></table><p>特点:  </p><ol><li>抽象：逻辑实体非物理实体（不直观）；</li><li>不存在磨损问题，可无限期使用；</li><li>可移植性；（零成本无限复制）；</li><li>复杂性，实现、维护等越来越复杂；</li><li>昂贵性，开发维护成本高；</li></ol></blockquote><ul><li><h4 id="软件危机概念，包含的两方面内容，提出的时间"><a href="#软件危机概念，包含的两方面内容，提出的时间" class="headerlink" title="软件危机概念，包含的两方面内容，提出的时间"></a>软件危机概念，包含的两方面内容，提出的时间</h4></li></ul><blockquote><p>软件危机的概念:计算机软件的开发和维护过程中遇到的一系列严重问题。<br>两方面内容:</p><ol><li>如何开发软件，满足对软件日益增长的需求</li><li>如何维护数量不断膨胀的已有软件。</li></ol><p>提出的时间:<br>1968年，NATO北大西洋公约组织的计算机科学家召开了计算机国际会议，提出“软件危机”的概念，并提出了“软件工程”学科</p></blockquote><ul><li><h4 id="为消除软件危机，需要采取哪两方面措施？"><a href="#为消除软件危机，需要采取哪两方面措施？" class="headerlink" title="为消除软件危机，需要采取哪两方面措施？"></a>为消除软件危机，需要采取哪两方面措施？</h4><blockquote><pre><code>  1. 对计算机软件有正确的认识，消除“软件就是程序”的错误认识。认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目，充分借鉴吸取已有经验。  2. 应该推广使用在实践中总结出来的开发软件的成功技术和方法，并继续研究探索。  3. 应该开发和使用更好的软件工具。  </code></pre><p>总之，为了解决软件危机，既要有<strong>技术</strong>措施(方法和工具)，又要有必要的组织<strong>管理</strong>措施<br><strong>管理:</strong> 通过计划、组织和控制等一系列活动，合理地配置和使用各种资源，以达到既定目标的过程。<br><strong>技术(软件工程方法学):</strong> 通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学(methodology)，也称为范型(paradigm)。  </p></blockquote></li><li><h4 id="软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点"><a href="#软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点" class="headerlink" title="软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点"></a>软件工程的概念？软件工程方法学：传统方法学（生命周期方法学或结构化范型）和面向对象方法学，概念和优缺点</h4><blockquote><ol><li><p>概念: 是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p></li><li><p>软件工程方法学:</p><ul><li><p>概念: 通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学(methodology)，也称为范型(paradigm)。</p></li><li><p>3要素:</p><ul><li>方法：是完成软件开发的各项任务的技术方法，回答“怎样做”的问题；</li><li>工具：是为运用方法而提供的自动的或半自动的软件工程支撑环境；如，CASE(Computer-Aided Software Engineering )工具</li><li>过程：需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。</li></ul></li><li><p>传统方法学(生命周期方法学或结构化范型)——强调自顶向下:</p><ul><li>采用结构化技术来完成软件开发的各项任务；</li><li>划分为若干个阶段，然后顺序地完成每个阶段的任务；</li><li><strong>每个阶段的任务相对独立，而且比较简单，降低了整个软件开发工程的困难程度；</strong> 前一个阶段是后一个阶段的前提和基础，而后一阶段提出的解法更具体，细节更多；</li><li><strong>每个阶段结束前必须从技术和管理两方面对这个阶段的开发成果进行严格的检查，通过之后这个阶段才算结束；保证了质量，提高可维护性；</strong></li><li>当软件规模庞大，或者的需求模糊或随时间而变化时，传统方法学往往不成功；维护起来仍然很困难。</li></ul></li><li><p>面向对象方法学——强调主动地多次反复迭代</p><ul><li>面向对象方法: 把数据和行为看成同等重要，它是一种以数据为主线，把数据和对数据的操作紧密地结合起来的方法。</li><li>面向对象方法学4个要点：<ul><li>对象(object)：融合了数据及在数据上的操作行为。</li><li>类(class)：类是对具有相同数据和相同操作的一组相似对象的定义。</li><li>继承：按照父类与子类的关系，把若干个相关类组成一个层次结构的系统。</li><li>消息：对象彼此间仅能通过发送消息互相联系。</li></ul></li><li>优点:<ol><li>面向对象方法学的尽量模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程。</li><li>面向对象方法学开发软件的过程，是一个主动地多次反复迭代的演化过程，保证了在各项开发活动之间的平滑过渡。</li><li>促进了软件重用。最终的软件产品由许多较小的、基本上独立的对象组成，每个对象相当于一个微型程序，而且大多数对象都与现实世界中的实体相对应，降低了复杂性，提高了可理解性，简化了开发和维护工作。</li></ol></li></ul></li></ul></li></ol></blockquote></li><li><h4 id="软件生命周期（三个时期八个阶段）"><a href="#软件生命周期（三个时期八个阶段）" class="headerlink" title="软件生命周期（三个时期八个阶段）"></a>软件生命周期（三个时期八个阶段）</h4></li></ul><blockquote><p><img src="/img/soft_intro_c1/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="软件生命周期"></p><ol><li><p>问题定义:</p><blockquote><p><strong>任务: 问题是什么?</strong></p><ul><li>通过对客户的访问调查，系统分析员扼要地写出关于问题性质、工程目标和工程规模的书面报告。</li><li>经过讨论和必要的修改之后这份报告应该得到客户的确认。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 关于系统规模和目标的</p></blockquote></li><li><p>可行性研究:</p><blockquote><p><strong>任务: 有可行的解吗?</strong></p><ul><li>系统分析员需要进行一次大大压缩和简化了的系统分析和设计过程。</li><li>研究问题的范围，探索这个问题是否值得去解，是否有可行的解决办法。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>系统的高层逻辑模型（数据流图、成本效益分析）</li><li>可行性论证报告（立即进行/推迟进行/不能或不值得进行）</li></ul></blockquote></li><li><p>需求分析:</p><blockquote><p><strong>任务: 必须做什么</strong></p><ul><li>主要是确定目标系统必须具备哪些功能。</li><li>系统分析员必须和用户密切配合，充分交流信息，以得出经过用户确认的系统逻辑模型。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>系统的逻辑模型（数据流图、数据字典、简要的算法描述）</li><li>用规格说明书（Specification）准确地记录对目标系统的需求</li></ul></blockquote></li><li><p>总体设计:</p><blockquote><p><strong>任务: 如何提出已提出的问题</strong></p><ul><li>设计出实现目标系统的几种可能的方案（低、中、高成本）。</li><li>用适当的表达工具描述每种方案，分析优缺点，推荐一个最佳方案，制定出实现最佳方案的详细计划。设计程序的体系结构。</li></ul></blockquote><blockquote><p>**结果: **</p><ul><li>可能的解法(系统流程图、成本效益分析)</li><li>推荐的系统体系结构(层次图或结构图)</li></ul></blockquote></li><li><p>详细设计:</p><blockquote><p><strong>任务: 怎样具体实现该系统</strong></p><ul><li>详细地设计每个模块, 确定实现模块功能所需要的算法和数据结构</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>每个模块的算法和数据结构(程序流程图、PAD图、N-S图等)</li></ul></blockquote></li><li><p>编码和单元测试:</p><blockquote><p><strong>任务: 得到正确的程序模块</strong></p><ul><li>选取一种适当的高级程序设计语言(必要时用汇编语言)，把详细设计的结果翻译成用选定的语言书写的程序；</li><li>并且仔细测试编写出的每一个模块。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 代码和测试报告</p></blockquote></li><li><p>综合测试:</p><blockquote><p><strong>任务: 得到符合要求的软件</strong></p><ul><li>通过集成测试、验收测试、现场测试、平行运行等方法对目标系统进一步测试检验。</li><li>通过对软件测试结果的分析可以预测软件的可靠性；反之，根据对软件可靠性的要求，也可以决定测试和调试过程什么时候可以结束。</li></ul></blockquote><blockquote><p><strong>结果:</strong></p><ul><li>测试计划、详细测试方案以及实际测试结果</li><li>完整一致的软件配置 </li></ul></blockquote></li><li><p>软件维护:<br><img src="/img/soft_intro_c1/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4.png" alt="软件维护"></p><blockquote><p><strong>任务: 使系统持久地满足用户的需要</strong></p><ul><li>改正性维护,诊断和改正在使用过程中发现的软件错误；</li><li>适应性维护，修改软件以适应环境的变化；</li><li>完善性维护，根据用户的要求改进或扩充软件；</li><li>预防性维护，修改软件为将来的维护活动做准备。</li><li>每一项维护活动经历了一次压缩和简化了的软件定义和开发的全过程。</li></ul></blockquote><blockquote><p><strong>结果:</strong> 完整准确的维护记录</p></blockquote></li></ol></blockquote><ul><li><h4 id="软件过程（几个模型）"><a href="#软件过程（几个模型）" class="headerlink" title="软件过程（几个模型）"></a>软件过程（几个模型）</h4></li></ul><blockquote><p><strong>1. 瀑布模型</strong> (文档驱动型)<br><img src="/img/soft_intro_c1/%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B.png" alt="瀑布模型"></p><ul><li>瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落</li><li>特点:<blockquote><p><strong>1. 阶段间具有顺序性和依赖性</strong></p><ul><li>前一阶段的工作完成之后，才能开始后一阶段的工作；</li><li>前一阶段的输出文档就是后一阶段的输入文档。</li></ul><p><strong>2. 推迟实现的观点</strong></p><ul><li>对于规模较大的软件项目来说，往往编码开始得越早最终完成开发工作所需要的时间反而越长。</li></ul><p><strong>3. 质量保证的观点</strong></p><ul><li>每个阶段都必须完成规定的文档，是“文档驱动”的模型；</li><li>每个阶段结束前都要对所完成的文档进行评审，尽早发现问题，改正错误。</li></ul></blockquote></li><li><strong>优点:</strong><blockquote><ul><li>可强迫开发人员采用规范的方法；</li><li>严格地规定了每个阶段必须提交的文档；</li><li>要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li><strong>只能通过文档了解产品，不经过实践的需求是不切实际的。</strong></li></ul></blockquote></li><li><strong>适用于:</strong><blockquote><ul><li>需求是预知的；</li><li>软件实现方法是成熟的；</li><li>项目周期较短。</li></ul></blockquote></li></ul><p><strong>2. 快速原型模型</strong><br><img src="/img/soft_intro_c1/%E5%BF%AB%E9%80%9F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%9E%8B.png" alt="快速原型模型"></p><ul><li>特点:<blockquote><ul><li>快速原型模型不带反馈环，软件产品的开发基本上是线性顺序进行的。</li><li>快速原型的本质是“快速”。应该尽可能快地建造出原型系统，以加速软件开发过程，节约成本。</li></ul></blockquote></li><li><strong>根据原型的不同作用,有三类原型模型</strong><blockquote><ul><li>探索型原型——用于开发的需求分析阶段</li><li>实验型原型——主要用于设计阶段</li><li>演化型原型——用于及早向用户提交一个原型系统</li></ul></blockquote></li><li><strong>快速原型模型的运用方式:</strong><blockquote><ul><li>抛弃策略——探索型和实验型采用此策略</li><li>附加策略——演化型快速原型采用此策略 </li></ul></blockquote></li></ul><p><strong>3. 增量模型</strong><br><img src="/img/soft_intro_c1/%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%9E%8B.png" alt="增量模型"></p><ul><li><strong>优点:</strong><blockquote><ul><li>人员分配灵活，刚开始不用投入大量人力资源。 </li><li>当配备的人员不能在设定的期限内完成产品时，它提供了一种先推出核心产品的途径。 </li><li>逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。</li></ul></blockquote></li><li><strong>难点:</strong><blockquote><ul><li>软件体系结构必须是开放的。</li><li>模型本身是自相矛盾的。整体——独立构件。</li><li>不同的构件并行地构建有可能加快工程进度，但是冒无法集成到一起的风险。</li></ul></blockquote></li><li><strong>适用于:</strong><blockquote><ul><li>适用于需求经常改变的软件开发过程。</li><li>如果在项目既定的商业要求期限之前不可能找到足够的开发人员，在这种情况下，增量模型显得特别有用。</li></ul></blockquote></li></ul><p><strong>4. 螺旋模型</strong> (风险驱动型)<br><img src="/img/soft_intro_c1/%E7%AE%80%E5%8C%96%E7%9A%84%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png" alt="简化的螺旋模型"></p><ul><li><strong>优点:</strong><blockquote><ul><li>主要优势在于它是风险驱动的。</li><li>对可选方案和约束条件的强调有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标；</li><li>减少了过多测试或测试不足所带来的风险；</li><li>维护只是模型的另一个周期，维护和开发之间没有本质区别。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li>采用螺旋模型需要具有相当丰富的风险评估经验和专门知识，在风险较大的项目开发中，如果未能够及时标识风险，势必造成重大损失。 </li><li>过多的迭代次数会增加开发成本，延迟提交时间。 </li></ul></blockquote></li></ul><p><img src="/img/soft_intro_c1/%E5%AE%8C%E6%95%B4%E7%9A%84%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B.png" alt="完整的螺旋模型"></p><ul><li><strong>适用于:</strong><blockquote><ul><li>特别适用于庞大、复杂并具有高风险的系统。</li><li>适用于内部开发的大规模软件项目。</li></ul></blockquote></li></ul><p><strong>5. 喷泉模型</strong><br><img src="/img/soft_intro_c1/%E5%96%B7%E6%B3%89%E6%A8%A1%E5%9E%8B.png" alt="喷泉模型"></p><ul><li><strong>优点:</strong><blockquote><ul><li>该模型的各个阶段没有明显的界限，开发人员可以同步进行开发。</li><li>多次反复地增加或明确目标系统，而不是本质性的改动，降低错误的可能性。</li></ul></blockquote></li><li><strong>缺点:</strong><blockquote><ul><li>由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，不利于项目的管理。</li><li>要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。</li></ul></blockquote></li><li><strong>适用于:</strong> 面向对象的软件开发过程。</li></ul></blockquote><h3 id="如有错误-请在博客页下方评论"><a href="#如有错误-请在博客页下方评论" class="headerlink" title="如有错误, 请在博客页下方评论"></a>如有错误, 请在<a href="https://ckxgzxa.github.io/2021/05/15/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/">博客页</a>下方评论</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-软件工程概述&quot;&gt;&lt;a href=&quot;#第一章-软件工程概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 软件工程概述&quot;&gt;&lt;/a&gt;第一章 软件工程概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;软件包含几部分、软件本身特点&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="学习笔记" scheme="http://www.ckxgzxa.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件工程导论" scheme="http://www.ckxgzxa.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数据库系统概论第四章第7题</title>
    <link href="http://www.ckxgzxa.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%AC7%E9%A2%98"/>
    <id>http://www.ckxgzxa.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%AC%AC7%E9%A2%98</id>
    <published>2021-05-13T13:42:24.000Z</published>
    <updated>2021-05-14T18:36:18.428Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>今有以下两个关系模式:<br>&ensp;&ensp;&ensp;&ensp;职工(职工号，姓名，年龄，职务，工资，部门号)<br>&ensp;&ensp;&ensp;&ensp;部门(部门号，名称，经理名，地址，电话号)<br>请用SQL的GRANT和REVOKE语句（加上视图机制）完成以下授权定义或存储控制功能:<br>(1)用户王明对两个表有SELECT权限。<br>(2)用户李勇对两个表有NSERT和DELETE权限。<br>(3)每个职工只对自己的记录有SELECT权限。<br>(4)用户刘星对职工表有SELECT权限，对工资字段具有更新权限。<br>(5)用户张新具有修改这两个表的结构的权限。<br>(6)用户周平具有对两个表的所有权限(读、插、改、删数据)，并具有给其他用户授权的权限。<br>(7)用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限，她不能查看每个人的工资。</p></blockquote><hr><h3 id="一些准备工作"><a href="#一些准备工作" class="headerlink" title="一些准备工作"></a>一些准备工作</h3><h5 id="建表"><a href="#建表" class="headerlink" title="建表:"></a>建表:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 部门 (<br>    部门号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    名称 <span class="hljs-type">CHAR</span>(<span class="hljs-number">16</span>),<br>    经理名 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    地址 <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>    电话号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">11</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 职工 (<br>    职工号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>    姓名 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    年龄 <span class="hljs-type">SMALLINT</span>,<br>    职务 <span class="hljs-type">CHAR</span>(<span class="hljs-number">12</span>),<br>    工资 <span class="hljs-type">NUMERIC</span>(<span class="hljs-number">8</span>,<span class="hljs-number">2</span>),<br>    部门号 <span class="hljs-type">CHAR</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-keyword">FOREIGN</span> KEY ( 部门号 ) <span class="hljs-keyword">REFERENCES</span> 部门(部门号)<br>);<br></code></pre></td></tr></table></figure><h5 id="创建习题中涉及用户"><a href="#创建习题中涉及用户" class="headerlink" title="创建习题中涉及用户:"></a>创建习题中涉及用户:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 王明 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 李勇 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 刘星 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 张新 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 周平 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> 杨兰 IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><h5 id="插入一些测试数据"><a href="#插入一些测试数据" class="headerlink" title="插入一些测试数据:"></a>插入一些测试数据:</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM001&#x27;</span>,<span class="hljs-string">&#x27;部门一&#x27;</span>,<span class="hljs-string">&#x27;经理一&#x27;</span>,<span class="hljs-string">&#x27;地址一&#x27;</span>,<span class="hljs-string">&#x27;12345678901&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM002&#x27;</span>,<span class="hljs-string">&#x27;部门二&#x27;</span>,<span class="hljs-string">&#x27;经理二&#x27;</span>,<span class="hljs-string">&#x27;地址二&#x27;</span>,<span class="hljs-string">&#x27;12345678902&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;BM003&#x27;</span>,<span class="hljs-string">&#x27;部门三&#x27;</span>,<span class="hljs-string">&#x27;经理三&#x27;</span>,<span class="hljs-string">&#x27;地址三&#x27;</span>,<span class="hljs-string">&#x27;12345678903&#x27;</span>);<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG001&#x27;</span>,<span class="hljs-string">&#x27;王明&#x27;</span>,<span class="hljs-number">31</span>,<span class="hljs-string">&#x27;职位一&#x27;</span>,<span class="hljs-number">11000</span>,<span class="hljs-string">&#x27;BM001&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG002&#x27;</span>,<span class="hljs-string">&#x27;李勇&#x27;</span>,<span class="hljs-number">32</span>,<span class="hljs-string">&#x27;职位二&#x27;</span>,<span class="hljs-number">12000</span>,<span class="hljs-string">&#x27;BM002&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG003&#x27;</span>,<span class="hljs-string">&#x27;刘星&#x27;</span>,<span class="hljs-number">33</span>,<span class="hljs-string">&#x27;职位三&#x27;</span>,<span class="hljs-number">13000</span>,<span class="hljs-string">&#x27;BM003&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG004&#x27;</span>,<span class="hljs-string">&#x27;张新&#x27;</span>,<span class="hljs-number">34</span>,<span class="hljs-string">&#x27;职位四&#x27;</span>,<span class="hljs-number">14000</span>,<span class="hljs-string">&#x27;BM002&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG005&#x27;</span>,<span class="hljs-string">&#x27;周平&#x27;</span>,<span class="hljs-number">35</span>,<span class="hljs-string">&#x27;职位五&#x27;</span>,<span class="hljs-number">15000</span>,<span class="hljs-string">&#x27;BM003&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;ZG006&#x27;</span>,<span class="hljs-string">&#x27;杨兰&#x27;</span>,<span class="hljs-number">36</span>,<span class="hljs-string">&#x27;职位六&#x27;</span>,<span class="hljs-number">16000</span>,<span class="hljs-string">&#x27;BM001&#x27;</span>);<br></code></pre></td></tr></table></figure><h5 id="1-用户王明对两个表有SELECT权限"><a href="#1-用户王明对两个表有SELECT权限" class="headerlink" title="1. 用户王明对两个表有SELECT权限"></a>1. 用户王明对两个表有SELECT权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 王明;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 王明;<br></code></pre></td></tr></table></figure><h5 id="2-用户李勇对两个表有INSERT和DELETE权限"><a href="#2-用户李勇对两个表有INSERT和DELETE权限" class="headerlink" title="2. 用户李勇对两个表有INSERT和DELETE权限"></a>2. 用户李勇对两个表有INSERT和DELETE权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 李勇;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">INSERT</span>, <span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 李勇;<br></code></pre></td></tr></table></figure><h5 id="3-每个职工只对自己的记录有SELECT权利"><a href="#3-每个职工只对自己的记录有SELECT权利" class="headerlink" title="3. 每个职工只对自己的记录有SELECT权利"></a>3. 每个职工只对自己的记录有SELECT权利</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 职工视图 <br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <br><span class="hljs-keyword">FROM</span> 职工 <br><span class="hljs-keyword">WHERE</span> concat(姓名,<span class="hljs-string">&#x27;@localhost&#x27;</span>) <span class="hljs-operator">=</span> <span class="hljs-keyword">USER</span>();<br><br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span> <br><span class="hljs-keyword">ON</span> 职工视图<br><span class="hljs-keyword">TO</span> 王明,李勇,刘星, 张新,周平,杨兰;<br></code></pre></td></tr></table></figure><h5 id="4-用户刘星对职工表有SELECT权限-对工资字段有更新权限"><a href="#4-用户刘星对职工表有SELECT权限-对工资字段有更新权限" class="headerlink" title="4. 用户刘星对职工表有SELECT权限, 对工资字段有更新权限"></a>4. 用户刘星对职工表有SELECT权限, 对工资字段有更新权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, UPDATE(工资)<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 刘星;<br></code></pre></td></tr></table></figure><h5 id="5-用户张新具有修改两个表结构权限"><a href="#5-用户张新具有修改两个表结构权限" class="headerlink" title="5. 用户张新具有修改两个表结构权限"></a>5. 用户张新具有修改两个表结构权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALTER</span> <br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 张新;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALTER</span><br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 张新;<br></code></pre></td></tr></table></figure><h5 id="6-用户周平具有对两个表的所有权限-读、插、改、删数据-并具有给其他用户授权的权限"><a href="#6-用户周平具有对两个表的所有权限-读、插、改、删数据-并具有给其他用户授权的权限" class="headerlink" title="6. 用户周平具有对两个表的所有权限(读、插、改、删数据),并具有给其他用户授权的权限"></a>6. 用户周平具有对两个表的所有权限(读、插、改、删数据),并具有给其他用户授权的权限</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 职工<br><span class="hljs-keyword">TO</span> 周平<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">TABLE</span> 部门<br><span class="hljs-keyword">TO</span> 周平<br><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></td></tr></table></figure><h5 id="7-用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资"><a href="#7-用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资" class="headerlink" title="7. 用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资"></a>7. 用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限但不能查看每个人的工资</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 部门工资(名称,最高工资,最低工资,平均工资)<br><span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> `部门`.`名称`, <span class="hljs-built_in">MAX</span>(`工资`), <span class="hljs-built_in">MIN</span>(`工资`), <span class="hljs-built_in">AVG</span>(`工资`)<br><span class="hljs-keyword">FROM</span> `职工`, `部门`<br><span class="hljs-keyword">WHERE</span> `职工`.`部门号` <span class="hljs-operator">=</span> `部门`.`部门号`<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> `职工`.`部门号`;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span><br><span class="hljs-keyword">ON</span> 部门工资<br><span class="hljs-keyword">TO</span> 杨兰;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;今有以下两个关系模式:&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;职工(职工号，姓名，年龄，职务，工资，部门号)&lt;br&gt;&amp;ensp;&amp;ensp;&amp;ensp;&amp;ensp;部门(部门号，名称，经理名，地址，电话号)&lt;br&gt;请用SQ</summary>
      
    
    
    
    
    <category term="数据库系统概论" scheme="http://www.ckxgzxa.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
    
  </entry>
  
</feed>
