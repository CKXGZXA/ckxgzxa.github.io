

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="baidu-site-verification" content="code-HJwAkkohj2" />
  <meta name="sogou_site_verification" content="2t6zxaPafe"/>
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="残魁斜罡">
  <meta name="keywords" content="">
  
  <title>百度高效研发实战训练营 - 技术匝记簿</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"www.ckxgzxa.top","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"01f66cc4caefba46f8cad22b739f765a","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="技术匝记簿" type="application/atom+xml">
</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>残魁斜罡的小小簿记</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/%E9%A3%8E%E6%99%AF.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="百度高效研发实战训练营">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-27 08:10" pubdate>
        2021年11月27日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      36k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      373
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">百度高效研发实战训练营</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年12月5日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="一、百度高效研发实战训练营Step1"><a href="#一、百度高效研发实战训练营Step1" class="headerlink" title="一、百度高效研发实战训练营Step1"></a>一、百度高效研发实战训练营Step1</h1><p><a target="_blank" rel="noopener" href="http://bit.baidu.com/productsBuy?id=272">百度工程能力实战训练营线上课程</a></p>
<h2 id="1-设计方法与实践"><a href="#1-设计方法与实践" class="headerlink" title="1 设计方法与实践"></a>1 设计方法与实践</h2><h3 id="1-1-软件设计原则"><a href="#1-1-软件设计原则" class="headerlink" title="1.1 软件设计原则"></a>1.1 软件设计原则</h3><ol>
<li><p>软件设计的目的</p>
<blockquote>
<p>软件设计是为了使软件在长期范围内能够容易的进行变化。我们从下面这三个点来理解这句话。</p>
<blockquote>
<ol>
<li><p>变化：<em>软件不是一成不变的</em>，无论是软件本身的需求、软件依赖的其他软件资源都是一直在发生变化的，唯一不变的就是变化。</p>
</li>
<li><p>容易：任何一个软件的变化都需要成本，要尽可能的降低变化的成本，使得软件可以很容易应对软件的变化。</p>
</li>
<li><p>长期：事实上需要长期进行维护的软件更应该做好软件设计，因为软件长期的变化非常多，难以提前作出预测，需要良好的软件设计来应对。</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p>软件设计原则</p>
</li>
</ol>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111232319206.png"></p>
<blockquote>
<p>软件设计有着很多的原则，<em>最基本的原则是高内聚低耦合，它也是软件设计追求的最高目标</em>。 <em><strong>内聚</strong></em> 指的是一个软件内部间元素相关联的程度。</p>
<p><em><strong>高内聚</strong></em>追求的是紧密相关联的元素要放在一起。</p>
<p><em><strong>低耦合</strong></em>指的是单位之间尽可能少地关联，依赖。</p>
</blockquote>
<blockquote>
<p>在高内聚低耦合之上有很多其他的原则：如SOLID原则、简单设计、正交设计，在这之上还会有设计模式作为最高层的软件设计原则。</p>
</blockquote>
<h3 id="1-2-clean-code"><a href="#1-2-clean-code" class="headerlink" title="1.2 clean code"></a>1.2 clean code</h3><ol>
<li><p>clean code的概念</p>
<blockquote>
<p>clean code中文解释为<em>整洁代码</em>，是指写的代码能够在尽可能短的时间内被别人读懂，且代码看上去排版整洁、逻辑清晰、扩展性好。</p>
</blockquote>
</li>
<li><p>命名规则</p>
<blockquote>
<p>代码中命名需要遵循以下的几个规则：</p>
<blockquote>
<ol>
<li><p>表达它是什么，不要表达怎么做。</p>
</li>
<li><p>代码要做到自注释。</p>
</li>
<li><p>使用有意义的循环迭代变量。</p>
</li>
<li><p>避免缩写，尤其拼音缩写。</p>
</li>
<li><p>不要使用非约定俗成的缩写。</p>
</li>
<li><p>避免使用魔法数。</p>
</li>
<li><p>不要害怕长变量名。</p>
</li>
</ol>
</blockquote>
</blockquote>
</li>
<li><p>注释</p>
<blockquote>
<p>注释对于代码来说是必不可少的。通常情况下，<em>好的注释包含：版权信息，设计意图，警示信息。</em></p>
<p>不好的注释则具有以下一个或几个特点：同义反复、隐晦关联关系、套用模板、提供历史修改记录以及注释掉的代码。</p>
</blockquote>
</li>
<li><p>函数</p>
<blockquote>
<p>在写函数时，应当注意，<em>每个函数只做一件事</em>，每个函数应是单一职责。</p>
<p>函数分为骨架函数和步骤函数。</p>
<ul>
<li><em>骨架函数</em> 是业务逻辑和算法是在高层次上的抽象描述。</li>
<li><em>步骤函数</em> 是业务逻辑和算法的一些实现细节，是被隐藏起来的。</li>
</ul>
</blockquote>
</li>
<li><p>编码细节</p>
<blockquote>
<p>在编码细节方面，需要遵循以下几点规则：</p>
<blockquote>
<ol>
<li>使用自然的比较顺序。</li>
<li>简化逻辑层次，避免多层嵌套。</li>
<li>在写三元表达式时不要出现复杂的逻辑和过长的条件。</li>
<li>需要控制变量的作用域，也就是缩小变量作用域的范围，越小越好。</li>
</ol>
</blockquote>
</blockquote>
</li>
</ol>
<h3 id="1-3-单元测试"><a href="#1-3-单元测试" class="headerlink" title="1.3 单元测试"></a>1.3 单元测试</h3><ol>
<li><p>为什么进行单元测试</p>
<blockquote>
<p>测试是分为不同层次的：最底层是单元测试，中间是基于模块级、组件级的测试，再往上则是系统级别的测试。</p>
<p><em>越底层的测试，越能够快速地发现问题。</em>底层的测试集成性更好，能够安全的进行代码修改。上层的测试一般情况下获得反馈的速度比较慢，测试过程也比较笨重。</p>
<p>所以单元测试具有<em>更早发现问题，更容易集成，更安全地代码修改的优点</em>。</p>
</blockquote>
</li>
<li><p>写好单元测试的重要性</p>
<blockquote>
<p>写好单元很费时。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111232334866.webp"></p>
<p><em>好的单元测试能够降低产品开发的成本。</em> 然而单元测试写得不好的话，不但会增加产品开发的成本，而且还会增加单元测试成本。</p>
</blockquote>
</li>
<li><p>单元测试原则与模式</p>
<p><strong>第一个原则：Tests As Documentation</strong></p>
<p>将测试当成一个文档工作，也就是说我们需要把测试写得像文档一样简洁，通过一些描述，可以清晰地知道这个测试的作用。在之后对项目修改时，只需要查看单元测试即可。</p>
<p><strong>第二个原则：Fully Automated and Self-Checking</strong></p>
<p>单元测试都是可以进行自我检查、自我校验的，通过代码的编写，能够知道测试是否成功，不需要人为判定。</p>
<p><strong>第三个原则：Do No Harm，不可破坏性。</strong></p>
<p>部分开发人员在进行测试时，为了完成目的，会基于测试代码创立一些逻辑，这种做法是错误的。在写测试时不能单独为测试创建特别的逻辑，更不能破坏原有代码的逻辑。</p>
<p><strong>第四个原则：Keep tests as simple as possible，简洁性。</strong></p>
<p>单元测试虽然是用来保证代码的正确性，但单元测试也是一份代码，为了避免过多的测试代码相覆盖，要尽可能地把单元测试的代码写得简单，保证其不会出错。</p>
</li>
</ol>
<h3 id="1-4-重构"><a href="#1-4-重构" class="headerlink" title="1.4 重构"></a>1.4 重构</h3><p>​    重构时需要遵循的规则如下:</p>
<blockquote>
<ol>
<li><strong>业务导向</strong></li>
</ol>
<p>重构一定是要解决实际的业务问题的，而不是为了重构去重构。</p>
<ol start="2">
<li><strong>小步快跑</strong></li>
</ol>
<p>​        通常重构是需要多人同时参与，重构过程中开发人员要随时对比主干与分支的情况。当某一个开发人员在分支上进行了大量改动并准备将其合并到主干时，有可能主干和分支的代码有很大的差异。所以进行重构时，要<em>将问题拆分成多个小的单元进行修改，并且每修改一个就进行一次分支合并</em>。这种小步快跑的模式可以随时同步主干上的代码，减少出错的可能。</p>
<ol start="3">
<li><strong>演进式设计</strong></li>
</ol>
<p>​        在进行代码重构之前，我们不可能知道重构的最终结果是什么。为了保证能够得到一个比较好的结果，我们采用演进式设计方法。在重构过程中<em>遵循包括高内聚低耦合、正交设计原则、SOLID原则等软件设计原则，不断地用小步快跑的方式去重构</em>，只有这样结果才能令人满意。</p>
<ol start="4">
<li><p><strong>正交设计原则</strong></p>
<p>分离关注点、消除重复、缩小依赖范围、向着稳定的方向依赖。</p>
</li>
</ol>
</blockquote>
<p>​        在代码中，根据功能的不同，将其分为不同的变化方向。每个变化方向都是一个职责，我们把每一个不同的变化方向称作关注点，根据它的变化方向来进行相应的处理。</p>
<h3 id="1-5-配置化架构"><a href="#1-5-配置化架构" class="headerlink" title="1.5 配置化架构"></a>1.5 配置化架构</h3><ol>
<li><strong>配置化架构的定义：</strong></li>
</ol>
<p>以可配置的方式构建软件的方法。它是在领域建模的基础上，以配置表述业务，以配置组织架构元素，比如服务、组件、数据等，并对配置进行规范化、自动化的管理。</p>
<p>定义的原因：</p>
<blockquote>
<ol>
<li><p>通常情况下配置指的是对数据的抽象，需要架构上的描述；</p>
</li>
<li><p>架构上描述的配置指的是对架构元素的抽象，描述配置化不完整；</p>
</li>
<li><p>配置化包括对业务的抽象，尤其是逻辑；</p>
</li>
<li><p>配置化还包括对配置的管理以及分支。</p>
</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>如何应用配置化架构</strong></li>
</ol>
<p>应用配置化架构包括三方面：从业务上改造，提高配置本身的开发效率，降低配置的维护成本。</p>
<blockquote>
<ol>
<li><strong>业务配置化改造</strong></li>
</ol>
<blockquote>
<ol>
<li>组件配置化</li>
</ol>
<p>组件配置化表达<em>是业务层面上非常重要的一环</em>，组件是一个独立升级发布的单元，这样的单元关联了很多配置，可将这些配置分为两类。一类是<em>组件内部的配置</em>，另二类是<em>描述组件与组件间关系的配置</em>。只有组件配置化是不够的，往往还需要构建DSL来帮助。</p>
<ol start="2">
<li>构建DSL：</li>
</ol>
<p>DSL是工程师针对不同的领域创建的语言。具有很强的针对性，在专业领域有时很长的代码只需要将其改为一行配置就足够了。</p>
</blockquote>
<ol start="2">
<li><strong>提高配置的开发效率</strong></li>
</ol>
<p>通过下面的持续发布的系统，能够很好地提高配置的开发效率。它只针对配置，可以独立的发布配置。在系统中：需要配置前端编辑逻辑，后端校验逻辑，当存储发生变更时，触发测试流水线，当测试流水线无异常后，才会借用部署的工具，将配置分发到线上去。</p>
<ol start="3">
<li><strong>降低配置的维护成本</strong></li>
</ol>
<p>通常来说，代码数量很大的项目，配置也会很多。这样的配置在维护起来需要花费大量的成本。所以在设计配置的时候，要满足以下这些规则：</p>
<blockquote>
<ol>
<li><p>让配置尽可能地在部署、数据版本、业务属性和架构描述这四个不同维度间参数能够共用。把部署的配置和策略的配置分离开来。</p>
</li>
<li><p>针对配置本身的语法，让配置支持合并.</p>
</li>
<li><p>减少冗余信息。</p>
</li>
<li><p>消除信息重复。</p>
</li>
<li><p>使用配置的默认值。</p>
</li>
</ol>
</blockquote>
</blockquote>
<h2 id="2-高效研发流程脚本"><a href="#2-高效研发流程脚本" class="headerlink" title="2. 高效研发流程脚本"></a>2. 高效研发流程脚本</h2><h3 id="2-1-从产品目标到产品路线图"><a href="#2-1-从产品目标到产品路线图" class="headerlink" title="2.1 从产品目标到产品路线图"></a><strong>2.1 从产品目标到产品路线图</strong></h3><blockquote>
<p>满足用户诉求是产品的基础功能，在此之上还有一个更高的期望，即产品的目标。通常情况下产品目标与产品的收益、市场份额、流水有关。在制定具体产品目标时，需要考虑产品的商业模式以及产品所处的阶段。<em>好的产品目标是具体的、可衡量的、相对稳定的。</em></p>
<p>在进行产品目标阶段性地拆解时，需要考虑拆解的维度与方法。除了根据阶段性的时间维度进行拆分外，还可以根据产品的里程碑进行拆分。</p>
</blockquote>
<h3 id="2-2-从产品路线图到发布计划"><a href="#2-2-从产品路线图到发布计划" class="headerlink" title="2.2 从产品路线图到发布计划"></a>2.2 <strong>从产品路线图到发布计划</strong></h3><p>在了解如何制定产品发布计划之前，我们需要先了解一个工具：<em>用户故事地图</em>。用户故事地图实际上是一个完整的用户故事。它可以帮助我们增强团队协作、洞察真实需求、打磨优良产品。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242041157.png" alt="image-20211124204157089"></p>
<p>想要创建用户故事地图，首先要有用户故事地图的框架。它的核心是一条从左到右的时间线，然后从上到下按照归纳结构分为三个层级。这一条时间线上方的一级粒度的功能需求，在工作中，我们称之为Epic，也就是橙色卡片。这条时间线下方的第一行为二级粒度的功能需求，在工作中，称之为Feature，是黄色卡片。在二级粒度功能下，蓝色的卡片为三级粒度的需求，工作中，称之为Story，是蓝色卡片。</p>
<p>用户故事地图创建中五个重要的步骤：</p>
<blockquote>
<ol>
<li><p>一步一步写出你的故事</p>
</li>
<li><p>组织情节</p>
</li>
<li><p>探索替代故事</p>
</li>
<li><p>提取故事地图的主干</p>
</li>
<li><p>切分出能帮你达成特定目标的任务</p>
</li>
</ol>
</blockquote>
<p><strong>“训练智能机器人小A从起床到出门”</strong>的简单例子</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242043740.png" alt="image-20211124204337683"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242053569.png"></p>
<p><em>首先我们使用蓝色卡片</em> 按照步骤写出每个任务，每张卡片只写一个任务，任务以动词开头，如“睁眼”、“关闹钟”、“穿拖鞋”、“叠被子”等等。然后按照任务的发生顺序从左到右的组织卡片摆放。</p>
<p>接下来第二步，对所有的任务进行提取，得到概括性的行为，把这些<em>行为放到黄色卡片</em>上，也就是feature。如：“睁眼”、“关闹钟”这些行为可以归为“醒来”后要做的事情；“穿拖鞋”、“叠被子”这两个行为可以归为“起来”后要做的事情。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242055033.png"></p>
<p>接下来进入第三步：探索替代故事。细节、替代、变化和异常构成故事地图的主题。比如：时间充裕可以睡个回笼觉，楼上装修被提前吵醒等等可能发生的变化和异常。我们需要将这些任务补充进地图。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242057602.png"></p>
<p>然后进入第四步：将一系列类似的任务提取出来，形成更大的目标。在类似任务的上方，放一张<em>橙色的卡片,也就是之前提到的Epic,卡片贴上一个动词短语</em>，使其足以覆盖其下方所有任务卡片所要表达的意思。例如：“起床”可以概括“醒来”和“起来”；“如厕”可以概括“如厕”和“刷牙”。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242058456.png"></p>
<p>此时已经完成了较为完整的故事地图。然后进入第五步，切分出能达成特定目标的任务。先确定本次迭代需要完成的特性/目标，使用切分来识别和特定相关的所有任务和细节。</p>
<p>在“训练智能机器人小A从起床到出门”这个例子中，分为了三个版本。在第一个版本15分钟起床，回笼觉这张卡片明显是不需要放到其中的。在这些的story中选出满足15分钟起床的事务并将其放入都第一个版本中。至此我们也就完成了一个简单的用户故事地图的创建。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242002082.webp"></p>
<p>上面这张图片是实际工作中对用户故事地图的应用，可以看到在实际工作中完整的用户故事地图所包含的内容非常庞杂。</p>
<p>完成用户故事地图之后，就需要制订发布计划。在创建用户故事地图的第五步中，我们切分出了达成特定功能的任务目标，每一个发布计划都对应着一个版本。具体的步骤如下：</p>
<blockquote>
<ol>
<li><p>Big Story进行细化讨论</p>
</li>
<li><p>按照价值和重要程度进行版本规划</p>
</li>
<li><p>确定每个版本的期望达成目标</p>
</li>
<li><p>确定每个版本的内容</p>
</li>
<li><p>团队达成共识</p>
</li>
</ol>
</blockquote>
<p>通过以上步骤，就基本确定了用户故事地图的发布计划。</p>
<h3 id="2-3-从发布计划到迭代计划"><a href="#2-3-从发布计划到迭代计划" class="headerlink" title="2.3 从发布计划到迭代计划"></a>2.3 <strong>从发布计划到迭代计划</strong></h3><p>第三部分主要讲解 <em>集中发布式模式</em> 这一常用的模式，在集中发布式模式中<em>，一次发布包含多次迭代</em>；在迭代发布模式中，一次发布等于一次迭代。</p>
<p>很多大型项目都在使用这一模式，通常是每月发布一次，<em>一次发布包含四个迭代</em>，四个迭代之后，发布一次版本。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242101886.png"></p>
<p>从发布计划到迭代计划共包括四个内容。</p>
<ol>
<li><strong>用户故事拆分</strong></li>
</ol>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242101974.png"></p>
<p>​        用户故事的拆分<em>对迭代速率有一定影响</em>。对用户故事的拆分要做到拆分出的故事尽量小，但是要适当，并不是越小越好。避免出现一个迭代内无法完成的故事。</p>
<ol start="2">
<li><strong>用户故事优先级</strong></li>
</ol>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242104291.webp"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242006342.webp"></p>
<p>​        在完成用户故事拆分后，需要对用户故事的优先级进行排序。用户故事的排序其实是对需求的一个排序，优先级排序有许多方法，如高中低、数字排序、衣服尺码L、XL等方式。<em>优先级决定排入迭代的顺序。</em></p>
<p>​        以一个两周的迭代时间为例，假设我们有这样一个需求，前面的数字是需求卡片的序号，后面的数字从100到45，这是项目优先级排序的一个方式。每一次迭代能做4个卡片时，我们就会<em>把优先级最高的卡片放入迭代池</em>。</p>
<p>​        而当第二次迭代时，需求发生了变化，出现了x和y两个新的需求，x和y有着较高的优先级，那么我们仍然将优先级最高的四个卡片放入迭代池中。</p>
<p>​        第三次迭代中又插入了新需求z，需求z也有较高的优先级，那么当我们进行迭代的时候，需求z就会顶替另一个需求被放入迭代池中。</p>
<p>​        通过以上的例子可以看到，在原本的迭代计划中，12张卡片会被按顺序放入迭代池中，而真实情况是插入了更高优先级的需求，替换了低优先级的需求，把低优先级的需求放入了下一次迭代中。这就是优先级排序对迭代计划的影响。</p>
<ol start="3">
<li><strong>用户故事估算</strong></li>
</ol>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242105269.png"></p>
<p>​        在迭代之前，需要对用户故事进行估算，<em>用户故事估算实际上是对工作量的估算</em>。这个工作量体现的是团队均值能力。</p>
<p>​        通常在公司内有不同级别的员工，高级别的员工和低级别的员工完成同一任务所需的时间是不同的。所以在进行用户故事估算时就需要规避掉技能的差异，根据团队的均值能力来进行估算。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242106613.png"></p>
<ol start="4">
<li><strong>迭代计划制定</strong></li>
</ol>
<p>当前面三步全部完成后，才能开始指定迭代计划。</p>
<p>将已拆分好的用户故事按照优先级依次放入迭代池中，对每个要进行迭代的用户故事进行估算，确定好迭代的时间期限。所以我们就制定出了迭代计划。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242107859.png"></p>
<p><em>推荐采用范围调整、需求置换</em>方式，即插入高优先级用户故事，顺延低优先级故事到下一次迭代。</p>
<h3 id="2-4-从迭代计划到迭代的落地执行"><a href="#2-4-从迭代计划到迭代的落地执行" class="headerlink" title="2.4 从迭代计划到迭代的落地执行"></a>2.4 <strong>从迭代计划到迭代的落地执行</strong></h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242108710.png" alt="迭代计划会、站会、需求评审会、迭代回顾会"></p>
<p>在整个过程中开发和测试以story的力度进行。<em>分析、开发与测试三个步骤并行。</em></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111242110996.png" alt="卡片墙"></p>
<p>团队可以使用卡片墙标注完成的任务和未完成的任务以及遇到的bug等。通过这种方式，能够对执行情况有清晰的认知，对执行过程产生积极的影响。</p>
<h2 id="3-研发工具链介绍"><a href="#3-研发工具链介绍" class="headerlink" title="3 研发工具链介绍"></a>3 研发工具链介绍</h2><h3 id="3-1-项目管理工具-iCafe"><a href="#3-1-项目管理工具-iCafe" class="headerlink" title="3.1 项目管理工具: iCafe"></a>3.1 项目管理工具: iCafe</h3><h4 id="3-1-1-需求管理"><a href="#3-1-1-需求管理" class="headerlink" title="3.1.1 需求管理"></a>3.1.1 需求管理</h4><p><strong>需求管理是一个项目的基石。</strong>在互联网行业中，因为产品需求迭代快速这一特点，需求管理一直非常令人头疼。所以如何对需求进行更好的管理，更好的做出产品规划对互联网行业的项目来说是一个重要的问题。</p>
<blockquote>
<p>传统的需求管理方法有以下几种：</p>
<ol>
<li><p>直接将需求写在文档上面，</p>
</li>
<li><p>将需求制作成需求卡片，通过这样的方式让研发人员与需求人员保持信息的一致。</p>
</li>
<li><p>使用Excel进行需求管理和排序。</p>
</li>
</ol>
</blockquote>
<p>这三种方法都存在很多的缺点，如撰写文档耗时长、文档编写需求较多人力、文档维护成本高、文档使用过程中沟通不畅等等。文字因为其阅读特性，不方便对任务进行直观的展现。所以在很多项目开发过程中，经常会出现文档交给研发人员后，开发出的产品与文档设计不一致的问题。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111250059343.png"></p>
<p>互联网的需求管理需要具有<strong>需求完整性、沟通高效性、表达准确性，沟通便捷性</strong>等特点。</p>
<p>研究表明，不同的沟通方式产生的沟通效果各有不同。在所有的沟通方式中，文档沟通是最低效的沟通方式，而面对面使用白板沟通是最高效的沟通方式。结合多种高效沟通方式，就产生了用户故事地图这种新颖的需求管理、排序的方式。</p>
<p><strong>用户故事地图是敏捷项目管理中一种重要的管理方式。</strong></p>
<p>首先<strong>使用卡片在白板上将所有的需求列出来，</strong>这样有助于展现产品全貌，而且将需求转化为可视的卡片能更好的根据用户反馈对任务需求进行排序；</p>
<p>然后<strong>使用不同的颜色对卡片进行分层。</strong>蓝色卡片是第一层，黄色卡片是第二层，白色卡片是第三层。将颗粒度最小的需求放在白色卡片这一层，低颗粒度的需求更容易被研发人员接受。</p>
<p>最后通过横向的分组，把迭代计划每一期的每一版本的<strong>需求进行归类分组。</strong>这样有利于打通产品视图和研发计划视图。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292131175.png"></p>
<p>通过以上步骤可以得到一个较为完整的用户故事地图。</p>
<h4 id="3-1-2-迭代计划"><a href="#3-1-2-迭代计划" class="headerlink" title="3.1.2 迭代计划"></a>3.1.2 迭代计划</h4><p>在完成产品的版本规划后，研发团队需要制定相应的迭代计划。敏捷、快速、合理地迭代计划能够更高效地促进项目的迭代。</p>
<p>基于用户故事地图，可以在制定迭代计划的过程中中直接对需求进行<strong>上下拖拽修改优先级，左右拖拽更改计划。</strong>这样可以更清晰的展现迭代计划，使开发团队更好定位到的里程碑，完善整个迭代计划。</p>
<h4 id="3-1-3-进度追踪"><a href="#3-1-3-进度追踪" class="headerlink" title="3.1.3 进度追踪"></a>3.1.3 进度追踪</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111250103932.png"></p>
<p>进度跟踪的三大法宝：<strong>站会、卡片墙、燃尽图。</strong></p>
<p>站会同卡片墙相结合，在站会过程中可以直接通过电子看板共享项目进度和项目问题，提升站会沟通效率。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270116972.png"></p>
<p><strong>用户故事地图是一种非常高效需求管理方式，</strong>目前所有的研发团队都可以在效率云上不受物理条件限制的直接使用它进行需求管理和追踪。</p>
<h4 id="3-1-4-持续改进"><a href="#3-1-4-持续改进" class="headerlink" title="3.1.4 持续改进"></a>3.1.4 持续改进</h4><p>针对持续改进，有卡片状态时长散点图和卡片状态累积流图这两种工具。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270127171.png"></p>
<p><strong>卡片状态时长散点图</strong>能够精确展示团队工作速率，从需求提出到需求上线的单个周期时长和平均周期时长，精确的展示团队在每一个状态的工作速率及工作速率的变化。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270128848.png"></p>
<p><strong>卡片状态累积流图</strong>能够宏观展示项目各流程效率趋势，颜色的色块宽表示该流程积压的需求和任务比较多，色条变窄表明团队状态流动速率提高。</p>
<p>基于这两幅图工具，研发团队可以周期性地进行自检，对过去一段时间的工作进行自我审视，然后持续改进。</p>
<h3 id="3-2-代码管理工具-iCode"><a href="#3-2-代码管理工具-iCode" class="headerlink" title="3.2 代码管理工具:iCode"></a>3.2 代码管理工具:iCode</h3><h4 id="3-2-1-工作流"><a href="#3-2-1-工作流" class="headerlink" title="3.2.1 工作流"></a>3.2.1 工作流</h4><p>运转无序，开发混乱是困扰很多团队的一个问题，严重影响产品的交付。</p>
<p>典型的问题有：代码处理随意、bug重复发生、测试不完善、发布版本混乱等。</p>
<p>支持以下两种标准的工作流，用来保障团队有序协作。</p>
<h5 id="1-基于主干的工作流"><a href="#1-基于主干的工作流" class="headerlink" title="1.  基于主干的工作流"></a>1.  基于主干的工作流</h5><p>​            在基于主干的工作流中，整个团队维护一条主干分支。为了保证主干分支的质量，需要配套严    格的准入机制，变更点在合入前需要经过机器、人工的双重评审，通过后才能合入主干。</p>
<p>​            需要发布的时候，会基于主干拉取发布分支，这个分支其实是主干特定点的快照，单纯用于发        布，如果发布问题过程中发现问题，回到主干修复Bug或进行功能增强，必要时再将主干提交拣        选到相应的发布分支上。</p>
<p>​            分支发布和主干并行不悖，不用担心开发中的功能被带到线上，发布完成后恢复到一条主干的        简明模式。</p>
<blockquote>
<p>  基于主干的工作流<strong>优点</strong>有：</p>
<ol>
<li>主干质量高，随时可以发布。</li>
<li>模型简单，只有一条主干，节省分支合并的成本。</li>
</ol>
</blockquote>
<p>​    缺点: 在开发高质量的工程项目时，团队需要建设完备的测试用例，在提交环节要求提交人保持原子提交，即功能和提交一一对应。</p>
<h5 id="2-基于分支的工作流"><a href="#2-基于分支的工作流" class="headerlink" title="2. 基于分支的工作流"></a>2. 基于分支的工作流</h5><p>在基于分支的工作流中，<strong>主干用于存储线上代码</strong>，需要变更时，基于主干最新代码开分支完成功能的开发、测试和发布；分支发布前，需要先同步主干的更新；上线之后，需要将分支合并回主干。</p>
<blockquote>
<p>基于分支的工作流的<strong>优点</strong>有：</p>
<ol>
<li>分支并行，独立开发，分支不会相互影响；</li>
<li>对团队而言，使用门槛低，分支贯穿一个独立功能开发、测试、发布的整个过程，给予团队充分的时间完善测试用例及完成人工测试；</li>
<li>容易上手，系统会引导开发人员完成新建分支、同步主干、合会主干等全部操作。</li>
</ol>
</blockquote>
<p>缺点：需要花费分支合并的成本、需要不断地同步主干，来发现分支的冲突风险点并提前解决。</p>
<h3 id="3-2-2-评审"><a href="#3-2-2-评审" class="headerlink" title="3.2.2 评审"></a>3.2.2 评审</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270327159.png"></p>
<p>评审是<strong>保证团队工程质量</strong>的一个重要的过程。如果不经过评审直接提交代码，可能会污染代码历史，增加后期维护成本，严重时可能还会产生代码质量问题。</p>
<p>在项目开发过程中，可能会出现本地运行正常的代码，在测试环境或者线上环境突然崩溃的情况。针对这样的问题，可以使用<strong>质量防护网</strong>。质量防护网包括代码扫描、持续集成、人工评审三个层次。</p>
<p><strong>代码扫描</strong>能够找出不符合代码规范的地方，在行间距中插入代码评论，同时出具一个风格报告，方便工程师对代码风格问题进行修改。</p>
<p><strong>持续集成</strong>会配置一个云端构建，通过云端构建，快速探测出代码初期Bug，帮助开发人员提早修复。</p>
<p>在前两步做好后，团队的资深成员就可以就架构、逻辑、设计等问题进行深入评审。</p>
<p>通过这三步，实现了机器、人工双重评审，层层递进，确保团队的工程质量。</p>
<h3 id="3-3-交付平台-iPipe"><a href="#3-3-交付平台-iPipe" class="headerlink" title="3.3 交付平台:iPipe"></a>3.3 交付平台:iPipe</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270329017.png"></p>
<h4 id="3-3-1-固化端到端的交付流程"><a href="#3-3-1-固化端到端的交付流程" class="headerlink" title="3.3.1 固化端到端的交付流程"></a>3.3.1 固化端到端的交付流程</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111270333279.png"></p>
<p>标准的软件交付的过程包括以下几点：</p>
<blockquote>
<ol>
<li><p>会有一个明确的发布版本的输入，</p>
</li>
<li><p>基于这个发布版本，会进行代码提交。</p>
</li>
<li><p>代码提交之后会进行编译、测试。其中测试环节可能包含模块级的测试和系统级的测试。</p>
</li>
<li><p>进行发布。发布上线的过程可能会分为预上线、生产灰度、生产全量几个环节。</p>
</li>
</ol>
</blockquote>
<p>为了使代码变更流程标准化，需要<strong>使用交付流水线的方式来落地</strong>。通过标准化交付过程从而达到可靠、可重复的作用。交付流水线是<strong>串行执行</strong>的，上一个阶段成功执行后，就会触发下一个阶段。执行阶段由任务组成，这些任务可以是穿行的也可是并行的。任务的执行状态决定阶段执行状态。</p>
<p><strong>iPipe这一工具目前包含了标准的交付流水线</strong>，用户可以在iPipe中看到流水线的构建情况。在使用交付流水线的过程中，如果当前阶段失败，后面的阶段就不会继续进行，这样可以节省资源并且快速的发现问题，及时修复问题。</p>
<h4 id="3-3-2-插件化现有工具和服务"><a href="#3-3-2-插件化现有工具和服务" class="headerlink" title="3.3.2 插件化现有工具和服务"></a>3.3.2 插件化现有工具和服务</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130209.png"></p>
<p>在交付流水线中执行各种任务时需要依赖很多工具和服务，比如maven，docker、jenkins、git等工具和服务。</p>
<p>我们通过一套<strong>标准的插件化开发规范</strong>将这些工具和服务集成到了流水线中，用户在使用流水线的过程中就可以很方便的使用这些插件和服务。如果流水线中没有想使用的插件、服务或工具，可以根据效率云提供的插件规范，自行扩展以满足项目需求。</p>
<h4 id="3-3-3-数据度量驱动过程改进"><a href="#3-3-3-数据度量驱动过程改进" class="headerlink" title="3.3.3 数据度量驱动过程改进"></a>3.3.3 数据度量驱动过程改进</h4><p>通过交付流水线，可以快速获取项目所有的数据和信息，如：一个版本从代码提交到交付上线的周期或者一个项目各个阶段发现的缺陷数量等等。</p>
<p>用户可以通过调用API获取数据来进行数据的度量，从而推动交付过程的改进。在后续的发展中，平台会识别项目中关键的数据指标并且自动化的形成更加鲜明的数据报表。这样就可以持续的进行数据度量，给个人及团队提供一个维度丰富的平台。</p>
<h2 id="4-持续交付方法与实践"><a href="#4-持续交付方法与实践" class="headerlink" title="4 持续交付方法与实践"></a>4 持续交付方法与实践</h2><h3 id="4-1-为什么要做持续交付"><a href="#4-1-为什么要做持续交付" class="headerlink" title="4.1 为什么要做持续交付"></a>4.1 为什么要做持续交付</h3><h4 id="4-1-1-软件交付流程"><a href="#4-1-1-软件交付流程" class="headerlink" title="4.1.1 软件交付流程"></a>4.1.1 软件交付流程</h4><p>传统软件交付流程通常包括四个步骤：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271338880.png"></p>
<ol>
<li><p>首先业务人员会诞生一个软件的想法；</p>
</li>
<li><p>然后开发人员将这个想法变为一个产品或者功能；</p>
</li>
<li><p>经过测试人员的测试之后提交给用户使用并产生收益；</p>
</li>
<li><p>最后运维人员参与产品或功能的后期运维。</p>
</li>
</ol>
<h4 id="4-1-2-传统软件交付的问题和困境"><a href="#4-1-2-传统软件交付的问题和困境" class="headerlink" title="4.1.2 传统软件交付的问题和困境"></a>4.1.2 传统软件交付的问题和困境</h4><p>通过分析以上流程，可以发现一些传统软件交付流程<strong>存在的问题</strong>。</p>
<ol>
<li><p><strong>业务人员产生的需求文档沟通效率较低</strong>，有时会产生需求文档描述不明确、需求文档变更频繁等问题。</p>
</li>
<li><p>随着开发进度的推进，测试人员的工作量会逐步增加，测试工作的比重会越来越大。而且由于测试方法和测试工具有限，自动化测试程度低，<strong>无法很好地把控软件质量</strong>。</p>
</li>
<li><p>真实项目中运维的排期经常会被挤占，又因为手工运维繁琐复杂，<strong>时间和技术上的双重压迫</strong>会导致运维质量难以保证。</p>
</li>
</ol>
<p>因为存在以上问题，所以传统的软件交付经常会出现开发团队花费大量成本开发出的功能或产品并不能满足客户需求这一双输的局面。由此可以总结出传统的软件交付存在<strong>两个层面的困境：</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271339450.png"></p>
<p>从<strong>表现层</strong>来看，传统软件交付存在进度不可控；流程不可靠；环境不稳定；协作不顺畅等困境。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271339695.png"></p>
<p>表现层的问题其实都是由<strong>底层问题</strong>引起的，从根源上来说，存在分支冗余导致合并困难；缺陷过多导致阻塞测试；开发环境、测试环境、部署环境不统一导致的未知错误；代码提交版本混乱无法回溯；等待上线周期过长；项目部署操作复杂经常失败；上线之后出现问题需要紧急回滚；架构设计不合理导致发生错误之后无法准确定位等困境。</p>
<h4 id="4-1-3-持续交付的流程与优势"><a href="#4-1-3-持续交付的流程与优势" class="headerlink" title="4.1.3 持续交付的流程与优势"></a>4.1.3 持续交付的流程与优势</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271340504.png"></p>
<p>经过对传统软件交付问题的分析和总结，持续交付应运而生，持续交付是一系列开发实践方法，用来确保让代码能够快速、安全的部署到生产环境中。持续交付是一个完全自动化的过程，当业务开发完成的时候，可以做到一键部署。持续交付提供了一套更为完善的解决传统软件开发流程的方案。</p>
<ol>
<li><p>在需求阶段，抛弃了传统的需求文档的方式，使用便于开发人员理解的用户故事。</p>
</li>
<li><p>在开发测试阶段，做到持续集成，让测试人员尽早进入项目开始测试。</p>
</li>
<li><p>在运维阶段，打通开发和运维之间的通路，保持开发环境和运维环境的统一。</p>
</li>
</ol>
<p><strong>持续交付具备以下几个优势：</strong></p>
<blockquote>
<ol>
<li>持续交付能够有效缩短提交代码到正式部署上线的时间，降低部署风险。</li>
<li>持续交付能够自动的、快速的提供反馈，及时发现和修复缺陷。</li>
<li>持续交付让软件在整个生命周期内都处于可部署的状态。</li>
<li>持续交付能够简化部署步骤，使软件版本更加清晰。</li>
<li>持续交付能够让交付过程成为一种可靠的、可预期的、可视化的过程。</li>
</ol>
</blockquote>
<h4 id="4-1-4-敏捷开发与Devops"><a href="#4-1-4-敏捷开发与Devops" class="headerlink" title="4.1.4 敏捷开发与Devops"></a>4.1.4 敏捷开发与Devops</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271341155.png"></p>
<p>持续交付依靠<strong>敏捷开发（Agile）</strong>和<strong>Devops</strong>两个组件的支撑可以更好地发挥作用。</p>
<p>敏捷开发（Agile）主要作用于需求阶段和研发阶段。</p>
<p>Devops主要作用于开发测试和运维部署阶段。</p>
<blockquote>
<p>了解Devops的相关知识。</p>
<blockquote>
<ol>
<li><p>Devops的趋势</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271341165.png"></p>
<p>根据最近的一项集体研究，DevOps的市场在2020年创造了约50亿美元的产值，预计到2022年，这个数字将达到约66亿美元。随着Devops的影响力不断扩大，目前DevOps已经成为软件工程的主流模式。</p>
</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><p>Devops效能</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271342341.png"></p>
<p>Devops的效能跟发布频率、部署时间、平均修复故障的时间点、部署变更的失败率四个因素紧密相关。通常在高效的团队内，发布频率会达到每天多次发布、部署时间和平均修复故障时间都小于一小时，部署变更的失败率也能维持在15%以下。</p>
</li>
</ol>
</blockquote>
</blockquote>
<h4 id="4-1-5-软件交付能力指标"><a href="#4-1-5-软件交付能力指标" class="headerlink" title="4.1.5 软件交付能力指标"></a>4.1.5 软件交付能力指标</h4><p>在评价互联网公司的软件交付能力的时候，通常会使用两个指标：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271343658.png"></p>
<ol>
<li><p>仅涉及一行代码的改动需要花费多少时间才能部署上线，这也是<strong>核心指标</strong>。</p>
</li>
<li><p>开发团队是否在以一种可重复、可靠的方式在执行软件交付。</p>
</li>
</ol>
<p>目前，国外的主流互联网企业部署周期都以分钟为单位， Amazon、Google这些头部互联网企业单日的部署频率都在20000次以上。国内以百度、阿里、腾讯三大互联网巨头的数据来看，单日部署的频率也达到了单日8000次以上。高频率的部署代表着能够更快更好的响应客户的需求。</p>
<h3 id="4-2-如何做到高效的持续交付"><a href="#4-2-如何做到高效的持续交付" class="headerlink" title="4.2 如何做到高效的持续交付"></a>4.2 如何做到高效的持续交付</h3><h4 id="4-2-1-持续交付方法"><a href="#4-2-1-持续交付方法" class="headerlink" title="4.2.1 持续交付方法"></a>4.2.1 持续交付方法</h4><p>为了能更好的做到高效的持续交付。在此我们提供了一个<strong>三层叠加的持续交付方法</strong>。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271345629.png"></p>
<p>首先最上层，持续交付的<strong>总目标是价值交付</strong>，要为用户交付有价值的内容。</p>
<p>然后第二层包含了业务、流程、组织三个维度。</p>
<p>在业务这一维度，主要通过精益、用户故事地图、看板三种方式来减少业务部门与开发部门的沟通困难。</p>
<p>在流程这一维度，主要集中于创建一个供开发、测试、运维人员使用的可靠、可重复的流水线，将这种流水线应用于项目的流程中。</p>
<p>在组织这一维度，要求加强团队协作，提高项目质量和项目改进能力，并且引入了成熟度模型用于评估团队的能力层级。</p>
<p>如果没有技术能力的支撑，仅依靠方法和指导思想不足以做到高效持续交付。所以<strong>第三层也是最重要的底层是技术层</strong>。技术层包括了基础架构和应用架构。<strong>基础架构</strong>引入了容器集群管理、研发工具平台、持续交付工具链。<strong>应用框架</strong>引入了浮现式设计、微服务框架还有能够抽离出来的配置化架构。</p>
<h4 id="4-2-2-持续交付、持续集成、持续部署的关系"><a href="#4-2-2-持续交付、持续集成、持续部署的关系" class="headerlink" title="4.2.2 持续交付、持续集成、持续部署的关系"></a>4.2.2 持续交付、持续集成、持续部署的关系</h4><p>要进一步构建可靠可重复的流水线，首先就是要理清持续交付、持续集成和持续部署三者之间的关系。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271348755.png"></p>
<p>简单来说<strong>持续集成和持续部署是持续交付的基础，持续交付包括但不限于持续集成和持续部署。</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271350656.png"></p>
<p>持续集成是包含了代码的编译、近代检查、单元测试任务的集成，虽然持续集成也能构成一条流水线，但是这条流水线并不完整，而且集成并没有明确的目标。</p>
<p>近几年得益于虚拟机技术和容器技术的迅速发展，持续部署也逐渐变得简单高效，能够运用这些工具快速将项目部署到例如准入环境、预生产环境等等各种环境中。</p>
<h4 id="4-2-3-如何构建一个可靠可重复的流水线"><a href="#4-2-3-如何构建一个可靠可重复的流水线" class="headerlink" title="4.2.3 如何构建一个可靠可重复的流水线"></a>4.2.3 如何构建一个可靠可重复的流水线</h4><p>在理清持续交付的关系后，需要通过持续交付来构建一条可靠可重复的流水线，构建这条流水线的目的是为了让开发人员、测试人员、运维人员能更好的协作完成整个项目并上线到生产环境。</p>
<p>通过对比传统流水线和持续交付流水线，能更加清晰地展现出持续交付流水线的强大。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271351747.png"></p>
<p>在传统流水线中，首先代码提交要用过填写表单的形式进行版本申请，然后开发人员在离线环境上手工进行代码编译和单元测试，单元测试完成后需要撰写对应的测试报告文档并且向上提测，在系统测试环节需要测试人员手动构建和部署测试环境，完成测试之后再次撰写测试报告，并且申请上线，在通过上线审批之后，在线上生产环境需要再次手动构建环境以及进行生产环境的测试，最终完成整体的开发。</p>
<p>在持续交付流水线中，代码合入到主干之后会直接触发自动编译，自动编译完成之后会进行初步的自动化单元测试、模块测试和系统测试，在测试过程中持续交付可以自动构建和部署环境。完成系统测试之后会将问题抛出来，解决完成后再次提测，会自动化的再次进行系统测试，通过系统测试之后可以一键操作进行项目发布，并进行预上线，在完成预上线后，可以再次进行一键操作完成正式生产环境的上线。</p>
<p>通过两种流水线的对比，可以看出来，持续交付的流水线有显著的优势。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271352109.png"></p>
<p>实际生产中的产品级流水线，可以视为多个模块级流水线的组合，多个模块级流水线组合成为复杂的多线并发的产品级流水线，最终可以完成整个项目的持续交付。</p>
<h4 id="4-2-4-交付流水线落地工具"><a href="#4-2-4-交付流水线落地工具" class="headerlink" title="4.2.4 交付流水线落地工具"></a>4.2.4 交付流水线落地工具</h4><p>交付流水线的落地需要依靠<strong>落地方案</strong>和<strong>落地工具</strong>，目前常用的落地方案有GoCD，这是thoughtworks的一个产品。还有目前广泛应用的Jenkins和Spinnakeer。</p>
<img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271354818.png" style="zoom:50%;" />

<img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271354355.png" style="zoom:50%;" />

<p>常用的交付流水线落地工具有效率云平台中的iPipe工具，在这个工具中可以根据需求创建流水线，并且将相关内容全都关联到流水线中，这样可以让开发人员、测试人员和运维人员在这个工具中直观的看到产品的状态以及质量情况。</p>
<h3 id="4-3-持续部署"><a href="#4-3-持续部署" class="headerlink" title="4.3 持续部署"></a>4.3 持续部署</h3><p>对于持续交付整体来说，持续部署非常重要。</p>
<h4 id="4-3-1-持续部署方案"><a href="#4-3-1-持续部署方案" class="headerlink" title="4.3.1 持续部署方案"></a>4.3.1 持续部署方案</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130946.png"></p>
<p>容器技术目前是部署中最流行的技术，常用的持续部署方案有Kubernetes+Docker和Matrix系统两种。容器技术一经推出就被广泛的接受和应用，主要原因是对比传统的虚拟机技术有以下几个<strong>优点</strong>：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130129.png"></p>
<ol>
<li>容器技术上手简单，轻量级架构，体积很小。</li>
<li>容器技术的集合性更好，能更容易对环境和软件进行打包复制和发布。</li>
</ol>
<p>容器技术的引入为软件的部署带来了前所未有的改进，不但<strong>解决了复制和部署麻烦</strong>的问题，还能<strong>更精准的将环境中的各种依赖进行完整的打包。</strong></p>
<h4 id="4-3-2-部署原则"><a href="#4-3-2-部署原则" class="headerlink" title="4.3.2 部署原则"></a>4.3.2 部署原则</h4><p><strong>在持续部署管理的时候，需要遵循一定的原则，内容包括以下几点：</strong></p>
<ol>
<li>部署包全部来自统一的存储库。</li>
<li>所有的环境使用相同的部署方式。</li>
<li>所有的环境使用相同的部署脚本。</li>
<li>部署流程编排阶梯式晋级，即在部署过程中需要设置多个检查点，一旦发生问题可以有序的进行回滚操作。</li>
<li>整体部署由运维人员执行。</li>
<li>仅通过流水线改变生产环境，防止配置漂移。</li>
<li>不可变服务器。部署方式采用蓝绿部署或金丝雀部署。</li>
</ol>
<h4 id="4-3-3-部署层次"><a href="#4-3-3-部署层次" class="headerlink" title="4.3.3 部署层次"></a>4.3.3 部署层次</h4><p>部署层次的设置对于部署管理来说也是非常重要的。首先要明确部署的目的并不是部署一个可工作的软件，而是<strong>部署一套可正常运行的环境</strong>。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271634406.png"></p>
<p><strong>完整的镜像部署包括三个环节：Build – Ship – Run。</strong></p>
<p>Build跟传统的编译类似，将软件编译形成RPM包或者Jar包。</p>
<p>Ship则是将所需的第三方依赖和第三方插件安装到环境中。</p>
<p>Run就是在不同的地方启动整套环境。</p>
<p>制作完成部署包之后，每次需要变更软件或者第三方依赖、插件升级的时候，不需要重新打包，直接更新部署包即可。</p>
<h4 id="4-3-4-不可变服务器"><a href="#4-3-4-不可变服务器" class="headerlink" title="4.3.4 不可变服务器"></a>4.3.4 不可变服务器</h4><p>在部署原则中提到的不可变服务器原则对于部署管理来说非常重要。不可变服务器<strong>是技术逐步演化的结果。</strong></p>
<p>在早期阶段，软件的部署是在物理机上进行的，每一台服务器的网络、存储、软件环境都是不同的，物理机的不稳定让环境重构变得异常困难。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271635334.png"></p>
<p>后来逐渐发展为虚拟机部署，在虚拟机上借助流程化的部署能较好的构建软件环境，但是第三方依赖库的重构不稳定为整体部署带来了困难。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130431.png"></p>
<p>现阶段使用容器部署不但继承和优化了虚拟机部署的优点，而且很好的解决了第三方依赖库的重构问题，容器部署就像一个集装箱，直接把所有需要的内容全部打包进行复制和部署。</p>
<h4 id="4-3-5-蓝绿部署和金丝雀部署"><a href="#4-3-5-蓝绿部署和金丝雀部署" class="headerlink" title="4.3.5 蓝绿部署和金丝雀部署"></a>4.3.5 蓝绿部署和金丝雀部署</h4><p>在部署原则中提到两大部署方式分别为蓝绿部署和金丝雀部署。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271635700.png"></p>
<p><strong>蓝绿部署</strong>是指在部署的时候准备新旧两个部署版本，通过域名解析切换的方式将用户使用环境切换到新版本中，当出现问题的时候，可以快速的将用户环境切回旧版本，并对新版本进行修复和调整。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271636728.png"></p>
<p><strong>金丝雀部署</strong>是指当有新版本发布的时候，先让少量的用户使用新版本并且观察新版本是否存在问题，如果出现问题，就及时处理并重新发布，如果一切正常，就稳步的将新版本适配给所有的用户。</p>
<h4 id="4-3-6-服务描述"><a href="#4-3-6-服务描述" class="headerlink" title="4.3.6 服务描述"></a>4.3.6 服务描述</h4><p>服务描述要实现的目标是当软件部署到不同的环境中时，通过服务描述来<strong>规避环境配置的差异</strong>。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637518.png"></p>
<p>在服务描述中，通常会对不同的环境下所需的配置进行描述，例如所需要的CPU、内存、网络等。当实际部署的时候，如果出现环境差异，调度工具就可以按照服务描述的配置发放资源，使环境能够正常运行。</p>
<h4 id="4-3-7-流程控制"><a href="#4-3-7-流程控制" class="headerlink" title="4.3.7 流程控制"></a>4.3.7 流程控制</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637506.png"></p>
<p>在部署阶段，为了防止意外问题的发生，会在一些环节<strong>加入人工审核</strong>。例如在灰度发布工具中，就会先对线上机器进行分组部署，然后由人工去分组检查，如果没有问题，就进行下一组的部署，如果出现问题，人工就可以及时的进行回滚操作，避免问题扩大到更多地线上环境中。</p>
<h4 id="4-3-8-数据度量和分析"><a href="#4-3-8-数据度量和分析" class="headerlink" title="4.3.8 数据度量和分析"></a>4.3.8 数据度量和分析</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271637498.png"></p>
<p>在完成持续部署或持续交付之后，需要结合多个维度的数据对项目整体的<strong>研发效率和部署效率进行分析</strong>。例如通过交付时间周期的长短变化来反映流水线为团队带来的价值。再比如通过筛选和展示团队的相关数据，方便团队来进行决策。还有通过环比汇总数据来分析变化的趋势。系统也会通过数据的自动分析和异常报表监控一些关键指标，一旦关键数据出现问题，系统能够及时联系关键人员关注。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111271640201.png"></p>
<p>通过以上的例子能够发现，<strong>持续交付与量化驱动改进是密不可分的</strong>，团队能够在度量中发现问题，在度量中看到进步。持续交付就是这样一个不断改进不断优化的过程，通过数据可以量化产出并且指引团队找到痛点并且进一步的深化改进。</p>
<h1 id="二、百度高效研发实战训练营Step2"><a href="#二、百度高效研发实战训练营Step2" class="headerlink" title="二、百度高效研发实战训练营Step2"></a>二、百度高效研发实战训练营Step2</h1><h2 id="1-代码的艺术"><a href="#1-代码的艺术" class="headerlink" title="1 代码的艺术"></a>1 代码的艺术</h2><h3 id="1-1-《代码的艺术》目的解读"><a href="#1-1-《代码的艺术》目的解读" class="headerlink" title="1.1 《代码的艺术》目的解读"></a>1.1 《代码的艺术》目的解读</h3><h4 id="1-1-1-了解公司与学校写代码的不同"><a href="#1-1-1-了解公司与学校写代码的不同" class="headerlink" title="1.1.1 了解公司与学校写代码的不同"></a>1.1.1 了解公司与学校写代码的不同</h4><p>在公司写程序和在学校写程序有很大的不同。</p>
<p>在学校写程序时，对于代码的质量要求比较低。</p>
<p>当进入公司之后，做的是工业级的产品，服务用户量可能会到达亿万级，所以相对而言对于代码的质量要求比较高。<em>一些伟大产品中的代码，甚至可以被称为艺术品。</em></p>
<h4 id="1-1-2-消除对于程序员这个职业的误解"><a href="#1-1-2-消除对于程序员这个职业的误解" class="headerlink" title="1.1.2 消除对于程序员这个职业的误解"></a>1.1.2 消除对于程序员这个职业的误解</h4><p>很多人都对程序员这个职业有误解，认为程序员就是码农，认为程序员35岁之后就写不出代码了。还有人认为程序员未来的唯一出路是以后做管理。</p>
<p>希望通过这门课程的学习，能使大家对于程序员有一个新的认识，消除误解。</p>
<h4 id="1-1-3-建立对软件编程的正确认识"><a href="#1-1-3-建立对软件编程的正确认识" class="headerlink" title="1.1.3 建立对软件编程的正确认识"></a>1.1.3 建立对软件编程的正确认识</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272315701.png"></p>
<p>在做一件事物时，我们常说“知”与“行”要合一。即：我们需要对这件事物有一个正确的认识，才会有正确的行动。同理，<em>写出好代码的前提，是对软件编程有正确的认识</em>。</p>
<h4 id="1-1-4-明确作为软件工程师的修炼方向"><a href="#1-1-4-明确作为软件工程师的修炼方向" class="headerlink" title="1.1.4 明确作为软件工程师的修炼方向"></a>1.1.4 明确作为软件工程师的修炼方向</h4><p>艺术品是由艺术家创造的。艺术家的修炼是有方式方法的。同样，软件工程师的修炼也是方式有方法的。希望通过这门课程，能使大家对软件工程师这个职业有一个全新的认识。</p>
<h3 id="1-2-代码与艺术之间的关系"><a href="#1-2-代码与艺术之间的关系" class="headerlink" title="1.2 代码与艺术之间的关系"></a>1.2 代码与艺术之间的关系</h3><h4 id="1-2-1-代码是可以被称为艺术的"><a href="#1-2-1-代码是可以被称为艺术的" class="headerlink" title="1.2.1 代码是可以被称为艺术的"></a>1.2.1 代码是可以被称为艺术的</h4><p>艺术，是多种多样、丰富多彩的。同时艺术也是有多个层次的，其实，在我们编写代码时，我们的脑海中也会有类似的感觉。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272319344.png"></p>
<p>艺术就是人类通过借助特殊的物质材料与工具，运用一定的审美能力和技巧，在精神与物质材料、心灵与审美对象的相互作用下，进行的充满激情与活力的创造性劳动，可以说它是一种精神文化的创造行为，是人的意识形态和生产形态的有机结合体。</p>
<p>写代码也恰恰要经历这样的一个过程。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272319626.png"></p>
<p>在编写代码的过程中：</p>
<p>我们<em>借助的物质是计算机系统，借助的工具是设计、编写、编译、调试、测试等</em>。</p>
<p>同样，编写代码需要激情。而且，编写代码是一件非常具有创造性的工作。</p>
<p>代码是人类智慧的结晶，代码反映了一个团队或一个人的精神。<em>代码可以被称为是艺术的。</em></p>
<h4 id="1-4-2-艺术可以从不同的角度进行解读、研究与创造"><a href="#1-4-2-艺术可以从不同的角度进行解读、研究与创造" class="headerlink" title="1.4.2 艺术可以从不同的角度进行解读、研究与创造"></a><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272320545.png">1.4.2 艺术可以从不同的角度进行解读、研究与创造</h4><p>达芬奇有多幅著名的画作。拿著名的《蒙娜丽莎》这幅画来举例：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272322121.png"></p>
<p>站在观众的角度，可能只是在欣赏画中的人物微笑。但是对于画家来说，可能就会考虑画画的手法、构图、光线明暗、色彩对比等等方面。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272323753.png"></p>
<p>在艺术方面，可以站在很多不同的角度进行解读。</p>
<p>但是如果要成为一名创作者，我们需要的不仅仅是欣赏的能力，更重要的是<em>从多角度进行解读、研究与创造的能力</em>。</p>
<h4 id="1-4-3-写代码如同艺术创作"><a href="#1-4-3-写代码如同艺术创作" class="headerlink" title="1.4.3 写代码如同艺术创作"></a>1.4.3 写代码如同艺术创作</h4><p>写代码的内涵是：</p>
<ol>
<li>写代码这个过程是一个<em>从无序到有序</em>的过程。</li>
<li>写代码需要把现实问题转化为数学模型。在写代码的过程中，我们需要有很好的模型能力。</li>
<li>写代码实际是一个认识的过程。很多时候，编码的过程也是我们认识未知问题的过程。</li>
<li>在写代码的过程中，我们需要综合的全方位的能力。包括把握问题的能力、建立模型的能力、沟通协助的能力、编码执行的能力等等。</li>
<li>在写好代码之前，首先需要建立品位。品味是指我们首先要知道什么是好的代码，什么是不好的代码。这样我们才能去不断地调整自己的行为，然后去学习，去提高我们的编码能力，写出具有艺术感的代码。</li>
</ol>
<h3 id="1-3-软件工程师不等于码农"><a href="#1-3-软件工程师不等于码农" class="headerlink" title="1.3 软件工程师不等于码农"></a>1.3 软件工程师不等于码农</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111272336586.png"></p>
<p>软件工程师不能只会写代码，更需要具有综合的素质。这个综合的素质包括：</p>
<h4 id="1、技术"><a href="#1、技术" class="headerlink" title="1、技术"></a>1、技术</h4><p><em><strong>技术能力是基础。</strong></em>包括但不限于编码能力、数据结构和算法能力、系统结构知识、操作系统知识、计算机网络知识、分布式系统知识等等。</p>
<h4 id="2、产品"><a href="#2、产品" class="headerlink" title="2、产品"></a>2、产品</h4><p>要对产品业务有深刻的理解，需要了解产品交互设计、产品数据统计、产品业务运营等。</p>
<h4 id="3、其他"><a href="#3、其他" class="headerlink" title="3、其他"></a>3、其他</h4><p>要了解一些管理知识，需要知道项目是怎么管理的 ，如何去协调多个人一起去完成一个项目。有一些项目需要具有很强的研究与创新方面的能力。</p>
<p>以上这些能力素质，是一个软件工程师需要具有的综合素质。要成为一个全部掌握这些素质系统工程师至少需要8~10年的时间。</p>
<p>所以，软件工程师绝对不是一个只会简单编写代码就可以的职业。<em><strong>软件工程师不等于码农。</strong></em></p>
<h3 id="1-4-正确认识代码实践方面的问题"><a href="#1-4-正确认识代码实践方面的问题" class="headerlink" title="1.4 正确认识代码实践方面的问题"></a>1.4 正确认识代码实践方面的问题</h3><h4 id="1-4-1-什么是好代码，好的代码有哪些标准"><a href="#1-4-1-什么是好代码，好的代码有哪些标准" class="headerlink" title="1.4.1 什么是好代码，好的代码有哪些标准"></a>1.4.1 什么是好代码，好的代码有哪些标准</h4><p><strong>好代码的标准是：</strong></p>
<p>①高效、②鲁棒、③简洁、④简短、⑤可共享、</p>
<p>⑥可测试、⑦可移植、⑧可监控、⑨可运维、⑩可扩展。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130734.png"></p>
<blockquote>
<p>将以上十条标准进行总结精简，可以归纳为：</p>
<p>（1）代码的正确和性能；</p>
<p>（2）代码的可读和可维护性；</p>
<p>（3）代码的可运维和可运营；</p>
<p>（4）代码的可共享和可重用。</p>
</blockquote>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280007786.png"></p>
<p>了解完好代码的标准，接下来我们来看一下不好的代码主要表现在哪些方面：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280005709.png"></p>
<ol>
<li>不好的函数名</li>
</ol>
<p>​    比如，在函数名中，加my等单词，这属于很不专业的用法。</p>
<ol start="2">
<li>不好的变量名</li>
</ol>
<p>​    比如，看不出任何含义的a,b,c,j,k,temp等变量名。</p>
<ol start="3">
<li>没有注释或注释不清晰</li>
</ol>
<p>​    没有注释的代码是非常难读懂的。注释不清晰往往是因为文字功底或者描述能力欠缺，从而导致无法通过注释把代码的执行原理讲解清楚。</p>
<ol start="4">
<li>一个函数执行多个功能</li>
</ol>
<p>​    比如LoadFromFileAndCalculate()函数，它既执行了文件中去加载数据，还执行了计算功能。像这样的函数，我们建议把它切分成两个单独的函数。</p>
<ol start="5">
<li>不好的代码样式排版</li>
</ol>
<p>​    代码的样式排版在某种程度上体现了代码的一种逻辑。好的代码排版能增强代码的可读性和逻辑性。我们在写代码时，要规避不好的代码样式排版。</p>
<ol start="6">
<li>难以测试的代码</li>
</ol>
<p>​    代码没法测试，难写测试用例，这些都是一些不好的表现。</p>
<h4 id="1-4-2-好的代码从哪里来"><a href="#1-4-2-好的代码从哪里来" class="headerlink" title="1.4.2 好的代码从哪里来"></a>1.4.2 好的代码从哪里来</h4><p>代码不只是“写”出来的。实际上，在整个项目中，真正的编码时间约占项目整体时间的10%。<em>好的代码是多个环节工作共同作用的结果。</em></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280009655.png"></p>
<p>这些环节包括：</p>
<blockquote>
<ol>
<li>在编码前，要进行需求分析和系统设计。</li>
<li>在编码过程中，要注意做单元测试。</li>
<li>在编码后，要做集成测试，要上线，要持续运营，要迭代改进。</li>
</ol>
</blockquote>
<p>一个好的系统或产品，是以上几个环节持续循环的结果。</p>
<p>接下来我们着重介绍一下重点环节——<em>需求分析和系统设计</em>。</p>
<p><strong>1. 认识需求分析和系统设计的重要性</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280011841.png"></p>
<p>需求分析和系统设计在软件开发中经常被忽略或轻视，但是这两点都是非常重要的环节。</p>
<p>人们的直觉往往是拿到一个项目就想尽快把它写出来并运行，感觉这样的路径是最快的。</p>
<p>但是实际上在软件前期需求分析和系统设计投入更多的成本，会在后期节省更多的消耗。即：<em>前期更多的投入，收益往往最大</em>。</p>
<p>原因是：如果我们开始的设计做错的话，那么后期开发、测试、上线、调试这些成本都会被浪费掉。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280010793.png"></p>
<p><strong>2. 清楚需求分析和系统设计的差别</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292126264.png"></p>
<p>需求分析和系统设计是有泾渭分明的区别的，为了避免这两者相互混杂，我们需要清楚需求分析和系统设计各自的内涵。</p>
<p><em>需求分析主要是定义系统或软件的黑盒行为，即：外部行为。</em>比如，系统从外部来看能够执行什么功能。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280011809.png"></p>
<p><em>系统设计主要是设计系统或软件的白盒机制。即：内部行为。</em>比如，系统从内部来看，是怎么做出来的，为什么这么做。</p>
<p><strong>3.  需求分析的注意要点</strong></p>
<p>要点一：清楚怎么用寥寥数语勾勒出一个系统的功能。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280012501.png"></p>
<p>每个系统都有自己的定位，我们可以从简洁的总体描述，展开到具体的需求描述。</p>
<blockquote>
<p>需求描述的内容基本包括：</p>
<ol>
<li><p>系统类型描述</p>
</li>
<li><p>系统规模描述</p>
</li>
<li><p>系统定位和系统差异描述</p>
</li>
<li><p>系统对外接口功能描述</p>
</li>
</ol>
</blockquote>
<p>要点二：需求分析需要用精确的数字来描述。</p>
<p>需求分析中会涉及大量的数据分析，这些分析都需要精确的数字来进行支撑。</p>
<p><strong>4. 系统设计的注意要点</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280014355.png"></p>
<p><strong>要点一、清楚什么是系统架构</strong></p>
<p><em>系统架构，英文名 System Architectrue。</em>在wiki上有一个英文定义阐述了系统架构是一个概念的模型，它定义了系统的结构、行为、更多的视图。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280017695.png"></p>
<p>进一步解读系统架构，它的几个要素是：</p>
<p>①系统要完成哪些功能</p>
<p>②系统如何组成</p>
<p>③功能在这些组成部分之间如何划分</p>
<p><strong>要点二、注意系统设计的约束</strong></p>
<p><em>重点是资源的限制。</em>比如，计算的资源限制，存储的资源限制，IO网络的资源限制等。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280018199.png"></p>
<p><strong>要点三、清楚需求是系统设计决策的来源</strong></p>
<p>精确定义需求中的各个细节，以及量的定义，对系统设计的决策起着重要的作用。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130393.png"></p>
<p><strong>要点四、系统设计的风格与哲学</strong></p>
<p><em>在同样的需求下，可能出现不同的设计方式。</em>即目的相同，设计不同。比如：复杂指令集和精简指令集的设计差异。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292130655.png"></p>
<p>一个好的系统是<em>在合适假设下的精确平衡</em>。一个通用的系统在某些方面是不如专用系统的。每个系统每个组件的功能都应该足够的专一和单一。每个组件是指子系统或模块等。功能的单一是复用和扩展的基础。倘若不单一，未来就有可能很难进行复用和扩展。</p>
<p>子系统或模块之间的关系应该是<em>简单而清晰的</em>。软件中最复杂的是耦合，如果各系统之间的接口定义非常复杂，那么未来便很难控制系统的健康发展。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280019144.png"></p>
<p>值得注意的是，使用全局变量就是在增加系统的耦合，从而增加系统的复杂性，所以<em>在系统中需要减少使用全局变量。</em></p>
<p><strong>要点五、清楚接口的重要性</strong></p>
<p><em>接口，英文名Interface。</em>系统对外的接口比系统实现本身还要更加重要，接口的设计开发不容忽视。</p>
<p><strong>接口主要包括：</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280019599.png"></p>
<p><strong>接口重要的原因在于：</strong></p>
<p>①接口定义了功能。如果定义的功能不正确，那么系统的可用性与价值便会大打折扣。</p>
<p>②接口决定了系统和系统外部之间的关系。相对于内部而言，外部关系确定后非常难以修改。</p>
<p>接口的修改需要非常慎重且要考虑周全。</p>
<p><strong>后期接口修改时主要注意两点：</strong></p>
<ol>
<li>合理好用。新改的接口应该是非常合理好用的。不能使调度方感觉我们做的接口非常难以使用。</li>
<li>修改时需要向前兼容。新改的接口应该尽量实现前项的兼容。不能出现当新接口上线时其他程序无法使用的情况。</li>
</ol>
<h4 id="1-4-3-如何写好代码"><a href="#1-4-3-如何写好代码" class="headerlink" title="1.4.3 如何写好代码"></a>1.4.3 如何写好代码</h4><h5 id="1-代码也是一种表达方式"><a href="#1-代码也是一种表达方式" class="headerlink" title="1 代码也是一种表达方式"></a>1 代码也是一种表达方式</h5><p>在一个项目中，软件的维护成本远远高于开发成本，而且超过50%的项目时间都是用于沟通。</p>
<p>常规意义的沟通方式主要有面对面交流、Email、文档或网络电话会议等。但是其实 <em>代码也是一种沟通方式</em>。</p>
<p>在计算机早期，我们使用机器语言或汇编语言，更多的是考虑代码如何更高效率地执行。</p>
<p>然而，随着技术的进步，代码编译器的逐渐完善，我们写代码时更多的是要考虑如何让其他人看得懂、看得清楚。于是，<strong><em>编程规范应运而生</em>。</strong></p>
<p><strong>编程规范主要包含：</strong></p>
<ol>
<li>如何规范的表达代码。 </li>
<li>语言使用的相关注意事项。</li>
</ol>
<p><strong>基于编程规范，看代码的理想场景是：</strong></p>
<ol>
<li>看别人的代码，感觉和看自己的代码一样。</li>
<li>看代码时能够专注于逻辑，而不是格式方面。</li>
<li>看代码时不用想太多。</li>
</ol>
<h5 id="2-代码书写过程中的细节问题"><a href="#2-代码书写过程中的细节问题" class="headerlink" title="2 代码书写过程中的细节问题"></a>2 代码书写过程中的细节问题</h5><h6 id="1-关于模块"><a href="#1-关于模块" class="headerlink" title="1. 关于模块"></a>1. 关于模块</h6><p><strong>模块，是程序的基本组成单位</strong>。在一个模块内，会涉及它的数据、函数或类。对于Python、Go、C语言这样的程序来说，一个后缀名为.py 、 .c或.go的文件就是一个模块。</p>
<p>每一个模块需要有明确的功能。需要符合<em><strong>紧内聚，松耦合</strong></em>。模块切分的是否合理对于软件架构的稳定起着至关重要的左右。</p>
<p>切分模块的方法：</p>
<p>先区分数据类的模块和过程类的模块。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280041920.png"></p>
<p><strong>数据类的模块：</strong>主要是要完成<em><strong>对数据的封装</strong></em>。封装往往是通过模块内部变量或类的内部变量来实现的。</p>
<p><strong>过程类的模块：</strong>本身不含数据。过程类模块可以<em><strong>从文件中去读取一个数据</strong></em>，或者执行一些相关的操作。过程类模块可以调用其他数据类模块或过程类模块。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292131236.png"></p>
<p>编写程序时，我们需要注意减少模块间的耦合。<em><strong>减少模块间的耦合，有利于降低软件复杂性，明确接口关系</strong>。</em></p>
<h6 id="2-关于类和函数"><a href="#2-关于类和函数" class="headerlink" title="2. 关于类和函数"></a>2. 关于类和函数</h6><p>类和函数是两种不同的类型，有他们各自适用的范围。另外，遇见和类的成员变量无关的函数时，可以将该函数抽出来，作为一个独立的函数使用，这样便于未来的复用。</p>
<h6 id="3-关于面向对象"><a href="#3-关于面向对象" class="headerlink" title="3. 关于面向对象"></a>3. 关于面向对象</h6><p>面向对象，是一个优秀的编程方法和范式，但是真正理解的人并不多。</p>
<p>面向对象的<em><strong>本质是数据封装</strong></em>。这就要求我们在写程序的过程中应该<em><strong>从数据的角度开始想问题</strong></em>，而不是从执行过程的角度开始想问题。</p>
<p>我们需要注意一个普遍的错误认知，即：C语言是面向过程的，C++是面向对象的。</p>
<p>实际上，<strong><em>C语言是基于对象的，它和C++的区别主要是没有多态和继承</em>。</strong></p>
<p>C++是一个经常被滥用的语言。因为C++有太强的功能。</p>
<p>作为软件工程师，我们最重要的任务是去实现出我们所需要的功能，语言只是我们的工具。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280052593.png"></p>
<p>另外，在系统中，我们应该<em><strong>谨慎地使用多态和继承</strong></em>。如果一个系统中，类的继承超过三层，那么这个系统的复杂度便很难把握。</p>
<p>有这样一个悖论：很好的继承模型是基于对需求的准确把握，而在我们在初始设计阶段往往对需求理解的不透彻。系统在初始阶段可能只是一个很简单的原型，然后通过不断地迭代完善，才逐步发展起来变好的。</p>
<h6 id="4-关于模块内部的组成"><a href="#4-关于模块内部的组成" class="headerlink" title="4. 关于模块内部的组成"></a>4. 关于模块内部的组成</h6><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280051076.png"></p>
<p>一个模块，比如.py、.c或.go这样一个模块，它的内部组成主要是：在文件头中，需要对模块的功能进行简要说明。需要把文件的修改历史写清楚，包括修改时间、修改人和修改内容。在模块内，内容的顺序尽量保持一致，以方便未来对内容的搜索查询。</p>
<h6 id="5-关于函数"><a href="#5-关于函数" class="headerlink" title="5. 关于函数"></a>5. 关于函数</h6><p>函数的切分同样是非常重要的。对于一个函数来说，要有明确的单一功能。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280051088.png"></p>
<p>函数描述三要素包括<em><strong>功能、传入参数和返回值</strong></em>。</p>
<ol>
<li>功能描述是指描述这个函数是做什么的、实现了哪些功能。</li>
<li> 传入参数描述是指描述这个函数中传入参数的含义和限制条件。</li>
<li>返回值描述是指描述这个函数中返回值都有哪些可能性。</li>
</ol>
<p><em><strong>函数的规模要足够的短小</strong></em>，这是写好程序的秘诀之一。bug往往出现在那些非常长的函数里。</p>
<p>在函数头中，需要对函数的语义做出清晰和准确的说明。我们需要<em><strong>注意函数的返回值</strong></em>。在写函数时，要判断函数的语义，确定返回值的类型。</p>
<p><strong>基于函数的语义，函数的返回值有三种类型。</strong></p>
<p><em><strong>第一种类型</strong></em>：在“逻辑判断型”函数中，返回布尔类型的值——True或False，表示“真”或“假”。</p>
<p><em><strong>第二种类型</strong>：</em>在“操作型”函数中，作为一个动作，返回成功或失败的结果——SUCCESS或ERROR。</p>
<p><em><strong>第三种类型</strong>：</em>在“获取数据型”函数中，返回一个“数据”，或者返回“无数据/获取数据失败”。</p>
<p><em><strong>以“单入口、单出口”的方式书写</strong></em>的方式能够比较清晰地反映出函数的逻辑。尤其是在实现多线程的数据表中，推荐使用一个内部函数来实现“单入口单出口”的方式。</p>
<h6 id="6-关于代码注释"><a href="#6-关于代码注释" class="headerlink" title="6. 关于代码注释"></a>6. 关于代码注释</h6><p>要重视注释，书写注释要做到清晰明确。在编写程序的过程中，<strong><em>先写注释，后写代码</em>。</strong></p>
<h6 id="7-关于代码块"><a href="#7-关于代码块" class="headerlink" title="7. 关于代码块"></a>7. 关于代码块</h6><p>代码块的讨论范围是在一个函数内的代码实现。书写代码块的思路是<em><strong>先把代码中的段落分清楚</strong></em>。文章有段落，代码同样有段落。代码的段落背后表达的是我们对于代码的逻辑理解。包括<em><strong>代码的层次、段落划分、逻辑</strong></em>。代码中的空行或空格是帮助我们表达代码逻辑的，并非可有可无。好的代码可以使人在观看时做过一眼明了。</p>
<h6 id="8-关于命名"><a href="#8-关于命名" class="headerlink" title="8. 关于命名"></a>8. 关于命名</h6><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280053731.png"></p>
<p>命名包括系统命名、子系统命名、模块命名、函数命名、变量命名、常量命名等。</p>
<p>我们要清楚命名的重要性。<strong>命名重要的主要原因为：</strong></p>
<p>一是“望名生义”是人的自然反应。不准确的命名会使人产生误导。</p>
<p>二是概念是建立模型的出发点。好的命名是系统设计的基础。</p>
<p>命名中普遍存在的问题有：</p>
<p>一是名字中不携带任何信息。</p>
<p>二是名字携带的信息是错误的。</p>
<p>命名<strong><em>关系着代码的可读性</em>，</strong>需要仔细思考。<em><strong>命名的基本要求是准确、易懂。</strong></em>提高代码命名可读性的方式之一是：<em><strong>在名字的格式中加入下划线、驼峰等。</strong></em></p>
<h6 id="9-关于系统的运营"><a href="#9-关于系统的运营" class="headerlink" title="9. 关于系统的运营"></a>9. 关于系统的运营</h6><p>在互联网时代，系统非常依赖运营。并不是我们把代码写完调试通了就可以。</p>
<p>在系统运营过程中，<strong><em>代码的可监测性非常重要</em>。</strong>很多程序都是通过线上的不断运行、不断监测、不断优化而迭代完善的，所以我们在编写代码的过程中，要注意尽可能多地暴露出可监控接口。</p>
<p>对于一个系统来说，<strong><em>数据和功能同等重要</em>。</strong></p>
<p>数据收集很重要，数据量够大才能知道这个项目或这个系统的具体收益。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280056080.png"></p>
<p>关于系统的运营，我们在设计和编码阶段就需要考虑。即：在设计和编码阶段，提供足够的状态记录，提供方便的对外接口。</p>
<h3 id="1-5-怎样修炼成为优秀的软件工程师"><a href="#1-5-怎样修炼成为优秀的软件工程师" class="headerlink" title="1.5 怎样修炼成为优秀的软件工程师"></a>1.5 怎样修炼成为优秀的软件工程师</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280057161.png"></p>
<p>通常人们在判断一名软件工程师的水平时，都会用工作时间、代码量、学历、曾就职的公司等等这类外部因素作为评判标准。</p>
<p>修炼成为优秀的软件工程师，<strong>重要的因素有三点：</strong></p>
<ol>
<li>学习-思考-实践</li>
<li>知识-方法-精神</li>
<li>基础知识是根本</li>
</ol>
<h4 id="1-5-1-学习-思考-实践"><a href="#1-5-1-学习-思考-实践" class="headerlink" title="1.5.1 学习-思考-实践"></a>1.5.1 <strong>学习-思考-实践</strong></h4><h5 id="（1）多学习"><a href="#（1）多学习" class="headerlink" title="（1）多学习"></a><strong>（1）多学习</strong></h5><p>软件编写的历史已经超过半个世纪，有太多的经验可以借鉴学习。要不断的学习进步。</p>
<h5 id="（2）多思考"><a href="#（2）多思考" class="headerlink" title="（2）多思考"></a><strong>（2）多思考</strong></h5><p>学而不思则罔，思而不学则殆。对于做过的项目要去深入思考，复盘写心得。</p>
<h5 id="（3）多实践"><a href="#（3）多实践" class="headerlink" title="（3）多实践"></a><strong>（3）多实践</strong></h5><p>要做到知行合一，我们大部分的心得和成长其实是来自于实践中的经历。在学习和思考的基础之上，要多做项目，把学到的理论运用到真正的工作中。</p>
<h4 id="1-5-2-知识-方法-精神"><a href="#1-5-2-知识-方法-精神" class="headerlink" title="1.5.2 知识-方法-精神"></a>1.5.2 知识-方法-精神</h4><p>互联网的发展日新月异，对于软件开发来说，知识永远在增加，所以在变化快速的知识世界中，<strong><em>最好的方式是找到方法</em>。</strong></p>
<p>方法就是用来分析问题和解决问题的。虽然说起来简单，但是适合每个人的方法都需要自己去寻找和总结。</p>
<p>在大多数人的成长过程中，并不单单只是鲜花和掌声，更多的时候是在和困难荆棘做斗争。而真正能做出成就的人，都有着远大理想和宏伟志向。所以，光有知识和方法往往是不够的，还需要有精神作为支撑。</p>
<p>几个精神理念：</p>
<ol>
<li><strong>自由精神、独立思想。</strong></li>
</ol>
<p>人一定要有自己的思考。不要人云亦云，不要随波逐流。</p>
<ol start="2">
<li><strong>对完美的不懈追求。</strong></li>
</ol>
<p>不要做到一定程度就满意了，而是要去不断的追求一个更好的结果。</p>
<h4 id="1-5-3-基础知识是根本"><a href="#1-5-3-基础知识是根本" class="headerlink" title="1.5.3 基础知识是根本"></a>1.5.3 基础知识是根本</h4><p>唐朝著名宰相魏征曾经对唐太宗说过：“求木之长者，必固其根本；欲流之远者，必浚其泉源”，充分表达了基础乃治学之根本。</p>
<p>对于一个软件工程师来说，需要掌握的基础是非常全面的。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111280058449.png"></p>
<p>包括数据结构、算法、操作系统、系统结构、计算机网络。包括软件工程、编程思想。包括逻辑思维能力、归纳总结能力、表达能力。还包括研究能力、分析问题、解决问题的能力等。这些基础的建立，至少也要5~8年的时间。</p>
<h2 id="2-Mini-Spider实践"><a href="#2-Mini-Spider实践" class="headerlink" title="2 Mini-Spider实践"></a>2 Mini-Spider实践</h2><h3 id="2-1-多线程编程"><a href="#2-1-多线程编程" class="headerlink" title="2.1 多线程编程"></a>2.1 多线程编程</h3><h4 id="2-1-1-数据互斥访问"><a href="#2-1-1-数据互斥访问" class="headerlink" title="2.1.1 数据互斥访问"></a>2.1.1 数据互斥访问</h4><p>多线程中数据互斥访问的情况非常常见，在真实生产的环境中，经常有开发人员会将一张表的“添加”和“判断是否存在”分为两个接口，这是一种非常常见的错误。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281424954.png"></p>
<p>以图中的代码为例，左边的代码是正确的写法，<strong>将添加和判断写进一个函数中</strong>。右边的代码是典型的错误代码，编写了两个函数，分别是添加和判断函数。</p>
<p>事实上，这种将添加和判断写进一个函数并且运行的实现机制是同8086的底层指令集支持密不可分的。</p>
<h4 id="2-1-2-临界区的注意事项"><a href="#2-1-2-临界区的注意事项" class="headerlink" title="2.1.2 临界区的注意事项"></a>2.1.2 临界区的注意事项</h4><p>在代码中，<strong>有锁来保护的区域被称为临界区</strong>。以图中代码为例，临界区为self.lock.acquire()和self.lock.release()两句话之间的区域。在使用临界区的时候要注意，不要把耗费时间的操作放在临界区内执行。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281429165.png"></p>
<p>很多开发人员在编写多线程的时候会将耗费时间很多的逻辑放入临界区内，这样会导致无法发挥多线程对于硬件资源最大化利用的优势。</p>
<h4 id="2-1-3-I-O操作的处理"><a href="#2-1-3-I-O操作的处理" class="headerlink" title="2.1.3 I/O操作的处理"></a>2.1.3 I/O操作的处理</h4><p>在多线程编程中还要注意对于I/O操作的处理。首先在编写代码的时候要注意不能出现无捕捉的exception，以图中最左边的代码为例，如果不对异常进行捕捉，那么一旦出现问题就不会执行self.lock.release()语句，进而导致死锁的发生。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281444010.png"></p>
<p>其次，因为异常处理是非常消耗资源的，所以我们也不能像图中中间的代码一样，将异常放在临界区内，要像最右边的代码一样处理。</p>
<h3 id="2-2-细节处理"><a href="#2-2-细节处理" class="headerlink" title="2.2 细节处理"></a>2.2 细节处理</h3><h4 id="2-2-1-种子信息的读取"><a href="#2-2-1-种子信息的读取" class="headerlink" title="2.2.1 种子信息的读取"></a>2.2.1 种子信息的读取</h4><p>很多开发人员会将种子信息读取的逻辑和其他逻辑耦合在一起，这样是错误的。以图中代码为例，虽然通过_get_seeds函数直接读取文件中的信息并没有书写错误，但是如果后续的开发中文件的格式发生了变化，那就需要重新回来修改这部分的代码。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281445680.png"></p>
<p>通过上述代码可以发现，模块划分和逻辑的复杂程度是没有关系的。即使是逻辑简单的代码，如果没有做好模块划分，也会变得难于维护。</p>
<h4 id="2-2-2-程序优雅退出"><a href="#2-2-2-程序优雅退出" class="headerlink" title="2.2.2 程序优雅退出"></a>2.2.2 程序优雅退出</h4><p>在真实应用中，很多开发人员在实现程序退出功能的时候使用了非常复杂的机制，导致后期维护难度较高。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281446653.png"></p>
<p>在实际应用中可以使用python系统库中关于队列的task_done()和join()的机制。</p>
<p>以图中代码为例，左边的代码就是使用了task_done()，中间的代码是主程序中的一种常规逻辑使用。右边是对中间主程序的一种优化，增加了spider.wait()，让整个逻辑可读性更强，更容易被理解。</p>
<h4 id="2-2-3-爬虫的主逻辑编码"><a href="#2-2-3-爬虫的主逻辑编码" class="headerlink" title="2.2.3 爬虫的主逻辑编码"></a>2.2.3 爬虫的主逻辑编码</h4><p>很多开发人员编写的主逻辑非常的复杂且难懂。事实上，图中的代码就是一个爬虫的主逻辑的所有代码。可以看到，里面包含了六个步骤。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281448571.png"></p>
<p>第一步，从队列中拿到任务。</p>
<p>第二步，读取内容。如果读取失败，则重新读取。如果读取成功，则执行第三步。</p>
<p>第三步，存储数据。</p>
<p>第四步，检查数据深度。</p>
<p>第五步，如果数据深度不足，就进一步解析，并且放到队列中。</p>
<p>第六步，结束任务。</p>
<h2 id="3-代码检查规则背景及总体介绍"><a href="#3-代码检查规则背景及总体介绍" class="headerlink" title="3 代码检查规则背景及总体介绍"></a>3 代码检查规则背景及总体介绍</h2><h3 id="3-1-代码检查的意义"><a href="#3-1-代码检查的意义" class="headerlink" title="3.1 代码检查的意义"></a>3.1 代码检查的意义</h3><ol>
<li>提高代码可读性，统一规范，方便他人维护，长远来看符合公司内部开源战略。</li>
<li>帮助发现代码缺陷，弥补人工代码评审的疏漏，节省代码评审的时间与成本。</li>
<li>有助于提前发现问题，节约时间成本，降低缺陷修复成本。</li>
<li>促进公司编码规范的落地，在规范制定后借助工具进行准入检查。</li>
<li>提升编码规范的可运营性，针对反馈较多的不合理规范进行调整更新。</li>
</ol>
<h3 id="3-2-代码检查场景及工具"><a href="#3-2-代码检查场景及工具" class="headerlink" title="3.2 代码检查场景及工具"></a>3.2 代码检查场景及工具</h3><h4 id="3-2-1-代码检查场景"><a href="#3-2-1-代码检查场景" class="headerlink" title="3.2.1 代码检查场景"></a>3.2.1 代码检查场景</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281541973.png"></p>
<p>首先是<strong>本地研发环节</strong>，借助客户端工具，在push发起评审之前进行检查。</p>
<p>若本地代码扫描没有出现问题，就进入第二个环节：<strong>代码准入环节，即Code Review</strong>，这一环节进行增量检查，属于公司强制要求。</p>
<p>第三个环节：<strong>持续集成环节</strong>，当代码合入到代码库之后，进行全量检查，业务线根据自身需求来配置。</p>
<h4 id="3-2-2-代码检查工具与服务"><a href="#3-2-2-代码检查工具与服务" class="headerlink" title="3.2.2 代码检查工具与服务"></a>3.2.2 代码检查工具与服务</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281543538.png"></p>
<p>代码检查的产品，客户端、SCM(icode)、CI(Agile)之间具有交互性，共同构成整个代码检查环节。</p>
<h4 id="3-2-3-代码检查覆盖范围"><a href="#3-2-3-代码检查覆盖范围" class="headerlink" title="3.2.3 代码检查覆盖范围"></a>3.2.3 代码检查覆盖范围</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281544909.png"></p>
<p>在<strong>覆盖语言</strong>方面，代码检查目前已经覆盖了包括C++，Java/android, PHP, Python, Go, JS, OC, Kotlin在内的几乎所有主流语言。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281544915.png"></p>
<p>在<strong>检查维度</strong>方面，代码检查包括编码规范 代码缺陷，开源框架引用安全检查，可维护性(MI)。</p>
<h4 id="3-2-4-代码检查速度"><a href="#3-2-4-代码检查速度" class="headerlink" title="3.2.4 代码检查速度"></a>3.2.4 代码检查速度</h4><p>编码规范：只扫描变更文件，检查代码变更行是否符合规范，速度较快。</p>
<p>缺陷检查：需考虑文件依赖、函数调用关系、代码上下文等，相对耗时。</p>
<h3 id="3-3-代码检查规则分级"><a href="#3-3-代码检查规则分级" class="headerlink" title="3.3 代码检查规则分级"></a>3.3 代码检查规则分级</h3><h4 id="3-3-1-规则等级梳理"><a href="#3-3-1-规则等级梳理" class="headerlink" title="3.3.1 规则等级梳理"></a>3.3.1 规则等级梳理</h4><p>Code Review阶段，所有维度扫描出的问题可以分为以下3个等级：</p>
<ol>
<li><p>Error：属于需要强制解决的类型，影响代码合入，应视具体情况不同采取修复、临时豁免、标记误报等措施及时处理；</p>
</li>
<li><p>Warning：非强制解决类型，不影响代码含入，很可能存在风险，应尽量修复；</p>
</li>
<li><p>Advice：非强制解决类型，级别相对较低，不影响代码含入，可以选择性修复。</p>
</li>
</ol>
<h4 id="3-3-2-机检任务统一"><a href="#3-3-2-机检任务统一" class="headerlink" title="3.3.2 机检任务统一"></a>3.3.2 机检任务统一</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281548620.png"></p>
<h4 id="3-3-3-评审页行间提示"><a href="#3-3-3-评审页行间提示" class="headerlink" title="3.3.3 评审页行间提示"></a>3.3.3 评审页行间提示</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550018.png"></p>
<h4 id="3-3-4-针对豁免、误报、咨询的说明"><a href="#3-3-4-针对豁免、误报、咨询的说明" class="headerlink" title="3.3.4 针对豁免、误报、咨询的说明"></a>3.3.4 针对豁免、误报、咨询的说明</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550799.png"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550899.png"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281550116.png"></p>
<h2 id="4-代码检查规则：Python语言案例详解"><a href="#4-代码检查规则：Python语言案例详解" class="headerlink" title="4 代码检查规则：Python语言案例详解"></a>4 代码检查规则：Python语言案例详解</h2><h3 id="4-1-Python的代码检查规则"><a href="#4-1-Python的代码检查规则" class="headerlink" title="4.1 Python的代码检查规则"></a>4.1 Python的代码检查规则</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281552034.png"></p>
<p>Python代码检查规则主要分为四个大类，分别是<strong>代码风格规范、引用规范、定义规范和异常处理规范</strong>。</p>
<h4 id="4-1-1-代码风格规范"><a href="#4-1-1-代码风格规范" class="headerlink" title="4.1.1 代码风格规范"></a>4.1.1 代码风格规范</h4><h5 id="（1）程序规模规范："><a href="#（1）程序规模规范：" class="headerlink" title="（1）程序规模规范："></a><strong>（1）程序规模规范：</strong></h5><ol>
<li><p>每行不得超过 120 个字符。</p>
</li>
<li><p>定义的函数长度不得超过 120 行。</p>
</li>
</ol>
<p>这意味着，在编写代码时，需要时刻注意自己的程序规模，避免冗余，确保写出简洁而高效的代码。</p>
<h5 id="（2）语句规范"><a href="#（2）语句规范" class="headerlink" title="（2）语句规范"></a><strong>（2）语句规范</strong></h5><p>因为Python与其他语言不同，可以不需要明确的标识符表示语句的结尾，所以规定：</p>
<ol start="3">
<li><p>禁止以分号结束语句。</p>
</li>
<li><p>在任何情况下，一行只能写一条语句。</p>
</li>
</ol>
<h5 id="（3）括号使用规范"><a href="#（3）括号使用规范" class="headerlink" title="（3）括号使用规范"></a><strong>（3）括号使用规范</strong></h5><ol start="5">
<li>除非用于明确算术表达式优先级、元组或者隐式行连接，否则尽量避免冗余的括号。</li>
</ol>
<h5 id="（4）缩进规范"><a href="#（4）缩进规范" class="headerlink" title="（4）缩进规范"></a><strong>（4）缩进规范</strong></h5><ol start="6">
<li>禁止使用Tab进行缩进，而统一使用4个空格进行缩进</li>
</ol>
<p>需要将单行内容拆成多行写时规定：</p>
<ol start="7">
<li>与首行保持对齐；或者首行留空，从第二行起统一缩进4个空格。</li>
</ol>
<h5 id="（5）空行规范"><a href="#（5）空行规范" class="headerlink" title="（5）空行规范"></a><strong>（5）空行规范</strong></h5><ol start="8">
<li>文件级定义（类或全局函数）之间，相隔两个空行；类方法之间，相隔一个空行。</li>
</ol>
<h5 id="（6）空格规范"><a href="#（6）空格规范" class="headerlink" title="（6）空格规范"></a><strong>（6）空格规范</strong></h5><ol start="9">
<li><p>括号之内均不添加空格。</p>
</li>
<li><p>参数列表、索引或切片的左括号前不应加空格。</p>
</li>
<li><p>逗号、分号、冒号之前均不添加空格，而是在它们之后添加一个空格。</p>
</li>
<li><p>所有二元运算符前后各加一个空格。</p>
</li>
<li><p>关键字参数或参数默认值的等号前后不加空格。</p>
</li>
</ol>
<h5 id="（7）注释规范"><a href="#（7）注释规范" class="headerlink" title="（7）注释规范"></a><strong>（7）注释规范</strong></h5><ol start="14">
<li>每个文件都必须有文件声明，每个文件声明至少必须包括以下三个方面的信息：版权声明、功能和用途介绍、修改人及联系方式。</li>
</ol>
<p>另外在使用文档字符串（docstirng）进行注释时，规定：</p>
<ol start="15">
<li><p>使用docstring描述模块、函数、类和类方法接口时，docstring必须用三个双引号括起来。</p>
</li>
<li><p>对外接口部分必须使用docstring描述，内部接口视情况自行决定是否写docstring。</p>
</li>
<li><p>接口的docstring描述内容至少包括以下三个方面的信息：功能简介、参数、返回值。如果可能抛出异常，必须特别注明。</p>
</li>
</ol>
<h4 id="4-1-2-引用规范"><a href="#4-1-2-引用规范" class="headerlink" title="4.1.2 引用规范"></a>4.1.2 引用规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281600533.png"></p>
<p><strong>严格而具体的规定：</strong></p>
<ol>
<li>禁止使用 from……import…… 句式直接导入类或函数，而应在导入库后再行调用。</li>
<li>每行只导入一个库。</li>
<li>按标准库、第三方库、应用程序自有库的顺序排列import，三个部分之间分别留一个空行。</li>
</ol>
<h4 id="4-1-3-定义规范"><a href="#4-1-3-定义规范" class="headerlink" title="4.1.3 定义规范"></a>4.1.3 定义规范</h4><p><strong>（1）在变量定义方面，我们有强制的规范规定：</strong></p>
<ol>
<li>局部变量使用全小写字母，单词间使用下划线分隔。</li>
<li>定义的全局变量必须写在文件头部。</li>
<li>常量使用全大写字母，单词间使用下划线分隔</li>
</ol>
<p><strong>（2）函数的定义规范主要体现在函数的返回值以及默认参数的定义上。</strong></p>
<p>为提高代码可读性，对于函数的返回值，规范要求为：</p>
<ol>
<li>函数返回值必须小于或等于3个。若返回值大于3个，则必须通过各种具名的形式进行包装。</li>
</ol>
<p>为了保障函数的运行效率以及降低后期维护和纠错的成本，对于函数默认参数的定义有如下要求：</p>
<ol start="2">
<li>仅可使用以下基本类型的常量或字面常量作为默认参数：整数、bool、浮点数、字符串、None。</li>
</ol>
<p><strong>（3）类定义的规范包括了四个方面的内容：</strong></p>
<ol>
<li>类的命名使用首字母大写的驼峰式命名法。</li>
<li>对于类定义的成员：protected成员使用单下划线前缀；private成员使用双下划线前缀。</li>
<li>如果一个类没有基类，必须继承自object类。</li>
<li>类构造函数应尽量简单，不能包含可能失败或过于复杂的操作。</li>
</ol>
<h4 id="4-1-4-异常处理规范"><a href="#4-1-4-异常处理规范" class="headerlink" title="4.1.4 异常处理规范"></a>4.1.4 异常处理规范</h4><p>在代码编写中应该<strong>尽量避免出现代码异常状态</strong>，然而错误有时在所难免，对于这些异常状态的处理，有着明确的规范要求：</p>
<ol>
<li>禁止使用双参数形式或字符串形式的语法抛出异常。</li>
<li>如需自定义异常，应在模块内定义名为 Error 的异常基类。并且，该基类必须继承自 Exception 。其他异常均由该基类派生而来。</li>
<li>除非重新抛出异常，禁止使用 except：语句捕获所有异常， 一般情况下，应使except……：语句捕获具体的异常。</li>
<li>捕捉异常时，应当使用 as 语法，禁止使用逗号语法。</li>
</ol>
<h3 id="4-2-Python编码惯例"><a href="#4-2-Python编码惯例" class="headerlink" title="4.2 Python编码惯例"></a>4.2 Python编码惯例</h3><h4 id="4-2-1-让模块既可被导入又可被执行"><a href="#4-2-1-让模块既可被导入又可被执行" class="headerlink" title="4.2.1 让模块既可被导入又可被执行"></a>4.2.1 让模块既可被导入又可被执行</h4><p>python不同于编译型语言，而<strong>属于脚本语言</strong>，是动态的逐行解释运行，没有统一的程序入口。所以，为了方便模块之间的相互导入，我们通常<strong>自定义一个 main 函数，并使用一个if 语句</strong>， if 内置变量 <strong>name</strong> == ‘__main__’ ，在这个if 条件下，再去执行 main函数。这样，我们就能够实现，让模块既可被导入又可执行。</p>
<h4 id="4-2-2-in运算符的使用"><a href="#4-2-2-in运算符的使用" class="headerlink" title="4.2.2 in运算符的使用"></a>4.2.2 in运算符的使用</h4><p>in一种简洁而高效的运算符，很多时候，合理的使用in运算符，可以<strong>代替大量的重复判断过程</strong>，降低时间复杂度，提高代码的运行效率。</p>
<h4 id="4-2-3-不使用临时变量交换两个值"><a href="#4-2-3-不使用临时变量交换两个值" class="headerlink" title="4.2.3 不使用临时变量交换两个值"></a>4.2.3 不使用临时变量交换两个值</h4><p>Python有更简洁而高效的语句可以实现交换两个值的操作，并<strong>无必要引入临时变量</strong>来交换两个值。</p>
<h4 id="4-2-4-用序列构建字符串"><a href="#4-2-4-用序列构建字符串" class="headerlink" title="4.2.4 用序列构建字符串"></a>4.2.4 用序列构建字符串</h4><p>对于一个字符串列表、元组等，可以用序列来构建字符串，<strong>利用一个空字符串和join函数</strong>，就可以避免重复，高效完成相应字符串的构建。</p>
<h1 id="三、百度高效研发实战训练营Step3"><a href="#三、百度高效研发实战训练营Step3" class="headerlink" title="三、百度高效研发实战训练营Step3"></a>三、百度高效研发实战训练营Step3</h1><h2 id="1-质量意识"><a href="#1-质量意识" class="headerlink" title="1 质量意识"></a>1 质量意识</h2><h3 id="1-1-质量的基本概念"><a href="#1-1-质量的基本概念" class="headerlink" title="1.1 质量的基本概念"></a>1.1 质量的基本概念</h3><h4 id="1-1-1-质量重要性的认识"><a href="#1-1-1-质量重要性的认识" class="headerlink" title="1.1.1 质量重要性的认识"></a>1.1.1 质量重要性的认识</h4><p>随着技术更新，市场竞争的加剧，质量问题成为困扰不少企业的一大难题，也给一些企业造成了巨大的损失，这就使得项目质量的重要性不断凸显。</p>
<p>通过对于这些失败案例的分析不难发现，项目的质量保证是一个需要<strong>项目全体成员参与</strong>的重要工作，只有在项目团队的共同努力下，才能有效保证项目的质量，为企业和社会创造价值。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281614025.png"></p>
<p>项目管理三要素为<strong>质量、时间、成本</strong>，三个要素缺一不可、相互制约，一味追求某一要素的做法是不明智的。一个成功的项目必然是在三者的取舍间达成了一个平衡。</p>
<h4 id="1-1-2-质量保证和测试的关系"><a href="#1-1-2-质量保证和测试的关系" class="headerlink" title="1.1.2 质量保证和测试的关系"></a>1.1.2 质量保证和测试的关系</h4><p>质量问题有很多种，常见的有代码缺陷、产品缺陷、Bug、用户体验差、性能差、服务不稳、安全问题、可兼容性差等。我们经常通过测试来发现问题，并将发现的问题分<strong>功能性测试类问题和用户体验评估类问题。</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281615870.png"></p>
<p>测试工作是质量保证工作中的重要一环，但是我们应该认识到，质量保证工作不能只依靠测试的反馈，而应该贯穿项目开发的整个过程。</p>
<h4 id="1-1-3-Bug的基本认识"><a href="#1-1-3-Bug的基本认识" class="headerlink" title="1.1.3 Bug的基本认识"></a>1.1.3 Bug的基本认识</h4><p><strong>Bug</strong>是程序中的缺陷和问题，<strong>属于功能性测试类问题的范畴</strong>， Bug是一种很常见的质量问题，也是我们在项目开发中应该尽量减少或避免的质量问题。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281617228.png"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281618840.png"></p>
<p>Bug的修复有一套完整的规定流程。</p>
<p>首先，测试人员或者用户发现Bug后，将其置为<strong>激活状态</strong>；开发人员收到激活状态的Bug后，对其进行修复，修复过程中， Bug状态为<strong>处理中</strong>；修复完成后，开发人员将其置为<strong>解决状态</strong>；测试人员再对其进行<strong>验证</strong>，若通过，则将其关闭，否则，重新激活Bug即重启状态，交予开发人员继续修复，直至验证通过。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111292129042.png"></p>
<p>从这一流程可以看到，<strong>Bug有五种状态，Open（激活）、In Process（处理中）、Resolved（解决）、closed（关闭）、Reopen（重启）</strong>。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281621054.png"></p>
<p>Bug生命周期有一定规律性。以传统软件中的瀑布模型举例，85%的问题在项目初期的编码阶段引入，在后期测试阶段，发现Bug的数量会逐渐增多，与之对应的修复成本也会急剧增加。可见，降低<strong>修复成本最有效的方式，就是在Bug引入的阶段就及时发现并修复Bug。</strong></p>
<h3 id="1-2-Bug提交方法"><a href="#1-2-Bug提交方法" class="headerlink" title="1.2 Bug提交方法"></a>1.2 Bug提交方法</h3><blockquote>
<p>Bug提交需要反馈渠道，Bug的反馈渠道分为内部用户反馈渠道和外部用户反馈渠道两种。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281623796.png"></p>
<ol>
<li>内部用户反馈渠道包括：产品Icafe空间、产品论坛、Bugs邮件组、Bugs平台。</li>
<li>外部用户反馈渠道包括：产品自身反馈渠道和产品接入反馈平台。</li>
</ol>
</blockquote>
<p><strong>Bug的提交有严格的格式要求，提交的Bug反馈应包括以下七个方面的内容：</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281624518.png"></p>
<p>正确提交Bug能确保负责人能够清晰了解问题，直接进行数据挖掘，找到Bug所有的属性，便于后续维护工作的开展。</p>
<h3 id="1-3-质量保证在项目各阶段的实现"><a href="#1-3-质量保证在项目各阶段的实现" class="headerlink" title="1.3 质量保证在项目各阶段的实现"></a>1.3 质量保证在项目各阶段的实现</h3><p>质量的保证不能仅仅依靠测试人员，而是需要贯穿项目的各个阶段。</p>
<p>Bug的发现和修复是项目质量保证的一个重要方面，但质量保证工作绝不仅仅是修复Bug这么简单。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281626934.png"></p>
<p>项目的开发整体路径包括：需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、上线阶段以及线上阶段。</p>
<p>在一个项目开发的各个不同阶段，质量保证工作的要求和思路均有一定的不同，下面我们来展现质量保证工作在各个阶段的具体实现。</p>
<h4 id="1-3-1-需求与设计阶段的质量保证工作"><a href="#1-3-1-需求与设计阶段的质量保证工作" class="headerlink" title="1.3.1 需求与设计阶段的质量保证工作"></a>1.3.1 需求与设计阶段的质量保证工作</h4><p>需求与设计阶段是项目开始的重要阶段，只有从客户真正的需求出发，才能设计出真正令客户满意的产品。</p>
<p>在一阶段，质量保证工作的关键点有三：</p>
<ol>
<li><p><strong>需求评审：</strong>站在用户的角度思考和挖掘需求，是设计和开发的前提性条件。</p>
</li>
<li><p><strong>需求的变更管理：</strong>用户的需求始终在改变，建立一套完善机制去及时适应需求的变更十分重要。</p>
</li>
<li><p><strong>设计评审：</strong>通过评审需求的可行性和设计的相关风险，可以极大降低设计风险，避免人力浪费。</p>
</li>
</ol>
<h4 id="1-3-2-开发与测试阶段的质量保证工作"><a href="#1-3-2-开发与测试阶段的质量保证工作" class="headerlink" title="1.3.2 开发与测试阶段的质量保证工作"></a>1.3.2 开发与测试阶段的质量保证工作</h4><p>在开发阶段，质量保证工作最重要的有两点：<strong>单元测试和代码评审。</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281632782.png"></p>
<blockquote>
<p>单元测试的作用很多，主要有：</p>
<p>（1） 调试代码，确保代码实时可编译。</p>
<p>（2） 验证逻辑，减少代码中的Bug。</p>
<p>（3） 作为一个最细粒度回归测试，实时反馈代码的质量。</p>
</blockquote>
<blockquote>
<p>代码评审也同样十分重要，它的作用主要为：</p>
<p>（1） 保持代码风格的一致和可读性，利于贯彻编程规范。</p>
<p>（2） 提高代码质量，减少Bug。</p>
<p>（3） 促进互相交流学习，提升团队的整体研发能力，进而提高企业的整体竞争力。</p>
</blockquote>
<p>而在测试阶段，我们的主要任务是<strong>测试功能性测试类问题。</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281632723.png"></p>
<blockquote>
<p>测试阶段一般流程为：</p>
<p>第一步：<strong>撰写测试方案</strong>。由测试人员编写方案并提交开发人员评审。</p>
<p>第二步：<strong>进行单元测试</strong>。由开发人员编写用例，并交给测试人员评审。</p>
<p>第三步：<strong>进行功能性测试</strong>。由测试人员设计和编写用例。</p>
<p>第四步：<strong>进行性能/压力等测试</strong>。测试人员根据项目情况决定是否进行。</p>
<p>第五步：<strong>自动化和持续集成</strong>。将测试自动化，并把流程加入持续集成。</p>
<p>第六步：<strong>撰写测试报告</strong>。测试人员要在大版本时编写测试报告。</p>
</blockquote>
<p>测试环节涉及很多的内容，包括了：</p>
<p>（1）测试方案。</p>
<p>（2）自动化/持续集成。</p>
<p>（3）测试报告。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281634364.png"></p>
<p>在这一环节中，<strong>撰写测试方案是对该阶段工作的整体规划。</strong>测试方案描绘了测试和质量保证的各种工作，规划了如何组织测试，方案中包括了：质量目标、风险评估、测试范围、测试优先级、测试方法、测试流程、测试计划和测试设计的内容。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281634848.png"></p>
<p><strong>常用的测试方法有</strong>：黑盒/白盒、静态测试/动态测试、自动化测试/手工测试、验收测试/α测试/β测试、单元测试/模块测试/集成测试/联调测试/系统测试、功能性测试/性能测试/压力测试/异常测试/安全测试、接口测试/用户场景测试、回归测试、探索性测试等。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281635604.png"></p>
<p>不同的测试方法有不同的特点和擅长解决的问题。测试的侧重点不同，发现的问题也不同。我们需要根据测试方案，来选择合适的测试方法，提高测试的效率。为此，在前期的测试和设计方案评审时要及早发现问题，避免无效劳动，提高测试效率。</p>
<p>同样，自动化和持续集成也是有效提高测试效率的方法。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281635791.png"></p>
<p><strong>自动化包括流程自动化和测试自动化。</strong>流程自动化包括编译、部署、发布、回滚、上线和测试阶段。测试自动化可以降低成本并保证测试结果，降低风险。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281636766.png"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281637773.png"></p>
<p>而基于自动化，我们可以搭建串联工作流，即持续集成，可以将代码提交、编译、模块测试、部署、系统测试、发布这一循环性流程集成在一起，从而提高工作效率，保证持续的质量反馈。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281637103.png"></p>
<p>测试完成后需要撰写详细的测试报告，以方便后期的持续维护和迭代，其内容包括：</p>
<p>测试结果、质量风险评估、质量评估、测试过程描述、缺陷分析、评估改进意见、测试版本/测试人员/测试时间。</p>
<h4 id="1-3-3-上线与线上阶段的质量保证工作"><a href="#1-3-3-上线与线上阶段的质量保证工作" class="headerlink" title="1.3.3 上线与线上阶段的质量保证工作"></a>1.3.3 上线与线上阶段的质量保证工作</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281638579.png" alt="image-20211128163800434"></p>
<p><strong>上线阶段包括上线过程和回滚过程。</strong></p>
<p>上线阶段的上线方案需要经过评审和测试，对于重点项目，还应有回滚方案和相应的评审和测试工作。</p>
<p>上线后，我们需要进行线上测试，常用的线上测试有三类：众包测试、用户反馈和业务监控、产品评测。</p>
<blockquote>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281641413.png"></p>
<p>（1）<strong>众包测试：</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281642738.png">众包测试的目的是使更多的用户参与测试，降低测试成本。众测服务分为四类：测试类（包括探索性测试、用例组合爆炸测试），产品体验（包括产品建议、Badcase收集）、评估评测（包括大数据量评估标注、降低成本）、用户调研（产品需求调研、用户反馈)。一个众测平台：<a target="_blank" rel="noopener" href="http://test.baidu.com/">http://test.baidu.com</a></p>
<p>（2）<strong>用户反馈和业务监控</strong>：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281642375.png">目的则是为了实现线上问题闭环，通过用户反馈和业务监控可以解决大部分的线上问题。步骤分为收集、分发、定位和解决。主要平台有反馈平台、Bugs平台和 Monitor平台。</p>
<p>（3）<strong>产品评测：</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281643572.png"></p>
<p>包括用户反馈分析、产品Bug分析、Top问题梳理和竞品对比分析。</p>
<p>→ <strong>用户反馈分析</strong>是指对用户反馈的问题进行分析。→ 产品Bug分析是指对产品的Bug进行分析，然后解决问题最大的Bug。</p>
<p>→ <strong>Top问题梳理</strong>是指，对问题进行梳理分类，解决最突出的问题。</p>
<p>→ <strong>竞品对比分析</strong>是指对自家产品和市场上同类型产品进行分析。</p>
</blockquote>
<p>从对各个阶段质量保证工作的分析中，我们不难看出，每一个阶段的质量保证工作都需要多方角色的共同参与。可见，项目的出色质量来源于<strong>每个环节的严格把控和每个成员的共同参与，这是团队质量意识的两大核心。</strong></p>
<h3 id="1-4-质量保证意识的4个核心内容"><a href="#1-4-质量保证意识的4个核心内容" class="headerlink" title="1.4 质量保证意识的4个核心内容"></a>1.4 质量保证意识的4个核心内容</h3><h4 id="1-4-1-质量保证工作存在于每一个环节"><a href="#1-4-1-质量保证工作存在于每一个环节" class="headerlink" title="1.4.1 质量保证工作存在于每一个环节"></a>1.4.1 质量保证工作存在于每一个环节</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647902.png"></p>
<h4 id="1-4-2-每一个成员都需要对质量负责"><a href="#1-4-2-每一个成员都需要对质量负责" class="headerlink" title="1.4.2 每一个成员都需要对质量负责"></a>1.4.2 每一个成员都需要对质量负责</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647522.png"></p>
<h4 id="1-4-3-测试是一种核心的质量保证工作"><a href="#1-4-3-测试是一种核心的质量保证工作" class="headerlink" title="1.4.3 测试是一种核心的质量保证工作"></a>1.4.3 测试是一种核心的质量保证工作</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281646302.png"></p>
<h4 id="1-4-4-尽早发现问题，尽早解决问题"><a href="#1-4-4-尽早发现问题，尽早解决问题" class="headerlink" title="1.4.4 尽早发现问题，尽早解决问题"></a>1.4.4 尽早发现问题，尽早解决问题</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281647888.png"></p>
<h2 id="2-代码单元测试总体介绍"><a href="#2-代码单元测试总体介绍" class="headerlink" title="2 代码单元测试总体介绍"></a>2 代码单元测试总体介绍</h2><h3 id="2-1-单元测试基础"><a href="#2-1-单元测试基础" class="headerlink" title="2.1 单元测试基础"></a>2.1 单元测试基础</h3><h4 id="2-1-1-单元测试的误区"><a href="#2-1-1-单元测试的误区" class="headerlink" title="2.1.1 单元测试的误区"></a>2.1.1 单元测试的误区</h4><p>单元测试存在一些认识上的误区，包括：</p>
<ol>
<li>开发单元测试代码的工作量大。</li>
<li>做单元测试不属于开发人员的职责。</li>
<li>代码正确率高，进行单元测试必要性不大。</li>
<li>后期有集成测试，前期进行单元测试必要性不大。</li>
<li>单元测试无法带来显著收益，效率不高。</li>
</ol>
<h4 id="2-1-2-单元测试的概念"><a href="#2-1-2-单元测试的概念" class="headerlink" title="2.1.2 单元测试的概念"></a>2.1.2 单元测试的概念</h4><p><em><strong>在维基百科中，单元测试的定义为：一段代码调用另一段代码，随后检验一些假设的正确性。</strong></em></p>
<p><em><strong>在百度百科中，单元测试是指对软件中的最小可测试单元进行检查和验证。</strong></em></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281653449.png"></p>
<p>那么我们不禁要问：一次编写的单元测试是否只是为了验证该次开发过程中对应的代码逻辑的正确性？</p>
<p>其实不然，单元测试不仅在于实现问题中的功能，优秀的单元测试作用长久，可以减少后续工作的负担，从而提升整体生产力。</p>
<h4 id="2-1-3-常见的单元测试问题"><a href="#2-1-3-常见的单元测试问题" class="headerlink" title="2.1.3 常见的单元测试问题"></a>2.1.3 常见的单元测试问题</h4><p>目前单元测试中存在一些常见的问题：</p>
<ol>
<li>使用System.out输出测试结果，依赖人去判断测试是否正确。</li>
<li>不使用Assert(断言)对测试结果进行判断。</li>
</ol>
<p><em>在以上两种情形都需要依赖人与电脑的交互来判断此case是否成功，人的工作量较大；**在实际的单元测试中，应当使用断言进行判断，使 case运行时自动输出结果。</em></p>
<ol start="3">
<li>没有边界检查。</li>
<li>多个测试分支放入一个单元测试方法中。</li>
</ol>
<p><em>这种情况会导致一旦出现运行失败时，难以判断出现错误的分支所在。</em></p>
<ol start="5">
<li>测试case环境相关（依赖已知库表、时间）。</li>
</ol>
<p><em>对于这种情况，应当做出修改，使输入参数为确定的值。</em></p>
<ol start="6">
<li>测试方法执行有先后顺序。</li>
</ol>
<p><em>在实际测试过程中，由于不同的用于运行单元测试的测试框架对于case执行顺序有自己的行为，故单元测试实际执行顺序存在不确定性。</em></p>
<h4 id="2-1-4-优秀的单元测试"><a href="#2-1-4-优秀的单元测试" class="headerlink" title="2.1.4 优秀的单元测试"></a>2.1.4 优秀的单元测试</h4><p>优秀的单元测试需要以下原则：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281655957.png"></p>
<ol>
<li>单元测试彼此之间应具备<strong>独立性</strong>。一个单元测试应独立于其它测试及运行它的环境。</li>
<li>一个优秀的单元测试是<strong>可重复</strong>的。它需要具备多次运行的能力，若不可重复，则不能算作优秀的单元测试。</li>
<li>优秀的单元测试<strong>可自动化</strong>。自动化具备双重含义：第一，单元测试<strong>可依赖于现有工具自动化运行</strong>；第二，单元测试执行成功与否<strong>可自动进行判断</strong>，而不依赖于人为判断。</li>
<li>优秀的单元测试是<strong>彻底的</strong>。单元测试对于被测试对象而言需要覆盖全部的分支。</li>
</ol>
<h3 id="2-2-单元测试的意义与建议"><a href="#2-2-单元测试的意义与建议" class="headerlink" title="2.2 单元测试的意义与建议"></a>2.2 单元测试的意义与建议</h3><h4 id="2-2-1-什么情况下做单元测试"><a href="#2-2-1-什么情况下做单元测试" class="headerlink" title="2.2.1 什么情况下做单元测试"></a>2.2.1 什么情况下做单元测试</h4><p><strong>（1）单元测试的好处</strong></p>
<p>①带来<strong>更高的测试覆盖率</strong>：有些分支问题在集成测试过程中很难发现，但在单元测试中极易发现。</p>
<p>②<strong>提高团队效率</strong>：单元测试在开发完后立即执行，将测试提前一步，不必等集成测试时才发现问题。</p>
<p>③<strong>自信的重构和改进实现。</strong></p>
<p>④<strong>将预期的行为文档化</strong>：完整的单元测试是产品代码的最好文档。</p>
<p><strong>（2）不当的单元测试会降低生产力</strong></p>
<p>单元测试并不是越多越好，不当的单元测试会降低生产力。</p>
<p>①单元测试的工作量与普通代码的工作量的比例介于1:1~1.5:1。</p>
<p>②整体项目的单元测试运行时间随着单元测试case增多线性增长，测试的执行速度影响每次变更等待的时间。</p>
<p>③单元测试的代码，也需要长期维护。</p>
<p><strong>（3）如何选择单元测试的对象</strong></p>
<p>不写单元测试不好，单元测试写多了也不好，这就要求我们要细心选择单元测试的对象。</p>
<p>在进行单元测试的时候，应<strong>重点关注核心业务逻辑代码、重用性高的代码与调用频繁的代码</strong>，后两者较为相近。</p>
<h4 id="2-2-2-不同场景下的单元测试tips"><a href="#2-2-2-不同场景下的单元测试tips" class="headerlink" title="2.2.2 不同场景下的单元测试tips"></a>2.2.2 不同场景下的单元测试tips</h4><p>1）Java Web项目底层的BO\DAO大体都是工具自动生成，无需额外单测，但是<strong>Action(Controller)<strong>层不含有较多的业务逻辑，</strong>需要通过集成测试</strong>发现问题。要注意的是<strong>java web项目</strong>的核心业务逻辑主要存在于Service层代码中，需要<strong>着重进行单元测试</strong>。</p>
<p>（2）平台类Java项目虽然在单独的场景下几乎不会出现问题，但是交叉混合时可能存在问题。而且由于平台类项目更多的兼顾不同的复杂的应用场景，所以在测试时要尽量做到全面。值得注意的是平台类Java项目的分支较多，所以<strong>要求在单元测试时要做到覆盖分支全面</strong>。</p>
<p>（3）组件类Java项目和平台类项目类似，也需要侧重分支覆盖全面，包括异常调用情况的覆盖。</p>
<p>（4）Hadoop的MR任务属于特殊的JAVA程序，集成测试成本高，主要体现在时间成本上。在进行单测时，<strong>可以将核心逻辑代码抽取出来，单独测试。</strong></p>
<h2 id="3-Python单元测试"><a href="#3-Python单元测试" class="headerlink" title="3 Python单元测试"></a>3 Python单元测试</h2><h3 id="3-1-单元测试的概念、工具与方法"><a href="#3-1-单元测试的概念、工具与方法" class="headerlink" title="3.1 单元测试的概念、工具与方法"></a>3.1 单元测试的概念、工具与方法</h3><h4 id="3-1-1-单元测试的概念"><a href="#3-1-1-单元测试的概念" class="headerlink" title="3.1.1 单元测试的概念"></a>3.1.1 单元测试的概念</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281703584.png"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281704541.png"></p>
<p>测试具有许多种不同的类型，比如说单元测试、模块测试、联调测试、系统测试、交付测试等。在这些测试之中，<strong>单元测试是最先要完成的</strong>。单元测试通常是由开发者去完成，用来验证代码中的函数是否符合预期。因此，它聚焦于函数的逻辑以及核心的算法是否正确。<em><strong>通常而言，一个单元测试用例是用于判断在某个特定条件或场景下，某个特定函数的行为。</strong></em></p>
<h4 id="3-1-2-单元测试的意义"><a href="#3-1-2-单元测试的意义" class="headerlink" title="3.1.2 单元测试的意义"></a>3.1.2 单元测试的意义</h4><p><strong>单元测试的意义包括两个方面。</strong></p>
<p>（1）质量</p>
<blockquote>
<p>①单元测试主要针对函数，<strong>颗粒度小、测试针对性强</strong>，bug更容易暴露；</p>
<p>②由于单元测试覆盖面较窄，无需考虑其它函数或者所依赖的模块，所以它的<strong>场景易构造，核心功能验证更充分</strong>；</p>
<p>③进行单元测试保证整体代码结构良好，使代码就具有较高的可测性和可维护性。</p>
</blockquote>
<p>（2）效率</p>
<p>单元测试能够提高开发效率，主要表现在：</p>
<blockquote>
<p>①单元测试<strong>进行的时间较早，测试场景构建快</strong>，可有效减少调试时间。</p>
<p>②由于单元测试<strong>只针对修改的代码</strong>展开测试，无需考虑额外内容，所以在较短时间内即可把预期的逻辑测试充分。</p>
<p>③单元测试<strong>能够在项目开发初期发现的bug</strong>，bug发现的时间越早，所带来的收益越大。由于尽早发现bug能够节省整个项目开发的时间，所以单元测试可加快开发效率，缩短开发周期。</p>
</blockquote>
<h4 id="3-1-3-单元测试框架"><a href="#3-1-3-单元测试框架" class="headerlink" title="3.1.3 单元测试框架"></a>3.1.3 单元测试框架</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281706919.png"></p>
<p><strong>Unitest的基础概念</strong></p>
<blockquote>
<p>在做单元测试之前，需要先了解一下Unittest的几个基础概念。</p>
<p>①**Test(测试用例)**，针对一个特定场景，特定目的具体测试过程。</p>
<p><em>比如说一个函数通过一组输入测试它，就是一个测试用例；如果一个函数通过三组输入来测试，即为三个测试用例。</em></p>
<p>②<strong>TestCase（测试类）</strong>，可以包含同一个测试对象的多个测试用例。</p>
<p><em>如果一个函数通过三组输入来测试，也就是三个测试用例，这三个测试用例可以合成为一个测试类。</em></p>
<p>③<strong>TestSuite（测试集）</strong>，可以包含多个测试类的多个测试用例。</p>
<p>④<strong>Assertion（断言）</strong>，必须使用断言判断测试结果。</p>
<p>⑤<strong>TestFixture</strong>，为测试做统一的准备和清除工作，通常是初始化，连接数据库，准备数据，断开数据库，清除现场等。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281711746.png"></p>
<p>扩展来说，TestFixture有四种最常使用的作用范围，分别为：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281710167.png"></p>
<blockquote>
<ol>
<li>setUp：在测试类的每个测试用例执行前执行。</li>
<li>teardown：在测试类的每个测试用例执行后执行。</li>
<li>setUpClass：在测试类的第一个测试用例执行前执行。</li>
<li>tearDownClass：在测试类的最后一个测试用例执行后执行。</li>
</ol>
</blockquote>
<p>TestFixture可以让单元测试代码更简单，但并非必须使用，也不要求配对出现。</p>
</blockquote>
<h4 id="3-1-4-单元测试的规范"><a href="#3-1-4-单元测试的规范" class="headerlink" title="3.1.4 单元测试的规范"></a>3.1.4 单元测试的规范</h4><p>如下是单元测试涉及的规范。</p>
<p>（1）所有的单元测试<strong>必须使用断言（assert）判断结果</strong>，禁止出现无断言的测试用例；</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281712364.webp"></p>
<p>使用断言，不但有利于他人理解，而且一旦出现不符合预期的情况，可以立即找出问题。</p>
<p>可以使用assertEqual, assertNotEqual 来判断相等或不相等，assertTrue,assertFalse 来判断Boolean, assertRaises 判断抛出的异常是否符合预期。</p>
<p>（2）测试用例需要具有自表述能力，达到见名知意。</p>
<p>比如命名test_login_with_invalid_password()，通过它的名字便可知它是用一个非法的密码去测试登录功能，具有自表述能力；但是如果命名为 test_login_case_（），名字减少了很多信息，难以得知它具体在做什么，不具有自表述能力。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281714852.png"></p>
<p>（3）测试用例之间相互独立，不应相互依赖、相互调用。</p>
<p>（4）<strong>一个测试用例只测一个函数。</strong>一个测试用例里面可以包含这一个函数的多个场景，但不能包含有多个参数的函数。原因在于，复杂测试用例出现错误时，无法定位问题的出处。</p>
<h4 id="3-1-5-单元测试对编码的要求"><a href="#3-1-5-单元测试对编码的要求" class="headerlink" title="3.1.5  单元测试对编码的要求"></a>3.1.5  单元测试对编码的要求</h4><p>单元测试中代码需保持一致性，尽量不要出现结果不一致的情况。假设有的代码会带来不一致性，导致单元测试无法稳定运行。针对这种情况，有两种解决方案：</p>
<p><strong>第一，将带来不一致性的代码抽取出来，</strong>把它作为一种变量传入我们需要调用或使用一致性变量的时候；</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281715404.png"></p>
<p><strong>第二，借助第三部分即将讲到的一个工具——mock</strong>——来解决这种问题。</p>
<h3 id="3-2-Coverage-统计单元测试覆盖率的工具"><a href="#3-2-Coverage-统计单元测试覆盖率的工具" class="headerlink" title="3.2 Coverage 统计单元测试覆盖率的工具"></a>3.2 Coverage 统计单元测试覆盖率的工具</h3><p>单元测试做完之后如何评价我们单元测试的效果。此时需要用到覆盖率工具，即Coverage。Coverage是一个第三方的工具，需要提前下载安装。</p>
<h4 id="3-2-1-统计覆盖率方法"><a href="#3-2-1-统计覆盖率方法" class="headerlink" title="3.2.1 统计覆盖率方法"></a>3.2.1 统计覆盖率方法</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281719654.png"></p>
<p>把python替换为coverage run-branch，然后会生成coverage文件，文件里会记录所有我们需要的覆盖率信息。</p>
<h4 id="3-2-2-打印覆盖率信息"><a href="#3-2-2-打印覆盖率信息" class="headerlink" title="3.2.2 打印覆盖率信息"></a>3.2.2 打印覆盖率信息</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718158.png"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281716523.webp"></p>
<p>执行coverage report-m 命令，读取当前目录下.coverage文件，打印覆盖率信息。输出Stmts(总行数), Miss(未覆盖行数), Branch（总分支数）, BrPart （未覆盖分支数）, Cover（覆盖率） , Missing（未覆盖具体信息）等信息。</p>
<h4 id="3-2-3-覆盖率中排除某些文件"><a href="#3-2-3-覆盖率中排除某些文件" class="headerlink" title="3.2.3 覆盖率中排除某些文件"></a>3.2.3 覆盖率中排除某些文件</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718278.png"></p>
<p>执行coverage report-m—omit=file 1[,file 2,……] 命令, 在统计并打印覆盖率时，排除某些文件。若有多个文件用逗号分隔。</p>
<h4 id="3-2-4-生成HTML格式的覆盖率信息"><a href="#3-2-4-生成HTML格式的覆盖率信息" class="headerlink" title="3.2.4 生成HTML格式的覆盖率信息"></a>3.2.4 生成HTML格式的覆盖率信息</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281718034.png"></p>
<p>针对代码量较大，查找覆盖率信息难度较大、耗时较长的情况，执行coverage html [–omit=file1[,file2,……]]命令，将覆盖率信息以html格式显示。</p>
<h3 id="3-3-Mock-简化单元测试的工具"><a href="#3-3-Mock-简化单元测试的工具" class="headerlink" title="3.3 Mock 简化单元测试的工具"></a>3.3 Mock 简化单元测试的工具</h3><h4 id="3-3-1-使用mock工具的原因与其功能"><a href="#3-3-1-使用mock工具的原因与其功能" class="headerlink" title="3.3.1 使用mock工具的原因与其功能"></a>3.3.1 使用mock工具的原因与其功能</h4><p>Mock基于实际进行单元测试的场景而产生，以下三类场景非常具有代表性：</p>
<ol>
<li><p><strong>构造模块</strong>。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281724821.png">需要测试模块A,但它要调用的模块B还未开发，可是测试却不容推迟、需按时进行，面对这种情况，我们可以使用Mock生成一个还未写完的代码，即可进行相应的测试。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281724884.png"></p>
</li>
<li><p><strong>改变函数逻辑</strong>。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281725807.png">代码中含有结果不可预知的代码，例如time.time()(时间)， random.random()(随机数)。Mock可以改变含有结果不可预知代码的函数的逻辑，强行让其返回我们想要的返回值，使其结果可预知。</p>
</li>
<li><p><strong>减少依赖</strong>。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281725930.png" alt="image-20211128172546775">在所有模块代码都已完成，但无法保证代码稳定性的情况下。针对其他模块的质量不可靠的情况，可通过Mock工具构造一个相对稳定的模块，从而规避其他模块的问题。</p>
</li>
</ol>
<h4 id="3-3-2-Mock使用场景"><a href="#3-3-2-Mock使用场景" class="headerlink" title="3.3.2 Mock使用场景"></a>3.3.2 Mock使用场景</h4><p>通过以下10个场景来讲述Mock的常见用法。</p>
<p>场景01：通过 <strong>return_value</strong>，Mock可以强行修改，永远返回我们想要的返回值，支持的类型包括string,number,Boolean,list,dict等。</p>
<p>场景02：将前一个例子的<strong>实例名改为类名</strong>，可实现替换类方法的返回值。</p>
<p>场景03：通过 <strong>side_effect</strong>,根据调用次数返回想要的结果,当超出调用次数时抛StopIteration 异常。</p>
<p>场景04：通过 <strong>side_effect</strong>可以完全修改函数的逻辑，使用另一个函数来替换它，根据参数返回想要的结果。</p>
<p>场景05：通过 <strong>side_effect</strong>抛出想要的异常或错误。</p>
<p>场景06：针对需要mock在特定要求下生效的情况，通过<strong>with.patch.object</strong>设定一个作用域以达到限制mock作用域的目的。</p>
<p>场景07：<strong>获取调用信息</strong>，如函数是否被调用、函数被调用的次数、函数被调用的形式、函数调用的参数等。</p>
<p>场景08：通过<strong>create_autospec</strong>在返回值改变的同时，确保api不会因mock而改变。</p>
<p>场景09：针对需要调用的函数、调用的接口完全没有开发的情况，可以通过<strong>Mock从零构造依赖模块</strong>从而完成测试。</p>
<p>场景10 ：<strong>替换函数调用链。</strong>比如说用popen去执行一个命令，然后用read函数把它读取出来，再用split去做切分，这就是一个函数调用链(os.popen(cmd).read().split())。</p>
<h4 id="3-3-3-Mock对编码的要求"><a href="#3-3-3-Mock对编码的要求" class="headerlink" title="3.3.3 Mock对编码的要求"></a>3.3.3 Mock对编码的要求</h4><p>在模块引入方式上，推荐以import XXX的形式引入，以XXX.func()形式调用，不要from.xxx import *,因为需要一个链条指向它，否则无法达到我们的预期。</p>
<h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281727442.png"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281727860.png"></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281728367.png"></p>
<h2 id="4-单元测试实践"><a href="#4-单元测试实践" class="headerlink" title="4 单元测试实践"></a>4 单元测试实践</h2><h3 id="4-1-Unittest-简单应用"><a href="#4-1-Unittest-简单应用" class="headerlink" title="4.1 Unittest 简单应用"></a>4.1 Unittest 简单应用</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736705.webp"></p>
<p>如图所示，这是一个要被测试的类，这个类代表了一个人，类中有一个函数为<strong>get_name()，作用是获取这个人的名字</strong>。围绕着这个函数首先想到的测试点就是函数能否正确输出人名。因此就有了如下图所示的单元测试代码。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281738269.webp"></p>
<p>第一步，将使用到的unittest框架和所需要的函数导入。</p>
<p>第二步，针对被测试的函数写一个测试类，这里要注意<strong>测试类必须继承自unittest和TestCase。</strong></p>
<p>第三步，构建实例化的函数，可以理解为生成两个人，一个叫张三，一个叫李四。</p>
<p>第四步，编写一个用于测试的函数，这里注意<strong>函数名必须是以test开头</strong>。通过图片里的代码可以看到，通过使用assertEqual断言来做相应的测试，断言中包括了两部分，第一部分是预期，第二部分是实际的值。通过对两个值的比较来完成测试。</p>
<h3 id="4-2-Unittest复杂应用"><a href="#4-2-Unittest复杂应用" class="headerlink" title="4.2 Unittest复杂应用"></a>4.2 Unittest复杂应用</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736271.webp"></p>
<p>下面来看一个复杂的例子。如图所示，这个被测试的类是一个公司。这个公司的信息包含了公司的名字、公司的老板、公司的员工数。在这个公司的类中设置了三个函数，老板是谁、雇佣一个新员工、解雇一个员工。通过这些信息，可以想到的测试点有：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281735339.webp"></p>
<p>（1）who_is_boss()这个函数能够正确的返回老板的姓名；</p>
<p>（2）使用hire()函数雇佣新人，公司的员工总数+1；</p>
<p>（3）使用hire()函数重复雇佣一个人，函数会报错或者公司员工数量不变；</p>
<p>（4）使用fire()函数解雇一个人，公司的员工总数-1；</p>
<p>（5）使用fire()函数解雇非公司的员工，函数会报错或者员工数量不变。</p>
<p>针对以上的几个测试点，可以编写出相应的测试类。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736693.webp"></p>
<p>首先将所需要的类库导入，并且测试类要继承自unittest和TestCase。然后使用setUpClass()函数构建一个公司，设置老板的姓名和公司的名字。在这里设置了一个tearDown()清理函数，是为了方便测试的时候将员工全部清理掉。</p>
<p>通过图片可以看到，下面的三个函数原理基本跟上一个案例相同，都是通过断言来进行测试。测试类编写完成之后，需要运行这个类进行测试。如果需要执行全部的测试用例，如图所示，使用unittest.main()这个函数且不需要添加任何参数。执行完成后会得到如下图所示的结果，测试结果分为几个部分：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281736738.webp"></p>
<p>第一部分的代码展示的是执行测试用例的结果，“.”说明测试用例执行通过，“E”说明测试用例发生了特殊情况异常中断，“F”说明测试用例执行失败。</p>
<p>第二部分则是打印的报错信息，当出现“E”或者“F”的时候，系统会打印出异常中断和执行失败的原因。</p>
<p>第三部分为统计信息，包括了共执行了几个测试用例，测试用例执行共花费了多少时间，测试用例执行成功或失败的数量。</p>
<h1 id="四、百度高效研发实战训练营Step4"><a href="#四、百度高效研发实战训练营Step4" class="headerlink" title="四、百度高效研发实战训练营Step4"></a>四、百度高效研发实战训练营Step4</h1><h2 id="1-代码检查规则：Java语言案例讲解"><a href="#1-代码检查规则：Java语言案例讲解" class="headerlink" title="1 代码检查规则：Java语言案例讲解"></a>1 代码检查规则：Java语言案例讲解</h2><h3 id="1-1-源文件规范"><a href="#1-1-源文件规范" class="headerlink" title="1.1 源文件规范"></a>1.1 源文件规范</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281859378.png"></p>
<h4 id="1-1-1-文件名"><a href="#1-1-1-文件名" class="headerlink" title="1.1.1 文件名"></a>1.1.1 文件名</h4><p>Java源文件名必须和它包含的顶层类名保持一致，包括大小写，并以**.java作为后缀名**。</p>
<h4 id="1-1-2-文件编码"><a href="#1-1-2-文件编码" class="headerlink" title="1.1.2 文件编码"></a>1.1.2 文件编码</h4><p>为保持编码风格的一致性，避免编码不一致导致的乱码问题，要求所有源文件编码<strong>必须使用UTF-8格式</strong>。</p>
<h4 id="1-1-3-特殊字符"><a href="#1-1-3-特殊字符" class="headerlink" title="1.1.3 特殊字符"></a>1.1.3 特殊字符</h4><p>特殊字符方面的规则主要是针对<strong>换行、缩进、空格</strong>等操作而制定，有以下强制规定：</p>
<ol>
<li>除换行符以外，<strong>ASCII空格（0x20）是唯一合法的空格字符</strong>。</li>
<li>由于不同系统将Tab转化成空格的数目不一致，统一使用空格进行缩进。</li>
<li>文件的换行符统一使用Unix格式（\n），而不要使用Windows格式（\r\n）。</li>
</ol>
<h3 id="1-2-源文件组织结构规范"><a href="#1-2-源文件组织结构规范" class="headerlink" title="1.2 源文件组织结构规范"></a>1.2 源文件组织结构规范</h3><blockquote>
<p>这一大类规则主要规定了源文件所应包含的具体组成部分和各个部分之间应遵循的一系列规则。</p>
<p><strong>对于源文件的组成部分，规定如下：</strong></p>
<p>源文件必须按顺序包含：许可证或版权声明、package语句、import语句、唯一的顶层类，四个方面的内容。</p>
<p>同时，每两个部分之间用一个空行进行分隔，不允许出现多余空行。对于以上四个方面的内容，每个组成部分又有相应的编码规则。</p>
</blockquote>
<h4 id="1-2-1-许可证或版权声明规范"><a href="#1-2-1-许可证或版权声明规范" class="headerlink" title="1.2.1 许可证或版权声明规范"></a>1.2.1 许可证或版权声明规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281903514.png"></p>
<h4 id="1-2-2-package语句规范"><a href="#1-2-2-package语句规范" class="headerlink" title="1.2.2 package语句规范"></a>1.2.2 package语句规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281911018.png"></p>
<h4 id="1-2-3-import语句规范"><a href="#1-2-3-import语句规范" class="headerlink" title="1.2.3 import语句规范"></a>1.2.3 import语句规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281904436.png"></p>
<h4 id="1-2-4-类声明规范"><a href="#1-2-4-类声明规范" class="headerlink" title="1.2.4 类声明规范"></a>1.2.4 类声明规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111281905480.png"></p>
<h3 id="1-3-代码结构规范"><a href="#1-3-代码结构规范" class="headerlink" title="1.3 代码结构规范"></a>1.3 代码结构规范</h3><h4 id="1-3-1-花括号"><a href="#1-3-1-花括号" class="headerlink" title="1.3.1 花括号"></a>1.3.1 花括号</h4><p>花括号经常在<strong>类和方法定义以及代码块划分</strong>中使用，花括号在使用中常需要合理的换行操作进行配合。规定为：在非空代码块中使用花括号时要遵循<strong>K&amp;R风格（Kernighan and Ritchie Style）</strong>，三个主要原则为:</p>
<ol>
<li>在左花括号（{）前不能换行，在其后换行；</li>
<li>在右花括号（}）前应有换行；</li>
<li>表示终止的右花括号（}）后必须换行，否则，右花括号后不换行。</li>
</ol>
<h4 id="1-3-2-缩进与换行"><a href="#1-3-2-缩进与换行" class="headerlink" title="1.3.2 缩进与换行"></a>1.3.2 缩进与换行</h4><p>缩进与换行主要是为了保证代码风格的一致性，提升代码的可维护性。主要规范有：</p>
<ol>
<li><p>每次开始书写一个新代码块时，使用4个空格进行缩进，在代码块结束时，恢复之前的缩进级别。</p>
</li>
<li><p>每条语句之后都要换行，每行只能有一条完整语句。</p>
</li>
<li><p>除package语句和import语句外，代码单行字符数限制不超过120个。超出则需要换行，换行时，遵循如下五条原则：</p>
<blockquote>
<ol>
<li>第二行相对第一行缩进四个空格，从第三行开始，不再继续缩进。</li>
<li>运算符与下文一起换行，即运算符位于行首。</li>
<li>方法调用的标点符号与下文一起换行。</li>
<li>方法调用中的多个参数需要换行时，在逗号后进行。</li>
<li>在括号前不要换行。</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="1-3-3-空行"><a href="#1-3-3-空行" class="headerlink" title="1.3.3 空行"></a>1.3.3 空行</h4><p>合理使用空行可以提高代码的可读性，有利于后期维护。</p>
<p>对于空行的使用，有如下规范进行约束：</p>
<ol>
<li><strong>在类的不同成员间增加空行</strong>，包括：成员变量、构造函数、方法、内部类、静态初始化块、实例初始化块等。</li>
<li>两个成员变量声明之间可以不加空行。<strong>空行通常对于成员变量进行逻辑分组。</strong></li>
<li>方法体内，按需增加空行，以便从逻辑上对语句进行分组。</li>
<li>使用空行时，<strong>禁止使用连续的空行。</strong></li>
</ol>
<h4 id="1-3-4-其他说明"><a href="#1-3-4-其他说明" class="headerlink" title="1.3.4 其他说明"></a>1.3.4 其他说明</h4><p><strong><em>Java中有两种数组定义形式</em>，为规范代码书写形式，要求为：</strong></p>
<p>①类型与中括号紧挨相连来表示数组，即中括号写在数组名之前。</p>
<p><strong>而当注解与注释同时存在时，统一的规范要求为：</strong></p>
<p>②添加在类、方法、构造函数、成员属性上的注解直接写在注释块之后，每个注解独占一行。</p>
<p><strong>当同时存在多个修饰符时，需要<em>按照顺序书写</em>，顺序要求如下：</strong></p>
<p>public protected private abstract static final transient volatile synchronized native strictfp</p>
<p>排在首位的一定是访问修饰符，随后是abstract，即抽象类或抽象方法，紧接着是static、final。这是常见的几类修饰符，对于其他的修饰符，可以参考以上列举的顺序进行书写。</p>
<p><strong>为避免小写字母l与1混淆，有如下规定：</strong></p>
<p>长整型数字必须使用大写字母L结尾，以便于和数字1进行区分。</p>
<h3 id="1-4-命名规范"><a href="#1-4-命名规范" class="headerlink" title="1.4 命名规范"></a>1.4 命名规范</h3><h4 id="1-4-1-驼峰命名格式"><a href="#1-4-1-驼峰命名格式" class="headerlink" title="1.4.1 驼峰命名格式"></a>1.4.1 驼峰命名格式</h4><p>对于两种驼峰命名格式的使用范围，有如下规范：</p>
<ol>
<li>方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，即首字母小写的驼峰命名格式。</li>
<li>类名使用UpperCamelCase风格，即首字母大写的驼峰命名格式，以下情形例外：DO/BO/DTO/VO/AO/PO/UID等。</li>
</ol>
<h4 id="1-4-2-类的命名格式"><a href="#1-4-2-类的命名格式" class="headerlink" title="1.4.2 类的命名格式"></a>1.4.2 类的命名格式</h4><p>除此之外，对于一些类，命名格式有更加具体的规范要求：</p>
<ol>
<li>抽象类命名使用Abstract或Base开头；</li>
<li>异常类命名使用Exception结尾；</li>
<li>测试类命名以它要测试的类的名称开始，以Test结尾。</li>
</ol>
<h4 id="1-4-3-常量命名格式"><a href="#1-4-3-常量命名格式" class="headerlink" title="1.4.3 常量命名格式"></a>1.4.3 常量命名格式</h4><p>常量的命名规范：</p>
<p>①常量命名全部大写，单词间用下划线隔开。</p>
<p>②不允许任何未经预先定义的常量直接出现在代码中。</p>
<h3 id="1-5-OOP规约"><a href="#1-5-OOP规约" class="headerlink" title="1.5 OOP规约"></a>1.5 OOP规约</h3><p><strong>OOP规约主要是针对面向对象编程过程中定义的一些类所制定的一些规则。</strong></p>
<p>包含的强制规范要求有：</p>
<ol>
<li>所有的POJO类属性<strong>必须使用包装数据类型</strong>，禁止使用基本类型。</li>
<li>所有的覆写方法，<strong>必须加@Override注解。</strong></li>
<li>Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</li>
<li>定义DO/DTO/VO等POJO类时，均不要设定任何属性默认值。</li>
</ol>
<h3 id="1-6-集合处理规范"><a href="#1-6-集合处理规范" class="headerlink" title="1.6 集合处理规范"></a>1.6 集合处理规范</h3><p>集合和数组是我们开发过程中使用频度最高的两个数据结构，对于二者的使用也有严格的强制规范：</p>
<ol>
<li>当需要将集合转换为数组时，必须使用集合的toArray方法，传入的是类型完全一样的数组，大小是list.size()。</li>
<li>对一个集合求子集合时，需高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除，产生ConcurrentModificationException异常。应通过对子集合进行相应操作，来反射到原集合，从而避免异常的发生。</li>
<li>不要在循环体内部进行集合元素的remove/add操作。remove元素请使用Iterator（迭代器）方式，如果并发操作，需要对Iterator对象加锁。</li>
</ol>
<h3 id="1-7-控制语句规范"><a href="#1-7-控制语句规范" class="headerlink" title="1.7 控制语句规范"></a>1.7 控制语句规范</h3><p>Java中的控制语句主要有<strong>switch、if、else、while等</strong>，这些语句的使用在编码过程中需要遵循以下规范：</p>
<ol>
<li>在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch快内，都必须包含一个default语句并且放在最后。</li>
<li>使用if/else/for/while/do语句必须使用花括号。即使只有一行代码，避免采用单行的编码方式。</li>
<li>在高并发场景中，避免使用“等于”判断作为中断或退出的条件。防止在击穿现象下，程序无法正常中断或退出的情况发生。</li>
</ol>
<h3 id="1-8-注释规约"><a href="#1-8-注释规约" class="headerlink" title="1.8 注释规约"></a>1.8 注释规约</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282007834.png"></p>
<p>合理使用注释可以提高程序可读性，便于后期维护。注释可以是程序说明，也可以是编程思路。<strong>Java中的注释主要分三种形式：文档注释、单行注释和多行注释。</strong>注释规约包括：</p>
<p>①类、类属性、类方法的注释必须使用文档注释形式，即使用 /<strong>内容</strong>/ 格式，不得使用单行注释的格式。单行注释和多行注释主要使用在方法体内。</p>
<p>②方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释，使用/<em>内容</em>/注释，注意与代码对齐。</p>
<h3 id="1-9-异常处理规范"><a href="#1-9-异常处理规范" class="headerlink" title="1.9 异常处理规范"></a>1.9 异常处理规范</h3><p>在Java中，我们通常使用<strong>try catch来进行捕获异常处理</strong>，而Java中的异常又分为运行时异常和非运行时异常。</p>
<ol>
<li><strong>对于处理运行时异常，有如下规范：</strong>Java类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过try catch的方式来处理，比如：空指针异常和数组越界异常等等。</li>
<li><strong>对于捕获后异常的处理，有如下规范：</strong>捕获异常是为了处理异常，不要捕获后不进行任何处理而将其抛弃。若不想进行异常的处理，应将该异常抛给它的调用者。最外层的业务使用者必须处理异常，将其转化为用户可以理解的内容。即对于捕获后的异常，要么继续向上抛，要么自己进行处理。</li>
<li><strong>异常处理的规范要求还包括：</strong>不能在finally块中使用return语句。</li>
</ol>
<h3 id="1-10-缺陷检查规则"><a href="#1-10-缺陷检查规则" class="headerlink" title="1.10 缺陷检查规则"></a>1.10 缺陷检查规则</h3><p>缺陷检查主要是<strong>对Java源代码进行静态分析</strong>，扫描其中潜在的缺陷，比如：空指针异常、死循环等，这一阶段所应遵循的规则包括：</p>
<ol>
<li>不能使用单个字符定义StringBuffer和StringBuilder。</li>
<li>任何上锁的对象均需保证其锁可以被释放。</li>
<li>严格避免死循环的发生。</li>
<li>对于字符串中的点号（“.”）、竖线（“|”）和文件分隔符（“File.separator”）进行替代时，需要注意其特殊含义。</li>
</ol>
<blockquote>
<p><strong>“.”：匹配任意单个字符。</strong>在replaceAll中使用，它匹配所有内容。</p>
<p><strong>“|”：通常用作选项分隔符，</strong>它匹配字符间的空格</p>
<p><strong>“File.separator”：匹配特定平台的文件路径分隔符。</strong>在Windows上，这将被视为转义字符。</p>
</blockquote>
<ol start="5">
<li>当synchronize对成员变量进行上锁时，该成员变量必须是final类型的。</li>
<li>synchronize上锁的成员变量类型一定不能是装箱类型。</li>
<li>所有被spring托管的类，其成员属性的初始化<strong>均要使用注入的方式。</strong></li>
<li>当使用try catch方式进行异常捕获，且需要在catch中对异常信息进行输出时，不得使用printStackTrace的方式。这种方式会导致后期分析代码困难。而应<strong>采用一些Log框架，方便用户检索和浏览日志。</strong></li>
<li>方法返回值包含操作状态代码时，该状态码不应被忽略</li>
<li>【%s】数组具有协变性，元素赋值类型与初始化类型不一致，此种情况可通过编译，但运行阶段会发生错误。</li>
<li>对于用户名和密码不应直接写在Java的文件中，避免泄露。而应将相应关键信息写在配置文件中进行读取。</li>
<li>方法和成员变量的命名不应相同，也不应通过大小写来进行区分。</li>
</ol>
<h2 id="2-单元测试之Java实践"><a href="#2-单元测试之Java实践" class="headerlink" title="2 单元测试之Java实践"></a>2 单元测试之Java实践</h2><h3 id="2-1-如何写单元测试"><a href="#2-1-如何写单元测试" class="headerlink" title="2.1 如何写单元测试"></a>2.1 如何写单元测试</h3><h4 id="2-1-1-基本流程"><a href="#2-1-1-基本流程" class="headerlink" title="2.1.1 基本流程"></a>2.1.1 基本流程</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282024759.png"></p>
<p><strong>单元测试的基本流程如下：</strong></p>
<p>首先，环境初始化；</p>
<p>其次，准备输入参数；</p>
<p>再次，调用待测试方法；</p>
<p>然后，检查输出；</p>
<p>最后，测试完成后环境复原。</p>
<h4 id="2-1-2-测试替身"><a href="#2-1-2-测试替身" class="headerlink" title="2.1.2 测试替身"></a>2.1.2 测试替身</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282025752.png"></p>
<p><strong>测试替身可用于隔离被测试的代码、加速执行顺序、使得随机行为变得确定、模拟特殊情况以及能够使测试访问隐藏信息等。</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282025297.png"></p>
<p>常见的测试替身有四类：桩（Stub)、伪造对象（Fake)、测试间谋（Spy)以及模拟对象（Mock)。</p>
<ol>
<li>Stub(桩）:一般什么都不做，实现空的方法调用或者简单的硬编码返回即可。</li>
<li>Fake(伪造对象）:真实数据的简单版本，伪造真实对象的行为，但是没有副作用或者使用真实事物的其它后果。比如替换数据库的对象，而得到虚假的伪造对象。</li>
<li>Spy(测试间谋）:需要得到封闭对象内部状态的时候，就要用到测试间谋，事先学会反馈消息，然后潜入对象内部去获取对象的状态。测试间谋是一种测试替身，它用于记录过去发生的情况，这样测试在事后就能知道所发生的一切。</li>
<li>Mock(模拟对象）:模拟对象是一个特殊的测试间谋。是一个在特定的情况下可以配置行为的对象，规定了在什么情况下，返回什么样的值的一种测试替身。Mock已经有了非常成熟的对象库，包括JMock、Mockito和EasyMock等。</li>
</ol>
<blockquote>
<p><strong>重点讲解一下模拟对象（Mock)：</strong></p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282028940.png"></p>
<p>假如我们有业务逻辑→数据存取→数据这三层逻辑，现在需要对“业务逻辑”层进行单元测试，那么我们可以使用Mock对数据存取与数据层的内容进行模拟，从而使上面的单元测试是独立的。</p>
</blockquote>
<h4 id="2-1-3-设计思路"><a href="#2-1-3-设计思路" class="headerlink" title="2.1.3 设计思路"></a>2.1.3 设计思路</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282028962.png"></p>
<p><strong>如何设计单元测试：</strong></p>
<p>**单元测试case的核心:**结合具体的应用场景、具体的输入数据与当前函数的功能实现，对于输出数据作出具体的预期，即可把全部待测试的分支都罗列了出来。</p>
<p>即：<strong>应用场景+输入数据+功能实现=输出数据。</strong></p>
<h4 id="2-1-4-断言-Assertions"><a href="#2-1-4-断言-Assertions" class="headerlink" title="2.1.4 断言(Assertions)"></a>2.1.4 断言(Assertions)</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282029555.png"></p>
<p>断言是一种在java单元测试中经常使用的测试方法。在单元测试中，我们<strong>使用“断言”来检验当前的测试结果是成功还是失败。</strong></p>
<blockquote>
<p><strong>常见的断言：</strong></p>
<p>Assert.assertNotNull</p>
<p>Assert.assertEquals</p>
<p>Assert.assertTrue</p>
<p>Assert.assertFalse</p>
<p>Assert.fail     </p>
</blockquote>
<p><strong>在单元测试中使用断言可以令预测结果自动呈现，无需人工对单元测试结果进行判断。</strong></p>
<h3 id="2-2-单元测试的运行"><a href="#2-2-单元测试的运行" class="headerlink" title="2.2 单元测试的运行"></a>2.2 单元测试的运行</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282031441.png"></p>
<h4 id="2-2-1-手动"><a href="#2-2-1-手动" class="headerlink" title="2.2.1 手动"></a>2.2.1 手动</h4><ol>
<li><strong>直接在IDE中执行</strong></li>
</ol>
<p>在开发编码完成之后，开发人员可以直接在自己的环境和编译器内运行单元测试。</p>
<ol start="2">
<li><strong>使用maven的mvn test</strong></li>
</ol>
<p>Maven是目前java开发中最流行的项目构建工具，它非常全面的包含了很多功能。mvn test这个测试模块就可以为我们的单元测试提供极大的便利。</p>
<h4 id="2-2-2-自动"><a href="#2-2-2-自动" class="headerlink" title="2.2.2 自动"></a>2.2.2 自动</h4><p><strong>持续集成（Jenkins）：</strong>自动化持续集成是我们在项目中常用的一种单元测试的方法。通用工具为Jenkins，Jenkins是一种持续集成的工具，它的功能非常强大。他的主要的功能有软件发布和版本测试、外部调用监控。</p>
<h3 id="2-3-如何判断单元测试的质量"><a href="#2-3-如何判断单元测试的质量" class="headerlink" title="2.3 如何判断单元测试的质量"></a>2.3 如何判断单元测试的质量</h3><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282032798.png"></p>
<p>衡量标准：</p>
<p>从<strong>主观层面</strong>，优秀的单元测试可读性高、易于维护、值得信赖.</p>
<p>从<strong>客观层面</strong>，使用单元测试代码覆盖率来衡。覆盖率工具包括：集成IDE和单独布署。</p>
<h2 id="3-如何做好-Code-Review"><a href="#3-如何做好-Code-Review" class="headerlink" title="3 如何做好 Code Review"></a>3 如何做好 Code Review</h2><h3 id="3-1-为什么要做好-Code-Review"><a href="#3-1-为什么要做好-Code-Review" class="headerlink" title="3.1 为什么要做好 Code Review"></a>3.1 为什么要做好 Code Review</h3><h4 id="3-1-1-Code-Review是提升代码质量的最好方法"><a href="#3-1-1-Code-Review是提升代码质量的最好方法" class="headerlink" title="3.1.1 Code Review是提升代码质量的最好方法"></a>3.1.1 Code Review是提升代码质量的最好方法</h4><p>强化Code Review是<strong>提升代码质量的第一选择。</strong></p>
<p>在代码开发过程中，我们越早发现问题、定位问题，在修复问题时付出的成本越小。</p>
<p>大约有50%以上的bug，都是在做Code Review时发现的。前期做好Code Review，后期将会减少反复修改等不必要的复工。</p>
<h4 id="3-1-2-Code-Review能够在团队内传递知识"><a href="#3-1-2-Code-Review能够在团队内传递知识" class="headerlink" title="3.1.2 Code Review能够在团队内传递知识"></a>3.1.2 Code Review能够在团队内传递知识</h4><p>从知识传递的角度看，<strong>Code Review是极为重要的。</strong></p>
<p>做好Code Review，能够帮助团队传递知识、沟通交流、互相学习，能够提升学习能力、提升编写代码能力、提升代码质量、提升工作效率、降低项目风险。</p>
<p>另外，基于codebase可以使我们了解项目全局，培养系统的思考方式。</p>
<h4 id="3-1-3-Code-Review是辅导怎么写代码的最好方法"><a href="#3-1-3-Code-Review是辅导怎么写代码的最好方法" class="headerlink" title="3.1.3 Code Review是辅导怎么写代码的最好方法"></a>3.1.3 Code Review是辅导怎么写代码的最好方法</h4><p>我们要意识到，做Code Review可以学习到别人的经验，同时也可以向别人传递我们的经验。</p>
<p>如果我们想辅导别人，<strong>最好的办法就是让对方先写一段代码，我们对他的代码进行Code Review。</strong>在辅导他人的过程中，我们可以快速地发现问题，从而帮助改进。</p>
<h4 id="3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力"><a href="#3-1-4-做好Code-Review可以增加公司对最顶级开发者的吸引力" class="headerlink" title="3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力"></a>3.1.4 做好Code Review可以增加公司对最顶级开发者的吸引力</h4><p>工作中是否有Code Review对于公司或团队来说非常重要。不但对于公司或团队内的人员有所提升，而且能够吸引出色的开发者加入开发团队。</p>
<p>未做好Code Review的公司或团队有如下特点：</p>
<ol>
<li>代码质量差。</li>
<li>团队内人员备份差。</li>
<li>团队开发人员得不到有效的辅导，提高慢。</li>
</ol>
<h4 id="3-1-5-为什么要提高代码质量？"><a href="#3-1-5-为什么要提高代码质量？" class="headerlink" title="3.1.5 为什么要提高代码质量？"></a>3.1.5 为什么要提高代码质量？</h4><ol>
<li>提高代码质量可以提高代码的可读性。</li>
<li>提高代码质量可以提高代码的复用性和参考性。</li>
<li>提高代码质量可以减少bug出现的风险。</li>
<li>提高代码质量可以减少后期补丁的风险。</li>
<li>提高代码质量可以降低代码失控的风险。</li>
<li>提高代码质量可以降低项目重构和升级的麻烦。</li>
</ol>
<h4 id="3-1-6-为什么要提高写代码的能力"><a href="#3-1-6-为什么要提高写代码的能力" class="headerlink" title="3.1.6 为什么要提高写代码的能力"></a>3.1.6 为什么要提高写代码的能力</h4><ol>
<li>代码能力如果停滞不前，对于个人而言，将导致职业危机。</li>
<li>代码能力如果停滞不前，对于团队而言，将意味着团队没有成长。</li>
</ol>
<p><strong>Code Review是一个非常重要的提升代码质量和代码能力的手段。</strong>无论是从个人发展角度，还是团队发展角度，我们都需要重视Code Review。</p>
<h3 id="3-2-如何做好-Code-Review"><a href="#3-2-如何做好-Code-Review" class="headerlink" title="3.2 如何做好 Code Review"></a>3.2 如何做好 Code Review</h3><h4 id="3-2-1-在Code-Review中可能发现的问题"><a href="#3-2-1-在Code-Review中可能发现的问题" class="headerlink" title="3.2.1 在Code Review中可能发现的问题"></a>3.2.1 在Code Review中可能发现的问题</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282043808.png"></p>
<h4 id="3-2-2-在Code-Review中应有的态度"><a href="#3-2-2-在Code-Review中应有的态度" class="headerlink" title="3.2.2 在Code Review中应有的态度"></a>3.2.2 在Code Review中应有的态度</h4><ol>
<li><p>对所有检查的代码逻辑要做到“完全看懂”，对于审核的代码，熟悉程度要做到“如数家珍”。如果在审核代码后，对代码的逻辑和背后的原因仍然很模糊，则是一个失败的Code Review。</p>
</li>
<li><p>好代码的标准，不仅仅是“可以运行通过”，在正确性、可读性、可重用性、可运维性等方面上，都需要综合考虑。</p>
</li>
<li><p>建立Code Review和写代码一样重要的意识。即：</p>
<blockquote>
<ol>
<li>Code Review和写代码一样，也有产出，即产出更高质量的代码。</li>
<li>审核代码在很多情况下比写代码还要辛苦，需要理解和找出问题等。</li>
</ol>
</blockquote>
</li>
<li><p>以提升代码质量为最终目标。</p>
</li>
<li><p>要投入足够的时间和精力。</p>
<blockquote>
<pre><code>        1. 审核代码花费的时间经常和写代码一样多，有时甚至比写代码的时间更多，要有时间意识。
        1. 要有责任意识。如果出现bug，不仅仅是写代码人员的职责，也不仅仅是QA的职责，代码审核者也需要承担相当大的责任。
</code></pre>
</blockquote>
</li>
</ol>
<h4 id="3-2-3-在Code-Review之前，需要了解一流代码的特性"><a href="#3-2-3-在Code-Review之前，需要了解一流代码的特性" class="headerlink" title="3.2.3 在Code Review之前，需要了解一流代码的特性"></a>3.2.3 在Code Review之前，需要了解一流代码的特性</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282046798.png" alt="一流代码的特性"></p>
<p><strong>一流代码有以下特性：①高效性；②鲁棒性；③简洁；④简短；⑤可共享；⑥可测试；⑦可移植；⑧可监控；⑨可运维；⑩可扩展。</strong></p>
<p>将以上十条标准进行总结精简归纳为：</p>
<blockquote>
<ol>
<li>代码的正确和性能；</li>
<li>代码的可读和可维护性；</li>
<li>代码的可运维和可运行；</li>
<li>代码的可共享和可重用；</li>
</ol>
</blockquote>
<p>在Code Review时，综合考虑以上一流代码的特性，可以快速提升代码质量、提升编写代码的能力等。</p>
<h4 id="3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力"><a href="#3-2-4-在Code-Review时，需要有对-bad-code-进行简单判断的能力" class="headerlink" title="3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力"></a>3.2.4 在Code Review时，需要有对 bad code 进行简单判断的能力</h4><p><strong>通常bad code有以下特点：</strong></p>
<ol>
<li>5分钟内不能看懂的代码。</li>
</ol>
<p>​        不能快速看懂的代码，一定是有问题的代码，可以先抛回给编写代码人员进行修正。<strong>一般一个函数的操作不能超过6个step</strong>，如果超过这个数量，则需要重新调整编码逻辑。</p>
<ol start="2">
<li>需要思考才能看懂的代码。</li>
</ol>
<p>​        好的代码阅读时基本不用动脑子，甚至看注释就能看懂。</p>
<ol start="3">
<li>需要来回翻屏才能看懂的代码。</li>
</ol>
<p>​        好的代码，经常在一屏内就是一个完整的逻辑。</p>
<ol start="4">
<li>没有空行或注释的代码。</li>
</ol>
<p>​        在Code Review时，发现不会用段落、不会写注释的代码，肯定不是好的程序员写的代码，可以直接打回给编写代码人员进行修正。</p>
<h4 id="3-2-5-Code-Review的注意事项"><a href="#3-2-5-Code-Review的注意事项" class="headerlink" title="3.2.5 Code Review的注意事项"></a>3.2.5 Code Review的注意事项</h4><ol>
<li>在必要时，review的双方做<strong>面对面的沟通。</strong></li>
</ol>
<p>​        面对面沟通并不是单指当面沟通，还包括云共享、电话、视频沟通等。在沟通时，对于背景、关键点等应进行说明，便于reviewer的理解。在必要时，应提供设计文档。</p>
<ol start="2">
<li>对于关键模块，应该建<strong>立owner制度。</strong></li>
</ol>
<p>​        所有提交的代码，必须由owner做最终确认。由owner掌握全局，并建立明确的责任关系。</p>
<ol start="3">
<li><p>检查中发现的问题，要一追到底。</p>
</li>
<li><p>要<strong>注意细节。</strong>对每一行提交的代码，都要进行检查。</p>
</li>
<li><p><strong>Code Review的方式，要小步快跑。</strong>每次提交review的代码量不要太多，降低复杂度。在特殊情况时，比如一个新模块的构建，最好逐步完成，通过多次进行提交。</p>
</li>
<li><p>要为Code Review<strong>预留出足够的时间。</strong>Code Review VS Coding的时间，有时可能达到1:1。在这里需要考虑到有时会做大的修改，科学地规划工作量，尽量避免出现时间倒排。</p>
</li>
<li><p>注意每天 review代码的数量不宜过多。</p>
</li>
</ol>
<h4 id="3-2-6-Code-Review的步骤"><a href="#3-2-6-Code-Review的步骤" class="headerlink" title="3.2.6 Code Review的步骤"></a>3.2.6 Code Review的步骤</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282051436.png" alt="、"></p>
<p>Code Review的步骤为以下几点：</p>
<p><strong>Step1：先看系统全貌</strong></p>
<p>不深究细节，浏览系统全貌，理清模块划分的逻辑、模块间的关系、如何构成的整个系统等。</p>
<p><strong>Step2：进入模块级别</strong></p>
<p>同样不深究细节，浏览模块内的全貌，判断模块切分是否合理，理清模块内的逻辑，明确关键数据、关键的类和函数等。</p>
<p><strong>Step3：理清类、函数内部的逻辑。</strong></p>
<p><strong>Step4：进入细节。</strong></p>
<p>比如Layout、命名等。</p>
<h4 id="3-2-7-人为因素"><a href="#3-2-7-人为因素" class="headerlink" title="3.2.7 人为因素"></a>3.2.7 人为因素</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282053170.png"></p>
<p>除了代码上的问题，在Code Review过程中还会有一些人为因素，例如：</p>
<p><strong>①QA人员</strong></p>
<p>好的QA人员不仅仅会发现系统中的bug，还会质疑或提出产品需求，挑战或优化系统架构和实现方式。</p>
<p><strong>②Code Reviewer</strong></p>
<p>好的代码审核人员不仅仅指出代码表面的问题，还会检查系统需求分析的质量、接口或函数定义的合理性、模块划分的合理性、系统关键机制的合理性等。</p>
<h3 id="3-3-例子：Python-代码的-Code-Review"><a href="#3-3-例子：Python-代码的-Code-Review" class="headerlink" title="3.3 例子：Python 代码的 Code Review"></a>3.3 例子：Python 代码的 Code Review</h3><h4 id="3-3-1-Python的编码规范"><a href="#3-3-1-Python的编码规范" class="headerlink" title="3.3.1 Python的编码规范"></a>3.3.1 Python的编码规范</h4><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282111474.png"></p>
<ul>
<li><p>代码要写的漂亮。</p>
</li>
<li><p>代码要<strong>明确直接</strong>，不要含蓄表达。</p>
</li>
<li><p>代码要<strong>简洁</strong>，一个函数可以实现的功能就不要写两个函数。</p>
</li>
<li><p><strong>代码深奥胜过代码复杂</strong>。代码可以写的深奥难懂，但是不能写的过于复杂。</p>
</li>
<li><p>代码要<strong>平铺直叙</strong>，不要层层嵌套。</p>
</li>
<li><p>代码要做到<strong>合理间隔。</strong></p>
</li>
<li><p>代码<strong>可读性</strong>非常重要。</p>
</li>
<li><p>代码要有普适性。尽量规避代码特殊性，用最简洁最通用的代码来实现。</p>
</li>
<li><p>代码要实用。</p>
</li>
<li><p>要重视所有发现的错误。</p>
</li>
<li><p>代码逻辑要清晰。在含糊混乱的面前，我们要拒绝猜测。读写代码时，不要出现“好像”、“可能”、“似乎”等猜测。当一段代码很难懂的时候，代码一定存在问题。</p>
</li>
<li><p>写代码要注重行动。</p>
</li>
<li><p>代码实现方法要简洁。如果一个方法很难解释，就意味着这个方法存在一定的问题。</p>
</li>
<li><p>要重视命名空间的使用。</p>
</li>
</ul>
<h4 id="3-3-2关于Python编程规范的部分说明"><a href="#3-3-2关于Python编程规范的部分说明" class="headerlink" title="3.3.2关于Python编程规范的部分说明"></a>3.3.2关于Python编程规范的部分说明</h4><p>Python编程规范有九个维度。</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282113051.png"></p>
<h5 id="1-模块的划分"><a href="#1-模块的划分" class="headerlink" title="1 模块的划分"></a>1 模块的划分</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282118231.png"></p>
<p>我们要对模块有概念，这是整个系统的基础。</p>
<ol>
<li><p>一个.py文件是一个模块。</p>
</li>
<li><p>模块的划分对软件的长期维护非常重要。</p>
</li>
<li><p>每个模块都应该有特定的功能。</p>
</li>
</ol>
<blockquote>
<p>比如：配置文件的读取，网页文件的写入，网页文件的解析，一个内存数据表，一个抓取的线程等等。</p>
</blockquote>
<ol start="4">
<li>多个本应独立的模块，写到一个.py文件中是常见的错误。从Code Review角度看，首先就是要看模块切分的对不对。</li>
</ol>
<h5 id="2-数据的封装"><a href="#2-数据的封装" class="headerlink" title="2 数据的封装"></a>2 数据的封装</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282117284.png"></p>
<p>在Code Review时，要着重注意数据是否封装这一问题。</p>
<h5 id="3-import"><a href="#3-import" class="headerlink" title="3 import"></a>3 import</h5><p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282118516.png"></p>
<p>Import在使用过程中，禁止使用from xxx import yyy语法直接导入类或函数。禁止使用from xxx import *这样的方法。这样做的目标是：容易判断代码中使用外部变量或函数的来源。</p>
<p>如果使用禁止中的语法，会大大增加判断来源的难度，以及代码阅读的难度。</p>
<p>在Code Review时，遇到这种情况，及时将代码打回给编程人员进行修正。</p>
<h5 id="4-异常"><a href="#4-异常" class="headerlink" title="4 异常"></a>4 异常</h5><p>对于异常的处理有以下几点需要注意：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282120853.png"></p>
<blockquote>
<ol>
<li>异常的使用</li>
</ol>
<p>​        使用异常前请需要详细了解异常的行为。不要主动抛出异常，使用返回值。如果一定要抛异常，需要注释进行说明。</p>
<ol start="2">
<li>异常的获取强制</li>
</ol>
<p>​        除非重新抛出异常，否则禁止使用except:捕获所有异常，不建议捕获Exception或StandardError。</p>
<p>​        在实际编码中建议try中的代码尽可能少，避免catch住未预期的异常，掩藏掉真正的错误。底线是至少要打印异常的日志，而不是捕获后直接pass通过。</p>
<p>​        在对异常进行处理时尽量针对特定操作的特定异常来捕获。</p>
<ol start="3">
<li>函数的返回值</li>
</ol>
<p>​        如果函数会抛出异常，需要在函数的注释中明确说明。</p>
</blockquote>
<p>在Code Review时，需要注意上述问题，及时返回给编程人员进行修正。</p>
<h5 id="5-构造函数"><a href="#5-构造函数" class="headerlink" title="5 构造函数"></a>5 构造函数</h5><p>对于构造函数有以下几点需要注意：</p>
<ol>
<li>规范：</li>
</ol>
<p>类构造函数应该尽量简单，不能包含可能失败或过于复杂的操作。</p>
<ol start="2">
<li>解读：</li>
</ol>
<p>在构造函数中常出现的错误是：无法判断、或捕获异常。</p>
<h5 id="6-函数返回值"><a href="#6-函数返回值" class="headerlink" title="6 函数返回值"></a>6 函数返回值</h5><p>对于函数返回值有以下几点需要注意：</p>
<ol>
<li>规范：</li>
</ol>
<blockquote>
<p>函数返回值必须小于等于3个。返回值超过3个时必须通过class/namedtuple/dict等具名形式进行包装。</p>
</blockquote>
<ol start="2">
<li>解读：</li>
</ol>
<blockquote>
<p>a. 多数情况下的错误，是因为很多人不会思考和设计函数的语义。</p>
<p>函数描述涉及的三要素为：功能描述、传入参数描述和返回值描述。</p>
<p>每个函数都应该有足够明确的语义。基于函数的语义，函数的返回值有三种类型：</p>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282122993.png"></p>
<p>b .另外，函数需要有返回值，对于正确或错误的情况，在返回值中要有体现。</p>
<p>c .还有一个问题是：Python的数据格式不需要定义，过于灵活。当程序规模变大、维护周期变长时，会导致后期极难维护。</p>
<p>应对措施是：多写注释，写清楚返回值说明、参数说明。</p>
</blockquote>
<p><img src="https://gitee.com/ckxgzxa/BlogPictures/raw/master/202111282123350.png"></p>
<p>在Code Review时，注释未写清楚的代码，一定要打回给编程人员，进行修正、补注释。</p>
<h5 id="7-代码长度"><a href="#7-代码长度" class="headerlink" title="7 代码长度"></a>7 代码长度</h5><p>关于代码长度有以下几点需要注意：</p>
<ol>
<li>每行不得超过120个字符。避免在终端上显示出现折行。</li>
<li>函数长度不得超过100行。函数过长会增加理解函数逻辑的难度。Python的函数应尽量控制在30~40行之间。</li>
</ol>
<p>在Code Review时，代码过长，建议全部打回给编程人员进行修正。</p>
<h5 id="8-空行、空格"><a href="#8-空行、空格" class="headerlink" title="8 空行、空格"></a>8 空行、空格</h5><p>关于空行、空格有以下几点需要注意：</p>
<ol>
<li>空行</li>
</ol>
<p>​        文件及定义之间隔两个空行。比如类或全局函数。类方法之间隔一个空行。</p>
<ol start="2">
<li>空格</li>
</ol>
<p>​        逗号、分号、冒号前不加空格，后边加一个空格。所有二元运算符前后各加一个空格。</p>
<p>在Code Review时，需要着重注意空行和空格。空行和空格不是可有可无的。空行和空格的存在，是为了增加可读性。不好读的代码，一律打回给编程人员进行修正。</p>
<h5 id="9-注释"><a href="#9-注释" class="headerlink" title="9 注释"></a>9 注释</h5><p>关于注释有以下几点需要注意：</p>
<p>Python中的注释有一个特殊之处是docstring，<strong>docstring要和“＃”注意区分开。</strong></p>
<blockquote>
<p>相关规范有：</p>
<ol>
<li><p>使用docstring描述module、 function 、class和method接口时，<strong>docstring必须用三个双引号括起来。</strong></p>
</li>
<li><p>对外接口部分必须用docstring描述。内部接口视情况自行决定是否写docstring。</p>
</li>
<li><p>接口的docstring描述<strong>至少包括功能简介、参数、返回值。</strong>如果可能抛出异常，必须使用注释进行说明。</p>
</li>
<li><p><strong>每个文件都必须有文件声明</strong>，文件声明必须包括以下信息：版权声明、功能和用途简介、修改人及联系方式。</p>
</li>
</ol>
</blockquote>
<p>在Code Review时，不符合上述规范的，及时打回给编程人员进行修正。</p>
<h3 id="3-4-如何成为一个好的reviewer"><a href="#3-4-如何成为一个好的reviewer" class="headerlink" title="3.4 如何成为一个好的reviewer"></a>3.4 如何成为一个好的reviewer</h3><p>代码审核的质量，和审核者的代码能力直接相关。代码审核的质量差，反映的是审核者的代码水平。如果作为一个代码审核员不会写代码，就要承认真相，并且要不断提高自己的代码能力。</p>
<p>学习资料：</p>
<ol>
<li>关于代码的书籍：《编写可读代码的艺术》，《代码整洁之道》。</li>
<li>综合的书籍：《代码大全》，《201  principles of software development》。</li>
<li>其他：《代码的艺术》课程，Python Good Coder考试指南。</li>
</ol>
<h3 id="3-5-公司针对-Code-Review-的措施"><a href="#3-5-公司针对-Code-Review-的措施" class="headerlink" title="3.5 公司针对 Code Review 的措施"></a>3.5 公司针对 Code Review 的措施</h3><p><strong>1、建立高效可运营的代码审核机制，提升代码质量，降低代码评审成本。</strong></p>
<blockquote>
<p>①基于平台：icode+bugbye</p>
<p>②代码检查规则分级，分为ERROR、WARNING、ADVICE三类，对ERROR级别阻塞提交。</p>
<p>③通过统计数据驱动代码检测规则的优化。</p>
</blockquote>
<p><strong>2、通过工程能力地图考察项目的Code Review情况。</strong></p>
<p><strong>3、所有的Code Review行为，都基于icode平台进行。良好的工具可以帮助更好的进行代码审核</strong></p>
<h3 id="3-6-Code-Review-总结"><a href="#3-6-Code-Review-总结" class="headerlink" title="3.6 Code Review 总结"></a>3.6 Code Review 总结</h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%99%BE%E5%BA%A6%E9%AB%98%E6%95%88%E7%A0%94%E5%8F%91%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E8%90%A5/">百度高效研发实战训练营</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/SDE01.html">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">计算机网络与信息安全</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/bitTraingClub4.html">
                        <span class="hidden-mobile">百度高效研发实战训练营Step4</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'CKXGZXA/GitPageComments');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        湘ICP备2021018734号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=43052102000188"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" alt="police-icon"/>
            
            <span>湘公网安备 43052102000188号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->




  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?01f66cc4caefba46f8cad22b739f765a";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
